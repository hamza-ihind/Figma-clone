"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@liveblocks";
exports.ids = ["vendor-chunks/@liveblocks"];
exports.modules = {

/***/ "(ssr)/./node_modules/@liveblocks/core/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@liveblocks/core/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientMsgCode: () => (/* binding */ ClientMsgCode),\n/* harmony export */   CommentsApiError: () => (/* binding */ CommentsApiError),\n/* harmony export */   CrdtType: () => (/* binding */ CrdtType),\n/* harmony export */   LiveList: () => (/* binding */ LiveList),\n/* harmony export */   LiveMap: () => (/* binding */ LiveMap),\n/* harmony export */   LiveObject: () => (/* binding */ LiveObject),\n/* harmony export */   OpCode: () => (/* binding */ OpCode),\n/* harmony export */   ServerMsgCode: () => (/* binding */ ServerMsgCode),\n/* harmony export */   WebsocketCloseCodes: () => (/* binding */ WebsocketCloseCodes),\n/* harmony export */   ackOp: () => (/* binding */ ackOp),\n/* harmony export */   asPos: () => (/* binding */ asPos),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   b64decode: () => (/* binding */ b64decode),\n/* harmony export */   cloneLson: () => (/* binding */ cloneLson),\n/* harmony export */   console: () => (/* binding */ fancy_console_exports),\n/* harmony export */   convertToCommentData: () => (/* binding */ convertToCommentData),\n/* harmony export */   convertToCommentUserReaction: () => (/* binding */ convertToCommentUserReaction),\n/* harmony export */   convertToThreadData: () => (/* binding */ convertToThreadData),\n/* harmony export */   createAsyncCache: () => (/* binding */ createAsyncCache),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   createCommentsApi: () => (/* binding */ createCommentsApi),\n/* harmony export */   deprecate: () => (/* binding */ deprecate),\n/* harmony export */   deprecateIf: () => (/* binding */ deprecateIf),\n/* harmony export */   detectDupes: () => (/* binding */ detectDupes),\n/* harmony export */   errorIf: () => (/* binding */ errorIf),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* binding */ getMentionedIdsFromCommentBody),\n/* harmony export */   isChildCrdt: () => (/* binding */ isChildCrdt),\n/* harmony export */   isJsonArray: () => (/* binding */ isJsonArray),\n/* harmony export */   isJsonObject: () => (/* binding */ isJsonObject),\n/* harmony export */   isJsonScalar: () => (/* binding */ isJsonScalar),\n/* harmony export */   isLiveNode: () => (/* binding */ isLiveNode),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRootCrdt: () => (/* binding */ isRootCrdt),\n/* harmony export */   legacy_patchImmutableObject: () => (/* binding */ legacy_patchImmutableObject),\n/* harmony export */   lsonToJson: () => (/* binding */ lsonToJson),\n/* harmony export */   makeEventSource: () => (/* binding */ makeEventSource),\n/* harmony export */   makePoller: () => (/* binding */ makePoller),\n/* harmony export */   makePosition: () => (/* binding */ makePosition),\n/* harmony export */   nn: () => (/* binding */ nn),\n/* harmony export */   patchLiveObjectKey: () => (/* binding */ patchLiveObjectKey),\n/* harmony export */   raise: () => (/* binding */ raise),\n/* harmony export */   shallow: () => (/* binding */ shallow),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   stringifyCommentBody: () => (/* binding */ stringifyCommentBody),\n/* harmony export */   throwUsageError: () => (/* binding */ throwUsageError),\n/* harmony export */   toPlainLson: () => (/* binding */ toPlainLson),\n/* harmony export */   tryParseJson: () => (/* binding */ tryParseJson),\n/* harmony export */   withTimeout: () => (/* binding */ withTimeout)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"1.9.7\";\nvar PKG_FORMAT = \"esm\";\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n    if (false) {} else {\n        throw new Error(msg);\n    }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n    const pkgId = Symbol.for(pkgName);\n    const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n    if (!g[pkgId]) {\n        g[pkgId] = pkgBuildInfo;\n    } else if (g[pkgId] === pkgBuildInfo) {} else {\n        const msg = [\n            `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n            \"\",\n            \"Conflicts:\",\n            `- ${pkgName} ${g[pkgId]} (already loaded)`,\n            `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n        ].join(\"\\n\");\n        error(msg);\n    }\n    if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n        error([\n            `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n            \"\",\n            \"Conflicts:\",\n            `- ${PKG_NAME} is at ${PKG_VERSION}`,\n            `- ${pkgName} is at ${pkgVersion}`,\n            \"\",\n            \"Always upgrade all Liveblocks packages to the same version number.\"\n        ].join(\"\\n\"));\n    }\n}\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n    throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n    if (true) {\n        if (!condition) {\n            const err = new Error(errmsg);\n            err.name = \"Assertion failure\";\n            throw err;\n        }\n    }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n    assert(value !== null && value !== void 0, errmsg);\n    return value;\n}\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n    let flagger;\n    const promise = new Promise((res)=>{\n        flagger = res;\n    });\n    if (!flagger) {\n        throw new Error(\"Should never happen\");\n    }\n    return [\n        promise,\n        flagger\n    ];\n}\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n    const _onetimeObservers = /* @__PURE__ */ new Set();\n    const _observers = /* @__PURE__ */ new Set();\n    let _buffer = null;\n    function pause() {\n        _buffer = [];\n    }\n    function unpause() {\n        if (_buffer === null) {\n            return;\n        }\n        for (const event of _buffer){\n            notify(event);\n        }\n        _buffer = null;\n    }\n    function subscribe(callback) {\n        _observers.add(callback);\n        return ()=>_observers.delete(callback);\n    }\n    function subscribeOnce(callback) {\n        _onetimeObservers.add(callback);\n        return ()=>_onetimeObservers.delete(callback);\n    }\n    async function waitUntil(predicate) {\n        let unsub;\n        return new Promise((res)=>{\n            unsub = subscribe((event)=>{\n                if (predicate === void 0 || predicate(event)) {\n                    res(event);\n                }\n            });\n        }).finally(()=>unsub?.());\n    }\n    function notifyOrBuffer(event) {\n        if (_buffer !== null) {\n            _buffer.push(event);\n        } else {\n            notify(event);\n        }\n    }\n    function notify(event) {\n        _onetimeObservers.forEach((callback)=>callback(event));\n        _onetimeObservers.clear();\n        _observers.forEach((callback)=>callback(event));\n    }\n    function clear() {\n        _onetimeObservers.clear();\n        _observers.clear();\n    }\n    function count() {\n        return _onetimeObservers.size + _observers.size;\n    }\n    return {\n        // Private/internal control over event emission\n        notify: notifyOrBuffer,\n        subscribe,\n        subscribeOnce,\n        clear,\n        count,\n        waitUntil,\n        pause,\n        unpause,\n        // Publicly exposable subscription API\n        observable: {\n            subscribe,\n            subscribeOnce,\n            waitUntil\n        }\n    };\n}\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n    error: ()=>error2,\n    errorWithTitle: ()=>errorWithTitle,\n    warn: ()=>warn,\n    warnWithTitle: ()=>warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n    return  true ? console[method] : /* istanbul ignore next */ 0;\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n    return  true ? console[method] : /* istanbul ignore next */ 0;\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n    if (state1 === state2) {\n        return [\n            0,\n            0\n        ];\n    }\n    const chunks1 = state1.split(\".\");\n    const chunks2 = state2.split(\".\");\n    const minLen = Math.min(chunks1.length, chunks2.length);\n    let shared = 0;\n    for(; shared < minLen; shared++){\n        if (chunks1[shared] !== chunks2[shared]) {\n            break;\n        }\n    }\n    const up = chunks1.length - shared;\n    const down = chunks2.length - shared;\n    return [\n        up,\n        down\n    ];\n}\nfunction patterns(targetState, levels) {\n    const parts = targetState.split(\".\");\n    if (levels < 1 || levels > parts.length + 1) {\n        throw new Error(\"Invalid number of levels\");\n    }\n    const result = [];\n    if (levels > parts.length) {\n        result.push(\"*\");\n    }\n    for(let i = parts.length - levels + 1; i < parts.length; i++){\n        const slice = parts.slice(0, i);\n        if (slice.length > 0) {\n            result.push(slice.join(\".\") + \".*\");\n        }\n    }\n    result.push(targetState);\n    return result;\n}\nvar SafeContext = class {\n    constructor(initialContext){\n        this.curr = initialContext;\n    }\n    get current() {\n        return this.curr;\n    }\n    /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */ allowPatching(callback) {\n        const self = this;\n        let allowed = true;\n        const patchableContext = {\n            ...this.curr,\n            patch (patch) {\n                if (allowed) {\n                    self.curr = Object.assign({}, self.curr, patch);\n                    for (const pair of Object.entries(patch)){\n                        const [key, value] = pair;\n                        if (key !== \"patch\") {\n                            this[key] = value;\n                        }\n                    }\n                } else {\n                    throw new Error(\"Can no longer patch stale context\");\n                }\n            }\n        };\n        callback(patchableContext);\n        allowed = false;\n        return;\n    }\n};\nvar nextId = 1;\nvar FSM = class {\n    /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */ get initialState() {\n        const result = this.states.values()[Symbol.iterator]().next();\n        if (result.done) {\n            throw new Error(\"No states defined yet\");\n        } else {\n            return result.value;\n        }\n    }\n    get currentState() {\n        if (this.currentStateOrNull === null) {\n            if (this.runningState === 0 /* NOT_STARTED_YET */ ) {\n                throw new Error(\"Not started yet\");\n            } else {\n                throw new Error(\"Already stopped\");\n            }\n        }\n        return this.currentStateOrNull;\n    }\n    /**\n   * Starts the machine by entering the initial state.\n   */ start() {\n        if (this.runningState !== 0 /* NOT_STARTED_YET */ ) {\n            throw new Error(\"State machine has already started\");\n        }\n        this.runningState = 1 /* STARTED */ ;\n        this.currentStateOrNull = this.initialState;\n        this.enter(null);\n        return this;\n    }\n    /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */ stop() {\n        if (this.runningState !== 1 /* STARTED */ ) {\n            throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n        }\n        this.exit(null);\n        this.runningState = 2 /* STOPPED */ ;\n        this.currentStateOrNull = null;\n    }\n    constructor(initialContext){\n        this.id = nextId++;\n        this.runningState = 0 /* NOT_STARTED_YET */ ;\n        this.currentStateOrNull = null;\n        this.states = /* @__PURE__ */ new Set();\n        this.enterFns = /* @__PURE__ */ new Map();\n        this.cleanupStack = [];\n        this.knownEventTypes = /* @__PURE__ */ new Set();\n        this.allowedTransitions = /* @__PURE__ */ new Map();\n        this.currentContext = new SafeContext(initialContext);\n        this.eventHub = {\n            didReceiveEvent: makeEventSource(),\n            willTransition: makeEventSource(),\n            didIgnoreEvent: makeEventSource(),\n            willExitState: makeEventSource(),\n            didEnterState: makeEventSource()\n        };\n        this.events = {\n            didReceiveEvent: this.eventHub.didReceiveEvent.observable,\n            willTransition: this.eventHub.willTransition.observable,\n            didIgnoreEvent: this.eventHub.didIgnoreEvent.observable,\n            willExitState: this.eventHub.willExitState.observable,\n            didEnterState: this.eventHub.didEnterState.observable\n        };\n    }\n    get context() {\n        return this.currentContext.current;\n    }\n    /**\n   * Define an explicit finite state in the state machine.\n   */ addState(state) {\n        if (this.runningState !== 0 /* NOT_STARTED_YET */ ) {\n            throw new Error(\"Already started\");\n        }\n        this.states.add(state);\n        return this;\n    }\n    onEnter(nameOrPattern, enterFn) {\n        if (this.runningState !== 0 /* NOT_STARTED_YET */ ) {\n            throw new Error(\"Already started\");\n        } else if (this.enterFns.has(nameOrPattern)) {\n            throw new Error(// TODO We _currently_ don't support multiple .onEnters() for the same\n            // state, but this is not a fundamental limitation. Just not\n            // implemented yet. If we wanted to, we could make this an array.\n            `enter/exit function for ${nameOrPattern} already exists`);\n        }\n        this.enterFns.set(nameOrPattern, enterFn);\n        return this;\n    }\n    onEnterAsync(nameOrPattern, promiseFn, onOK, onError) {\n        return this.onEnter(nameOrPattern, ()=>{\n            let cancelled = false;\n            void promiseFn(this.currentContext.current).then(// On OK\n            (data)=>{\n                if (!cancelled) {\n                    this.transition({\n                        type: \"ASYNC_OK\",\n                        data\n                    }, onOK);\n                }\n            }, // On Error\n            (reason)=>{\n                if (!cancelled) {\n                    this.transition({\n                        type: \"ASYNC_ERROR\",\n                        reason\n                    }, onError);\n                }\n            });\n            return ()=>{\n                cancelled = true;\n            };\n        });\n    }\n    getStatesMatching(nameOrPattern) {\n        const matches = [];\n        if (nameOrPattern === \"*\") {\n            for (const state of this.states){\n                matches.push(state);\n            }\n        } else if (nameOrPattern.endsWith(\".*\")) {\n            const prefix = nameOrPattern.slice(0, -1);\n            for (const state of this.states){\n                if (state.startsWith(prefix)) {\n                    matches.push(state);\n                }\n            }\n        } else {\n            const name = nameOrPattern;\n            if (this.states.has(name)) {\n                matches.push(name);\n            }\n        }\n        if (matches.length === 0) {\n            throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n        }\n        return matches;\n    }\n    /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */ addTransitions(nameOrPattern, mapping) {\n        if (this.runningState !== 0 /* NOT_STARTED_YET */ ) {\n            throw new Error(\"Already started\");\n        }\n        for (const srcState of this.getStatesMatching(nameOrPattern)){\n            let map = this.allowedTransitions.get(srcState);\n            if (map === void 0) {\n                map = /* @__PURE__ */ new Map();\n                this.allowedTransitions.set(srcState, map);\n            }\n            for (const [type, target_] of Object.entries(mapping)){\n                if (map.has(type)) {\n                    throw new Error(`Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`);\n                }\n                const target = target_;\n                this.knownEventTypes.add(type);\n                if (target !== void 0) {\n                    const targetFn = typeof target === \"function\" ? target : ()=>target;\n                    map.set(type, targetFn);\n                }\n            }\n        }\n        return this;\n    }\n    /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern The state name, or state group pattern name.\n   * @param after          Number of milliseconds after which to take the\n   *                       transition. If in the mean time, another transition\n   *                       is taken, the timer will get cancelled.\n   * @param target     The target state to go to.\n   */ addTimedTransition(stateOrPattern, after2, target) {\n        return this.onEnter(stateOrPattern, ()=>{\n            const ms = typeof after2 === \"function\" ? after2(this.currentContext.current) : after2;\n            const timeoutID = setTimeout(()=>{\n                this.transition({\n                    type: \"TIMER\"\n                }, target);\n            }, ms);\n            return ()=>{\n                clearTimeout(timeoutID);\n            };\n        });\n    }\n    getTargetFn(eventName) {\n        return this.allowedTransitions.get(this.currentState)?.get(eventName);\n    }\n    /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */ exit(levels) {\n        this.eventHub.willExitState.notify(this.currentState);\n        this.currentContext.allowPatching((patchableContext)=>{\n            levels = levels ?? this.cleanupStack.length;\n            for(let i = 0; i < levels; i++){\n                this.cleanupStack.pop()?.(patchableContext);\n            }\n        });\n    }\n    /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */ enter(levels) {\n        const enterPatterns = patterns(this.currentState, levels ?? this.currentState.split(\".\").length + 1);\n        this.currentContext.allowPatching((patchableContext)=>{\n            for (const pattern of enterPatterns){\n                const enterFn = this.enterFns.get(pattern);\n                const cleanupFn = enterFn?.(patchableContext);\n                if (typeof cleanupFn === \"function\") {\n                    this.cleanupStack.push(cleanupFn);\n                } else {\n                    this.cleanupStack.push(null);\n                }\n            }\n        });\n        this.eventHub.didEnterState.notify(this.currentState);\n    }\n    /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */ send(event) {\n        if (!this.knownEventTypes.has(event.type)) {\n            throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n        }\n        if (this.runningState === 2 /* STOPPED */ ) {\n            return;\n        }\n        const targetFn = this.getTargetFn(event.type);\n        if (targetFn !== void 0) {\n            return this.transition(event, targetFn);\n        } else {\n            this.eventHub.didIgnoreEvent.notify(event);\n        }\n    }\n    transition(event, target) {\n        this.eventHub.didReceiveEvent.notify(event);\n        const oldState = this.currentState;\n        const targetFn = typeof target === \"function\" ? target : ()=>target;\n        const nextTarget = targetFn(event, this.currentContext.current);\n        let nextState;\n        let effects = void 0;\n        if (nextTarget === null) {\n            this.eventHub.didIgnoreEvent.notify(event);\n            return;\n        }\n        if (typeof nextTarget === \"string\") {\n            nextState = nextTarget;\n        } else {\n            nextState = nextTarget.target;\n            effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [\n                nextTarget.effect\n            ];\n        }\n        if (!this.states.has(nextState)) {\n            throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n        }\n        this.eventHub.willTransition.notify({\n            from: oldState,\n            to: nextState\n        });\n        const [up, down] = distance(this.currentState, nextState);\n        if (up > 0) {\n            this.exit(up);\n        }\n        this.currentStateOrNull = nextState;\n        if (effects !== void 0) {\n            const effectsToRun = effects;\n            this.currentContext.allowPatching((patchableContext)=>{\n                for (const effect of effectsToRun){\n                    if (typeof effect === \"function\") {\n                        effect(patchableContext, event);\n                    } else {\n                        patchableContext.patch(effect);\n                    }\n                }\n            });\n        }\n        if (down > 0) {\n            this.enter(down);\n        }\n    }\n};\n// src/lib/utils.ts\nfunction raise(msg) {\n    throw new Error(msg);\n}\nfunction isPlainObject(blob) {\n    return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction entries(obj) {\n    return Object.entries(obj);\n}\nfunction tryParseJson(rawMessage) {\n    try {\n        return JSON.parse(rawMessage);\n    } catch (e) {\n        return void 0;\n    }\n}\nfunction deepClone(value) {\n    return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n    try {\n        const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n        const decodedValue = decodeURIComponent(atob(formattedValue).split(\"\").map(function(c) {\n            return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n        }).join(\"\"));\n        return decodedValue;\n    } catch (err) {\n        return atob(b64value);\n    }\n}\nfunction compact(items) {\n    return items.filter((item)=>item !== null && item !== void 0);\n}\nfunction compactObject(obj) {\n    const newObj = {\n        ...obj\n    };\n    Object.keys(obj).forEach((k)=>{\n        const key = k;\n        if (newObj[key] === void 0) {\n            delete newObj[key];\n        }\n    });\n    return newObj;\n}\nasync function withTimeout(promise, millis, errmsg) {\n    let timerID;\n    const timer$ = new Promise((_, reject)=>{\n        timerID = setTimeout(()=>{\n            reject(new Error(errmsg));\n        }, millis);\n    });\n    return Promise.race([\n        promise,\n        timer$\n    ]).finally(()=>clearTimeout(timerID));\n}\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2)=>{\n    ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n    ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n    ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n    ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n    ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n    ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n    ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n    ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n    ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n    ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n    ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n    ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n    ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n    ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n    ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n    ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n    return ServerMsgCode2;\n})(ServerMsgCode || {});\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2)=>{\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n    return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n    return code === 4999 /* CLOSE_WITHOUT_RETRY */  || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n    return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n    return code === 1013 /* TRY_AGAIN_LATER */  || code >= 4200 && code < 4300;\n}\n// src/connection.ts\nfunction isIdle(status) {\n    return status === \"initial\" || status === \"disconnected\";\n}\nfunction newToLegacyStatus(status) {\n    switch(status){\n        case \"connecting\":\n            return \"connecting\";\n        case \"connected\":\n            return \"open\";\n        case \"reconnecting\":\n            return \"unavailable\";\n        case \"disconnected\":\n            return \"failed\";\n        case \"initial\":\n            return \"closed\";\n        default:\n            return \"closed\";\n    }\n}\nfunction toNewConnectionStatus(machine) {\n    const state = machine.currentState;\n    switch(state){\n        case \"@ok.connected\":\n        case \"@ok.awaiting-pong\":\n            return \"connected\";\n        case \"@idle.initial\":\n            return \"initial\";\n        case \"@auth.busy\":\n        case \"@auth.backoff\":\n        case \"@connecting.busy\":\n        case \"@connecting.backoff\":\n        case \"@idle.zombie\":\n            return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n        case \"@idle.failed\":\n            return \"disconnected\";\n        default:\n            return assertNever(state, \"Unknown state\");\n    }\n}\nvar BACKOFF_DELAYS = [\n    250,\n    500,\n    1e3,\n    2e3,\n    4e3,\n    8e3,\n    1e4\n];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [\n    2e3,\n    3e4,\n    6e4,\n    3e5\n];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n    constructor(reason){\n        super(reason);\n    }\n};\nvar LiveblocksError = class extends Error {\n    constructor(message, code){\n        super(message);\n        this.code = code;\n    }\n};\nfunction nextBackoffDelay(currentDelay, delays = BACKOFF_DELAYS) {\n    return delays.find((delay)=>delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n    context.patch({\n        backoffDelay: nextBackoffDelay(context.backoffDelay)\n    });\n}\nfunction increaseBackoffDelayAggressively(context) {\n    context.patch({\n        backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n    });\n}\nfunction resetSuccessCount(context) {\n    context.patch({\n        successCount: 0\n    });\n}\nfunction log(level, message) {\n    const logger = level === 2 /* ERROR */  ? error2 : level === 1 /* WARN */  ? warn : /* black hole */ ()=>{};\n    return ()=>{\n        logger(message);\n    };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n    const conn = \"Connection to Liveblocks websocket server\";\n    return (ctx)=>{\n        if (e instanceof Error) {\n            warn(`${conn} could not be established. ${String(e)}`);\n        } else {\n            warn(isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`);\n        }\n    };\n}\nfunction logCloseEvent(event) {\n    return (ctx)=>{\n        warn(`Connection to Liveblocks websocket server closed (code: ${event.code}). Retrying in ${ctx.backoffDelay}ms.`);\n    };\n}\nvar logPermanentClose = log(1 /* WARN */ , \"Connection to WebSocket closed permanently. Won't retry.\");\nfunction isCloseEvent(error3) {\n    return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n    const start = /* @__PURE__ */ new Date().getTime();\n    function log2(...args) {\n        warn(`${((/* @__PURE__ */ new Date().getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`, ...args);\n    }\n    const unsubs = [\n        machine.events.didReceiveEvent.subscribe((e)=>log2(`Event ${e.type}`)),\n        machine.events.willTransition.subscribe(({ from, to })=>log2(\"Transitioning\", from, \"â†’\", to)),\n        machine.events.didIgnoreEvent.subscribe((e)=>log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\"))\n    ];\n    return ()=>{\n        for (const unsub of unsubs){\n            unsub();\n        }\n    };\n}\nfunction defineConnectivityEvents(machine) {\n    const statusDidChange = makeEventSource();\n    const didConnect = makeEventSource();\n    const didDisconnect = makeEventSource();\n    let lastStatus = null;\n    const unsubscribe = machine.events.didEnterState.subscribe(()=>{\n        const currStatus = toNewConnectionStatus(machine);\n        if (currStatus !== lastStatus) {\n            statusDidChange.notify(currStatus);\n        }\n        if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n            didDisconnect.notify();\n        } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n            didConnect.notify();\n        }\n        lastStatus = currStatus;\n    });\n    return {\n        statusDidChange: statusDidChange.observable,\n        didConnect: didConnect.observable,\n        didDisconnect: didDisconnect.observable,\n        unsubscribe\n    };\n}\nvar assign = (patch)=>(ctx)=>ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n    const onMessage = makeEventSource();\n    onMessage.pause();\n    const onLiveblocksError = makeEventSource();\n    function fireErrorEvent(errmsg, errcode) {\n        return ()=>{\n            const err = new LiveblocksError(errmsg, errcode);\n            onLiveblocksError.notify(err);\n        };\n    }\n    const initialContext = {\n        successCount: 0,\n        authValue: null,\n        socket: null,\n        backoffDelay: RESET_DELAY\n    };\n    const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n    machine.addTransitions(\"*\", {\n        RECONNECT: {\n            target: \"@auth.backoff\",\n            effect: [\n                increaseBackoffDelay,\n                resetSuccessCount\n            ]\n        },\n        DISCONNECT: \"@idle.initial\"\n    });\n    machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n        CONNECT: (_, ctx)=>// If we still have a known authValue, try to reconnect to the socket directly,\n            // otherwise, try to obtain a new authValue\n            ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    });\n    machine.addTransitions(\"@auth.backoff\", {\n        NAVIGATOR_ONLINE: {\n            target: \"@auth.busy\",\n            effect: assign({\n                backoffDelay: RESET_DELAY\n            })\n        }\n    }).addTimedTransition(\"@auth.backoff\", (ctx)=>ctx.backoffDelay, \"@auth.busy\").onEnterAsync(\"@auth.busy\", ()=>withTimeout(delegates.authenticate(), AUTH_TIMEOUT, \"Timed out during auth\"), // On successful authentication\n    (okEvent)=>({\n            target: \"@connecting.busy\",\n            effect: assign({\n                authValue: okEvent.data,\n                backoffDelay: RESET_DELAY\n            })\n        }), // Auth failed\n    (failedEvent)=>{\n        if (failedEvent.reason instanceof StopRetrying) {\n            return {\n                target: \"@idle.failed\",\n                effect: [\n                    log(2 /* ERROR */ , failedEvent.reason.message),\n                    fireErrorEvent(failedEvent.reason.message, -1)\n                ]\n            };\n        }\n        return {\n            target: \"@auth.backoff\",\n            effect: [\n                increaseBackoffDelay,\n                log(2 /* ERROR */ , `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`)\n            ]\n        };\n    });\n    const onSocketError = (event)=>machine.send({\n            type: \"EXPLICIT_SOCKET_ERROR\",\n            event\n        });\n    const onSocketClose = (event)=>machine.send({\n            type: \"EXPLICIT_SOCKET_CLOSE\",\n            event\n        });\n    const onSocketMessage = (event)=>event.data === \"pong\" ? machine.send({\n            type: \"PONG\"\n        }) : onMessage.notify(event);\n    function teardownSocket(socket) {\n        if (socket) {\n            socket.removeEventListener(\"error\", onSocketError);\n            socket.removeEventListener(\"close\", onSocketClose);\n            socket.removeEventListener(\"message\", onSocketMessage);\n            socket.close();\n        }\n    }\n    machine.addTransitions(\"@connecting.backoff\", {\n        NAVIGATOR_ONLINE: {\n            target: \"@connecting.busy\",\n            effect: assign({\n                backoffDelay: RESET_DELAY\n            })\n        }\n    }).addTimedTransition(\"@connecting.backoff\", (ctx)=>ctx.backoffDelay, \"@connecting.busy\").onEnterAsync(\"@connecting.busy\", //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx)=>{\n        let capturedPrematureEvent = null;\n        const connect$ = new Promise((resolve, rej)=>{\n            if (ctx.authValue === null) {\n                throw new Error(\"No auth authValue\");\n            }\n            const socket = delegates.createSocket(ctx.authValue);\n            function reject(event) {\n                capturedPrematureEvent = event;\n                socket.removeEventListener(\"message\", onSocketMessage);\n                rej(event);\n            }\n            const [actor$, didReceiveActor] = controlledPromise();\n            if (!options.waitForActorId) {\n                didReceiveActor();\n            }\n            function waitForActorId(event) {\n                const serverMsg = tryParseJson(event.data);\n                if (serverMsg?.type === 104 /* ROOM_STATE */ ) {\n                    didReceiveActor();\n                }\n            }\n            socket.addEventListener(\"message\", onSocketMessage);\n            if (options.waitForActorId) {\n                socket.addEventListener(\"message\", waitForActorId);\n            }\n            socket.addEventListener(\"error\", reject);\n            socket.addEventListener(\"close\", reject);\n            socket.addEventListener(\"open\", ()=>{\n                socket.addEventListener(\"error\", onSocketError);\n                socket.addEventListener(\"close\", onSocketClose);\n                const unsub = ()=>{\n                    socket.removeEventListener(\"error\", reject);\n                    socket.removeEventListener(\"close\", reject);\n                    socket.removeEventListener(\"message\", waitForActorId);\n                };\n                void actor$.then(()=>{\n                    resolve([\n                        socket,\n                        unsub\n                    ]);\n                });\n            });\n        });\n        return withTimeout(connect$, SOCKET_CONNECT_TIMEOUT, \"Timed out during websocket connection\").then(//\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub])=>{\n            unsub();\n            if (capturedPrematureEvent) {\n                throw capturedPrematureEvent;\n            }\n            return socket;\n        });\n    }, // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent)=>({\n            target: \"@ok.connected\",\n            effect: assign({\n                socket: okEvent.data,\n                backoffDelay: RESET_DELAY\n            })\n        }), // If the WebSocket connection cannot be established\n    (failure)=>{\n        const err = failure.reason;\n        if (err instanceof StopRetrying) {\n            return {\n                target: \"@idle.failed\",\n                effect: [\n                    log(2 /* ERROR */ , err.message),\n                    fireErrorEvent(err.message, -1)\n                ]\n            };\n        }\n        if (isCloseEvent(err)) {\n            if (err.code === 4109 /* TOKEN_EXPIRED */ ) {\n                return \"@auth.busy\";\n            }\n            if (shouldRetryWithoutReauth(err.code)) {\n                return {\n                    target: \"@connecting.backoff\",\n                    effect: [\n                        increaseBackoffDelayAggressively,\n                        logPrematureErrorOrCloseEvent(err)\n                    ]\n                };\n            }\n            if (shouldDisconnect(err.code)) {\n                return {\n                    target: \"@idle.failed\",\n                    effect: [\n                        log(2 /* ERROR */ , err.reason),\n                        fireErrorEvent(err.reason, err.code)\n                    ]\n                };\n            }\n        }\n        return {\n            target: \"@auth.backoff\",\n            effect: [\n                increaseBackoffDelay,\n                logPrematureErrorOrCloseEvent(err)\n            ]\n        };\n    });\n    const sendHeartbeat = {\n        target: \"@ok.awaiting-pong\",\n        effect: (ctx)=>{\n            ctx.socket?.send(\"ping\");\n        }\n    };\n    const maybeHeartbeat = ()=>{\n        const doc = typeof document !== \"undefined\" ? document : void 0;\n        const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n        return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n    };\n    machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n        NAVIGATOR_OFFLINE: maybeHeartbeat,\n        // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n        WINDOW_GOT_FOCUS: sendHeartbeat\n    });\n    machine.addTransitions(\"@idle.zombie\", {\n        WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    });\n    machine.onEnter(\"@ok.*\", (ctx)=>{\n        ctx.patch({\n            successCount: ctx.successCount + 1\n        });\n        const timerID = setTimeout(// On the next tick, start delivering all messages that have already\n        // been received, and continue synchronous delivery of all future\n        // incoming messages.\n        onMessage.unpause, 0);\n        return (ctx2)=>{\n            teardownSocket(ctx2.socket);\n            ctx2.patch({\n                socket: null\n            });\n            clearTimeout(timerID);\n            onMessage.pause();\n        };\n    }).addTransitions(\"@ok.awaiting-pong\", {\n        PONG: \"@ok.connected\"\n    }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n        target: \"@connecting.busy\",\n        // Log implicit connection loss and drop the current open socket\n        effect: log(1 /* WARN */ , \"Received no pong from server, assume implicit connection loss.\")\n    }).addTransitions(\"@ok.*\", {\n        // When a socket receives an error, this can cause the closing of the\n        // socket, or not. So always check to see if the socket is still OPEN or\n        // not. When still OPEN, don't transition.\n        EXPLICIT_SOCKET_ERROR: (_, context)=>{\n            if (context.socket?.readyState === 1) {\n                return null;\n            }\n            return {\n                target: \"@connecting.backoff\",\n                effect: increaseBackoffDelay\n            };\n        },\n        EXPLICIT_SOCKET_CLOSE: (e)=>{\n            if (shouldDisconnect(e.event.code)) {\n                return {\n                    target: \"@idle.failed\",\n                    effect: [\n                        logPermanentClose,\n                        fireErrorEvent(e.event.reason, e.event.code)\n                    ]\n                };\n            }\n            if (shouldReauth(e.event.code)) {\n                if (e.event.code === 4109 /* TOKEN_EXPIRED */ ) {\n                    return \"@auth.busy\";\n                } else {\n                    return {\n                        target: \"@auth.backoff\",\n                        effect: [\n                            increaseBackoffDelay,\n                            logCloseEvent(e.event)\n                        ]\n                    };\n                }\n            }\n            if (shouldRetryWithoutReauth(e.event.code)) {\n                return {\n                    target: \"@connecting.backoff\",\n                    effect: [\n                        increaseBackoffDelayAggressively,\n                        logCloseEvent(e.event)\n                    ]\n                };\n            }\n            return {\n                target: \"@connecting.backoff\",\n                effect: [\n                    increaseBackoffDelay,\n                    logCloseEvent(e.event)\n                ]\n            };\n        }\n    });\n    if (typeof document !== \"undefined\") {\n        const doc = typeof document !== \"undefined\" ? document : void 0;\n        const win =  false ? 0 : void 0;\n        const root = win ?? doc;\n        machine.onEnter(\"*\", (ctx)=>{\n            function onNetworkOffline() {\n                machine.send({\n                    type: \"NAVIGATOR_OFFLINE\"\n                });\n            }\n            function onNetworkBackOnline() {\n                machine.send({\n                    type: \"NAVIGATOR_ONLINE\"\n                });\n            }\n            function onVisibilityChange() {\n                if (doc?.visibilityState === \"visible\") {\n                    machine.send({\n                        type: \"WINDOW_GOT_FOCUS\"\n                    });\n                }\n            }\n            win?.addEventListener(\"online\", onNetworkBackOnline);\n            win?.addEventListener(\"offline\", onNetworkOffline);\n            root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n            return ()=>{\n                root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n                win?.removeEventListener(\"online\", onNetworkBackOnline);\n                win?.removeEventListener(\"offline\", onNetworkOffline);\n                teardownSocket(ctx.socket);\n            };\n        });\n    }\n    const cleanups = [];\n    const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n    cleanups.push(unsubscribe);\n    if (options.enableDebugLogging) {\n        cleanups.push(enableTracing(machine));\n    }\n    machine.start();\n    return {\n        machine,\n        cleanups,\n        // Observable events that will be emitted by this machine\n        events: {\n            statusDidChange,\n            didConnect,\n            didDisconnect,\n            onMessage: onMessage.observable,\n            onLiveblocksError: onLiveblocksError.observable\n        }\n    };\n}\nvar ManagedSocket = class {\n    constructor(delegates, enableDebugLogging = false, waitForActorId = true){\n        const { machine, events, cleanups } = createConnectionStateMachine(delegates, {\n            waitForActorId,\n            enableDebugLogging\n        });\n        this.machine = machine;\n        this.events = events;\n        this.cleanups = cleanups;\n    }\n    getLegacyStatus() {\n        return newToLegacyStatus(this.getStatus());\n    }\n    getStatus() {\n        try {\n            return toNewConnectionStatus(this.machine);\n        } catch  {\n            return \"initial\";\n        }\n    }\n    /**\n   * Returns the current auth authValue.\n   */ get authValue() {\n        return this.machine.context.authValue;\n    }\n    /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */ connect() {\n        this.machine.send({\n            type: \"CONNECT\"\n        });\n    }\n    /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */ reconnect() {\n        this.machine.send({\n            type: \"RECONNECT\"\n        });\n    }\n    /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */ disconnect() {\n        this.machine.send({\n            type: \"DISCONNECT\"\n        });\n    }\n    /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */ destroy() {\n        this.machine.stop();\n        let cleanup;\n        while(cleanup = this.cleanups.pop()){\n            cleanup();\n        }\n    }\n    /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */ send(data) {\n        const socket = this.machine.context?.socket;\n        if (socket === null) {\n            warn(\"Cannot send: not connected yet\", data);\n        } else if (socket.readyState !== 1) {\n            warn(\"Cannot send: WebSocket no longer open\", data);\n        } else {\n            socket.send(data);\n        }\n    }\n    /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */ _privateSendMachineEvent(event) {\n        this.machine.send(event);\n    }\n};\n// src/protocol/AuthToken.ts\nfunction canWriteStorage(scopes) {\n    return scopes.includes(\"room:write\" /* Write */ );\n}\nfunction canComment(scopes) {\n    return scopes.includes(\"comments:write\" /* CommentsWrite */ ) || scopes.includes(\"room:write\" /* Write */ );\n}\nfunction isValidAuthTokenPayload(data) {\n    return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */  || data.k === \"id\" /* ID_TOKEN */  || data.k === \"sec-legacy\" /* SECRET_LEGACY */ );\n}\nfunction parseAuthToken(rawTokenString) {\n    const tokenParts = rawTokenString.split(\".\");\n    if (tokenParts.length !== 3) {\n        throw new Error(\"Authentication error: invalid JWT token\");\n    }\n    const payload = tryParseJson(b64decode(tokenParts[1]));\n    if (!(payload && isValidAuthTokenPayload(payload))) {\n        throw new Error(\"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\");\n    }\n    return {\n        raw: rawTokenString,\n        parsed: payload\n    };\n}\n// src/auth-manager.ts\nfunction createAuthManager(authOptions) {\n    const authentication = prepareAuthentication(authOptions);\n    const seenTokens = /* @__PURE__ */ new Set();\n    const tokens = [];\n    const expiryTimes = [];\n    const requestPromises = /* @__PURE__ */ new Map();\n    function reset() {\n        seenTokens.clear();\n        tokens.length = 0;\n        expiryTimes.length = 0;\n        requestPromises.clear();\n    }\n    function hasCorrespondingScopes(requestedScope, scopes) {\n        if (requestedScope === \"comments:read\") {\n            return scopes.includes(\"comments:read\" /* CommentsRead */ ) || scopes.includes(\"comments:write\" /* CommentsWrite */ ) || scopes.includes(\"room:read\" /* Read */ ) || scopes.includes(\"room:write\" /* Write */ );\n        } else if (requestedScope === \"room:read\") {\n            return scopes.includes(\"room:read\" /* Read */ ) || scopes.includes(\"room:write\" /* Write */ );\n        }\n        return false;\n    }\n    function getCachedToken(requestedScope, roomId) {\n        const now = Math.ceil(Date.now() / 1e3);\n        for(let i = tokens.length - 1; i >= 0; i--){\n            const token = tokens[i];\n            const expiresAt = expiryTimes[i];\n            if (expiresAt <= now) {\n                tokens.splice(i, 1);\n                expiryTimes.splice(i, 1);\n                continue;\n            }\n            if (token.parsed.k === \"id\" /* ID_TOKEN */ ) {\n                return token;\n            } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */ ) {\n                for (const [resource, scopes] of Object.entries(token.parsed.perms)){\n                    if (resource.includes(\"*\") && roomId.startsWith(resource.replace(\"*\", \"\")) || roomId === resource && hasCorrespondingScopes(requestedScope, scopes)) {\n                        return token;\n                    }\n                }\n            }\n        }\n        return void 0;\n    }\n    async function makeAuthRequest(roomId) {\n        const fetcher = authOptions.polyfills?.fetch ?? ( true ? void 0 : 0);\n        if (authentication.type === \"private\") {\n            if (fetcher === void 0) {\n                throw new StopRetrying(\"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\");\n            }\n            const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n                room: roomId\n            });\n            const parsed = parseAuthToken(response.token);\n            if (seenTokens.has(parsed.raw)) {\n                throw new StopRetrying(\"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\");\n            }\n            return parsed;\n        }\n        if (authentication.type === \"custom\") {\n            const response = await authentication.callback(roomId);\n            if (response && typeof response === \"object\") {\n                if (typeof response.token === \"string\") {\n                    return parseAuthToken(response.token);\n                } else if (typeof response.error === \"string\") {\n                    const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n                    if (response.error === \"forbidden\") {\n                        throw new StopRetrying(reason);\n                    } else {\n                        throw new Error(reason);\n                    }\n                }\n            }\n            throw new Error('Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }');\n        }\n        throw new Error(\"Unexpected authentication type. Must be private or custom.\");\n    }\n    async function getAuthValue(requestedScope, roomId) {\n        if (authentication.type === \"public\") {\n            return {\n                type: \"public\",\n                publicApiKey: authentication.publicApiKey\n            };\n        }\n        const cachedToken = getCachedToken(requestedScope, roomId);\n        if (cachedToken !== void 0) {\n            return {\n                type: \"secret\",\n                token: cachedToken\n            };\n        }\n        let currentPromise = requestPromises.get(roomId);\n        if (currentPromise === void 0) {\n            currentPromise = makeAuthRequest(roomId);\n            requestPromises.set(roomId, currentPromise);\n        }\n        try {\n            const token = await currentPromise;\n            const BUFFER = 30;\n            const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n            seenTokens.add(token.raw);\n            if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */ ) {\n                tokens.push(token);\n                expiryTimes.push(expiresAt);\n            }\n            return {\n                type: \"secret\",\n                token\n            };\n        } finally{\n            requestPromises.delete(roomId);\n        }\n    }\n    return {\n        reset,\n        getAuthValue\n    };\n}\nfunction prepareAuthentication(authOptions) {\n    const { publicApiKey, authEndpoint } = authOptions;\n    if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n        throw new Error(\"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\");\n    }\n    if (typeof publicApiKey === \"string\") {\n        if (publicApiKey.startsWith(\"sk_\")) {\n            throw new Error(\"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\");\n        } else if (!publicApiKey.startsWith(\"pk_\")) {\n            throw new Error(\"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\");\n        }\n        return {\n            type: \"public\",\n            publicApiKey\n        };\n    }\n    if (typeof authEndpoint === \"string\") {\n        return {\n            type: \"private\",\n            url: authEndpoint\n        };\n    } else if (typeof authEndpoint === \"function\") {\n        return {\n            type: \"custom\",\n            callback: authEndpoint\n        };\n    } else if (authEndpoint !== void 0) {\n        throw new Error(\"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\");\n    }\n    throw new Error(\"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\");\n}\nasync function fetchAuthEndpoint(fetch2, endpoint, body) {\n    const res = await fetch2(endpoint, {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(body)\n    });\n    if (!res.ok) {\n        const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n        if (res.status === 401 || res.status === 403) {\n            throw new StopRetrying(`Unauthorized: ${reason}`);\n        } else {\n            throw new Error(`Failed to authenticate: ${reason}`);\n        }\n    }\n    let data;\n    try {\n        data = await res.json();\n    } catch (er) {\n        throw new Error(`Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(er)}`);\n    }\n    if (!isPlainObject(data) || typeof data.token !== \"string\") {\n        throw new Error(`Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${JSON.stringify(data)}`);\n    }\n    const { token } = data;\n    return {\n        token\n    };\n}\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n    _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n    if (true) {\n        return;\n    }\n    const fullMsg = {\n        ...message,\n        source: \"liveblocks-devtools-client\"\n    };\n    if (!(options?.force || _bridgeActive)) {\n        return;\n    }\n    window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif (false) {}\nvar onMessageFromPanel = eventSource.observable;\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n    if (true) {\n        return;\n    }\n    if (_devtoolsSetupHasRun) {\n        return;\n    }\n    _devtoolsSetupHasRun = true;\n    onMessageFromPanel.subscribe((msg)=>{\n        switch(msg.msg){\n            case \"connect\":\n                {\n                    activateBridge(true);\n                    for (const roomId of getAllRooms()){\n                        sendToPanel({\n                            msg: \"room::available\",\n                            roomId,\n                            clientVersion: VERSION\n                        });\n                    }\n                    break;\n                }\n        }\n    });\n    sendToPanel({\n        msg: \"wake-up-devtools\"\n    }, {\n        force: true\n    });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n    const unsubs = unsubsByRoomId.get(roomId) ?? [];\n    unsubsByRoomId.delete(roomId);\n    for (const unsub of unsubs){\n        unsub();\n    }\n}\nfunction startSyncStream(room) {\n    stopSyncStream(room.id);\n    fullSync(room);\n    unsubsByRoomId.set(room.id, [\n        // When the connection status changes\n        room.events.status.subscribe(()=>partialSyncConnection(room)),\n        // When storage initializes, send the update\n        room.events.storageDidLoad.subscribeOnce(()=>partialSyncStorage(room)),\n        // Any time storage updates, send the new storage root\n        room.events.storage.subscribe(()=>partialSyncStorage(room)),\n        // Any time \"me\" or \"others\" updates, send the new values accordingly\n        room.events.self.subscribe(()=>partialSyncMe(room)),\n        room.events.others.subscribe(()=>partialSyncOthers(room)),\n        // Any time ydoc is updated, forward the update\n        room.events.ydoc.subscribe((update)=>syncYdocUpdate(room, update)),\n        // Any time a custom room event is received, forward it\n        room.events.customEvent.subscribe((eventData)=>forwardEvent(room, eventData))\n    ]);\n}\nfunction syncYdocUpdate(room, update) {\n    sendToPanel({\n        msg: \"room::sync::ydoc\",\n        roomId: room.id,\n        update\n    });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n    return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n    sendToPanel({\n        msg: \"room::events::custom-event\",\n        roomId: room.id,\n        event: {\n            type: \"CustomEvent\",\n            id: nextEventId(),\n            key: \"Event\",\n            connectionId: eventData.connectionId,\n            payload: eventData.event\n        }\n    });\n}\nfunction partialSyncConnection(room) {\n    sendToPanel({\n        msg: \"room::sync::partial\",\n        roomId: room.id,\n        status: room.getStatus()\n    });\n}\nfunction partialSyncStorage(room) {\n    const root = room.getStorageSnapshot();\n    if (root) {\n        sendToPanel({\n            msg: \"room::sync::partial\",\n            roomId: room.id,\n            storage: root.toTreeNode(\"root\").payload\n        });\n    }\n}\nfunction partialSyncMe(room) {\n    const me = room.__internal.getSelf_forDevTools();\n    if (me) {\n        sendToPanel({\n            msg: \"room::sync::partial\",\n            roomId: room.id,\n            me\n        });\n    }\n}\nfunction partialSyncOthers(room) {\n    const others = room.__internal.getOthers_forDevTools();\n    if (others) {\n        sendToPanel({\n            msg: \"room::sync::partial\",\n            roomId: room.id,\n            others\n        });\n    }\n}\nfunction fullSync(room) {\n    const root = room.getStorageSnapshot();\n    const me = room.__internal.getSelf_forDevTools();\n    const others = room.__internal.getOthers_forDevTools();\n    room.fetchYDoc(\"\");\n    sendToPanel({\n        msg: \"room::sync::full\",\n        roomId: room.id,\n        status: room.getStatus(),\n        storage: root?.toTreeNode(\"root\").payload ?? null,\n        me,\n        others\n    });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n    const listener = roomChannelListeners.get(roomId);\n    roomChannelListeners.delete(roomId);\n    if (listener) {\n        listener();\n    }\n}\nfunction linkDevTools(roomId, room) {\n    if (true) {\n        return;\n    }\n    sendToPanel({\n        msg: \"room::available\",\n        roomId,\n        clientVersion: VERSION\n    });\n    stopRoomChannelListener(roomId);\n    roomChannelListeners.set(roomId, // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg)=>{\n        switch(msg.msg){\n            case \"room::subscribe\":\n                {\n                    if (msg.roomId === roomId) {\n                        startSyncStream(room);\n                    }\n                    break;\n                }\n            case \"room::unsubscribe\":\n                {\n                    if (msg.roomId === roomId) {\n                        stopSyncStream(roomId);\n                    }\n                    break;\n                }\n        }\n    }));\n}\nfunction unlinkDevTools(roomId) {\n    if (true) {\n        return;\n    }\n    stopSyncStream(roomId);\n    stopRoomChannelListener(roomId);\n    sendToPanel({\n        msg: \"room::unavailable\",\n        roomId\n    });\n}\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n    if (true) {\n        if (!_emittedDeprecationWarnings.has(key)) {\n            _emittedDeprecationWarnings.add(key);\n            errorWithTitle(\"Deprecation warning\", message);\n        }\n    }\n}\nfunction deprecateIf(condition, message, key = message) {\n    if (true) {\n        if (condition) {\n            deprecate(message, key);\n        }\n    }\n}\nfunction throwUsageError(message) {\n    if (true) {\n        const usageError = new Error(message);\n        usageError.name = \"Usage error\";\n        errorWithTitle(\"Usage error\", message);\n        throw usageError;\n    }\n}\nfunction errorIf(condition, message) {\n    if (true) {\n        if (condition) {\n            throwUsageError(message);\n        }\n    }\n}\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n    return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyText(element) {\n    return \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n    return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n    return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n    paragraph: isCommentBodyParagraph,\n    text: isCommentBodyText,\n    link: isCommentBodyLink,\n    mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n    paragraph: \"block\",\n    text: \"inline\",\n    link: \"inline\",\n    mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n    if (!body || !body?.content) {\n        return;\n    }\n    const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n    const type = element ? commentBodyElementsTypes[element] : \"all\";\n    const guard = element ? commentBodyElementsGuards[element] : ()=>true;\n    const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n    for (const block of body.content){\n        if (type === \"all\" || type === \"block\") {\n            if (guard(block)) {\n                visitor?.(block);\n            }\n        }\n        if (type === \"all\" || type === \"inline\") {\n            for (const inline of block.children){\n                if (guard(inline)) {\n                    visitor?.(inline);\n                }\n            }\n        }\n    }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n    const mentionedIds = /* @__PURE__ */ new Set();\n    traverseCommentBody(body, \"mention\", (mention)=>mentionedIds.add(mention.id));\n    return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n    const resolvedUsers = /* @__PURE__ */ new Map();\n    if (!resolveUsers) {\n        return resolvedUsers;\n    }\n    const userIds = getMentionedIdsFromCommentBody(body);\n    const users = await resolveUsers({\n        userIds\n    });\n    for (const [index, userId] of userIds.entries()){\n        const user = users?.[index];\n        if (user) {\n            resolvedUsers.set(userId, user);\n        }\n    }\n    return resolvedUsers;\n}\nvar htmlEscapables = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(Object.keys(htmlEscapables).map((entity)=>`\\\\${entity}`).join(\"|\"), \"g\");\nfunction htmlSafe(value) {\n    return new HtmlSafeString([\n        String(value)\n    ], []);\n}\nfunction joinHtml(strings) {\n    if (strings.length <= 0) {\n        return new HtmlSafeString([\n            \"\"\n        ], []);\n    }\n    return new HtmlSafeString([\n        \"\",\n        ...Array(strings.length - 1).fill(\"\"),\n        \"\"\n    ], strings);\n}\nfunction escapeHtml(value) {\n    if (value instanceof HtmlSafeString) {\n        return value.toString();\n    }\n    if (Array.isArray(value)) {\n        return joinHtml(value).toString();\n    }\n    return String(value).replace(htmlEscapablesRegex, (character)=>htmlEscapables[character]);\n}\nvar HtmlSafeString = class {\n    constructor(strings, values){\n        this._strings = strings;\n        this._values = values;\n    }\n    toString() {\n        return this._strings.reduce((result, str, i)=>{\n            return result + escapeHtml(nn(this._values[i - 1])) + str;\n        });\n    }\n};\nfunction html(strings, ...values) {\n    return new HtmlSafeString(strings, values);\n}\nvar markdownEscapables = {\n    _: \"\\\\_\",\n    \"*\": \"\\\\*\",\n    \"#\": \"\\\\#\",\n    \"`\": \"\\\\`\",\n    \"~\": \"\\\\~\",\n    \"!\": \"\\\\!\",\n    \"|\": \"\\\\|\",\n    \"(\": \"\\\\(\",\n    \")\": \"\\\\)\",\n    \"{\": \"\\\\{\",\n    \"}\": \"\\\\}\",\n    \"[\": \"\\\\[\",\n    \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(Object.keys(markdownEscapables).map((entity)=>`\\\\${entity}`).join(\"|\"), \"g\");\nfunction joinMarkdown(strings) {\n    if (strings.length <= 0) {\n        return new MarkdownSafeString([\n            \"\"\n        ], []);\n    }\n    return new MarkdownSafeString([\n        \"\",\n        ...Array(strings.length - 1).fill(\"\"),\n        \"\"\n    ], strings);\n}\nfunction escapeMarkdown(value) {\n    if (value instanceof MarkdownSafeString) {\n        return value.toString();\n    }\n    if (Array.isArray(value)) {\n        return joinMarkdown(value).toString();\n    }\n    return String(value).replace(markdownEscapablesRegex, (character)=>markdownEscapables[character]);\n}\nvar MarkdownSafeString = class {\n    constructor(strings, values){\n        this._strings = strings;\n        this._values = values;\n    }\n    toString() {\n        return this._strings.reduce((result, str, i)=>{\n            return result + escapeMarkdown(nn(this._values[i - 1])) + str;\n        });\n    }\n};\nfunction markdown(strings, ...values) {\n    return new MarkdownSafeString(strings, values);\n}\nfunction toAbsoluteUrl(url) {\n    if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n        return url;\n    } else if (url.startsWith(\"www.\")) {\n        return \"https://\" + url;\n    }\n    return;\n}\nvar stringifyCommentBodyPlainElements = {\n    paragraph: ({ children })=>children,\n    text: ({ element })=>element.text,\n    link: ({ element })=>element.url,\n    mention: ({ element, user })=>{\n        return `@${user?.name ?? element.id}`;\n    }\n};\nvar stringifyCommentBodyHtmlElements = {\n    paragraph: ({ children })=>{\n        return children ? html`<p>${htmlSafe(children)}</p>` : children;\n    },\n    text: ({ element })=>{\n        let children = element.text;\n        if (!children) {\n            return children;\n        }\n        if (element.bold) {\n            children = html`<strong>${children}</strong>`;\n        }\n        if (element.italic) {\n            children = html`<em>${children}</em>`;\n        }\n        if (element.strikethrough) {\n            children = html`<s>${children}</s>`;\n        }\n        if (element.code) {\n            children = html`<code>${children}</code>`;\n        }\n        return children;\n    },\n    link: ({ element, href })=>{\n        return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.url}</a>`;\n    },\n    mention: ({ element, user })=>{\n        return html`<span data-mention>@${user?.name ?? element.id}</span>`;\n    }\n};\nvar stringifyCommentBodyMarkdownElements = {\n    paragraph: ({ children })=>{\n        return children;\n    },\n    text: ({ element })=>{\n        let children = element.text;\n        if (!children) {\n            return children;\n        }\n        if (element.bold) {\n            children = markdown`**${children}**`;\n        }\n        if (element.italic) {\n            children = markdown`_${children}_`;\n        }\n        if (element.strikethrough) {\n            children = markdown`~~${children}~~`;\n        }\n        if (element.code) {\n            children = markdown`\\`${children}\\``;\n        }\n        return children;\n    },\n    link: ({ element, href })=>{\n        return markdown`[${element.url}](${href})`;\n    },\n    mention: ({ element, user })=>{\n        return markdown`@${user?.name ?? element.id}`;\n    }\n};\nasync function stringifyCommentBody(body, options) {\n    const format = options?.format ?? \"plain\";\n    const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n    const elements = {\n        ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n        ...options?.elements\n    };\n    const resolvedUsers = await resolveUsersInCommentBody(body, options?.resolveUsers);\n    const blocks = body.content.flatMap((block, blockIndex)=>{\n        switch(block.type){\n            case \"paragraph\":\n                {\n                    const inlines = block.children.flatMap((inline, inlineIndex)=>{\n                        if (isCommentBodyMention(inline)) {\n                            return inline.id ? [\n                                elements.mention({\n                                    element: inline,\n                                    user: resolvedUsers.get(inline.id)\n                                }, inlineIndex)\n                            ] : [];\n                        }\n                        if (isCommentBodyLink(inline)) {\n                            return [\n                                elements.link({\n                                    element: inline,\n                                    href: toAbsoluteUrl(inline.url) ?? inline.url\n                                }, inlineIndex)\n                            ];\n                        }\n                        if (isCommentBodyText(inline)) {\n                            return [\n                                elements.text({\n                                    element: inline\n                                }, inlineIndex)\n                            ];\n                        }\n                        return [];\n                    });\n                    return [\n                        elements.paragraph({\n                            element: block,\n                            children: inlines.join(\"\")\n                        }, blockIndex)\n                    ];\n                }\n            default:\n                return [];\n        }\n    });\n    return blocks.join(separator);\n}\nfunction convertToCommentData(data) {\n    const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    const reactions = data.reactions.map((reaction)=>({\n            ...reaction,\n            createdAt: new Date(reaction.createdAt)\n        }));\n    if (data.body) {\n        return {\n            ...data,\n            reactions,\n            createdAt,\n            editedAt\n        };\n    } else {\n        const deletedAt = new Date(data.deletedAt);\n        return {\n            ...data,\n            reactions,\n            createdAt,\n            editedAt,\n            deletedAt\n        };\n    }\n}\nfunction convertToThreadData(data) {\n    const updatedAt = data.updatedAt ? new Date(data.updatedAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    const comments = data.comments.map((comment)=>convertToCommentData(comment));\n    return {\n        ...data,\n        createdAt,\n        updatedAt,\n        comments\n    };\n}\nfunction convertToCommentUserReaction(data) {\n    return {\n        ...data,\n        createdAt: new Date(data.createdAt)\n    };\n}\n// src/comments/index.ts\nfunction getAuthBearerHeaderFromAuthValue(authValue) {\n    if (authValue.type === \"public\") {\n        return authValue.publicApiKey;\n    } else {\n        return authValue.token.raw;\n    }\n}\nvar CommentsApiError = class extends Error {\n    constructor(message, status, details){\n        super(message);\n        this.message = message;\n        this.status = status;\n        this.details = details;\n    }\n};\nfunction createCommentsApi(roomId, getAuthValue, config) {\n    async function fetchJson(endpoint, options) {\n        const response = await fetchApi(roomId, endpoint, options);\n        if (!response.ok) {\n            if (response.status >= 400 && response.status < 600) {\n                let error3;\n                try {\n                    const errorBody = await response.json();\n                    error3 = new CommentsApiError(errorBody.message, response.status, errorBody);\n                } catch  {\n                    error3 = new CommentsApiError(response.statusText, response.status);\n                }\n                throw error3;\n            }\n        }\n        let body;\n        try {\n            body = await response.json();\n        } catch  {\n            body = {};\n        }\n        return body;\n    }\n    async function fetchApi(roomId2, endpoint, options) {\n        const authValue = await getAuthValue();\n        const url = new URL(`/v2/c/rooms/${encodeURIComponent(roomId2)}${endpoint}`, config.baseUrl);\n        return await fetch(url.toString(), {\n            ...options,\n            headers: {\n                ...options?.headers,\n                Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`\n            }\n        });\n    }\n    async function getThreads(options) {\n        const response = await fetchApi(roomId, \"/threads/search\", {\n            body: JSON.stringify({\n                ...options?.query?.metadata && {\n                    metadata: options.query.metadata\n                }\n            }),\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\"\n        });\n        if (response.ok) {\n            const json = await response.json();\n            return json.data.map((thread)=>convertToThreadData(thread));\n        } else if (response.status === 404) {\n            return [];\n        } else {\n            throw new Error(\"There was an error while getting threads.\");\n        }\n    }\n    async function createThread({ metadata, body, commentId, threadId }) {\n        const thread = await fetchJson(\"/threads\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                id: threadId,\n                comment: {\n                    id: commentId,\n                    body\n                },\n                metadata\n            })\n        });\n        return convertToThreadData(thread);\n    }\n    async function editThreadMetadata({ metadata, threadId }) {\n        return await fetchJson(`/threads/${encodeURIComponent(threadId)}/metadata`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(metadata)\n        });\n    }\n    async function createComment({ threadId, commentId, body }) {\n        const comment = await fetchJson(`/threads/${encodeURIComponent(threadId)}/comments`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                id: commentId,\n                body\n            })\n        });\n        return convertToCommentData(comment);\n    }\n    async function editComment({ threadId, commentId, body }) {\n        const comment = await fetchJson(`/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(commentId)}`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                body\n            })\n        });\n        return convertToCommentData(comment);\n    }\n    async function deleteComment({ threadId, commentId }) {\n        await fetchJson(`/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(commentId)}`, {\n            method: \"DELETE\"\n        });\n    }\n    async function addReaction({ threadId, commentId, emoji }) {\n        const reaction = await fetchJson(`/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(commentId)}/reactions`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                emoji\n            })\n        });\n        return convertToCommentUserReaction(reaction);\n    }\n    async function removeReaction({ threadId, commentId, emoji }) {\n        await fetchJson(`/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(commentId)}/reactions/${encodeURIComponent(emoji)}`, {\n            method: \"DELETE\"\n        });\n    }\n    return {\n        getThreads,\n        createThread,\n        editThreadMetadata,\n        createComment,\n        editComment,\n        deleteComment,\n        addReaction,\n        removeReaction\n    };\n}\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n    const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n    if (code < MIN_CODE || code > MAX_CODE) {\n        throw new Error(`Invalid n value: ${n}`);\n    }\n    return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n    if (x !== void 0 && y !== void 0) {\n        return between(x, y);\n    } else if (x !== void 0) {\n        return after(x);\n    } else if (y !== void 0) {\n        return before(y);\n    } else {\n        return ONE;\n    }\n}\nfunction before(pos) {\n    const lastIndex = pos.length - 1;\n    for(let i = 0; i <= lastIndex; i++){\n        const code = pos.charCodeAt(i);\n        if (code <= MIN_CODE) {\n            continue;\n        }\n        if (i === lastIndex) {\n            if (code === MIN_CODE + 1) {\n                return pos.substring(0, i) + ZERO_NINE;\n            } else {\n                return pos.substring(0, i) + String.fromCharCode(code - 1);\n            }\n        } else {\n            return pos.substring(0, i + 1);\n        }\n    }\n    return ONE;\n}\nfunction after(pos) {\n    for(let i = 0; i <= pos.length - 1; i++){\n        const code = pos.charCodeAt(i);\n        if (code >= MAX_CODE) {\n            continue;\n        }\n        return pos.substring(0, i) + String.fromCharCode(code + 1);\n    }\n    return pos + ONE;\n}\nfunction between(lo, hi) {\n    if (lo < hi) {\n        return _between(lo, hi);\n    } else if (lo > hi) {\n        return _between(hi, lo);\n    } else {\n        throw new Error(\"Cannot compute value between two equal positions\");\n    }\n}\nfunction _between(lo, hi) {\n    let index = 0;\n    const loLen = lo.length;\n    const hiLen = hi.length;\n    while(true){\n        const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n        const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n        if (loCode === hiCode) {\n            index++;\n            continue;\n        }\n        if (hiCode - loCode === 1) {\n            const size = index + 1;\n            let prefix = lo.substring(0, size);\n            if (prefix.length < size) {\n                prefix += ZERO.repeat(size - prefix.length);\n            }\n            const suffix = lo.substring(size);\n            const nines = \"\";\n            return prefix + _between(suffix, nines);\n        } else {\n            return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n        }\n    }\n}\nfunction takeN(pos, n) {\n    return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n    if (str === \"\") {\n        return false;\n    }\n    const lastIdx = str.length - 1;\n    const last = str.charCodeAt(lastIdx);\n    if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n        return false;\n    }\n    for(let i = 0; i < lastIdx; i++){\n        const code = str.charCodeAt(i);\n        if (code < MIN_CODE || code > MAX_CODE) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction convertToPos(str) {\n    const codes = [];\n    for(let i = 0; i < str.length; i++){\n        const code = str.charCodeAt(i);\n        codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n    }\n    while(codes.length > 0 && codes[codes.length - 1] === MIN_CODE){\n        codes.length--;\n    }\n    return codes.length > 0 ? String.fromCharCode(...codes) : // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE;\n}\nfunction asPos(str) {\n    return isPos(str) ? str : convertToPos(str);\n}\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2)=>{\n    OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n    OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n    OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n    OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n    OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n    OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n    OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n    OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n    OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n    return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n    return {\n        type: 5 /* DELETE_CRDT */ ,\n        id: \"ACK\",\n        // (H)ACK\n        opId\n    };\n}\nfunction isAckOp(op) {\n    return op.type === 5 /* DELETE_CRDT */  && op.id === \"ACK\";\n}\n// src/crdts/AbstractCrdt.ts\nfunction crdtAsLiveNode(value) {\n    return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n    return Object.freeze({\n        type: \"HasParent\",\n        node,\n        key,\n        pos\n    });\n}\nvar NoParent = Object.freeze({\n    type: \"NoParent\"\n});\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n    return Object.freeze({\n        type: \"Orphaned\",\n        oldKey,\n        oldPos\n    });\n}\nvar AbstractCrdt = class {\n    constructor(){\n        /** @internal */ this._parent = NoParent;\n    }\n    /** @internal */ _getParentKeyOrThrow() {\n        switch(this.parent.type){\n            case \"HasParent\":\n                return this.parent.key;\n            case \"NoParent\":\n                throw new Error(\"Parent key is missing\");\n            case \"Orphaned\":\n                return this.parent.oldKey;\n            default:\n                return assertNever(this.parent, \"Unknown state\");\n        }\n    }\n    /** @internal */ get _parentPos() {\n        switch(this.parent.type){\n            case \"HasParent\":\n                return this.parent.pos;\n            case \"NoParent\":\n                throw new Error(\"Parent key is missing\");\n            case \"Orphaned\":\n                return this.parent.oldPos;\n            default:\n                return assertNever(this.parent, \"Unknown state\");\n        }\n    }\n    /** @internal */ get _pool() {\n        return this.__pool;\n    }\n    get roomId() {\n        return this.__pool ? this.__pool.roomId : null;\n    }\n    /** @internal */ get _id() {\n        return this.__id;\n    }\n    /** @internal */ get parent() {\n        return this._parent;\n    }\n    /** @internal */ get _parentKey() {\n        switch(this.parent.type){\n            case \"HasParent\":\n                return this.parent.key;\n            case \"NoParent\":\n                return null;\n            case \"Orphaned\":\n                return this.parent.oldKey;\n            default:\n                return assertNever(this.parent, \"Unknown state\");\n        }\n    }\n    /** @internal */ _apply(op, _isLocal) {\n        switch(op.type){\n            case 5 /* DELETE_CRDT */ :\n                {\n                    if (this.parent.type === \"HasParent\") {\n                        return this.parent.node._detachChild(crdtAsLiveNode(this));\n                    }\n                    return {\n                        modified: false\n                    };\n                }\n        }\n        return {\n            modified: false\n        };\n    }\n    /** @internal */ _setParentLink(newParentNode, newParentKey) {\n        switch(this.parent.type){\n            case \"HasParent\":\n                if (this.parent.node !== newParentNode) {\n                    throw new Error(\"Cannot set parent: node already has a parent\");\n                } else {\n                    this._parent = HasParent(newParentNode, newParentKey);\n                    return;\n                }\n            case \"Orphaned\":\n            case \"NoParent\":\n                {\n                    this._parent = HasParent(newParentNode, newParentKey);\n                    return;\n                }\n            default:\n                return assertNever(this.parent, \"Unknown state\");\n        }\n    }\n    /** @internal */ _attach(id, pool) {\n        if (this.__id || this.__pool) {\n            throw new Error(\"Cannot attach node: already attached\");\n        }\n        pool.addNode(id, crdtAsLiveNode(this));\n        this.__id = id;\n        this.__pool = pool;\n    }\n    /** @internal */ _detach() {\n        if (this.__pool && this.__id) {\n            this.__pool.deleteNode(this.__id);\n        }\n        switch(this.parent.type){\n            case \"HasParent\":\n                {\n                    this._parent = Orphaned(this.parent.key, this.parent.pos);\n                    break;\n                }\n            case \"NoParent\":\n                {\n                    this._parent = NoParent;\n                    break;\n                }\n            case \"Orphaned\":\n                {\n                    break;\n                }\n            default:\n                assertNever(this.parent, \"Unknown state\");\n        }\n        this.__pool = void 0;\n    }\n    /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */ invalidate() {\n        if (this._cachedImmutable !== void 0 || this._cachedTreeNode !== void 0) {\n            this._cachedImmutable = void 0;\n            this._cachedTreeNode = void 0;\n            if (this.parent.type === \"HasParent\") {\n                this.parent.node.invalidate();\n            }\n        }\n    }\n    /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */ toTreeNode(key) {\n        if (this._cachedTreeNode === void 0 || this._cachedTreeNodeKey !== key) {\n            this._cachedTreeNodeKey = key;\n            this._cachedTreeNode = this._toTreeNode(key);\n        }\n        return this._cachedTreeNode;\n    }\n    /**\n   * Return an immutable snapshot of this Live node and its children.\n   */ toImmutable() {\n        if (this._cachedImmutable === void 0) {\n            this._cachedImmutable = this._toImmutable();\n        }\n        return this._cachedImmutable;\n    }\n};\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2)=>{\n    CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n    CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n    CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n    CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n    return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n    return crdt.type === 0 /* OBJECT */  && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n    return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n// src/lib/nanoid.ts\nfunction nanoid(length = 7) {\n    const alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,./;[]~!@#$%&*()_+=-\";\n    const len = alphabet.length;\n    return Array.from({\n        length\n    }, ()=>alphabet.charAt(Math.floor(Math.random() * len))).join(\"\");\n}\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n    constructor(data){\n        super();\n        this._data = data;\n    }\n    get data() {\n        return this._data;\n    }\n    /** @internal */ static _deserialize([id, item], _parentToChildren, pool) {\n        const register = new _LiveRegister(item.data);\n        register._attach(id, pool);\n        return register;\n    }\n    /** @internal */ _toOps(parentId, parentKey, pool) {\n        if (this._id === void 0) {\n            throw new Error(\"Cannot serialize register if parentId or parentKey is undefined\");\n        }\n        return [\n            {\n                type: 8 /* CREATE_REGISTER */ ,\n                opId: pool?.generateOpId(),\n                id: this._id,\n                parentId,\n                parentKey,\n                data: this.data\n            }\n        ];\n    }\n    /** @internal */ _serialize() {\n        if (this.parent.type !== \"HasParent\") {\n            throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n        }\n        return {\n            type: 3 /* REGISTER */ ,\n            parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n            parentKey: this.parent.key,\n            data: this.data\n        };\n    }\n    /** @internal */ _attachChild(_op) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @internal */ _detachChild(_crdt) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @internal */ _apply(op, isLocal) {\n        return super._apply(op, isLocal);\n    }\n    /** @internal */ _toTreeNode(key) {\n        return {\n            type: \"Json\",\n            id: this._id ?? nanoid(),\n            key,\n            payload: this._data\n        };\n    }\n    /** @internal */ _toImmutable() {\n        return this._data;\n    }\n    clone() {\n        return deepClone(this.data);\n    }\n};\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n    const posA = itemA._parentPos;\n    const posB = itemB._parentPos;\n    return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n    constructor(items = []){\n        super();\n        this._items = [];\n        this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n        this._unacknowledgedSets = /* @__PURE__ */ new Map();\n        let position = void 0;\n        for (const item of items){\n            const newPosition = makePosition(position);\n            const node = lsonToLiveNode(item);\n            node._setParentLink(this, newPosition);\n            this._items.push(node);\n            position = newPosition;\n        }\n    }\n    /** @internal */ static _deserialize([id], parentToChildren, pool) {\n        const list = new _LiveList();\n        list._attach(id, pool);\n        const children = parentToChildren.get(id);\n        if (children === void 0) {\n            return list;\n        }\n        for (const [id2, crdt] of children){\n            const child = deserialize([\n                id2,\n                crdt\n            ], parentToChildren, pool);\n            child._setParentLink(list, crdt.parentKey);\n            list._insertAndSort(child);\n        }\n        return list;\n    }\n    /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */ _toOps(parentId, parentKey, pool) {\n        if (this._id === void 0) {\n            throw new Error(\"Cannot serialize item is not attached\");\n        }\n        const ops = [];\n        const op = {\n            id: this._id,\n            opId: pool?.generateOpId(),\n            type: 2 /* CREATE_LIST */ ,\n            parentId,\n            parentKey\n        };\n        ops.push(op);\n        for (const item of this._items){\n            const parentKey2 = item._getParentKeyOrThrow();\n            const childOps = HACK_addIntentAndDeletedIdToOperation(item._toOps(this._id, parentKey2, pool), void 0);\n            const childOpId = childOps[0].opId;\n            if (childOpId !== void 0) {\n                this._unacknowledgedSets.set(parentKey2, childOpId);\n            }\n            ops.push(...childOps);\n        }\n        return ops;\n    }\n    /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */ _insertAndSort(item) {\n        this._items.push(item);\n        this._sortItems();\n    }\n    /** @internal */ _sortItems() {\n        this._items.sort(compareNodePosition);\n        this.invalidate();\n    }\n    /** @internal */ _indexOfPosition(position) {\n        return this._items.findIndex((item)=>item._getParentKeyOrThrow() === position);\n    }\n    /** @internal */ _attach(id, pool) {\n        super._attach(id, pool);\n        for (const item of this._items){\n            item._attach(pool.generateId(), pool);\n        }\n    }\n    /** @internal */ _detach() {\n        super._detach();\n        for (const item of this._items){\n            item._detach();\n        }\n    }\n    /** @internal */ _applySetRemote(op) {\n        if (this._pool === void 0) {\n            throw new Error(\"Can't attach child if managed pool is not present\");\n        }\n        const { id, parentKey: key } = op;\n        const child = creationOpToLiveNode(op);\n        child._attach(id, this._pool);\n        child._setParentLink(this, key);\n        const deletedId = op.deletedId;\n        const indexOfItemWithSamePosition = this._indexOfPosition(key);\n        if (indexOfItemWithSamePosition !== -1) {\n            const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n            if (itemWithSamePosition._id === deletedId) {\n                itemWithSamePosition._detach();\n                this._items[indexOfItemWithSamePosition] = child;\n                return {\n                    modified: makeUpdate(this, [\n                        setDelta(indexOfItemWithSamePosition, child)\n                    ]),\n                    reverse: []\n                };\n            } else {\n                this._implicitlyDeletedItems.add(itemWithSamePosition);\n                this._items[indexOfItemWithSamePosition] = child;\n                const delta = [\n                    setDelta(indexOfItemWithSamePosition, child)\n                ];\n                const deleteDelta2 = this._detachItemAssociatedToSetOperation(op.deletedId);\n                if (deleteDelta2) {\n                    delta.push(deleteDelta2);\n                }\n                return {\n                    modified: makeUpdate(this, delta),\n                    reverse: []\n                };\n            }\n        } else {\n            const updates = [];\n            const deleteDelta2 = this._detachItemAssociatedToSetOperation(op.deletedId);\n            if (deleteDelta2) {\n                updates.push(deleteDelta2);\n            }\n            this._insertAndSort(child);\n            updates.push(insertDelta(this._indexOfPosition(key), child));\n            return {\n                reverse: [],\n                modified: makeUpdate(this, updates)\n            };\n        }\n    }\n    /** @internal */ _applySetAck(op) {\n        if (this._pool === void 0) {\n            throw new Error(\"Can't attach child if managed pool is not present\");\n        }\n        const delta = [];\n        const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n        if (deletedDelta) {\n            delta.push(deletedDelta);\n        }\n        const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n        if (unacknowledgedOpId !== void 0) {\n            if (unacknowledgedOpId !== op.opId) {\n                return delta.length === 0 ? {\n                    modified: false\n                } : {\n                    modified: makeUpdate(this, delta),\n                    reverse: []\n                };\n            } else {\n                this._unacknowledgedSets.delete(op.parentKey);\n            }\n        }\n        const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n        const existingItem = this._items.find((item)=>item._id === op.id);\n        if (existingItem !== void 0) {\n            if (existingItem._parentKey === op.parentKey) {\n                return {\n                    modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n                    reverse: []\n                };\n            }\n            if (indexOfItemWithSamePosition !== -1) {\n                this._implicitlyDeletedItems.add(this._items[indexOfItemWithSamePosition]);\n                this._items.splice(indexOfItemWithSamePosition, 1);\n                delta.push(deleteDelta(indexOfItemWithSamePosition));\n            }\n            const previousIndex = this._items.indexOf(existingItem);\n            existingItem._setParentLink(this, op.parentKey);\n            this._sortItems();\n            const newIndex = this._items.indexOf(existingItem);\n            if (newIndex !== previousIndex) {\n                delta.push(moveDelta(previousIndex, newIndex, existingItem));\n            }\n            return {\n                modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n                reverse: []\n            };\n        } else {\n            const orphan = this._pool.getNode(op.id);\n            if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n                orphan._setParentLink(this, op.parentKey);\n                this._implicitlyDeletedItems.delete(orphan);\n                this._insertAndSort(orphan);\n                const recreatedItemIndex = this._items.indexOf(orphan);\n                return {\n                    modified: makeUpdate(this, [\n                        // If there is an item at this position, update is a set, else it's an insert\n                        indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n                        ...delta\n                    ]),\n                    reverse: []\n                };\n            } else {\n                if (indexOfItemWithSamePosition !== -1) {\n                    this._items.splice(indexOfItemWithSamePosition, 1);\n                }\n                const { newItem, newIndex } = this._createAttachItemAndSort(op, op.parentKey);\n                return {\n                    modified: makeUpdate(this, [\n                        // If there is an item at this position, update is a set, else it's an insert\n                        indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n                        ...delta\n                    ]),\n                    reverse: []\n                };\n            }\n        }\n    }\n    /**\n   * Returns the update delta of the deletion or null\n   * @internal\n   */ _detachItemAssociatedToSetOperation(deletedId) {\n        if (deletedId === void 0 || this._pool === void 0) {\n            return null;\n        }\n        const deletedItem = this._pool.getNode(deletedId);\n        if (deletedItem === void 0) {\n            return null;\n        }\n        const result = this._detachChild(deletedItem);\n        if (result.modified === false) {\n            return null;\n        }\n        return result.modified.updates[0];\n    }\n    /** @internal */ _applyRemoteInsert(op) {\n        if (this._pool === void 0) {\n            throw new Error(\"Can't attach child if managed pool is not present\");\n        }\n        const key = asPos(op.parentKey);\n        const existingItemIndex = this._indexOfPosition(key);\n        if (existingItemIndex !== -1) {\n            this._shiftItemPosition(existingItemIndex, key);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n        return {\n            modified: makeUpdate(this, [\n                insertDelta(newIndex, newItem)\n            ]),\n            reverse: []\n        };\n    }\n    /** @internal */ _applyInsertAck(op) {\n        const existingItem = this._items.find((item)=>item._id === op.id);\n        const key = asPos(op.parentKey);\n        const itemIndexAtPosition = this._indexOfPosition(key);\n        if (existingItem) {\n            if (existingItem._parentKey === key) {\n                return {\n                    modified: false\n                };\n            } else {\n                const oldPositionIndex = this._items.indexOf(existingItem);\n                if (itemIndexAtPosition !== -1) {\n                    this._shiftItemPosition(itemIndexAtPosition, key);\n                }\n                existingItem._setParentLink(this, key);\n                this._sortItems();\n                const newIndex = this._indexOfPosition(key);\n                if (newIndex === oldPositionIndex) {\n                    return {\n                        modified: false\n                    };\n                }\n                return {\n                    modified: makeUpdate(this, [\n                        moveDelta(oldPositionIndex, newIndex, existingItem)\n                    ]),\n                    reverse: []\n                };\n            }\n        } else {\n            const orphan = nn(this._pool).getNode(op.id);\n            if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n                orphan._setParentLink(this, key);\n                this._implicitlyDeletedItems.delete(orphan);\n                this._insertAndSort(orphan);\n                const newIndex = this._indexOfPosition(key);\n                return {\n                    modified: makeUpdate(this, [\n                        insertDelta(newIndex, orphan)\n                    ]),\n                    reverse: []\n                };\n            } else {\n                if (itemIndexAtPosition !== -1) {\n                    this._shiftItemPosition(itemIndexAtPosition, key);\n                }\n                const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n                return {\n                    modified: makeUpdate(this, [\n                        insertDelta(newIndex, newItem)\n                    ]),\n                    reverse: []\n                };\n            }\n        }\n    }\n    /** @internal */ _applyInsertUndoRedo(op) {\n        const { id, parentKey: key } = op;\n        const child = creationOpToLiveNode(op);\n        if (this._pool?.getNode(id) !== void 0) {\n            return {\n                modified: false\n            };\n        }\n        child._attach(id, nn(this._pool));\n        child._setParentLink(this, key);\n        const existingItemIndex = this._indexOfPosition(key);\n        let newKey = key;\n        if (existingItemIndex !== -1) {\n            const before2 = this._items[existingItemIndex]?._parentPos;\n            const after2 = this._items[existingItemIndex + 1]?._parentPos;\n            newKey = makePosition(before2, after2);\n            child._setParentLink(this, newKey);\n        }\n        this._insertAndSort(child);\n        const newIndex = this._indexOfPosition(newKey);\n        return {\n            modified: makeUpdate(this, [\n                insertDelta(newIndex, child)\n            ]),\n            reverse: [\n                {\n                    type: 5 /* DELETE_CRDT */ ,\n                    id\n                }\n            ]\n        };\n    }\n    /** @internal */ _applySetUndoRedo(op) {\n        const { id, parentKey: key } = op;\n        const child = creationOpToLiveNode(op);\n        if (this._pool?.getNode(id) !== void 0) {\n            return {\n                modified: false\n            };\n        }\n        this._unacknowledgedSets.set(key, nn(op.opId));\n        const indexOfItemWithSameKey = this._indexOfPosition(key);\n        child._attach(id, nn(this._pool));\n        child._setParentLink(this, key);\n        const newKey = key;\n        if (indexOfItemWithSameKey !== -1) {\n            const existingItem = this._items[indexOfItemWithSameKey];\n            existingItem._detach();\n            this._items[indexOfItemWithSameKey] = child;\n            const reverse = HACK_addIntentAndDeletedIdToOperation(existingItem._toOps(nn(this._id), key, this._pool), op.id);\n            const delta = [\n                setDelta(indexOfItemWithSameKey, child)\n            ];\n            const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n            if (deletedDelta) {\n                delta.push(deletedDelta);\n            }\n            return {\n                modified: makeUpdate(this, delta),\n                reverse\n            };\n        } else {\n            this._insertAndSort(child);\n            this._detachItemAssociatedToSetOperation(op.deletedId);\n            const newIndex = this._indexOfPosition(newKey);\n            return {\n                reverse: [\n                    {\n                        type: 5 /* DELETE_CRDT */ ,\n                        id\n                    }\n                ],\n                modified: makeUpdate(this, [\n                    insertDelta(newIndex, child)\n                ])\n            };\n        }\n    }\n    /** @internal */ _attachChild(op, source) {\n        if (this._pool === void 0) {\n            throw new Error(\"Can't attach child if managed pool is not present\");\n        }\n        let result;\n        if (op.intent === \"set\") {\n            if (source === 1 /* REMOTE */ ) {\n                result = this._applySetRemote(op);\n            } else if (source === 2 /* ACK */ ) {\n                result = this._applySetAck(op);\n            } else {\n                result = this._applySetUndoRedo(op);\n            }\n        } else {\n            if (source === 1 /* REMOTE */ ) {\n                result = this._applyRemoteInsert(op);\n            } else if (source === 2 /* ACK */ ) {\n                result = this._applyInsertAck(op);\n            } else {\n                result = this._applyInsertUndoRedo(op);\n            }\n        }\n        if (result.modified !== false) {\n            this.invalidate();\n        }\n        return result;\n    }\n    /** @internal */ _detachChild(child) {\n        if (child) {\n            const parentKey = nn(child._parentKey);\n            const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n            const indexToDelete = this._items.indexOf(child);\n            if (indexToDelete === -1) {\n                return {\n                    modified: false\n                };\n            }\n            this._items.splice(indexToDelete, 1);\n            this.invalidate();\n            child._detach();\n            return {\n                modified: makeUpdate(this, [\n                    deleteDelta(indexToDelete)\n                ]),\n                reverse\n            };\n        }\n        return {\n            modified: false\n        };\n    }\n    /** @internal */ _applySetChildKeyRemote(newKey, child) {\n        if (this._implicitlyDeletedItems.has(child)) {\n            this._implicitlyDeletedItems.delete(child);\n            child._setParentLink(this, newKey);\n            this._insertAndSort(child);\n            const newIndex = this._items.indexOf(child);\n            return {\n                modified: makeUpdate(this, [\n                    insertDelta(newIndex, child)\n                ]),\n                reverse: []\n            };\n        }\n        const previousKey = child._parentKey;\n        if (newKey === previousKey) {\n            return {\n                modified: false\n            };\n        }\n        const existingItemIndex = this._indexOfPosition(newKey);\n        if (existingItemIndex === -1) {\n            const previousIndex = this._items.indexOf(child);\n            child._setParentLink(this, newKey);\n            this._sortItems();\n            const newIndex = this._items.indexOf(child);\n            if (newIndex === previousIndex) {\n                return {\n                    modified: false\n                };\n            }\n            return {\n                modified: makeUpdate(this, [\n                    moveDelta(previousIndex, newIndex, child)\n                ]),\n                reverse: []\n            };\n        } else {\n            this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos));\n            const previousIndex = this._items.indexOf(child);\n            child._setParentLink(this, newKey);\n            this._sortItems();\n            const newIndex = this._items.indexOf(child);\n            if (newIndex === previousIndex) {\n                return {\n                    modified: false\n                };\n            }\n            return {\n                modified: makeUpdate(this, [\n                    moveDelta(previousIndex, newIndex, child)\n                ]),\n                reverse: []\n            };\n        }\n    }\n    /** @internal */ _applySetChildKeyAck(newKey, child) {\n        const previousKey = nn(child._parentKey);\n        if (this._implicitlyDeletedItems.has(child)) {\n            const existingItemIndex = this._indexOfPosition(newKey);\n            this._implicitlyDeletedItems.delete(child);\n            if (existingItemIndex !== -1) {\n                this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos));\n            }\n            child._setParentLink(this, newKey);\n            this._insertAndSort(child);\n            return {\n                modified: false\n            };\n        } else {\n            if (newKey === previousKey) {\n                return {\n                    modified: false\n                };\n            }\n            const previousIndex = this._items.indexOf(child);\n            const existingItemIndex = this._indexOfPosition(newKey);\n            if (existingItemIndex !== -1) {\n                this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos));\n            }\n            child._setParentLink(this, newKey);\n            this._sortItems();\n            const newIndex = this._items.indexOf(child);\n            if (previousIndex === newIndex) {\n                return {\n                    modified: false\n                };\n            } else {\n                return {\n                    modified: makeUpdate(this, [\n                        moveDelta(previousIndex, newIndex, child)\n                    ]),\n                    reverse: []\n                };\n            }\n        }\n    }\n    /** @internal */ _applySetChildKeyUndoRedo(newKey, child) {\n        const previousKey = nn(child._parentKey);\n        const previousIndex = this._items.indexOf(child);\n        const existingItemIndex = this._indexOfPosition(newKey);\n        if (existingItemIndex !== -1) {\n            this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos));\n        }\n        child._setParentLink(this, newKey);\n        this._sortItems();\n        const newIndex = this._items.indexOf(child);\n        if (previousIndex === newIndex) {\n            return {\n                modified: false\n            };\n        }\n        return {\n            modified: makeUpdate(this, [\n                moveDelta(previousIndex, newIndex, child)\n            ]),\n            reverse: [\n                {\n                    type: 1 /* SET_PARENT_KEY */ ,\n                    id: nn(child._id),\n                    parentKey: previousKey\n                }\n            ]\n        };\n    }\n    /** @internal */ _setChildKey(newKey, child, source) {\n        if (source === 1 /* REMOTE */ ) {\n            return this._applySetChildKeyRemote(newKey, child);\n        } else if (source === 2 /* ACK */ ) {\n            return this._applySetChildKeyAck(newKey, child);\n        } else {\n            return this._applySetChildKeyUndoRedo(newKey, child);\n        }\n    }\n    /** @internal */ _apply(op, isLocal) {\n        return super._apply(op, isLocal);\n    }\n    /** @internal */ _serialize() {\n        if (this.parent.type !== \"HasParent\") {\n            throw new Error(\"Cannot serialize LiveList if parent is missing\");\n        }\n        return {\n            type: 1 /* LIST */ ,\n            parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n            parentKey: this.parent.key\n        };\n    }\n    /**\n   * Returns the number of elements.\n   */ get length() {\n        return this._items.length;\n    }\n    /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */ push(element) {\n        this._pool?.assertStorageIsWritable();\n        return this.insert(element, this.length);\n    }\n    /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */ insert(element, index) {\n        this._pool?.assertStorageIsWritable();\n        if (index < 0 || index > this._items.length) {\n            throw new Error(`Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length}`);\n        }\n        const before2 = this._items[index - 1] ? this._items[index - 1]._parentPos : void 0;\n        const after2 = this._items[index] ? this._items[index]._parentPos : void 0;\n        const position = makePosition(before2, after2);\n        const value = lsonToLiveNode(element);\n        value._setParentLink(this, position);\n        this._insertAndSort(value);\n        if (this._pool && this._id) {\n            const id = this._pool.generateId();\n            value._attach(id, this._pool);\n            this._pool.dispatch(value._toOps(this._id, position, this._pool), [\n                {\n                    type: 5 /* DELETE_CRDT */ ,\n                    id\n                }\n            ], /* @__PURE__ */ new Map([\n                [\n                    this._id,\n                    makeUpdate(this, [\n                        insertDelta(index, value)\n                    ])\n                ]\n            ]));\n        }\n    }\n    /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */ move(index, targetIndex) {\n        this._pool?.assertStorageIsWritable();\n        if (targetIndex < 0) {\n            throw new Error(\"targetIndex cannot be less than 0\");\n        }\n        if (targetIndex >= this._items.length) {\n            throw new Error(\"targetIndex cannot be greater or equal than the list length\");\n        }\n        if (index < 0) {\n            throw new Error(\"index cannot be less than 0\");\n        }\n        if (index >= this._items.length) {\n            throw new Error(\"index cannot be greater or equal than the list length\");\n        }\n        let beforePosition = null;\n        let afterPosition = null;\n        if (index < targetIndex) {\n            afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos;\n            beforePosition = this._items[targetIndex]._parentPos;\n        } else {\n            afterPosition = this._items[targetIndex]._parentPos;\n            beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._parentPos;\n        }\n        const position = makePosition(beforePosition, afterPosition);\n        const item = this._items[index];\n        const previousPosition = item._getParentKeyOrThrow();\n        item._setParentLink(this, position);\n        this._sortItems();\n        if (this._pool && this._id) {\n            const storageUpdates = /* @__PURE__ */ new Map([\n                [\n                    this._id,\n                    makeUpdate(this, [\n                        moveDelta(index, targetIndex, item)\n                    ])\n                ]\n            ]);\n            this._pool.dispatch([\n                {\n                    type: 1 /* SET_PARENT_KEY */ ,\n                    id: nn(item._id),\n                    opId: this._pool.generateOpId(),\n                    parentKey: position\n                }\n            ], [\n                {\n                    type: 1 /* SET_PARENT_KEY */ ,\n                    id: nn(item._id),\n                    parentKey: previousPosition\n                }\n            ], storageUpdates);\n        }\n    }\n    /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */ delete(index) {\n        this._pool?.assertStorageIsWritable();\n        if (index < 0 || index >= this._items.length) {\n            throw new Error(`Cannot delete list item at index \"${index}\". index should be between 0 and ${this._items.length - 1}`);\n        }\n        const item = this._items[index];\n        item._detach();\n        this._items.splice(index, 1);\n        this.invalidate();\n        if (this._pool) {\n            const childRecordId = item._id;\n            if (childRecordId) {\n                const storageUpdates = /* @__PURE__ */ new Map();\n                storageUpdates.set(nn(this._id), makeUpdate(this, [\n                    deleteDelta(index)\n                ]));\n                this._pool.dispatch([\n                    {\n                        id: childRecordId,\n                        opId: this._pool.generateOpId(),\n                        type: 5 /* DELETE_CRDT */ \n                    }\n                ], item._toOps(nn(this._id), item._getParentKeyOrThrow()), storageUpdates);\n            }\n        }\n    }\n    clear() {\n        this._pool?.assertStorageIsWritable();\n        if (this._pool) {\n            const ops = [];\n            const reverseOps = [];\n            const updateDelta = [];\n            for (const item of this._items){\n                item._detach();\n                const childId = item._id;\n                if (childId) {\n                    ops.push({\n                        type: 5 /* DELETE_CRDT */ ,\n                        id: childId,\n                        opId: this._pool.generateOpId()\n                    });\n                    reverseOps.push(...item._toOps(nn(this._id), item._getParentKeyOrThrow()));\n                    updateDelta.push(deleteDelta(0));\n                }\n            }\n            this._items = [];\n            this.invalidate();\n            const storageUpdates = /* @__PURE__ */ new Map();\n            storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n            this._pool.dispatch(ops, reverseOps, storageUpdates);\n        } else {\n            for (const item of this._items){\n                item._detach();\n            }\n            this._items = [];\n            this.invalidate();\n        }\n    }\n    set(index, item) {\n        this._pool?.assertStorageIsWritable();\n        if (index < 0 || index >= this._items.length) {\n            throw new Error(`Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length - 1}`);\n        }\n        const existingItem = this._items[index];\n        const position = existingItem._getParentKeyOrThrow();\n        const existingId = existingItem._id;\n        existingItem._detach();\n        const value = lsonToLiveNode(item);\n        value._setParentLink(this, position);\n        this._items[index] = value;\n        this.invalidate();\n        if (this._pool && this._id) {\n            const id = this._pool.generateId();\n            value._attach(id, this._pool);\n            const storageUpdates = /* @__PURE__ */ new Map();\n            storageUpdates.set(this._id, makeUpdate(this, [\n                setDelta(index, value)\n            ]));\n            const ops = HACK_addIntentAndDeletedIdToOperation(value._toOps(this._id, position, this._pool), existingId);\n            this._unacknowledgedSets.set(position, nn(ops[0].opId));\n            const reverseOps = HACK_addIntentAndDeletedIdToOperation(existingItem._toOps(this._id, position, void 0), id);\n            this._pool.dispatch(ops, reverseOps, storageUpdates);\n        }\n    }\n    /**\n   * Returns an Array of all the elements in the LiveList.\n   */ toArray() {\n        return this._items.map((entry)=>liveNodeToLson(entry));\n    }\n    /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */ every(predicate) {\n        return this.toArray().every(predicate);\n    }\n    /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */ filter(predicate) {\n        return this.toArray().filter(predicate);\n    }\n    /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */ find(predicate) {\n        return this.toArray().find(predicate);\n    }\n    /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */ findIndex(predicate) {\n        return this.toArray().findIndex(predicate);\n    }\n    /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */ forEach(callbackfn) {\n        return this.toArray().forEach(callbackfn);\n    }\n    /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */ get(index) {\n        if (index < 0 || index >= this._items.length) {\n            return void 0;\n        }\n        return liveNodeToLson(this._items[index]);\n    }\n    /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */ indexOf(searchElement, fromIndex) {\n        return this.toArray().indexOf(searchElement, fromIndex);\n    }\n    /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */ lastIndexOf(searchElement, fromIndex) {\n        return this.toArray().lastIndexOf(searchElement, fromIndex);\n    }\n    /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */ map(callback) {\n        return this._items.map((entry, i)=>callback(liveNodeToLson(entry), //                    ^^^^^^^^\n            //                    FIXME! This isn't safe.\n            i));\n    }\n    /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */ some(predicate) {\n        return this.toArray().some(predicate);\n    }\n    [Symbol.iterator]() {\n        return new LiveListIterator(this._items);\n    }\n    /** @internal */ _createAttachItemAndSort(op, key) {\n        const newItem = creationOpToLiveNode(op);\n        newItem._attach(op.id, nn(this._pool));\n        newItem._setParentLink(this, key);\n        this._insertAndSort(newItem);\n        const newIndex = this._indexOfPosition(key);\n        return {\n            newItem,\n            newIndex\n        };\n    }\n    /** @internal */ _shiftItemPosition(index, key) {\n        const shiftedPosition = makePosition(key, this._items.length > index + 1 ? this._items[index + 1]?._parentPos : void 0);\n        this._items[index]._setParentLink(this, shiftedPosition);\n    }\n    /** @internal */ _toTreeNode(key) {\n        return {\n            type: \"LiveList\",\n            id: this._id ?? nanoid(),\n            key,\n            payload: this._items.map((item, index)=>item.toTreeNode(index.toString()))\n        };\n    }\n    toImmutable() {\n        return super.toImmutable();\n    }\n    /** @internal */ _toImmutable() {\n        const result = this._items.map((node)=>node.toImmutable());\n        return  false ? 0 : Object.freeze(result);\n    }\n    clone() {\n        return new _LiveList(this._items.map((item)=>item.clone()));\n    }\n};\nvar LiveListIterator = class {\n    constructor(items){\n        this._innerIterator = items[Symbol.iterator]();\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n    next() {\n        const result = this._innerIterator.next();\n        if (result.done) {\n            return {\n                done: true,\n                value: void 0\n            };\n        }\n        const value = liveNodeToLson(result.value);\n        return {\n            value\n        };\n    }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n    return {\n        node: liveList,\n        type: \"LiveList\",\n        updates: deltaUpdates\n    };\n}\nfunction setDelta(index, item) {\n    return {\n        index,\n        type: \"set\",\n        item: item instanceof LiveRegister ? item.data : item\n    };\n}\nfunction deleteDelta(index) {\n    return {\n        index,\n        type: \"delete\"\n    };\n}\nfunction insertDelta(index, item) {\n    return {\n        index,\n        type: \"insert\",\n        item: item instanceof LiveRegister ? item.data : item\n    };\n}\nfunction moveDelta(previousIndex, index, item) {\n    return {\n        index,\n        type: \"move\",\n        previousIndex,\n        item: item instanceof LiveRegister ? item.data : item\n    };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n    return ops.map((op, index)=>{\n        if (index === 0) {\n            const firstOp = op;\n            return {\n                ...firstOp,\n                intent: \"set\",\n                deletedId\n            };\n        } else {\n            return op;\n        }\n    });\n}\n// src/lib/freeze.ts\nvar freeze =  false ? /* istanbul ignore next */ 0 : Object.freeze;\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n    constructor(entries2){\n        super();\n        this.unacknowledgedSet = /* @__PURE__ */ new Map();\n        if (entries2) {\n            const mappedEntries = [];\n            for (const [key, value] of entries2){\n                const node = lsonToLiveNode(value);\n                node._setParentLink(this, key);\n                mappedEntries.push([\n                    key,\n                    node\n                ]);\n            }\n            this._map = new Map(mappedEntries);\n        } else {\n            this._map = /* @__PURE__ */ new Map();\n        }\n    }\n    /**\n   * @internal\n   */ _toOps(parentId, parentKey, pool) {\n        if (this._id === void 0) {\n            throw new Error(\"Cannot serialize item is not attached\");\n        }\n        const ops = [];\n        const op = {\n            id: this._id,\n            opId: pool?.generateOpId(),\n            type: 7 /* CREATE_MAP */ ,\n            parentId,\n            parentKey\n        };\n        ops.push(op);\n        for (const [key, value] of this._map){\n            ops.push(...value._toOps(this._id, key, pool));\n        }\n        return ops;\n    }\n    /**\n   * @internal\n   */ static _deserialize([id, _item], parentToChildren, pool) {\n        const map = new _LiveMap();\n        map._attach(id, pool);\n        const children = parentToChildren.get(id);\n        if (children === void 0) {\n            return map;\n        }\n        for (const [id2, crdt] of children){\n            const child = deserialize([\n                id2,\n                crdt\n            ], parentToChildren, pool);\n            child._setParentLink(map, crdt.parentKey);\n            map._map.set(crdt.parentKey, child);\n            map.invalidate();\n        }\n        return map;\n    }\n    /**\n   * @internal\n   */ _attach(id, pool) {\n        super._attach(id, pool);\n        for (const [_key, value] of this._map){\n            if (isLiveNode(value)) {\n                value._attach(pool.generateId(), pool);\n            }\n        }\n    }\n    /**\n   * @internal\n   */ _attachChild(op, source) {\n        if (this._pool === void 0) {\n            throw new Error(\"Can't attach child if managed pool is not present\");\n        }\n        const { id, parentKey, opId } = op;\n        const key = parentKey;\n        const child = creationOpToLiveNode(op);\n        if (this._pool.getNode(id) !== void 0) {\n            return {\n                modified: false\n            };\n        }\n        if (source === 2 /* ACK */ ) {\n            const lastUpdateOpId = this.unacknowledgedSet.get(key);\n            if (lastUpdateOpId === opId) {\n                this.unacknowledgedSet.delete(key);\n                return {\n                    modified: false\n                };\n            } else if (lastUpdateOpId !== void 0) {\n                return {\n                    modified: false\n                };\n            }\n        } else if (source === 1 /* REMOTE */ ) {\n            this.unacknowledgedSet.delete(key);\n        }\n        const previousValue = this._map.get(key);\n        let reverse;\n        if (previousValue) {\n            const thisId = nn(this._id);\n            reverse = previousValue._toOps(thisId, key);\n            previousValue._detach();\n        } else {\n            reverse = [\n                {\n                    type: 5 /* DELETE_CRDT */ ,\n                    id\n                }\n            ];\n        }\n        child._setParentLink(this, key);\n        child._attach(id, this._pool);\n        this._map.set(key, child);\n        this.invalidate();\n        return {\n            modified: {\n                node: this,\n                type: \"LiveMap\",\n                updates: {\n                    [key]: {\n                        type: \"update\"\n                    }\n                }\n            },\n            reverse\n        };\n    }\n    /**\n   * @internal\n   */ _detach() {\n        super._detach();\n        for (const item of this._map.values()){\n            item._detach();\n        }\n    }\n    /**\n   * @internal\n   */ _detachChild(child) {\n        const id = nn(this._id);\n        const parentKey = nn(child._parentKey);\n        const reverse = child._toOps(id, parentKey, this._pool);\n        for (const [key, value] of this._map){\n            if (value === child) {\n                this._map.delete(key);\n                this.invalidate();\n            }\n        }\n        child._detach();\n        const storageUpdate = {\n            node: this,\n            type: \"LiveMap\",\n            updates: {\n                [parentKey]: {\n                    type: \"delete\"\n                }\n            }\n        };\n        return {\n            modified: storageUpdate,\n            reverse\n        };\n    }\n    /**\n   * @internal\n   */ _serialize() {\n        if (this.parent.type !== \"HasParent\") {\n            throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n        }\n        return {\n            type: 2 /* MAP */ ,\n            parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n            parentKey: this.parent.key\n        };\n    }\n    /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */ get(key) {\n        const value = this._map.get(key);\n        if (value === void 0) {\n            return void 0;\n        }\n        return liveNodeToLson(value);\n    }\n    /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */ set(key, value) {\n        this._pool?.assertStorageIsWritable();\n        const oldValue = this._map.get(key);\n        if (oldValue) {\n            oldValue._detach();\n        }\n        const item = lsonToLiveNode(value);\n        item._setParentLink(this, key);\n        this._map.set(key, item);\n        this.invalidate();\n        if (this._pool && this._id) {\n            const id = this._pool.generateId();\n            item._attach(id, this._pool);\n            const storageUpdates = /* @__PURE__ */ new Map();\n            storageUpdates.set(this._id, {\n                node: this,\n                type: \"LiveMap\",\n                updates: {\n                    [key]: {\n                        type: \"update\"\n                    }\n                }\n            });\n            const ops = item._toOps(this._id, key, this._pool);\n            this.unacknowledgedSet.set(key, nn(ops[0].opId));\n            this._pool.dispatch(item._toOps(this._id, key, this._pool), oldValue ? oldValue._toOps(this._id, key) : [\n                {\n                    type: 5 /* DELETE_CRDT */ ,\n                    id\n                }\n            ], storageUpdates);\n        }\n    }\n    /**\n   * Returns the number of elements in the LiveMap.\n   */ get size() {\n        return this._map.size;\n    }\n    /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */ has(key) {\n        return this._map.has(key);\n    }\n    /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */ delete(key) {\n        this._pool?.assertStorageIsWritable();\n        const item = this._map.get(key);\n        if (item === void 0) {\n            return false;\n        }\n        item._detach();\n        this._map.delete(key);\n        this.invalidate();\n        if (this._pool && item._id) {\n            const thisId = nn(this._id);\n            const storageUpdates = /* @__PURE__ */ new Map();\n            storageUpdates.set(thisId, {\n                node: this,\n                type: \"LiveMap\",\n                updates: {\n                    [key]: {\n                        type: \"delete\"\n                    }\n                }\n            });\n            this._pool.dispatch([\n                {\n                    type: 5 /* DELETE_CRDT */ ,\n                    id: item._id,\n                    opId: this._pool.generateOpId()\n                }\n            ], item._toOps(thisId, key), storageUpdates);\n        }\n        return true;\n    }\n    /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */ entries() {\n        const innerIterator = this._map.entries();\n        return {\n            [Symbol.iterator] () {\n                return this;\n            },\n            next () {\n                const iteratorValue = innerIterator.next();\n                if (iteratorValue.done) {\n                    return {\n                        done: true,\n                        value: void 0\n                    };\n                }\n                const entry = iteratorValue.value;\n                const key = entry[0];\n                const value = liveNodeToLson(iteratorValue.value[1]);\n                return {\n                    value: [\n                        key,\n                        value\n                    ]\n                };\n            }\n        };\n    }\n    /**\n   * Same function object as the initial value of the entries method.\n   */ [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */ keys() {\n        return this._map.keys();\n    }\n    /**\n   * Returns a new Iterator object that contains the values for each element.\n   */ values() {\n        const innerIterator = this._map.values();\n        return {\n            [Symbol.iterator] () {\n                return this;\n            },\n            next () {\n                const iteratorValue = innerIterator.next();\n                if (iteratorValue.done) {\n                    return {\n                        done: true,\n                        value: void 0\n                    };\n                }\n                const value = liveNodeToLson(iteratorValue.value);\n                return {\n                    value\n                };\n            }\n        };\n    }\n    /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */ forEach(callback) {\n        for (const entry of this){\n            callback(entry[1], entry[0], this);\n        }\n    }\n    /** @internal */ _toTreeNode(key) {\n        return {\n            type: \"LiveMap\",\n            id: this._id ?? nanoid(),\n            key,\n            payload: Array.from(this._map.entries()).map(([key2, val])=>val.toTreeNode(key2))\n        };\n    }\n    toImmutable() {\n        return super.toImmutable();\n    }\n    /** @internal */ _toImmutable() {\n        const result = /* @__PURE__ */ new Map();\n        for (const [key, value] of this._map){\n            result.set(key, value.toImmutable());\n        }\n        return freeze(result);\n    }\n    clone() {\n        return new _LiveMap(Array.from(this._map).map(([key, node])=>[\n                key,\n                node.clone()\n            ]));\n    }\n};\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n    constructor(obj = {}){\n        super();\n        this._propToLastUpdate = /* @__PURE__ */ new Map();\n        for(const key in obj){\n            const value = obj[key];\n            if (value === void 0) {\n                continue;\n            } else if (isLiveNode(value)) {\n                value._setParentLink(this, key);\n            }\n        }\n        this._map = new Map(Object.entries(obj));\n    }\n    /** @internal */ static _buildRootAndParentToChildren(items) {\n        const parentToChildren = /* @__PURE__ */ new Map();\n        let root = null;\n        for (const [id, crdt] of items){\n            if (isRootCrdt(crdt)) {\n                root = [\n                    id,\n                    crdt\n                ];\n            } else {\n                const tuple = [\n                    id,\n                    crdt\n                ];\n                const children = parentToChildren.get(crdt.parentId);\n                if (children !== void 0) {\n                    children.push(tuple);\n                } else {\n                    parentToChildren.set(crdt.parentId, [\n                        tuple\n                    ]);\n                }\n            }\n        }\n        if (root === null) {\n            throw new Error(\"Root can't be null\");\n        }\n        return [\n            root,\n            parentToChildren\n        ];\n    }\n    /** @internal */ static _fromItems(items, pool) {\n        const [root, parentToChildren] = _LiveObject._buildRootAndParentToChildren(items);\n        return _LiveObject._deserialize(root, parentToChildren, pool);\n    }\n    /** @internal */ _toOps(parentId, parentKey, pool) {\n        if (this._id === void 0) {\n            throw new Error(\"Cannot serialize item is not attached\");\n        }\n        const opId = pool?.generateOpId();\n        const ops = [];\n        const op = {\n            type: 4 /* CREATE_OBJECT */ ,\n            id: this._id,\n            opId,\n            parentId,\n            parentKey,\n            data: {}\n        };\n        ops.push(op);\n        for (const [key, value] of this._map){\n            if (isLiveNode(value)) {\n                ops.push(...value._toOps(this._id, key, pool));\n            } else {\n                op.data[key] = value;\n            }\n        }\n        return ops;\n    }\n    /** @internal */ static _deserialize([id, item], parentToChildren, pool) {\n        const liveObj = new _LiveObject(item.data);\n        liveObj._attach(id, pool);\n        return this._deserializeChildren(liveObj, parentToChildren, pool);\n    }\n    /** @internal */ static _deserializeChildren(liveObj, parentToChildren, pool) {\n        const children = parentToChildren.get(nn(liveObj._id));\n        if (children === void 0) {\n            return liveObj;\n        }\n        for (const [id, crdt] of children){\n            const child = deserializeToLson([\n                id,\n                crdt\n            ], parentToChildren, pool);\n            if (isLiveStructure(child)) {\n                child._setParentLink(liveObj, crdt.parentKey);\n            }\n            liveObj._map.set(crdt.parentKey, child);\n            liveObj.invalidate();\n        }\n        return liveObj;\n    }\n    /** @internal */ _attach(id, pool) {\n        super._attach(id, pool);\n        for (const [_key, value] of this._map){\n            if (isLiveNode(value)) {\n                value._attach(pool.generateId(), pool);\n            }\n        }\n    }\n    /** @internal */ _attachChild(op, source) {\n        if (this._pool === void 0) {\n            throw new Error(\"Can't attach child if managed pool is not present\");\n        }\n        const { id, opId, parentKey: key } = op;\n        const child = creationOpToLson(op);\n        if (this._pool.getNode(id) !== void 0) {\n            if (this._propToLastUpdate.get(key) === opId) {\n                this._propToLastUpdate.delete(key);\n            }\n            return {\n                modified: false\n            };\n        }\n        if (source === 0 /* UNDOREDO_RECONNECT */ ) {\n            this._propToLastUpdate.set(key, nn(opId));\n        } else if (this._propToLastUpdate.get(key) === void 0) {} else if (this._propToLastUpdate.get(key) === opId) {\n            this._propToLastUpdate.delete(key);\n            return {\n                modified: false\n            };\n        } else {\n            return {\n                modified: false\n            };\n        }\n        const thisId = nn(this._id);\n        const previousValue = this._map.get(key);\n        let reverse;\n        if (isLiveNode(previousValue)) {\n            reverse = previousValue._toOps(thisId, key);\n            previousValue._detach();\n        } else if (previousValue === void 0) {\n            reverse = [\n                {\n                    type: 6 /* DELETE_OBJECT_KEY */ ,\n                    id: thisId,\n                    key\n                }\n            ];\n        } else {\n            reverse = [\n                {\n                    type: 3 /* UPDATE_OBJECT */ ,\n                    id: thisId,\n                    data: {\n                        [key]: previousValue\n                    }\n                }\n            ];\n        }\n        this._map.set(key, child);\n        this.invalidate();\n        if (isLiveStructure(child)) {\n            child._setParentLink(this, key);\n            child._attach(id, this._pool);\n        }\n        return {\n            reverse,\n            modified: {\n                node: this,\n                type: \"LiveObject\",\n                updates: {\n                    [key]: {\n                        type: \"update\"\n                    }\n                }\n            }\n        };\n    }\n    /** @internal */ _detachChild(child) {\n        if (child) {\n            const id = nn(this._id);\n            const parentKey = nn(child._parentKey);\n            const reverse = child._toOps(id, parentKey, this._pool);\n            for (const [key, value] of this._map){\n                if (value === child) {\n                    this._map.delete(key);\n                    this.invalidate();\n                }\n            }\n            child._detach();\n            const storageUpdate = {\n                node: this,\n                type: \"LiveObject\",\n                updates: {\n                    [parentKey]: {\n                        type: \"delete\"\n                    }\n                }\n            };\n            return {\n                modified: storageUpdate,\n                reverse\n            };\n        }\n        return {\n            modified: false\n        };\n    }\n    /**\n   * @internal\n   */ _detach() {\n        super._detach();\n        for (const value of this._map.values()){\n            if (isLiveNode(value)) {\n                value._detach();\n            }\n        }\n    }\n    /** @internal */ _apply(op, isLocal) {\n        if (op.type === 3 /* UPDATE_OBJECT */ ) {\n            return this._applyUpdate(op, isLocal);\n        } else if (op.type === 6 /* DELETE_OBJECT_KEY */ ) {\n            return this._applyDeleteObjectKey(op, isLocal);\n        }\n        return super._apply(op, isLocal);\n    }\n    /**\n   * @internal\n   */ _serialize() {\n        const data = {};\n        for (const [key, value] of this._map){\n            if (!isLiveNode(value)) {\n                data[key] = value;\n            }\n        }\n        if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n            return {\n                type: 0 /* OBJECT */ ,\n                parentId: this.parent.node._id,\n                parentKey: this.parent.key,\n                data\n            };\n        } else {\n            return {\n                type: 0 /* OBJECT */ ,\n                data\n            };\n        }\n    }\n    /** @internal */ _applyUpdate(op, isLocal) {\n        let isModified = false;\n        const id = nn(this._id);\n        const reverse = [];\n        const reverseUpdate = {\n            type: 3 /* UPDATE_OBJECT */ ,\n            id,\n            data: {}\n        };\n        for(const key in op.data){\n            const oldValue = this._map.get(key);\n            if (isLiveNode(oldValue)) {\n                reverse.push(...oldValue._toOps(id, key));\n                oldValue._detach();\n            } else if (oldValue !== void 0) {\n                reverseUpdate.data[key] = oldValue;\n            } else if (oldValue === void 0) {\n                reverse.push({\n                    type: 6 /* DELETE_OBJECT_KEY */ ,\n                    id,\n                    key\n                });\n            }\n        }\n        const updateDelta = {};\n        for(const key in op.data){\n            const value = op.data[key];\n            if (value === void 0) {\n                continue;\n            }\n            if (isLocal) {\n                this._propToLastUpdate.set(key, nn(op.opId));\n            } else if (this._propToLastUpdate.get(key) === void 0) {\n                isModified = true;\n            } else if (this._propToLastUpdate.get(key) === op.opId) {\n                this._propToLastUpdate.delete(key);\n                continue;\n            } else {\n                continue;\n            }\n            const oldValue = this._map.get(key);\n            if (isLiveNode(oldValue)) {\n                oldValue._detach();\n            }\n            isModified = true;\n            updateDelta[key] = {\n                type: \"update\"\n            };\n            this._map.set(key, value);\n            this.invalidate();\n        }\n        if (Object.keys(reverseUpdate.data).length !== 0) {\n            reverse.unshift(reverseUpdate);\n        }\n        return isModified ? {\n            modified: {\n                node: this,\n                type: \"LiveObject\",\n                updates: updateDelta\n            },\n            reverse\n        } : {\n            modified: false\n        };\n    }\n    /** @internal */ _applyDeleteObjectKey(op, isLocal) {\n        const key = op.key;\n        if (this._map.has(key) === false) {\n            return {\n                modified: false\n            };\n        }\n        if (!isLocal && this._propToLastUpdate.get(key) !== void 0) {\n            return {\n                modified: false\n            };\n        }\n        const oldValue = this._map.get(key);\n        const id = nn(this._id);\n        let reverse = [];\n        if (isLiveNode(oldValue)) {\n            reverse = oldValue._toOps(id, op.key);\n            oldValue._detach();\n        } else if (oldValue !== void 0) {\n            reverse = [\n                {\n                    type: 3 /* UPDATE_OBJECT */ ,\n                    id,\n                    data: {\n                        [key]: oldValue\n                    }\n                }\n            ];\n        }\n        this._map.delete(key);\n        this.invalidate();\n        return {\n            modified: {\n                node: this,\n                type: \"LiveObject\",\n                updates: {\n                    [op.key]: {\n                        type: \"delete\"\n                    }\n                }\n            },\n            reverse\n        };\n    }\n    /**\n   * Transform the LiveObject into a javascript object\n   */ toObject() {\n        return Object.fromEntries(this._map);\n    }\n    /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */ set(key, value) {\n        this._pool?.assertStorageIsWritable();\n        this.update({\n            [key]: value\n        });\n    }\n    /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */ get(key) {\n        return this._map.get(key);\n    }\n    /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */ delete(key) {\n        this._pool?.assertStorageIsWritable();\n        const keyAsString = key;\n        const oldValue = this._map.get(keyAsString);\n        if (oldValue === void 0) {\n            return;\n        }\n        if (this._pool === void 0 || this._id === void 0) {\n            if (isLiveNode(oldValue)) {\n                oldValue._detach();\n            }\n            this._map.delete(keyAsString);\n            this.invalidate();\n            return;\n        }\n        let reverse;\n        if (isLiveNode(oldValue)) {\n            oldValue._detach();\n            reverse = oldValue._toOps(this._id, keyAsString);\n        } else {\n            reverse = [\n                {\n                    type: 3 /* UPDATE_OBJECT */ ,\n                    data: {\n                        [keyAsString]: oldValue\n                    },\n                    id: this._id\n                }\n            ];\n        }\n        this._map.delete(keyAsString);\n        this.invalidate();\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(this._id, {\n            node: this,\n            type: \"LiveObject\",\n            updates: {\n                [key]: {\n                    type: \"delete\"\n                }\n            }\n        });\n        this._pool.dispatch([\n            {\n                type: 6 /* DELETE_OBJECT_KEY */ ,\n                key: keyAsString,\n                id: this._id,\n                opId: this._pool.generateOpId()\n            }\n        ], reverse, storageUpdates);\n    }\n    /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */ update(patch) {\n        this._pool?.assertStorageIsWritable();\n        if (this._pool === void 0 || this._id === void 0) {\n            for(const key in patch){\n                const newValue = patch[key];\n                if (newValue === void 0) {\n                    continue;\n                }\n                const oldValue = this._map.get(key);\n                if (isLiveNode(oldValue)) {\n                    oldValue._detach();\n                }\n                if (isLiveNode(newValue)) {\n                    newValue._setParentLink(this, key);\n                }\n                this._map.set(key, newValue);\n                this.invalidate();\n            }\n            return;\n        }\n        const ops = [];\n        const reverseOps = [];\n        const opId = this._pool.generateOpId();\n        const updatedProps = {};\n        const reverseUpdateOp = {\n            id: this._id,\n            type: 3 /* UPDATE_OBJECT */ ,\n            data: {}\n        };\n        const updateDelta = {};\n        for(const key in patch){\n            const newValue = patch[key];\n            if (newValue === void 0) {\n                continue;\n            }\n            const oldValue = this._map.get(key);\n            if (isLiveNode(oldValue)) {\n                reverseOps.push(...oldValue._toOps(this._id, key));\n                oldValue._detach();\n            } else if (oldValue === void 0) {\n                reverseOps.push({\n                    type: 6 /* DELETE_OBJECT_KEY */ ,\n                    id: this._id,\n                    key\n                });\n            } else {\n                reverseUpdateOp.data[key] = oldValue;\n            }\n            if (isLiveNode(newValue)) {\n                newValue._setParentLink(this, key);\n                newValue._attach(this._pool.generateId(), this._pool);\n                const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n                const createCrdtOp = newAttachChildOps.find((op)=>op.parentId === this._id);\n                if (createCrdtOp) {\n                    this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n                }\n                ops.push(...newAttachChildOps);\n            } else {\n                updatedProps[key] = newValue;\n                this._propToLastUpdate.set(key, opId);\n            }\n            this._map.set(key, newValue);\n            this.invalidate();\n            updateDelta[key] = {\n                type: \"update\"\n            };\n        }\n        if (Object.keys(reverseUpdateOp.data).length !== 0) {\n            reverseOps.unshift(reverseUpdateOp);\n        }\n        if (Object.keys(updatedProps).length !== 0) {\n            ops.unshift({\n                opId,\n                id: this._id,\n                type: 3 /* UPDATE_OBJECT */ ,\n                data: updatedProps\n            });\n        }\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(this._id, {\n            node: this,\n            type: \"LiveObject\",\n            updates: updateDelta\n        });\n        this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n    toImmutable() {\n        return super.toImmutable();\n    }\n    /** @internal */ toTreeNode(key) {\n        return super.toTreeNode(key);\n    }\n    /** @internal */ _toTreeNode(key) {\n        const nodeId = this._id ?? nanoid();\n        return {\n            type: \"LiveObject\",\n            id: nodeId,\n            key,\n            payload: Array.from(this._map.entries()).map(([key2, value])=>isLiveNode(value) ? value.toTreeNode(key2) : {\n                    type: \"Json\",\n                    id: `${nodeId}:${key2}`,\n                    key: key2,\n                    payload: value\n                })\n        };\n    }\n    /** @internal */ _toImmutable() {\n        const result = {};\n        for (const [key, val] of this._map){\n            result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n        }\n        return  false ? 0 : Object.freeze(result);\n    }\n    clone() {\n        return new _LiveObject(Object.fromEntries(Array.from(this._map).map(([key, value])=>[\n                key,\n                isLiveStructure(value) ? value.clone() : deepClone(value)\n            ])));\n    }\n};\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n    return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n    switch(op.type){\n        case 8 /* CREATE_REGISTER */ :\n            return op.data;\n        case 4 /* CREATE_OBJECT */ :\n            return new LiveObject(op.data);\n        case 7 /* CREATE_MAP */ :\n            return new LiveMap();\n        case 2 /* CREATE_LIST */ :\n            return new LiveList();\n        default:\n            return assertNever(op, \"Unknown creation Op\");\n    }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n    if (node === parent) {\n        return true;\n    }\n    if (node.parent.type === \"HasParent\") {\n        return isSameNodeOrChildOf(node.parent.node, parent);\n    }\n    return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n    switch(crdt.type){\n        case 0 /* OBJECT */ :\n            {\n                return LiveObject._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        case 1 /* LIST */ :\n            {\n                return LiveList._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        case 2 /* MAP */ :\n            {\n                return LiveMap._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        case 3 /* REGISTER */ :\n            {\n                return LiveRegister._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        default:\n            {\n                throw new Error(\"Unexpected CRDT type\");\n            }\n    }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n    switch(crdt.type){\n        case 0 /* OBJECT */ :\n            {\n                return LiveObject._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        case 1 /* LIST */ :\n            {\n                return LiveList._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        case 2 /* MAP */ :\n            {\n                return LiveMap._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        case 3 /* REGISTER */ :\n            {\n                return crdt.data;\n            }\n        default:\n            {\n                throw new Error(\"Unexpected CRDT type\");\n            }\n    }\n}\nfunction isLiveStructure(value) {\n    return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n    return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n    return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n    return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n    return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n    return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n    return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n    if (obj instanceof LiveRegister) {\n        return obj.data;\n    } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n        return obj;\n    } else {\n        return assertNever(obj, \"Unknown AbstractCrdt\");\n    }\n}\nfunction lsonToLiveNode(value) {\n    if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n        return value;\n    } else {\n        return new LiveRegister(value);\n    }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n    const ops = [];\n    currentItems.forEach((_, id)=>{\n        if (!newItems.get(id)) {\n            ops.push({\n                type: 5 /* DELETE_CRDT */ ,\n                id\n            });\n        }\n    });\n    newItems.forEach((crdt, id)=>{\n        const currentCrdt = currentItems.get(id);\n        if (currentCrdt) {\n            if (crdt.type === 0 /* OBJECT */ ) {\n                if (currentCrdt.type !== 0 /* OBJECT */  || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {\n                    ops.push({\n                        type: 3 /* UPDATE_OBJECT */ ,\n                        id,\n                        data: crdt.data\n                    });\n                }\n            }\n            if (crdt.parentKey !== currentCrdt.parentKey) {\n                ops.push({\n                    type: 1 /* SET_PARENT_KEY */ ,\n                    id,\n                    parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n                });\n            }\n        } else {\n            switch(crdt.type){\n                case 3 /* REGISTER */ :\n                    ops.push({\n                        type: 8 /* CREATE_REGISTER */ ,\n                        id,\n                        parentId: crdt.parentId,\n                        parentKey: crdt.parentKey,\n                        data: crdt.data\n                    });\n                    break;\n                case 1 /* LIST */ :\n                    ops.push({\n                        type: 2 /* CREATE_LIST */ ,\n                        id,\n                        parentId: crdt.parentId,\n                        parentKey: crdt.parentKey\n                    });\n                    break;\n                case 0 /* OBJECT */ :\n                    if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n                        throw new Error(\"Internal error. Cannot serialize storage root into an operation\");\n                    }\n                    ops.push({\n                        type: 4 /* CREATE_OBJECT */ ,\n                        id,\n                        parentId: crdt.parentId,\n                        parentKey: crdt.parentKey,\n                        data: crdt.data\n                    });\n                    break;\n                case 2 /* MAP */ :\n                    ops.push({\n                        type: 7 /* CREATE_MAP */ ,\n                        id,\n                        parentId: crdt.parentId,\n                        parentKey: crdt.parentKey\n                    });\n                    break;\n            }\n        }\n    });\n    return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n    const updates = first.updates;\n    for (const [key, value] of entries(second.updates)){\n        updates[key] = value;\n    }\n    return {\n        ...second,\n        updates\n    };\n}\nfunction mergeMapStorageUpdates(first, second) {\n    const updates = first.updates;\n    for (const [key, value] of entries(second.updates)){\n        updates[key] = value;\n    }\n    return {\n        ...second,\n        updates\n    };\n}\nfunction mergeListStorageUpdates(first, second) {\n    const updates = first.updates;\n    return {\n        ...second,\n        updates: updates.concat(second.updates)\n    };\n}\nfunction mergeStorageUpdates(first, second) {\n    if (first === void 0) {\n        return second;\n    }\n    if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n        return mergeObjectStorageUpdates(first, second);\n    } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n        return mergeMapStorageUpdates(first, second);\n    } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n        return mergeListStorageUpdates(first, second);\n    } else {}\n    return second;\n}\nfunction isPlain(value) {\n    const type = typeof value;\n    return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n    if (!isPlain) {\n        return {\n            path: path || \"root\",\n            value\n        };\n    }\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    for (const [key, nestedValue] of Object.entries(value)){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (!isPlain(nestedValue)) {\n            return {\n                path: nestedPath,\n                value: nestedValue\n            };\n        }\n        if (typeof nestedValue === \"object\") {\n            const nonSerializableNestedValue = findNonSerializableValue(nestedValue, nestedPath);\n            if (nonSerializableNestedValue) {\n                return nonSerializableNestedValue;\n            }\n        }\n    }\n    return false;\n}\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n    const errorLike = {\n        name: msg\n    };\n    if (typeof Error.captureStackTrace !== \"function\") {\n        return void 0;\n    }\n    Error.captureStackTrace(errorLike, traceRoot);\n    return errorLike.stack;\n}\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n    return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n    return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n    return !isJsonScalar(data) && !isJsonArray(data);\n}\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2)=>{\n    ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n    ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n    ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n    ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n    ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n    ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n    return ClientMsgCode2;\n})(ClientMsgCode || {});\n// src/refs/ImmutableRef.ts\nfunction merge(target, patch) {\n    let updated = false;\n    const newValue = {\n        ...target\n    };\n    Object.keys(patch).forEach((k)=>{\n        const key = k;\n        const val = patch[key];\n        if (newValue[key] !== val) {\n            if (val === void 0) {\n                delete newValue[key];\n            } else {\n                newValue[key] = val;\n            }\n            updated = true;\n        }\n    });\n    return updated ? newValue : target;\n}\nvar ImmutableRef = class {\n    constructor(){\n        this._ev = makeEventSource();\n    }\n    get didInvalidate() {\n        return this._ev.observable;\n    }\n    invalidate() {\n        if (this._cache !== void 0) {\n            this._cache = void 0;\n            this._ev.notify();\n        }\n    }\n    get current() {\n        return this._cache ?? (this._cache = this._toImmutable());\n    }\n};\n// src/refs/OthersRef.ts\nfunction makeUser(conn, presence) {\n    const { connectionId, id, info } = conn;\n    const canWrite = canWriteStorage(conn.scopes);\n    return freeze(compactObject({\n        connectionId,\n        id,\n        info,\n        canWrite,\n        canComment: canComment(conn.scopes),\n        isReadOnly: !canWrite,\n        // Deprecated, kept for backward-compatibility\n        presence\n    }));\n}\nvar OthersRef = class extends ImmutableRef {\n    //\n    // --------------------------------------------------------------\n    //\n    constructor(){\n        super();\n        this._connections = /* @__PURE__ */ new Map();\n        this._presences = /* @__PURE__ */ new Map();\n        this._users = /* @__PURE__ */ new Map();\n    }\n    connectionIds() {\n        return this._connections.keys();\n    }\n    /** @internal */ _toImmutable() {\n        const users = compact(Array.from(this._presences.keys()).map((connectionId)=>this.getUser(Number(connectionId))));\n        return users;\n    }\n    clearOthers() {\n        this._connections = /* @__PURE__ */ new Map();\n        this._presences = /* @__PURE__ */ new Map();\n        this._users = /* @__PURE__ */ new Map();\n        this.invalidate();\n    }\n    /** @internal */ _getUser(connectionId) {\n        const conn = this._connections.get(connectionId);\n        const presence = this._presences.get(connectionId);\n        if (conn !== void 0 && presence !== void 0) {\n            return makeUser(conn, presence);\n        }\n        return void 0;\n    }\n    getUser(connectionId) {\n        const cachedUser = this._users.get(connectionId);\n        if (cachedUser) {\n            return cachedUser;\n        }\n        const computedUser = this._getUser(connectionId);\n        if (computedUser) {\n            this._users.set(connectionId, computedUser);\n            return computedUser;\n        }\n        return void 0;\n    }\n    /** @internal */ _invalidateUser(connectionId) {\n        if (this._users.has(connectionId)) {\n            this._users.delete(connectionId);\n        }\n        this.invalidate();\n    }\n    /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */ setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n        this._connections.set(connectionId, freeze({\n            connectionId,\n            id: metaUserId,\n            info: metaUserInfo,\n            scopes\n        }));\n        if (this._presences.has(connectionId)) {\n            this._invalidateUser(connectionId);\n        }\n    }\n    /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */ removeConnection(connectionId) {\n        this._connections.delete(connectionId);\n        this._presences.delete(connectionId);\n        this._invalidateUser(connectionId);\n    }\n    /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */ setOther(connectionId, presence) {\n        this._presences.set(connectionId, freeze(compactObject(presence)));\n        if (this._connections.has(connectionId)) {\n            this._invalidateUser(connectionId);\n        }\n    }\n    /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */ patchOther(connectionId, patch) {\n        const oldPresence = this._presences.get(connectionId);\n        if (oldPresence === void 0) {\n            return;\n        }\n        const newPresence = merge(oldPresence, patch);\n        if (oldPresence !== newPresence) {\n            this._presences.set(connectionId, freeze(newPresence));\n            this._invalidateUser(connectionId);\n        }\n    }\n};\n// src/refs/PatchableRef.ts\nvar PatchableRef = class extends ImmutableRef {\n    constructor(data){\n        super();\n        this._data = freeze(compactObject(data));\n    }\n    /** @internal */ _toImmutable() {\n        return this._data;\n    }\n    /**\n   * Patches the current object.\n   */ patch(patch) {\n        const oldData = this._data;\n        const newData = merge(oldData, patch);\n        if (oldData !== newData) {\n            this._data = freeze(newData);\n            this.invalidate();\n        }\n    }\n};\n// src/refs/ValueRef.ts\nvar ValueRef = class extends ImmutableRef {\n    constructor(initialValue){\n        super();\n        this._value = freeze(initialValue);\n    }\n    /** @internal */ _toImmutable() {\n        return this._value;\n    }\n    set(newValue) {\n        this._value = freeze(newValue);\n        this.invalidate();\n    }\n};\nvar DerivedRef = class extends ImmutableRef {\n    constructor(...args){\n        super();\n        const transformFn = args.pop();\n        const otherRefs = args;\n        this._refs = otherRefs;\n        this._refs.forEach((ref)=>{\n            ref.didInvalidate.subscribe(()=>this.invalidate());\n        });\n        this._transform = transformFn;\n    }\n    /** @internal */ _toImmutable() {\n        return this._transform(...this._refs.map((ref)=>ref.current));\n    }\n};\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 1024;\nfunction makeIdFactory(connectionId) {\n    let count = 0;\n    return ()=>`${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n    return {\n        type: \"User\",\n        id: `${user.connectionId}`,\n        key,\n        payload: user\n    };\n}\nfunction installBackgroundTabSpy() {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const inBackgroundSince = {\n        current: null\n    };\n    function onVisibilityChange() {\n        if (doc?.visibilityState === \"hidden\") {\n            inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n        } else {\n            inBackgroundSince.current = null;\n        }\n    }\n    doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n    const unsub = ()=>{\n        doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n    };\n    return [\n        inBackgroundSince,\n        unsub\n    ];\n}\nfunction createRoom(options, config) {\n    const initialPresence = typeof options.initialPresence === \"function\" ? options.initialPresence(config.roomId) : options.initialPresence;\n    const initialStorage = typeof options.initialStorage === \"function\" ? options.initialStorage(config.roomId) : options.initialStorage;\n    const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n    const delegates = {\n        ...config.delegates,\n        // A connection is allowed to go into \"zombie state\" only if all of the\n        // following conditions apply:\n        //\n        // - The `backgroundKeepAliveTimeout` client option is configured\n        // - The browser window has been in the background for at least\n        //   `backgroundKeepAliveTimeout` milliseconds\n        // - There are no pending changes\n        //\n        canZombie () {\n            return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n        }\n    };\n    const managedSocket = new ManagedSocket(delegates, config.enableDebugLogging);\n    const context = {\n        buffer: {\n            flushTimerID: void 0,\n            lastFlushedAt: 0,\n            presenceUpdates: // Queue up the initial presence message as a Full Presenceâ„¢ update\n            {\n                type: \"full\",\n                data: initialPresence\n            },\n            messages: [],\n            storageOperations: []\n        },\n        staticSessionInfo: new ValueRef(null),\n        dynamicSessionInfo: new ValueRef(null),\n        myPresence: new PatchableRef(initialPresence),\n        others: new OthersRef(),\n        initialStorage,\n        idFactory: null,\n        // Storage\n        clock: 0,\n        opClock: 0,\n        nodes: /* @__PURE__ */ new Map(),\n        root: void 0,\n        undoStack: [],\n        redoStack: [],\n        pausedHistory: null,\n        activeBatch: null,\n        unacknowledgedOps: /* @__PURE__ */ new Map(),\n        // Debug\n        opStackTraces:  true ? /* @__PURE__ */ new Map() : 0\n    };\n    const doNotBatchUpdates = (cb)=>cb();\n    const batchUpdates = config.unstable_batchedUpdates ?? doNotBatchUpdates;\n    let lastTokenKey;\n    function onStatusDidChange(newStatus) {\n        const authValue = managedSocket.authValue;\n        if (authValue !== null) {\n            const tokenKey = authValue.type === \"secret\" ? authValue.token.raw : authValue.publicApiKey;\n            if (tokenKey !== lastTokenKey) {\n                lastTokenKey = tokenKey;\n                if (authValue.type === \"secret\") {\n                    const token = authValue.token.parsed;\n                    context.staticSessionInfo.set({\n                        userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */  ? token.id : token.uid,\n                        userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */  ? token.info : token.ui\n                    });\n                } else {\n                    context.staticSessionInfo.set({\n                        userId: void 0,\n                        userInfo: void 0\n                    });\n                }\n            }\n        }\n        batchUpdates(()=>{\n            eventHub.status.notify(newStatus);\n            notifySelfChanged(doNotBatchUpdates);\n        });\n    }\n    let _connectionLossTimerId;\n    let _hasLostConnection = false;\n    function handleConnectionLossEvent(newStatus) {\n        if (newStatus === \"reconnecting\") {\n            _connectionLossTimerId = setTimeout(()=>{\n                batchUpdates(()=>{\n                    eventHub.lostConnection.notify(\"lost\");\n                    _hasLostConnection = true;\n                    context.others.clearOthers();\n                    notify({\n                        others: [\n                            {\n                                type: \"reset\"\n                            }\n                        ]\n                    }, doNotBatchUpdates);\n                });\n            }, config.lostConnectionTimeout);\n        } else {\n            clearTimeout(_connectionLossTimerId);\n            if (_hasLostConnection) {\n                if (newStatus === \"disconnected\") {\n                    batchUpdates(()=>{\n                        eventHub.lostConnection.notify(\"failed\");\n                    });\n                } else {\n                    batchUpdates(()=>{\n                        eventHub.lostConnection.notify(\"restored\");\n                    });\n                }\n                _hasLostConnection = false;\n            }\n        }\n    }\n    function onDidConnect() {\n        context.buffer.presenceUpdates = {\n            type: \"full\",\n            data: // Because context.me.current is a readonly object, we'll have to\n            // make a copy here. Otherwise, type errors happen later when\n            // \"patching\" my presence.\n            {\n                ...context.myPresence.current\n            }\n        };\n        if (_getStorage$ !== null) {\n            refreshStorage({\n                flush: false\n            });\n        }\n        flushNowOrSoon();\n    }\n    function onDidDisconnect() {\n        clearTimeout(context.buffer.flushTimerID);\n    }\n    managedSocket.events.onMessage.subscribe(handleServerMessage);\n    managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n    managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n    managedSocket.events.didConnect.subscribe(onDidConnect);\n    managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n    managedSocket.events.onLiveblocksError.subscribe((err)=>{\n        batchUpdates(()=>{\n            if (true) {\n                error2(`Connection to websocket server closed. Reason: ${err.message} (code: ${err.code}).`);\n            }\n            eventHub.error.notify(err);\n        });\n    });\n    const pool = {\n        roomId: config.roomId,\n        getNode: (id)=>context.nodes.get(id),\n        addNode: (id, node)=>void context.nodes.set(id, node),\n        deleteNode: (id)=>void context.nodes.delete(id),\n        generateId: ()=>`${getConnectionId()}:${context.clock++}`,\n        generateOpId: ()=>`${getConnectionId()}:${context.opClock++}`,\n        dispatch (ops, reverse, storageUpdates) {\n            const activeBatch = context.activeBatch;\n            if (true) {\n                const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n                if (stackTrace) {\n                    for (const op of ops){\n                        if (op.opId) {\n                            nn(context.opStackTraces).set(op.opId, stackTrace);\n                        }\n                    }\n                }\n            }\n            if (activeBatch) {\n                activeBatch.ops.push(...ops);\n                for (const [key, value] of storageUpdates){\n                    activeBatch.updates.storageUpdates.set(key, mergeStorageUpdates(activeBatch.updates.storageUpdates.get(key), value));\n                }\n                activeBatch.reverseOps.unshift(...reverse);\n            } else {\n                batchUpdates(()=>{\n                    addToUndoStack(reverse, doNotBatchUpdates);\n                    context.redoStack.length = 0;\n                    dispatchOps(ops);\n                    notify({\n                        storageUpdates\n                    }, doNotBatchUpdates);\n                });\n            }\n        },\n        assertStorageIsWritable: ()=>{\n            const scopes = context.dynamicSessionInfo.current?.scopes;\n            if (scopes === void 0) {\n                return;\n            }\n            const canWrite = canWriteStorage(scopes);\n            if (!canWrite) {\n                throw new Error(\"Cannot write to storage with a read only user, please ensure the user has write permissions\");\n            }\n        }\n    };\n    const eventHub = {\n        connection: makeEventSource(),\n        // Old/deprecated API\n        status: makeEventSource(),\n        // New/recommended API\n        lostConnection: makeEventSource(),\n        customEvent: makeEventSource(),\n        self: makeEventSource(),\n        myPresence: makeEventSource(),\n        others: makeEventSource(),\n        error: makeEventSource(),\n        storage: makeEventSource(),\n        history: makeEventSource(),\n        storageDidLoad: makeEventSource(),\n        storageStatus: makeEventSource(),\n        ydoc: makeEventSource(),\n        comments: makeEventSource()\n    };\n    async function streamFetch(authTokenOrPublicApiKey, roomId) {\n        const url = new URL(`/v2/c/rooms/${encodeURIComponent(roomId)}/storage`, config.baseUrl).toString();\n        const fetcher = config.polyfills?.fetch || /* istanbul ignore next */ fetch;\n        return fetcher(url.toString(), {\n            method: \"GET\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Bearer ${authTokenOrPublicApiKey}`\n            }\n        });\n    }\n    async function httpPostToRoom(endpoint, body) {\n        if (!managedSocket.authValue) {\n            throw new Error(\"Not authorized\");\n        }\n        const authTokenOrPublicApiKey = managedSocket.authValue.type === \"public\" ? managedSocket.authValue.publicApiKey : managedSocket.authValue.token.raw;\n        const url = new URL(`/v2/c/rooms/${encodeURIComponent(config.roomId)}${endpoint}`, config.baseUrl).toString();\n        const fetcher = config.polyfills?.fetch || /* istanbul ignore next */ fetch;\n        return fetcher(url, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Bearer ${authTokenOrPublicApiKey}`\n            },\n            body: JSON.stringify(body)\n        });\n    }\n    function sendMessages(messages) {\n        const serializedPayload = JSON.stringify(messages);\n        const nonce = context.dynamicSessionInfo.current?.nonce;\n        if (config.unstable_fallbackToHTTP && nonce) {\n            const size = new TextEncoder().encode(serializedPayload).length;\n            if (size > MAX_SOCKET_MESSAGE_SIZE) {\n                void httpPostToRoom(\"/send-message\", {\n                    nonce,\n                    messages\n                }).then((resp)=>{\n                    if (!resp.ok && resp.status === 403) {\n                        managedSocket.reconnect();\n                    }\n                });\n                warn(\"Message was too large for websockets and sent over HTTP instead\");\n                return;\n            }\n        }\n        managedSocket.send(serializedPayload);\n    }\n    const self = new DerivedRef(context.staticSessionInfo, context.dynamicSessionInfo, context.myPresence, (staticSession, dynamicSession, myPresence)=>{\n        if (staticSession === null || dynamicSession === null) {\n            return null;\n        } else {\n            const canWrite = canWriteStorage(dynamicSession.scopes);\n            return {\n                connectionId: dynamicSession.actor,\n                id: staticSession.userId,\n                info: staticSession.userInfo,\n                presence: myPresence,\n                canWrite,\n                canComment: canComment(dynamicSession.scopes),\n                isReadOnly: !canWrite\n            };\n        }\n    });\n    let _lastSelf;\n    function notifySelfChanged(batchedUpdatesWrapper) {\n        const currSelf = self.current;\n        if (currSelf !== null && currSelf !== _lastSelf) {\n            batchedUpdatesWrapper(()=>{\n                eventHub.self.notify(currSelf);\n            });\n            _lastSelf = currSelf;\n        }\n    }\n    const selfAsTreeNode = new DerivedRef(self, (me)=>me !== null ? userToTreeNode(\"Me\", me) : null);\n    function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {\n        if (message.items.length === 0) {\n            throw new Error(\"Internal error: cannot load storage without items\");\n        }\n        if (context.root !== void 0) {\n            updateRoot(message.items, batchedUpdatesWrapper);\n        } else {\n            context.root = LiveObject._fromItems(message.items, pool);\n        }\n        const stackSizeBefore = context.undoStack.length;\n        for(const key in context.initialStorage){\n            if (context.root.get(key) === void 0) {\n                context.root.set(key, cloneLson(context.initialStorage[key]));\n            }\n        }\n        context.undoStack.length = stackSizeBefore;\n    }\n    function updateRoot(items, batchedUpdatesWrapper) {\n        if (context.root === void 0) {\n            return;\n        }\n        const currentItems = /* @__PURE__ */ new Map();\n        for (const [id, node] of context.nodes){\n            currentItems.set(id, node._serialize());\n        }\n        const ops = getTreesDiffOperations(currentItems, new Map(items));\n        const result = applyOps(ops, false);\n        notify(result.updates, batchedUpdatesWrapper);\n    }\n    function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {\n        if (context.undoStack.length >= 50) {\n            context.undoStack.shift();\n        }\n        context.undoStack.push(historyOps);\n        onHistoryChange(batchedUpdatesWrapper);\n    }\n    function addToUndoStack(historyOps, batchedUpdatesWrapper) {\n        if (context.pausedHistory !== null) {\n            context.pausedHistory.unshift(...historyOps);\n        } else {\n            _addToRealUndoStack(historyOps, batchedUpdatesWrapper);\n        }\n    }\n    function notify(updates, batchedUpdatesWrapper) {\n        const storageUpdates = updates.storageUpdates;\n        const othersUpdates = updates.others;\n        batchedUpdatesWrapper(()=>{\n            if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n                const others = context.others.current;\n                for (const event of othersUpdates){\n                    eventHub.others.notify({\n                        ...event,\n                        others\n                    });\n                }\n            }\n            if (updates.presence ?? false) {\n                notifySelfChanged(doNotBatchUpdates);\n                eventHub.myPresence.notify(context.myPresence.current);\n            }\n            if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n                const updates2 = Array.from(storageUpdates.values());\n                eventHub.storage.notify(updates2);\n            }\n            notifyStorageStatus();\n        });\n    }\n    function getConnectionId() {\n        const info = context.dynamicSessionInfo.current;\n        if (info) {\n            return info.actor;\n        }\n        throw new Error(\"Internal. Tried to get connection id but connection was never open\");\n    }\n    function applyOps(rawOps, isLocal) {\n        const output = {\n            reverse: [],\n            storageUpdates: /* @__PURE__ */ new Map(),\n            presence: false\n        };\n        const createdNodeIds = /* @__PURE__ */ new Set();\n        const ops = rawOps.map((op)=>{\n            if (op.type !== \"presence\" && !op.opId) {\n                return {\n                    ...op,\n                    opId: pool.generateOpId()\n                };\n            } else {\n                return op;\n            }\n        });\n        for (const op of ops){\n            if (op.type === \"presence\") {\n                const reverse = {\n                    type: \"presence\",\n                    data: {}\n                };\n                for(const key in op.data){\n                    reverse.data[key] = context.myPresence.current[key];\n                }\n                context.myPresence.patch(op.data);\n                if (context.buffer.presenceUpdates === null) {\n                    context.buffer.presenceUpdates = {\n                        type: \"partial\",\n                        data: op.data\n                    };\n                } else {\n                    for(const key in op.data){\n                        context.buffer.presenceUpdates.data[key] = op.data[key];\n                    }\n                }\n                output.reverse.unshift(reverse);\n                output.presence = true;\n            } else {\n                let source;\n                if (isLocal) {\n                    source = 0 /* UNDOREDO_RECONNECT */ ;\n                } else {\n                    const opId = nn(op.opId);\n                    if (true) {\n                        nn(context.opStackTraces).delete(opId);\n                    }\n                    const deleted = context.unacknowledgedOps.delete(opId);\n                    source = deleted ? 2 /* ACK */  : 1 /* REMOTE */ ;\n                }\n                const applyOpResult = applyOp(op, source);\n                if (applyOpResult.modified) {\n                    const nodeId = applyOpResult.modified.node._id;\n                    if (!(nodeId && createdNodeIds.has(nodeId))) {\n                        output.storageUpdates.set(nn(applyOpResult.modified.node._id), mergeStorageUpdates(output.storageUpdates.get(nn(applyOpResult.modified.node._id)), applyOpResult.modified));\n                        output.reverse.unshift(...applyOpResult.reverse);\n                    }\n                    if (op.type === 2 /* CREATE_LIST */  || op.type === 7 /* CREATE_MAP */  || op.type === 4 /* CREATE_OBJECT */ ) {\n                        createdNodeIds.add(nn(op.id));\n                    }\n                }\n            }\n        }\n        return {\n            ops,\n            reverse: output.reverse,\n            updates: {\n                storageUpdates: output.storageUpdates,\n                presence: output.presence\n            }\n        };\n    }\n    function applyOp(op, source) {\n        if (isAckOp(op)) {\n            return {\n                modified: false\n            };\n        }\n        switch(op.type){\n            case 6 /* DELETE_OBJECT_KEY */ :\n            case 3 /* UPDATE_OBJECT */ :\n            case 5 /* DELETE_CRDT */ :\n                {\n                    const node = context.nodes.get(op.id);\n                    if (node === void 0) {\n                        return {\n                            modified: false\n                        };\n                    }\n                    return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */ );\n                }\n            case 1 /* SET_PARENT_KEY */ :\n                {\n                    const node = context.nodes.get(op.id);\n                    if (node === void 0) {\n                        return {\n                            modified: false\n                        };\n                    }\n                    if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n                        return node.parent.node._setChildKey(asPos(op.parentKey), node, source);\n                    }\n                    return {\n                        modified: false\n                    };\n                }\n            case 4 /* CREATE_OBJECT */ :\n            case 2 /* CREATE_LIST */ :\n            case 7 /* CREATE_MAP */ :\n            case 8 /* CREATE_REGISTER */ :\n                {\n                    if (op.parentId === void 0) {\n                        return {\n                            modified: false\n                        };\n                    }\n                    const parentNode = context.nodes.get(op.parentId);\n                    if (parentNode === void 0) {\n                        return {\n                            modified: false\n                        };\n                    }\n                    return parentNode._attachChild(op, source);\n                }\n        }\n    }\n    function updatePresence(patch, options2) {\n        const oldValues = {};\n        if (context.buffer.presenceUpdates === null) {\n            context.buffer.presenceUpdates = {\n                type: \"partial\",\n                data: {}\n            };\n        }\n        for(const key in patch){\n            const overrideValue = patch[key];\n            if (overrideValue === void 0) {\n                continue;\n            }\n            context.buffer.presenceUpdates.data[key] = overrideValue;\n            oldValues[key] = context.myPresence.current[key];\n        }\n        context.myPresence.patch(patch);\n        if (context.activeBatch) {\n            if (options2?.addToHistory) {\n                context.activeBatch.reverseOps.unshift({\n                    type: \"presence\",\n                    data: oldValues\n                });\n            }\n            context.activeBatch.updates.presence = true;\n        } else {\n            flushNowOrSoon();\n            batchUpdates(()=>{\n                if (options2?.addToHistory) {\n                    addToUndoStack([\n                        {\n                            type: \"presence\",\n                            data: oldValues\n                        }\n                    ], doNotBatchUpdates);\n                }\n                notify({\n                    presence: true\n                }, doNotBatchUpdates);\n            });\n        }\n    }\n    function onUpdatePresenceMessage(message) {\n        if (message.targetActor !== void 0) {\n            const oldUser = context.others.getUser(message.actor);\n            context.others.setOther(message.actor, message.data);\n            const newUser = context.others.getUser(message.actor);\n            if (oldUser === void 0 && newUser !== void 0) {\n                return {\n                    type: \"enter\",\n                    user: newUser\n                };\n            }\n        } else {\n            context.others.patchOther(message.actor, message.data), message;\n        }\n        const user = context.others.getUser(message.actor);\n        if (user) {\n            return {\n                type: \"update\",\n                updates: message.data,\n                user\n            };\n        } else {\n            return void 0;\n        }\n    }\n    function onUserLeftMessage(message) {\n        const user = context.others.getUser(message.actor);\n        if (user) {\n            context.others.removeConnection(message.actor);\n            return {\n                type: \"leave\",\n                user\n            };\n        }\n        return null;\n    }\n    function onRoomStateMessage(message, batchedUpdatesWrapper) {\n        context.dynamicSessionInfo.set({\n            actor: message.actor,\n            nonce: message.nonce,\n            scopes: message.scopes\n        });\n        context.idFactory = makeIdFactory(message.actor);\n        notifySelfChanged(batchedUpdatesWrapper);\n        for (const connectionId of context.others.connectionIds()){\n            const user = message.users[connectionId];\n            if (user === void 0) {\n                context.others.removeConnection(connectionId);\n            }\n        }\n        for(const key in message.users){\n            const user = message.users[key];\n            const connectionId = Number(key);\n            context.others.setConnection(connectionId, user.id, user.info, user.scopes);\n        }\n        return {\n            type: \"reset\"\n        };\n    }\n    function canUndo() {\n        return context.undoStack.length > 0;\n    }\n    function canRedo() {\n        return context.redoStack.length > 0;\n    }\n    function onHistoryChange(batchedUpdatesWrapper) {\n        batchedUpdatesWrapper(()=>{\n            eventHub.history.notify({\n                canUndo: canUndo(),\n                canRedo: canRedo()\n            });\n        });\n    }\n    function onUserJoinedMessage(message) {\n        context.others.setConnection(message.actor, message.id, message.info, message.scopes);\n        context.buffer.messages.push({\n            type: 100 /* UPDATE_PRESENCE */ ,\n            data: context.myPresence.current,\n            targetActor: message.actor\n        });\n        flushNowOrSoon();\n        const user = context.others.getUser(message.actor);\n        return user ? {\n            type: \"enter\",\n            user\n        } : void 0;\n    }\n    function parseServerMessage(data) {\n        if (!isJsonObject(data)) {\n            return null;\n        }\n        return data;\n    }\n    function parseServerMessages(text) {\n        const data = tryParseJson(text);\n        if (data === void 0) {\n            return null;\n        } else if (isJsonArray(data)) {\n            return compact(data.map((item)=>parseServerMessage(item)));\n        } else {\n            return compact([\n                parseServerMessage(data)\n            ]);\n        }\n    }\n    function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {\n        if (offlineOps.size === 0) {\n            return;\n        }\n        const messages = [];\n        const ops = Array.from(offlineOps.values());\n        const result = applyOps(ops, true);\n        messages.push({\n            type: 201 /* UPDATE_STORAGE */ ,\n            ops: result.ops\n        });\n        notify(result.updates, batchedUpdatesWrapper);\n        sendMessages(messages);\n    }\n    function handleServerMessage(event) {\n        if (typeof event.data !== \"string\") {\n            return;\n        }\n        const messages = parseServerMessages(event.data);\n        if (messages === null || messages.length === 0) {\n            return;\n        }\n        const updates = {\n            storageUpdates: /* @__PURE__ */ new Map(),\n            others: []\n        };\n        batchUpdates(()=>{\n            for (const message of messages){\n                switch(message.type){\n                    case 101 /* USER_JOINED */ :\n                        {\n                            const userJoinedUpdate = onUserJoinedMessage(message);\n                            if (userJoinedUpdate) {\n                                updates.others.push(userJoinedUpdate);\n                            }\n                            break;\n                        }\n                    case 100 /* UPDATE_PRESENCE */ :\n                        {\n                            const othersPresenceUpdate = onUpdatePresenceMessage(message);\n                            if (othersPresenceUpdate) {\n                                updates.others.push(othersPresenceUpdate);\n                            }\n                            break;\n                        }\n                    case 103 /* BROADCASTED_EVENT */ :\n                        {\n                            const others = context.others.current;\n                            eventHub.customEvent.notify({\n                                connectionId: message.actor,\n                                user: message.actor < 0 ? null : others.find((u)=>u.connectionId === message.actor) ?? null,\n                                event: message.event\n                            });\n                            break;\n                        }\n                    case 102 /* USER_LEFT */ :\n                        {\n                            const event2 = onUserLeftMessage(message);\n                            if (event2) {\n                                updates.others.push(event2);\n                            }\n                            break;\n                        }\n                    case 300 /* UPDATE_YDOC */ :\n                        {\n                            eventHub.ydoc.notify(message);\n                            break;\n                        }\n                    case 104 /* ROOM_STATE */ :\n                        {\n                            updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));\n                            break;\n                        }\n                    case 200 /* INITIAL_STORAGE_STATE */ :\n                        {\n                            processInitialStorage(message);\n                            break;\n                        }\n                    case 201 /* UPDATE_STORAGE */ :\n                        {\n                            const applyResult = applyOps(message.ops, false);\n                            for (const [key, value] of applyResult.updates.storageUpdates){\n                                updates.storageUpdates.set(key, mergeStorageUpdates(updates.storageUpdates.get(key), value));\n                            }\n                            break;\n                        }\n                    case 299 /* REJECT_STORAGE_OP */ :\n                        {\n                            errorWithTitle(\"Storage mutation rejection error\", message.reason);\n                            if (true) {\n                                const traces = /* @__PURE__ */ new Set();\n                                for (const opId of message.opIds){\n                                    const trace = context.opStackTraces?.get(opId);\n                                    if (trace) {\n                                        traces.add(trace);\n                                    }\n                                }\n                                if (traces.size > 0) {\n                                    warnWithTitle(\"The following function calls caused the rejected storage mutations:\", `\n\n${Array.from(traces).join(\"\\n\\n\")}`);\n                                }\n                                throw new Error(`Storage mutations rejected by server: ${message.reason}`);\n                            }\n                            break;\n                        }\n                    case 400 /* THREAD_CREATED */ :\n                    case 401 /* THREAD_METADATA_UPDATED */ :\n                    case 405 /* COMMENT_REACTION_ADDED */ :\n                    case 406 /* COMMENT_REACTION_REMOVED */ :\n                    case 402 /* COMMENT_CREATED */ :\n                    case 403 /* COMMENT_EDITED */ :\n                    case 404 /* COMMENT_DELETED */ :\n                        {\n                            eventHub.comments.notify(message);\n                            break;\n                        }\n                }\n            }\n            notify(updates, doNotBatchUpdates);\n        });\n    }\n    function flushNowOrSoon() {\n        const storageOps = context.buffer.storageOperations;\n        if (storageOps.length > 0) {\n            for (const op of storageOps){\n                context.unacknowledgedOps.set(nn(op.opId), op);\n            }\n            notifyStorageStatus();\n        }\n        if (managedSocket.getStatus() !== \"connected\") {\n            context.buffer.storageOperations = [];\n            return;\n        }\n        const now = Date.now();\n        const elapsedMillis = now - context.buffer.lastFlushedAt;\n        if (elapsedMillis >= config.throttleDelay) {\n            const messagesToFlush = serializeBuffer();\n            if (messagesToFlush.length === 0) {\n                return;\n            }\n            sendMessages(messagesToFlush);\n            context.buffer = {\n                flushTimerID: void 0,\n                lastFlushedAt: now,\n                messages: [],\n                storageOperations: [],\n                presenceUpdates: null\n            };\n        } else {\n            clearTimeout(context.buffer.flushTimerID);\n            context.buffer.flushTimerID = setTimeout(flushNowOrSoon, config.throttleDelay - elapsedMillis);\n        }\n    }\n    function serializeBuffer() {\n        const messages = [];\n        if (context.buffer.presenceUpdates) {\n            messages.push(context.buffer.presenceUpdates.type === \"full\" ? {\n                type: 100 /* UPDATE_PRESENCE */ ,\n                // Populating the `targetActor` field turns this message into\n                // a Full Presenceâ„¢ update message (not a patch), which will get\n                // interpreted by other clients as such.\n                targetActor: -1,\n                data: context.buffer.presenceUpdates.data\n            } : {\n                type: 100 /* UPDATE_PRESENCE */ ,\n                data: context.buffer.presenceUpdates.data\n            });\n        }\n        for (const event of context.buffer.messages){\n            messages.push(event);\n        }\n        if (context.buffer.storageOperations.length > 0) {\n            messages.push({\n                type: 201 /* UPDATE_STORAGE */ ,\n                ops: context.buffer.storageOperations\n            });\n        }\n        return messages;\n    }\n    function updateYDoc(update, guid) {\n        const clientMsg = {\n            type: 301 /* UPDATE_YDOC */ ,\n            update,\n            guid\n        };\n        context.buffer.messages.push(clientMsg);\n        eventHub.ydoc.notify(clientMsg);\n        flushNowOrSoon();\n    }\n    function broadcastEvent(event, options2 = {\n        shouldQueueEventIfNotReady: false\n    }) {\n        if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n            return;\n        }\n        context.buffer.messages.push({\n            type: 103 /* BROADCAST_EVENT */ ,\n            event\n        });\n        flushNowOrSoon();\n    }\n    function dispatchOps(ops) {\n        context.buffer.storageOperations.push(...ops);\n        flushNowOrSoon();\n    }\n    let _getStorage$ = null;\n    let _resolveStoragePromise = null;\n    function processInitialStorage(message) {\n        const unacknowledgedOps = new Map(context.unacknowledgedOps);\n        createOrUpdateRootFromMessage(message, doNotBatchUpdates);\n        applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);\n        _resolveStoragePromise?.();\n        notifyStorageStatus();\n        eventHub.storageDidLoad.notify();\n    }\n    async function streamStorage() {\n        if (!managedSocket.authValue) {\n            return;\n        }\n        const result = await streamFetch(managedSocket.authValue.type === \"public\" ? managedSocket.authValue.publicApiKey : managedSocket.authValue.token.raw, config.roomId);\n        const items = await result.json();\n        processInitialStorage({\n            type: 200 /* INITIAL_STORAGE_STATE */ ,\n            items\n        });\n    }\n    function refreshStorage(options2) {\n        const messages = context.buffer.messages;\n        if (config.unstable_streamData) {\n            void streamStorage();\n        } else if (!messages.some((msg)=>msg.type === 200 /* FETCH_STORAGE */ )) {\n            messages.push({\n                type: 200 /* FETCH_STORAGE */ \n            });\n        }\n        if (options2.flush) {\n            flushNowOrSoon();\n        }\n    }\n    function startLoadingStorage() {\n        if (_getStorage$ === null) {\n            refreshStorage({\n                flush: true\n            });\n            _getStorage$ = new Promise((resolve)=>{\n                _resolveStoragePromise = resolve;\n            });\n            notifyStorageStatus();\n        }\n        return _getStorage$;\n    }\n    function getStorageSnapshot() {\n        const root = context.root;\n        if (root !== void 0) {\n            return root;\n        } else {\n            void startLoadingStorage();\n            return null;\n        }\n    }\n    async function getStorage() {\n        if (context.root !== void 0) {\n            return Promise.resolve({\n                root: context.root\n            });\n        }\n        await startLoadingStorage();\n        return {\n            root: nn(context.root)\n        };\n    }\n    function fetchYDoc(vector, guid) {\n        if (!context.buffer.messages.find((m)=>{\n            return m.type === 300 /* FETCH_YDOC */  && m.vector === vector && m.guid === guid;\n        })) {\n            context.buffer.messages.push({\n                type: 300 /* FETCH_YDOC */ ,\n                vector,\n                guid\n            });\n        }\n        flushNowOrSoon();\n    }\n    function undo() {\n        if (context.activeBatch) {\n            throw new Error(\"undo is not allowed during a batch\");\n        }\n        const historyOps = context.undoStack.pop();\n        if (historyOps === void 0) {\n            return;\n        }\n        context.pausedHistory = null;\n        const result = applyOps(historyOps, true);\n        batchUpdates(()=>{\n            notify(result.updates, doNotBatchUpdates);\n            context.redoStack.push(result.reverse);\n            onHistoryChange(doNotBatchUpdates);\n        });\n        for (const op of result.ops){\n            if (op.type !== \"presence\") {\n                context.buffer.storageOperations.push(op);\n            }\n        }\n        flushNowOrSoon();\n    }\n    function redo() {\n        if (context.activeBatch) {\n            throw new Error(\"redo is not allowed during a batch\");\n        }\n        const historyOps = context.redoStack.pop();\n        if (historyOps === void 0) {\n            return;\n        }\n        context.pausedHistory = null;\n        const result = applyOps(historyOps, true);\n        batchUpdates(()=>{\n            notify(result.updates, doNotBatchUpdates);\n            context.undoStack.push(result.reverse);\n            onHistoryChange(doNotBatchUpdates);\n        });\n        for (const op of result.ops){\n            if (op.type !== \"presence\") {\n                context.buffer.storageOperations.push(op);\n            }\n        }\n        flushNowOrSoon();\n    }\n    function clear() {\n        context.undoStack.length = 0;\n        context.redoStack.length = 0;\n    }\n    function batch(callback) {\n        if (context.activeBatch) {\n            return callback();\n        }\n        let returnValue = void 0;\n        batchUpdates(()=>{\n            context.activeBatch = {\n                ops: [],\n                updates: {\n                    storageUpdates: /* @__PURE__ */ new Map(),\n                    presence: false,\n                    others: []\n                },\n                reverseOps: []\n            };\n            try {\n                returnValue = callback();\n            } finally{\n                const currentBatch = context.activeBatch;\n                context.activeBatch = null;\n                if (currentBatch.reverseOps.length > 0) {\n                    addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);\n                }\n                if (currentBatch.ops.length > 0) {\n                    context.redoStack.length = 0;\n                }\n                if (currentBatch.ops.length > 0) {\n                    dispatchOps(currentBatch.ops);\n                }\n                notify(currentBatch.updates, doNotBatchUpdates);\n                flushNowOrSoon();\n            }\n        });\n        return returnValue;\n    }\n    function pauseHistory() {\n        if (context.pausedHistory === null) {\n            context.pausedHistory = [];\n        }\n    }\n    function resumeHistory() {\n        const historyOps = context.pausedHistory;\n        context.pausedHistory = null;\n        if (historyOps !== null && historyOps.length > 0) {\n            _addToRealUndoStack(historyOps, batchUpdates);\n        }\n    }\n    function getStorageStatus() {\n        if (context.root === void 0) {\n            return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n        } else {\n            return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n        }\n    }\n    let _lastStorageStatus = getStorageStatus();\n    function notifyStorageStatus() {\n        const storageStatus = getStorageStatus();\n        if (_lastStorageStatus !== storageStatus) {\n            _lastStorageStatus = storageStatus;\n            eventHub.storageStatus.notify(storageStatus);\n        }\n    }\n    const others_forDevTools = new DerivedRef(context.others, (others)=>others.map((other, index)=>userToTreeNode(`Other ${index}`, other)));\n    const events = {\n        status: eventHub.status.observable,\n        lostConnection: eventHub.lostConnection.observable,\n        customEvent: eventHub.customEvent.observable,\n        others: eventHub.others.observable,\n        self: eventHub.self.observable,\n        myPresence: eventHub.myPresence.observable,\n        error: eventHub.error.observable,\n        storage: eventHub.storage.observable,\n        history: eventHub.history.observable,\n        storageDidLoad: eventHub.storageDidLoad.observable,\n        storageStatus: eventHub.storageStatus.observable,\n        ydoc: eventHub.ydoc.observable,\n        comments: eventHub.comments.observable\n    };\n    const commentsApi = createCommentsApi(config.roomId, delegates.authenticate, {\n        baseUrl: config.baseUrl\n    });\n    return Object.defineProperty({\n        /* NOTE: Exposing __internal here only to allow testing implementation details in unit tests */ __internal: {\n            get presenceBuffer () {\n                return deepClone(context.buffer.presenceUpdates?.data ?? null);\n            },\n            // prettier-ignore\n            get undoStack () {\n                return deepClone(context.undoStack);\n            },\n            // prettier-ignore\n            get nodeCount () {\n                return context.nodes.size;\n            },\n            // prettier-ignore\n            // Support for the Liveblocks browser extension\n            getSelf_forDevTools: ()=>selfAsTreeNode.current,\n            getOthers_forDevTools: ()=>others_forDevTools.current,\n            // prettier-ignore\n            simulate: {\n                // These exist only for our E2E testing app\n                explicitClose: (event)=>managedSocket._privateSendMachineEvent({\n                        type: \"EXPLICIT_SOCKET_CLOSE\",\n                        event\n                    }),\n                rawSend: (data)=>managedSocket.send(data)\n            }\n        },\n        id: config.roomId,\n        subscribe: makeClassicSubscribeFn(events),\n        connect: ()=>managedSocket.connect(),\n        reconnect: ()=>managedSocket.reconnect(),\n        disconnect: ()=>managedSocket.disconnect(),\n        destroy: ()=>{\n            uninstallBgTabSpy();\n            managedSocket.destroy();\n        },\n        // Presence\n        updatePresence,\n        updateYDoc,\n        broadcastEvent,\n        // Storage\n        batch,\n        history: {\n            undo,\n            redo,\n            canUndo,\n            canRedo,\n            clear,\n            pause: pauseHistory,\n            resume: resumeHistory\n        },\n        fetchYDoc,\n        getStorage,\n        getStorageSnapshot,\n        getStorageStatus,\n        events,\n        // Core\n        getStatus: ()=>managedSocket.getStatus(),\n        getConnectionState: ()=>managedSocket.getLegacyStatus(),\n        getSelf: ()=>self.current,\n        // Presence\n        getPresence: ()=>context.myPresence.current,\n        getOthers: ()=>context.others.current,\n        ...commentsApi\n    }, // Explictly make the __internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    \"__internal\", {\n        enumerable: false\n    });\n}\nfunction makeClassicSubscribeFn(events) {\n    function subscribeToLiveStructureDeeply(node, callback) {\n        return events.storage.subscribe((updates)=>{\n            const relatedUpdates = updates.filter((update)=>isSameNodeOrChildOf(update.node, node));\n            if (relatedUpdates.length > 0) {\n                callback(relatedUpdates);\n            }\n        });\n    }\n    function subscribeToLiveStructureShallowly(node, callback) {\n        return events.storage.subscribe((updates)=>{\n            for (const update of updates){\n                if (update.node._id === node._id) {\n                    callback(update.node);\n                }\n            }\n        });\n    }\n    function subscribe(first, second, options) {\n        if (typeof first === \"string\" && isRoomEventName(first)) {\n            if (typeof second !== \"function\") {\n                throw new Error(\"Second argument must be a callback function\");\n            }\n            const callback = second;\n            switch(first){\n                case \"event\":\n                    return events.customEvent.subscribe(callback);\n                case \"my-presence\":\n                    return events.myPresence.subscribe(callback);\n                case \"others\":\n                    {\n                        const cb = callback;\n                        return events.others.subscribe((event)=>{\n                            const { others, ...internalEvent } = event;\n                            return cb(others, internalEvent);\n                        });\n                    }\n                case \"error\":\n                    return events.error.subscribe(callback);\n                case \"connection\":\n                    {\n                        const cb = callback;\n                        return events.status.subscribe((status)=>cb(newToLegacyStatus(status)));\n                    }\n                case \"status\":\n                    return events.status.subscribe(callback);\n                case \"lost-connection\":\n                    return events.lostConnection.subscribe(callback);\n                case \"history\":\n                    return events.history.subscribe(callback);\n                case \"storage-status\":\n                    return events.storageStatus.subscribe(callback);\n                default:\n                    return assertNever(first, `\"${String(first)}\" is not a valid event name`);\n            }\n        }\n        if (second === void 0 || typeof first === \"function\") {\n            if (typeof first === \"function\") {\n                const storageCallback = first;\n                return events.storage.subscribe(storageCallback);\n            } else {\n                throw new Error(\"Please specify a listener callback\");\n            }\n        }\n        if (isLiveNode(first)) {\n            const node = first;\n            if (options?.isDeep) {\n                const storageCallback = second;\n                return subscribeToLiveStructureDeeply(node, storageCallback);\n            } else {\n                const nodeCallback = second;\n                return subscribeToLiveStructureShallowly(node, nodeCallback);\n            }\n        }\n        throw new Error(`${String(first)} is not a value that can be subscribed to.`);\n    }\n    return subscribe;\n}\nfunction isRoomEventName(value) {\n    return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n    return async ()=>{\n        return authManager.getAuthValue(\"room:read\", roomId);\n    };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n    return (authValue)=>{\n        const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n        if (ws === void 0) {\n            throw new StopRetrying(\"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\");\n        }\n        const url = new URL(baseUrl);\n        url.protocol = url.protocol === \"http:\" ? \"ws\" : \"wss\";\n        url.pathname = \"/v7\";\n        url.searchParams.set(\"roomId\", roomId);\n        if (authValue.type === \"secret\") {\n            url.searchParams.set(\"tok\", authValue.token.raw);\n        } else if (authValue.type === \"public\") {\n            url.searchParams.set(\"pubkey\", authValue.publicApiKey);\n        } else {\n            return assertNever(authValue, \"Unhandled case\");\n        }\n        url.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n        return new ws(url.toString());\n    };\n}\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nfunction getBaseUrlFromClientOptions(clientOptions) {\n    if (\"liveblocksServer\" in clientOptions) {\n        throw new Error(\"Client option no longer supported\");\n    }\n    if (typeof clientOptions.baseUrl === \"string\" && clientOptions.baseUrl.startsWith(\"http\")) {\n        return clientOptions.baseUrl;\n    } else {\n        return DEFAULT_BASE_URL;\n    }\n}\nfunction createClient(options) {\n    const clientOptions = options;\n    const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n    const lostConnectionTimeout = getLostConnectionTimeout(clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT);\n    const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(clientOptions.backgroundKeepAliveTimeout);\n    const authManager = createAuthManager(options);\n    const roomsById = /* @__PURE__ */ new Map();\n    function teardownRoom(room) {\n        unlinkDevTools(room.id);\n        roomsById.delete(room.id);\n        room.destroy();\n    }\n    function leaseRoom(info) {\n        const leave = ()=>{\n            const self = leave;\n            if (!info.unsubs.delete(self)) {\n                warn(\"This leave function was already called. Calling it more than once has no effect.\");\n            } else {\n                if (info.unsubs.size === 0) {\n                    teardownRoom(info.room);\n                }\n            }\n        };\n        info.unsubs.add(leave);\n        return {\n            room: info.room,\n            leave\n        };\n    }\n    function enterRoom(roomId, options2) {\n        const existing = roomsById.get(roomId);\n        if (existing !== void 0) {\n            return leaseRoom(existing);\n        }\n        deprecateIf(options2.initialPresence === null || options2.initialPresence === void 0, \"Please provide an initial presence value for the current user when entering the room.\");\n        const baseUrl = getBaseUrlFromClientOptions(clientOptions);\n        const newRoom = createRoom({\n            initialPresence: options2.initialPresence ?? {},\n            initialStorage: options2.initialStorage\n        }, {\n            roomId,\n            throttleDelay,\n            lostConnectionTimeout,\n            backgroundKeepAliveTimeout,\n            polyfills: clientOptions.polyfills,\n            delegates: clientOptions.mockedDelegates ?? {\n                createSocket: makeCreateSocketDelegateForRoom(roomId, baseUrl, clientOptions.polyfills?.WebSocket),\n                authenticate: makeAuthDelegateForRoom(roomId, authManager)\n            },\n            enableDebugLogging: clientOptions.enableDebugLogging,\n            unstable_batchedUpdates: options2?.unstable_batchedUpdates,\n            baseUrl,\n            unstable_fallbackToHTTP: !!clientOptions.unstable_fallbackToHTTP,\n            unstable_streamData: !!clientOptions.unstable_streamData\n        });\n        const newRoomInfo = {\n            room: newRoom,\n            unsubs: /* @__PURE__ */ new Set()\n        };\n        roomsById.set(roomId, newRoomInfo);\n        setupDevTools(()=>Array.from(roomsById.keys()));\n        linkDevTools(roomId, newRoom);\n        const shouldConnect = options2.autoConnect ?? options2.shouldInitiallyConnect ?? true;\n        if (shouldConnect) {\n            if (typeof atob === \"undefined\") {\n                if (clientOptions.polyfills?.atob === void 0) {\n                    throw new Error(\"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\");\n                }\n                global.atob = clientOptions.polyfills.atob;\n            }\n            newRoom.connect();\n        }\n        return leaseRoom(newRoomInfo);\n    }\n    function enter(roomId, options2) {\n        const { room, leave: _ } = enterRoom(roomId, options2);\n        return room;\n    }\n    function getRoom(roomId) {\n        const room = roomsById.get(roomId)?.room;\n        return room ? room : null;\n    }\n    function forceLeave(roomId) {\n        const unsubs = roomsById.get(roomId)?.unsubs ?? /* @__PURE__ */ new Set();\n        for (const unsub of unsubs){\n            unsub();\n        }\n    }\n    function logout() {\n        authManager.reset();\n        for (const { room } of roomsById.values()){\n            if (!isIdle(room.getStatus())) {\n                room.reconnect();\n            }\n        }\n    }\n    return {\n        logout,\n        // Old, deprecated APIs\n        enter,\n        getRoom,\n        leave: forceLeave,\n        // New, preferred API\n        enterRoom\n    };\n}\nfunction checkBounds(option, value, min, max, recommendedMin) {\n    if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n        throw new Error(max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`);\n    }\n    return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n    if (value === void 0) return void 0;\n    return checkBounds(\"backgroundKeepAliveTimeout\", value, MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT);\n}\nfunction getThrottle(value) {\n    return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n    return checkBounds(\"lostConnectionTimeout\", value, MIN_LOST_CONNECTION_TIMEOUT, MAX_LOST_CONNECTION_TIMEOUT, RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT);\n}\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n    if (lson instanceof LiveObject) {\n        return {\n            liveblocksType: \"LiveObject\",\n            data: Object.fromEntries(Object.entries(lson.toObject()).flatMap(([key, value])=>value !== void 0 ? [\n                    [\n                        key,\n                        toPlainLson(value)\n                    ]\n                ] : []))\n        };\n    } else if (lson instanceof LiveMap) {\n        return {\n            liveblocksType: \"LiveMap\",\n            data: Object.fromEntries([\n                ...lson\n            ].map(([key, value])=>[\n                    key,\n                    toPlainLson(value)\n                ]))\n        };\n    } else if (lson instanceof LiveList) {\n        return {\n            liveblocksType: \"LiveList\",\n            data: [\n                ...lson\n            ].map((item)=>toPlainLson(item))\n        };\n    } else {\n        return lson;\n    }\n}\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n    const result = {};\n    for(const key in obj){\n        const val = obj[key];\n        if (val !== void 0) {\n            result[key] = lsonToJson(val);\n        }\n    }\n    return result;\n}\nfunction liveObjectToJson(liveObject) {\n    return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n    const result = {};\n    for (const [key, value] of map.entries()){\n        result[key] = lsonToJson(value);\n    }\n    return result;\n}\nfunction lsonListToJson(value) {\n    return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n    return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n    if (value instanceof LiveObject) {\n        return liveObjectToJson(value);\n    } else if (value instanceof LiveList) {\n        return liveListToJson(value);\n    } else if (value instanceof LiveMap) {\n        return liveMapToJson(value);\n    } else if (value instanceof LiveRegister) {\n        return value.data;\n    }\n    if (Array.isArray(value)) {\n        return lsonListToJson(value);\n    } else if (isPlainObject(value)) {\n        return lsonObjectToJson(value);\n    }\n    return value;\n}\nfunction deepLiveify(value) {\n    if (Array.isArray(value)) {\n        return new LiveList(value.map(deepLiveify));\n    } else if (isPlainObject(value)) {\n        const init = {};\n        for(const key in value){\n            const val = value[key];\n            if (val === void 0) {\n                continue;\n            }\n            init[key] = deepLiveify(val);\n        }\n        return new LiveObject(init);\n    } else {\n        return value;\n    }\n}\nfunction patchLiveList(liveList, prev, next) {\n    let i = 0;\n    let prevEnd = prev.length - 1;\n    let nextEnd = next.length - 1;\n    let prevNode = prev[0];\n    let nextNode = next[0];\n    outer: {\n        while(prevNode === nextNode){\n            ++i;\n            if (i > prevEnd || i > nextEnd) {\n                break outer;\n            }\n            prevNode = prev[i];\n            nextNode = next[i];\n        }\n        prevNode = prev[prevEnd];\n        nextNode = next[nextEnd];\n        while(prevNode === nextNode){\n            prevEnd--;\n            nextEnd--;\n            if (i > prevEnd || i > nextEnd) {\n                break outer;\n            }\n            prevNode = prev[prevEnd];\n            nextNode = next[nextEnd];\n        }\n    }\n    if (i > prevEnd) {\n        if (i <= nextEnd) {\n            while(i <= nextEnd){\n                liveList.insert(deepLiveify(next[i]), i);\n                i++;\n            }\n        }\n    } else if (i > nextEnd) {\n        let localI = i;\n        while(localI <= prevEnd){\n            liveList.delete(i);\n            localI++;\n        }\n    } else {\n        while(i <= prevEnd && i <= nextEnd){\n            prevNode = prev[i];\n            nextNode = next[i];\n            const liveListNode = liveList.get(i);\n            if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n                patchLiveObject(liveListNode, prevNode, nextNode);\n            } else {\n                liveList.set(i, deepLiveify(nextNode));\n            }\n            i++;\n        }\n        while(i <= nextEnd){\n            liveList.insert(deepLiveify(next[i]), i);\n            i++;\n        }\n        let localI = i;\n        while(localI <= prevEnd){\n            liveList.delete(i);\n            localI++;\n        }\n    }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n    if (true) {\n        const nonSerializableValue = findNonSerializableValue(next);\n        if (nonSerializableValue) {\n            error2(`New state path: '${nonSerializableValue.path}' value: '${String(nonSerializableValue.value)}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`);\n            return;\n        }\n    }\n    const value = liveObject.get(key);\n    if (next === void 0) {\n        liveObject.delete(key);\n    } else if (value === void 0) {\n        liveObject.set(key, deepLiveify(next));\n    } else if (prev === next) {\n        return;\n    } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n        patchLiveList(value, prev, next);\n    } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n        patchLiveObject(value, prev, next);\n    } else {\n        liveObject.set(key, deepLiveify(next));\n    }\n}\nfunction patchLiveObject(root, prev, next) {\n    const updates = {};\n    for(const key in next){\n        patchLiveObjectKey(root, key, prev[key], next[key]);\n    }\n    for(const key in prev){\n        if (next[key] === void 0) {\n            root.delete(key);\n        }\n    }\n    if (Object.keys(updates).length > 0) {\n        root.update(updates);\n    }\n}\nfunction getParentsPath(node) {\n    const path = [];\n    while(node.parent.type === \"HasParent\"){\n        if (isLiveList(node.parent.node)) {\n            path.push(node.parent.node._indexOfPosition(node.parent.key));\n        } else {\n            path.push(node.parent.key);\n        }\n        node = node.parent.node;\n    }\n    return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n    return updates.reduce((state2, update)=>legacy_patchImmutableObjectWithUpdate(state2, update), state);\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n    const path = getParentsPath(update.node);\n    return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n    const pathItem = path.pop();\n    if (pathItem === void 0) {\n        switch(update.type){\n            case \"LiveObject\":\n                {\n                    if (!isJsonObject(state)) {\n                        throw new Error(\"Internal: received update on LiveObject but state was not an object\");\n                    }\n                    const newState = Object.assign({}, state);\n                    for(const key in update.updates){\n                        if (update.updates[key]?.type === \"update\") {\n                            const val = update.node.get(key);\n                            if (val !== void 0) {\n                                newState[key] = lsonToJson(val);\n                            }\n                        } else if (update.updates[key]?.type === \"delete\") {\n                            delete newState[key];\n                        }\n                    }\n                    return newState;\n                }\n            case \"LiveList\":\n                {\n                    if (!Array.isArray(state)) {\n                        throw new Error(\"Internal: received update on LiveList but state was not an array\");\n                    }\n                    let newState = state.map((x)=>x);\n                    for (const listUpdate of update.updates){\n                        if (listUpdate.type === \"set\") {\n                            newState = newState.map((item, index)=>index === listUpdate.index ? lsonToJson(listUpdate.item) : item);\n                        } else if (listUpdate.type === \"insert\") {\n                            if (listUpdate.index === newState.length) {\n                                newState.push(lsonToJson(listUpdate.item));\n                            } else {\n                                newState = [\n                                    ...newState.slice(0, listUpdate.index),\n                                    lsonToJson(listUpdate.item),\n                                    ...newState.slice(listUpdate.index)\n                                ];\n                            }\n                        } else if (listUpdate.type === \"delete\") {\n                            newState.splice(listUpdate.index, 1);\n                        } else if (listUpdate.type === \"move\") {\n                            if (listUpdate.previousIndex > listUpdate.index) {\n                                newState = [\n                                    ...newState.slice(0, listUpdate.index),\n                                    lsonToJson(listUpdate.item),\n                                    ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                                    ...newState.slice(listUpdate.previousIndex + 1)\n                                ];\n                            } else {\n                                newState = [\n                                    ...newState.slice(0, listUpdate.previousIndex),\n                                    ...newState.slice(listUpdate.previousIndex + 1, listUpdate.index + 1),\n                                    lsonToJson(listUpdate.item),\n                                    ...newState.slice(listUpdate.index + 1)\n                                ];\n                            }\n                        }\n                    }\n                    return newState;\n                }\n            case \"LiveMap\":\n                {\n                    if (!isJsonObject(state)) {\n                        throw new Error(\"Internal: received update on LiveMap but state was not an object\");\n                    }\n                    const newState = Object.assign({}, state);\n                    for(const key in update.updates){\n                        if (update.updates[key]?.type === \"update\") {\n                            const value = update.node.get(key);\n                            if (value !== void 0) {\n                                newState[key] = lsonToJson(value);\n                            }\n                        } else if (update.updates[key]?.type === \"delete\") {\n                            delete newState[key];\n                        }\n                    }\n                    return newState;\n                }\n        }\n    }\n    if (Array.isArray(state)) {\n        const newArray = [\n            ...state\n        ];\n        newArray[pathItem] = legacy_patchImmutableNode(state[pathItem], path, update);\n        return newArray;\n    } else if (isJsonObject(state)) {\n        const node = state[pathItem];\n        if (node === void 0) {\n            return state;\n        } else {\n            const stateAsObj = state;\n            return {\n                ...stateAsObj,\n                [pathItem]: legacy_patchImmutableNode(node, path, update)\n            };\n        }\n    } else {\n        return state;\n    }\n}\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n    if (xs.length !== ys.length) {\n        return false;\n    }\n    for(let i = 0; i < xs.length; i++){\n        if (!Object.is(xs[i], ys[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction shallowObj(objA, objB) {\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null || Object.prototype.toString.call(objA) !== \"[object Object]\" || Object.prototype.toString.call(objB) !== \"[object Object]\") {\n        return false;\n    }\n    const keysA = Object.keys(objA);\n    if (keysA.length !== Object.keys(objB).length) {\n        return false;\n    }\n    return keysA.every((key)=>Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key]));\n}\nfunction shallow(a, b) {\n    if (Object.is(a, b)) {\n        return true;\n    }\n    const isArrayA = Array.isArray(a);\n    const isArrayB = Array.isArray(b);\n    if (isArrayA || isArrayB) {\n        if (!isArrayA || !isArrayB) {\n            return false;\n        }\n        return shallowArray(a, b);\n    }\n    return shallowObj(a, b);\n}\n// src/lib/AsyncCache.ts\nvar noop = ()=>{};\nfunction isShallowEqual(a, b) {\n    if (a.isLoading !== b.isLoading || a.data === void 0 !== (b.data === void 0) || a.error === void 0 !== (b.error === void 0)) {\n        return false;\n    } else {\n        return shallow(a.data, b.data) && shallow(a.error, b.error);\n    }\n}\nfunction createCacheItem(key, asyncFunction, options) {\n    const $asyncFunction = async ()=>asyncFunction(key);\n    const context = {\n        isInvalid: true\n    };\n    let state = {\n        isLoading: false\n    };\n    let previousState = {\n        isLoading: false\n    };\n    const eventSource2 = makeEventSource();\n    function notify() {\n        const isEqual = options?.isStateEqual ?? isShallowEqual;\n        if (!isEqual(previousState, state)) {\n            previousState = state;\n            eventSource2.notify(state);\n        }\n    }\n    async function resolve() {\n        if (!context.promise) {\n            return;\n        }\n        try {\n            const data = await context.promise;\n            context.isInvalid = false;\n            state = {\n                isLoading: false,\n                data\n            };\n        } catch (error3) {\n            state = {\n                isLoading: false,\n                data: state.data,\n                error: error3\n            };\n        }\n        context.promise = void 0;\n        notify();\n    }\n    async function revalidate() {\n        context.isInvalid = true;\n        return get();\n    }\n    async function get() {\n        if (context.isInvalid) {\n            if (!context.promise) {\n                context.isInvalid = true;\n                context.promise = $asyncFunction();\n                state = {\n                    isLoading: true,\n                    data: state.data\n                };\n                notify();\n            }\n            await resolve();\n        }\n        return getState();\n    }\n    function getState() {\n        return state;\n    }\n    return {\n        ...eventSource2.observable,\n        get,\n        getState,\n        revalidate\n    };\n}\nfunction createAsyncCache(asyncFunction, options) {\n    const cache = /* @__PURE__ */ new Map();\n    function create(key) {\n        let cacheItem = cache.get(key);\n        if (cacheItem) {\n            return cacheItem;\n        }\n        cacheItem = createCacheItem(key, asyncFunction, options);\n        cache.set(key, cacheItem);\n        return cacheItem;\n    }\n    function get(key) {\n        return create(key).get();\n    }\n    function getState(key) {\n        return cache.get(key)?.getState();\n    }\n    function revalidate(key) {\n        return create(key).revalidate();\n    }\n    function subscribe(key, callback) {\n        return create(key).subscribe(callback) ?? noop;\n    }\n    function subscribeOnce(key, callback) {\n        return create(key).subscribeOnce(callback) ?? noop;\n    }\n    function has(key) {\n        return cache.has(key);\n    }\n    function clear() {\n        cache.clear();\n    }\n    return {\n        create,\n        get,\n        getState,\n        revalidate,\n        subscribe,\n        subscribeOnce,\n        has,\n        clear\n    };\n}\n// src/lib/Poller.ts\nfunction makePoller(callback) {\n    let context = {\n        state: \"stopped\",\n        timeoutHandle: null,\n        interval: null,\n        lastScheduledAt: null,\n        remainingInterval: null\n    };\n    function poll() {\n        if (context.state === \"running\") {\n            schedule(context.interval);\n        }\n        void callback();\n    }\n    function schedule(interval) {\n        context = {\n            state: \"running\",\n            interval: context.state !== \"stopped\" ? context.interval : interval,\n            lastScheduledAt: performance.now(),\n            timeoutHandle: setTimeout(poll, interval),\n            remainingInterval: null\n        };\n    }\n    function scheduleRemaining(remaining) {\n        if (context.state !== \"paused\") {\n            return;\n        }\n        context = {\n            state: \"running\",\n            interval: context.interval,\n            lastScheduledAt: context.lastScheduledAt,\n            timeoutHandle: setTimeout(poll, remaining),\n            remainingInterval: null\n        };\n    }\n    function start(interval) {\n        if (context.state === \"running\") {\n            return;\n        }\n        schedule(interval);\n    }\n    function restart(interval) {\n        stop();\n        start(interval);\n    }\n    function pause() {\n        if (context.state !== \"running\") {\n            return;\n        }\n        clearTimeout(context.timeoutHandle);\n        context = {\n            state: \"paused\",\n            interval: context.interval,\n            lastScheduledAt: context.lastScheduledAt,\n            timeoutHandle: null,\n            remainingInterval: context.interval - (performance.now() - context.lastScheduledAt)\n        };\n    }\n    function resume() {\n        if (context.state !== \"paused\") {\n            return;\n        }\n        scheduleRemaining(context.remainingInterval);\n    }\n    function stop() {\n        if (context.state === \"stopped\") {\n            return;\n        }\n        if (context.timeoutHandle) {\n            clearTimeout(context.timeoutHandle);\n        }\n        context = {\n            state: \"stopped\",\n            interval: null,\n            lastScheduledAt: null,\n            timeoutHandle: null,\n            remainingInterval: null\n        };\n    }\n    return {\n        start,\n        restart,\n        pause,\n        resume,\n        stop\n    };\n}\n// src/lib/stringify.ts\nfunction stringify(object, ...args) {\n    if (typeof object !== \"object\" || object === null || Array.isArray(object)) {\n        return JSON.stringify(object, ...args);\n    }\n    const sortedObject = Object.keys(object).sort().reduce((sortedObject2, key)=>{\n        sortedObject2[key] = object[key];\n        return sortedObject2;\n    }, {});\n    return JSON.stringify(sortedObject, ...args);\n}\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsV0FBVyxDQUFDQyxRQUFRQztJQUN0QixJQUFLLElBQUlDLFFBQVFELElBQ2ZMLFVBQVVJLFFBQVFFLE1BQU07UUFBRUMsS0FBS0YsR0FBRyxDQUFDQyxLQUFLO1FBQUVFLFlBQVk7SUFBSztBQUMvRDtBQUVBLGlCQUFpQjtBQUNqQixJQUFJQyxXQUFXO0FBQ2YsSUFBSUMsY0FBYztBQUNsQixJQUFJQyxhQUFhO0FBRWpCLHdCQUF3QjtBQUN4QixJQUFJQyxJQUFJLE9BQU9DLGVBQWUsY0FBY0EsYUFBYSxNQUE2QixHQUFHQyxDQUFNQSxHQUFHLE9BQU9DLFdBQVcsY0FBY0EsU0FBUyxDQUFDO0FBQzVJLElBQUlDLGtCQUFrQjtBQUN0QixJQUFJQyxZQUFZO0FBQ2hCLElBQUlDLFFBQVE7QUFDWixTQUFTQyxNQUFNQyxHQUFHO0lBQ2hCLElBQUlDLEtBQXFDLEVBQUUsRUFFMUMsTUFBTTtRQUNMLE1BQU0sSUFBSUUsTUFBTUg7SUFDbEI7QUFDRjtBQUNBLFNBQVNJLFlBQVlDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxTQUFTO0lBQ2pELE1BQU1DLFFBQVFDLE9BQU9DLEdBQUcsQ0FBQ0w7SUFDekIsTUFBTU0sZUFBZUosWUFBWSxDQUFDLEVBQUVELGNBQWMsTUFBTSxFQUFFLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEdBQUdELGNBQWM7SUFDekYsSUFBSSxDQUFDZCxDQUFDLENBQUNnQixNQUFNLEVBQUU7UUFDYmhCLENBQUMsQ0FBQ2dCLE1BQU0sR0FBR0c7SUFDYixPQUFPLElBQUluQixDQUFDLENBQUNnQixNQUFNLEtBQUtHLGNBQWMsQ0FDdEMsT0FBTztRQUNMLE1BQU1YLE1BQU07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LGlCQUFpQjtZQUNqQkYsZUFBZTtZQUNmRyxtQkFBbUI7UUFDckI7SUFDRjtJQUNBLE9BQU87UUFDTDdoQztRQUNBbWlDO1FBQ0FqbkM7UUFDQSsrQjtRQUNBLzVCO0lBQ0Y7QUFDRjtBQUVBLHVCQUF1QjtBQUN2QixTQUFTd0MsVUFBVTAvQixNQUFNLEVBQUUsR0FBR3BsQyxJQUFJO0lBQ2hDLElBQUksT0FBT29sQyxXQUFXLFlBQVlBLFdBQVcsUUFBUWorQixNQUFNQyxPQUFPLENBQUNnK0IsU0FBUztRQUMxRSxPQUFPMy9CLEtBQUtDLFNBQVMsQ0FBQzAvQixXQUFXcGxDO0lBQ25DO0lBQ0EsTUFBTXFsQyxlQUFlcnFDLE9BQU9vTyxJQUFJLENBQUNnOEIsUUFBUXJlLElBQUksR0FBR25NLE1BQU0sQ0FDcEQsQ0FBQzBxQixlQUFlbGpDO1FBQ2RrakMsYUFBYSxDQUFDbGpDLElBQUksR0FBR2dqQyxNQUFNLENBQUNoakMsSUFBSTtRQUNoQyxPQUFPa2pDO0lBQ1QsR0FDQSxDQUFDO0lBRUgsT0FBTzcvQixLQUFLQyxTQUFTLENBQUMyL0IsaUJBQWlCcmxDO0FBQ3pDO0FBRUEsZUFBZTtBQUNmekQsWUFBWWYsVUFBVUMsYUFBYUM7QUFvRGpDLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmlnbWEtY2xvbmUvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4Lm1qcz84NzE1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbnZhciBQS0dfVkVSU0lPTiA9IFwiMS45LjdcIjtcbnZhciBQS0dfRk9STUFUID0gXCJlc21cIjtcblxuLy8gc3JjL2R1cGUtZGV0ZWN0aW9uLnRzXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge307XG52YXIgY3Jvc3NMaW5rZWREb2NzID0gXCJodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvY3Jvc3MtbGlua2VkXCI7XG52YXIgZHVwZXNEb2NzID0gXCJodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvZHVwZXNcIjtcbnZhciBTUEFDRSA9IFwiIFwiO1xuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVjdER1cGVzKHBrZ05hbWUsIHBrZ1ZlcnNpb24sIHBrZ0Zvcm1hdCkge1xuICBjb25zdCBwa2dJZCA9IFN5bWJvbC5mb3IocGtnTmFtZSk7XG4gIGNvbnN0IHBrZ0J1aWxkSW5mbyA9IHBrZ0Zvcm1hdCA/IGAke3BrZ1ZlcnNpb24gfHwgXCJkZXZcIn0gKCR7cGtnRm9ybWF0fSlgIDogcGtnVmVyc2lvbiB8fCBcImRldlwiO1xuICBpZiAoIWdbcGtnSWRdKSB7XG4gICAgZ1twa2dJZF0gPSBwa2dCdWlsZEluZm87XG4gIH0gZWxzZSBpZiAoZ1twa2dJZF0gPT09IHBrZ0J1aWxkSW5mbykge1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1zZyA9IFtcbiAgICAgIGBNdWx0aXBsZSBjb3BpZXMgb2YgTGl2ZWJsb2NrcyBhcmUgYmVpbmcgbG9hZGVkIGluIHlvdXIgcHJvamVjdC4gVGhpcyB3aWxsIGNhdXNlIGlzc3VlcyEgU2VlICR7ZHVwZXNEb2NzICsgU1BBQ0V9YCxcbiAgICAgIFwiXCIsXG4gICAgICBcIkNvbmZsaWN0czpcIixcbiAgICAgIGAtICR7cGtnTmFtZX0gJHtnW3BrZ0lkXX0gKGFscmVhZHkgbG9hZGVkKWAsXG4gICAgICBgLSAke3BrZ05hbWV9ICR7cGtnQnVpbGRJbmZvfSAodHJ5aW5nIHRvIGxvYWQgdGhpcyBub3cpYFxuICAgIF0uam9pbihcIlxcblwiKTtcbiAgICBlcnJvcihtc2cpO1xuICB9XG4gIGlmIChwa2dWZXJzaW9uICYmIFBLR19WRVJTSU9OICYmIHBrZ1ZlcnNpb24gIT09IFBLR19WRVJTSU9OKSB7XG4gICAgZXJyb3IoXG4gICAgICBbXG4gICAgICAgIGBDcm9zcy1saW5rZWQgdmVyc2lvbnMgb2YgTGl2ZWJsb2NrcyBmb3VuZCwgd2hpY2ggd2lsbCBjYXVzZSBpc3N1ZXMhIFNlZSAke2Nyb3NzTGlua2VkRG9jcyArIFNQQUNFfWAsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIFwiQ29uZmxpY3RzOlwiLFxuICAgICAgICBgLSAke1BLR19OQU1FfSBpcyBhdCAke1BLR19WRVJTSU9OfWAsXG4gICAgICAgIGAtICR7cGtnTmFtZX0gaXMgYXQgJHtwa2dWZXJzaW9ufWAsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIFwiQWx3YXlzIHVwZ3JhZGUgYWxsIExpdmVibG9ja3MgcGFja2FnZXMgdG8gdGhlIHNhbWUgdmVyc2lvbiBudW1iZXIuXCJcbiAgICAgIF0uam9pbihcIlxcblwiKVxuICAgICk7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9hc3NlcnQudHNcbmZ1bmN0aW9uIGFzc2VydE5ldmVyKF92YWx1ZSwgZXJybXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihlcnJtc2cpO1xufVxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgZXJybXNnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGVycm1zZyk7XG4gICAgICBlcnIubmFtZSA9IFwiQXNzZXJ0aW9uIGZhaWx1cmVcIjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG5uKHZhbHVlLCBlcnJtc2cgPSBcIkV4cGVjdGVkIHZhbHVlIHRvIGJlIG5vbi1udWxsYWJsZVwiKSB7XG4gIGFzc2VydCh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwLCBlcnJtc2cpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy9saWIvY29udHJvbGxlZFByb21pc2UudHNcbmZ1bmN0aW9uIGNvbnRyb2xsZWRQcm9taXNlKCkge1xuICBsZXQgZmxhZ2dlcjtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICBmbGFnZ2VyID0gcmVzO1xuICB9KTtcbiAgaWYgKCFmbGFnZ2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIG5ldmVyIGhhcHBlblwiKTtcbiAgfVxuICByZXR1cm4gW3Byb21pc2UsIGZsYWdnZXJdO1xufVxuXG4vLyBzcmMvbGliL0V2ZW50U291cmNlLnRzXG5mdW5jdGlvbiBtYWtlRXZlbnRTb3VyY2UoKSB7XG4gIGNvbnN0IF9vbmV0aW1lT2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgX29ic2VydmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBfYnVmZmVyID0gbnVsbDtcbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgX2J1ZmZlciA9IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHVucGF1c2UoKSB7XG4gICAgaWYgKF9idWZmZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBfYnVmZmVyKSB7XG4gICAgICBub3RpZnkoZXZlbnQpO1xuICAgIH1cbiAgICBfYnVmZmVyID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICBfb2JzZXJ2ZXJzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IF9vYnNlcnZlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmVPbmNlKGNhbGxiYWNrKSB7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4gX29uZXRpbWVPYnNlcnZlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB3YWl0VW50aWwocHJlZGljYXRlKSB7XG4gICAgbGV0IHVuc3ViO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICB1bnN1YiA9IHN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSA9PT0gdm9pZCAwIHx8IHByZWRpY2F0ZShldmVudCkpIHtcbiAgICAgICAgICByZXMoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHVuc3ViPy4oKSk7XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5T3JCdWZmZXIoZXZlbnQpIHtcbiAgICBpZiAoX2J1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgX2J1ZmZlci5wdXNoKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90aWZ5KGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5KGV2ZW50KSB7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGV2ZW50KSk7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuY2xlYXIoKTtcbiAgICBfb2JzZXJ2ZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhldmVudCkpO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIF9vbmV0aW1lT2JzZXJ2ZXJzLmNsZWFyKCk7XG4gICAgX29ic2VydmVycy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGNvdW50KCkge1xuICAgIHJldHVybiBfb25ldGltZU9ic2VydmVycy5zaXplICsgX29ic2VydmVycy5zaXplO1xuICB9XG4gIHJldHVybiB7XG4gICAgLy8gUHJpdmF0ZS9pbnRlcm5hbCBjb250cm9sIG92ZXIgZXZlbnQgZW1pc3Npb25cbiAgICBub3RpZnk6IG5vdGlmeU9yQnVmZmVyLFxuICAgIHN1YnNjcmliZSxcbiAgICBzdWJzY3JpYmVPbmNlLFxuICAgIGNsZWFyLFxuICAgIGNvdW50LFxuICAgIHdhaXRVbnRpbCxcbiAgICBwYXVzZSxcbiAgICB1bnBhdXNlLFxuICAgIC8vIFB1YmxpY2x5IGV4cG9zYWJsZSBzdWJzY3JpcHRpb24gQVBJXG4gICAgb2JzZXJ2YWJsZToge1xuICAgICAgc3Vic2NyaWJlLFxuICAgICAgc3Vic2NyaWJlT25jZSxcbiAgICAgIHdhaXRVbnRpbFxuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9mYW5jeS1jb25zb2xlLnRzXG52YXIgZmFuY3lfY29uc29sZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChmYW5jeV9jb25zb2xlX2V4cG9ydHMsIHtcbiAgZXJyb3I6ICgpID0+IGVycm9yMixcbiAgZXJyb3JXaXRoVGl0bGU6ICgpID0+IGVycm9yV2l0aFRpdGxlLFxuICB3YXJuOiAoKSA9PiB3YXJuLFxuICB3YXJuV2l0aFRpdGxlOiAoKSA9PiB3YXJuV2l0aFRpdGxlXG59KTtcbnZhciBiYWRnZSA9IFwiYmFja2dyb3VuZDojMGUwZDEyO2JvcmRlci1yYWRpdXM6OTk5OXB4O2NvbG9yOiNmZmY7cGFkZGluZzozcHggN3B4O2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NjAwO1wiO1xudmFyIGJvbGQgPSBcImZvbnQtd2VpZ2h0OjYwMFwiO1xuZnVuY3Rpb24gd3JhcChtZXRob2QpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiID8gY29uc29sZVttZXRob2RdIDogKFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IGNvbnNvbGVbbWV0aG9kXShcIiVjTGl2ZWJsb2Nrc1wiLCBiYWRnZSwgbWVzc2FnZSwgLi4uYXJncylcbiAgKTtcbn1cbnZhciB3YXJuID0gd3JhcChcIndhcm5cIik7XG52YXIgZXJyb3IyID0gd3JhcChcImVycm9yXCIpO1xuZnVuY3Rpb24gd3JhcFdpdGhUaXRsZShtZXRob2QpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiID8gY29uc29sZVttZXRob2RdIDogKFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgKHRpdGxlLCBtZXNzYWdlLCAuLi5hcmdzKSA9PiBjb25zb2xlW21ldGhvZF0oXG4gICAgICBgJWNMaXZlYmxvY2tzJWMgJHt0aXRsZX1gLFxuICAgICAgYmFkZ2UsXG4gICAgICBib2xkLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIC4uLmFyZ3NcbiAgICApXG4gICk7XG59XG52YXIgd2FybldpdGhUaXRsZSA9IHdyYXBXaXRoVGl0bGUoXCJ3YXJuXCIpO1xudmFyIGVycm9yV2l0aFRpdGxlID0gd3JhcFdpdGhUaXRsZShcImVycm9yXCIpO1xuXG4vLyBzcmMvbGliL2ZzbS50c1xuZnVuY3Rpb24gZGlzdGFuY2Uoc3RhdGUxLCBzdGF0ZTIpIHtcbiAgaWYgKHN0YXRlMSA9PT0gc3RhdGUyKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICBjb25zdCBjaHVua3MxID0gc3RhdGUxLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgY2h1bmtzMiA9IHN0YXRlMi5zcGxpdChcIi5cIik7XG4gIGNvbnN0IG1pbkxlbiA9IE1hdGgubWluKGNodW5rczEubGVuZ3RoLCBjaHVua3MyLmxlbmd0aCk7XG4gIGxldCBzaGFyZWQgPSAwO1xuICBmb3IgKDsgc2hhcmVkIDwgbWluTGVuOyBzaGFyZWQrKykge1xuICAgIGlmIChjaHVua3MxW3NoYXJlZF0gIT09IGNodW5rczJbc2hhcmVkXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGNvbnN0IHVwID0gY2h1bmtzMS5sZW5ndGggLSBzaGFyZWQ7XG4gIGNvbnN0IGRvd24gPSBjaHVua3MyLmxlbmd0aCAtIHNoYXJlZDtcbiAgcmV0dXJuIFt1cCwgZG93bl07XG59XG5mdW5jdGlvbiBwYXR0ZXJucyh0YXJnZXRTdGF0ZSwgbGV2ZWxzKSB7XG4gIGNvbnN0IHBhcnRzID0gdGFyZ2V0U3RhdGUuc3BsaXQoXCIuXCIpO1xuICBpZiAobGV2ZWxzIDwgMSB8fCBsZXZlbHMgPiBwYXJ0cy5sZW5ndGggKyAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgbGV2ZWxzXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBpZiAobGV2ZWxzID4gcGFydHMubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnB1c2goXCIqXCIpO1xuICB9XG4gIGZvciAobGV0IGkgPSBwYXJ0cy5sZW5ndGggLSBsZXZlbHMgKyAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzbGljZSA9IHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgIGlmIChzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQucHVzaChzbGljZS5qb2luKFwiLlwiKSArIFwiLipcIik7XG4gICAgfVxuICB9XG4gIHJlc3VsdC5wdXNoKHRhcmdldFN0YXRlKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBTYWZlQ29udGV4dCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW5pdGlhbENvbnRleHQpIHtcbiAgICB0aGlzLmN1cnIgPSBpbml0aWFsQ29udGV4dDtcbiAgfVxuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBhbGxvd3MgcGF0Y2hpbmcgb2YgdGhlIGNvbnRleHQsIGJ5XG4gICAqIGNhbGxpbmcgYGNvbnRleHQucGF0Y2goKWAuIFBhdGNoaW5nIGlzIG9ubHkgYWxsb3dlZCBmb3IgdGhlIGR1cmF0aW9uXG4gICAqIG9mIHRoaXMgd2luZG93LlxuICAgKi9cbiAgYWxsb3dQYXRjaGluZyhjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBhbGxvd2VkID0gdHJ1ZTtcbiAgICBjb25zdCBwYXRjaGFibGVDb250ZXh0ID0ge1xuICAgICAgLi4udGhpcy5jdXJyLFxuICAgICAgcGF0Y2gocGF0Y2gpIHtcbiAgICAgICAgaWYgKGFsbG93ZWQpIHtcbiAgICAgICAgICBzZWxmLmN1cnIgPSBPYmplY3QuYXNzaWduKHt9LCBzZWxmLmN1cnIsIHBhdGNoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgT2JqZWN0LmVudHJpZXMocGF0Y2gpKSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBwYWlyO1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gXCJwYXRjaFwiKSB7XG4gICAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm8gbG9uZ2VyIHBhdGNoIHN0YWxlIGNvbnRleHRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNhbGxiYWNrKHBhdGNoYWJsZUNvbnRleHQpO1xuICAgIGFsbG93ZWQgPSBmYWxzZTtcbiAgICByZXR1cm47XG4gIH1cbn07XG52YXIgbmV4dElkID0gMTtcbnZhciBGU00gPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsIHN0YXRlLCB3aGljaCBpcyBkZWZpbmVkIGJ5IHRoZSBmaXJzdCBjYWxsIG1hZGUgdG9cbiAgICogLmFkZFN0YXRlKCkuXG4gICAqL1xuICBnZXQgaW5pdGlhbFN0YXRlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc3RhdGVzLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdGF0ZXMgZGVmaW5lZCB5ZXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfVxuICB9XG4gIGdldCBjdXJyZW50U3RhdGUoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID09PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgPT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdGFydGVkIHlldFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RvcHBlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIG1hY2hpbmUgYnkgZW50ZXJpbmcgdGhlIGluaXRpYWwgc3RhdGUuXG4gICAqL1xuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSBtYWNoaW5lIGhhcyBhbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIHRoaXMucnVubmluZ1N0YXRlID0gMSAvKiBTVEFSVEVEICovO1xuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gdGhpcy5pbml0aWFsU3RhdGU7XG4gICAgdGhpcy5lbnRlcihudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU3RvcHMgdGhlIHN0YXRlIG1hY2hpbmUuIFN0b3BwaW5nIHRoZSBzdGF0ZSBtYWNoaW5lIHdpbGwgY2FsbCBleGl0XG4gICAqIGhhbmRsZXJzIGZvciB0aGUgY3VycmVudCBzdGF0ZSwgYnV0IG5vdCBlbnRlciBhIG5ldyBzdGF0ZS5cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAxIC8qIFNUQVJURUQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdG9wIGEgc3RhdGUgbWFjaGluZSB0aGF0IGhhc24ndCBzdGFydGVkIHlldFwiKTtcbiAgICB9XG4gICAgdGhpcy5leGl0KG51bGwpO1xuICAgIHRoaXMucnVubmluZ1N0YXRlID0gMiAvKiBTVE9QUEVEICovO1xuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbnVsbDtcbiAgfVxuICBjb25zdHJ1Y3Rvcihpbml0aWFsQ29udGV4dCkge1xuICAgIHRoaXMuaWQgPSBuZXh0SWQrKztcbiAgICB0aGlzLnJ1bm5pbmdTdGF0ZSA9IDAgLyogTk9UX1NUQVJURURfWUVUICovO1xuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5lbnRlckZucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5jbGVhbnVwU3RhY2sgPSBbXTtcbiAgICB0aGlzLmtub3duRXZlbnRUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5hbGxvd2VkVHJhbnNpdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQgPSBuZXcgU2FmZUNvbnRleHQoaW5pdGlhbENvbnRleHQpO1xuICAgIHRoaXMuZXZlbnRIdWIgPSB7XG4gICAgICBkaWRSZWNlaXZlRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgd2lsbFRyYW5zaXRpb246IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgZGlkSWdub3JlRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgd2lsbEV4aXRTdGF0ZTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICBkaWRFbnRlclN0YXRlOiBtYWtlRXZlbnRTb3VyY2UoKVxuICAgIH07XG4gICAgdGhpcy5ldmVudHMgPSB7XG4gICAgICBkaWRSZWNlaXZlRXZlbnQ6IHRoaXMuZXZlbnRIdWIuZGlkUmVjZWl2ZUV2ZW50Lm9ic2VydmFibGUsXG4gICAgICB3aWxsVHJhbnNpdGlvbjogdGhpcy5ldmVudEh1Yi53aWxsVHJhbnNpdGlvbi5vYnNlcnZhYmxlLFxuICAgICAgZGlkSWdub3JlRXZlbnQ6IHRoaXMuZXZlbnRIdWIuZGlkSWdub3JlRXZlbnQub2JzZXJ2YWJsZSxcbiAgICAgIHdpbGxFeGl0U3RhdGU6IHRoaXMuZXZlbnRIdWIud2lsbEV4aXRTdGF0ZS5vYnNlcnZhYmxlLFxuICAgICAgZGlkRW50ZXJTdGF0ZTogdGhpcy5ldmVudEh1Yi5kaWRFbnRlclN0YXRlLm9ic2VydmFibGVcbiAgICB9O1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRDb250ZXh0LmN1cnJlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIERlZmluZSBhbiBleHBsaWNpdCBmaW5pdGUgc3RhdGUgaW4gdGhlIHN0YXRlIG1hY2hpbmUuXG4gICAqL1xuICBhZGRTdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZXMuYWRkKHN0YXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvbkVudGVyKG5hbWVPclBhdHRlcm4sIGVudGVyRm4pIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVudGVyRm5zLmhhcyhuYW1lT3JQYXR0ZXJuKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBUT0RPIFdlIF9jdXJyZW50bHlfIGRvbid0IHN1cHBvcnQgbXVsdGlwbGUgLm9uRW50ZXJzKCkgZm9yIHRoZSBzYW1lXG4gICAgICAgIC8vIHN0YXRlLCBidXQgdGhpcyBpcyBub3QgYSBmdW5kYW1lbnRhbCBsaW1pdGF0aW9uLiBKdXN0IG5vdFxuICAgICAgICAvLyBpbXBsZW1lbnRlZCB5ZXQuIElmIHdlIHdhbnRlZCB0bywgd2UgY291bGQgbWFrZSB0aGlzIGFuIGFycmF5LlxuICAgICAgICBgZW50ZXIvZXhpdCBmdW5jdGlvbiBmb3IgJHtuYW1lT3JQYXR0ZXJufSBhbHJlYWR5IGV4aXN0c2BcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuZW50ZXJGbnMuc2V0KG5hbWVPclBhdHRlcm4sIGVudGVyRm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9uRW50ZXJBc3luYyhuYW1lT3JQYXR0ZXJuLCBwcm9taXNlRm4sIG9uT0ssIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gdGhpcy5vbkVudGVyKG5hbWVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgIHZvaWQgcHJvbWlzZUZuKHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudCkudGhlbihcbiAgICAgICAgLy8gT24gT0tcbiAgICAgICAgKGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAoIWNhbmNlbGxlZCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uKHsgdHlwZTogXCJBU1lOQ19PS1wiLCBkYXRhIH0sIG9uT0spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gT24gRXJyb3JcbiAgICAgICAgKHJlYXNvbikgPT4ge1xuICAgICAgICAgIGlmICghY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24oeyB0eXBlOiBcIkFTWU5DX0VSUk9SXCIsIHJlYXNvbiB9LCBvbkVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBnZXRTdGF0ZXNNYXRjaGluZyhuYW1lT3JQYXR0ZXJuKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGlmIChuYW1lT3JQYXR0ZXJuID09PSBcIipcIikge1xuICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiB0aGlzLnN0YXRlcykge1xuICAgICAgICBtYXRjaGVzLnB1c2goc3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZU9yUGF0dGVybi5lbmRzV2l0aChcIi4qXCIpKSB7XG4gICAgICBjb25zdCBwcmVmaXggPSBuYW1lT3JQYXR0ZXJuLnNsaWNlKDAsIC0xKTtcbiAgICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgdGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgaWYgKHN0YXRlLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclBhdHRlcm47XG4gICAgICBpZiAodGhpcy5zdGF0ZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN0YXRlcyBtYXRjaCAke0pTT04uc3RyaW5naWZ5KG5hbWVPclBhdHRlcm4pfWApO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfVxuICAvKipcbiAgICogRGVmaW5lIGFsbCBhbGxvd2VkIG91dGdvaW5nIHRyYW5zaXRpb25zIGZvciBhIHN0YXRlLlxuICAgKlxuICAgKiBUaGUgdGFyZ2V0cyBmb3IgZWFjaCBldmVudCBjYW4gYmUgZGVmaW5lZCBhcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlXG4gICAqIG5leHQgc3RhdGUgdG8gdHJhbnNpdGlvbiB0by4gVGhlc2UgZnVuY3Rpb25zIGNhbiBsb29rIGF0IHRoZSBgZXZlbnRgIG9yXG4gICAqIGBjb250ZXh0YCBwYXJhbXMgdG8gY29uZGl0aW9uYWxseSBkZWNpZGUgd2hpY2ggbmV4dCBzdGF0ZSB0byB0cmFuc2l0aW9uXG4gICAqIHRvLlxuICAgKlxuICAgKiBJZiB5b3Ugc2V0IGl0IHRvIGBudWxsYCwgdGhlbiB0aGUgdHJhbnNpdGlvbiB3aWxsIGJlIGV4cGxpY2l0bHkgZm9yYmlkZGVuXG4gICAqIGFuZCB0aHJvdyBhbiBlcnJvci4gSWYgeW91IGRvbid0IGRlZmluZSBhIHRhcmdldCBmb3IgYSB0cmFuc2l0aW9uLCB0aGVuXG4gICAqIHN1Y2ggZXZlbnRzIHdpbGwgZ2V0IGlnbm9yZWQuXG4gICAqL1xuICBhZGRUcmFuc2l0aW9ucyhuYW1lT3JQYXR0ZXJuLCBtYXBwaW5nKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNyY1N0YXRlIG9mIHRoaXMuZ2V0U3RhdGVzTWF0Y2hpbmcobmFtZU9yUGF0dGVybikpIHtcbiAgICAgIGxldCBtYXAgPSB0aGlzLmFsbG93ZWRUcmFuc2l0aW9ucy5nZXQoc3JjU3RhdGUpO1xuICAgICAgaWYgKG1hcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zLnNldChzcmNTdGF0ZSwgbWFwKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW3R5cGUsIHRhcmdldF9dIG9mIE9iamVjdC5lbnRyaWVzKG1hcHBpbmcpKSB7XG4gICAgICAgIGlmIChtYXAuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRyeWluZyB0byBzZXQgdHJhbnNpdGlvbiBcIiR7dHlwZX1cIiBvbiBcIiR7c3JjU3RhdGV9XCIgKHZpYSBcIiR7bmFtZU9yUGF0dGVybn1cIiksIGJ1dCBhIHRyYW5zaXRpb24gYWxyZWFkeSBleGlzdHMgdGhlcmUuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0XztcbiAgICAgICAgdGhpcy5rbm93bkV2ZW50VHlwZXMuYWRkKHR5cGUpO1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRGbiA9IHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRhcmdldCA6ICgpID0+IHRhcmdldDtcbiAgICAgICAgICBtYXAuc2V0KHR5cGUsIHRhcmdldEZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogTGlrZSBgLmFkZFRyYW5zaXRpb24oKWAsIGJ1dCB0YWtlcyBhbiAoYW5vbnltb3VzKSB0cmFuc2l0aW9uIHdoZW5ldmVyIHRoZVxuICAgKiB0aW1lciBmaXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JQYXR0ZXJuIFRoZSBzdGF0ZSBuYW1lLCBvciBzdGF0ZSBncm91cCBwYXR0ZXJuIG5hbWUuXG4gICAqIEBwYXJhbSBhZnRlciAgICAgICAgICBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIHRvIHRha2UgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLiBJZiBpbiB0aGUgbWVhbiB0aW1lLCBhbm90aGVyIHRyYW5zaXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgIGlzIHRha2VuLCB0aGUgdGltZXIgd2lsbCBnZXQgY2FuY2VsbGVkLlxuICAgKiBAcGFyYW0gdGFyZ2V0ICAgICBUaGUgdGFyZ2V0IHN0YXRlIHRvIGdvIHRvLlxuICAgKi9cbiAgYWRkVGltZWRUcmFuc2l0aW9uKHN0YXRlT3JQYXR0ZXJuLCBhZnRlcjIsIHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLm9uRW50ZXIoc3RhdGVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGNvbnN0IG1zID0gdHlwZW9mIGFmdGVyMiA9PT0gXCJmdW5jdGlvblwiID8gYWZ0ZXIyKHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudCkgOiBhZnRlcjI7XG4gICAgICBjb25zdCB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uKHsgdHlwZTogXCJUSU1FUlwiIH0sIHRhcmdldCk7XG4gICAgICB9LCBtcyk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZ2V0VGFyZ2V0Rm4oZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zLmdldCh0aGlzLmN1cnJlbnRTdGF0ZSk/LmdldChldmVudE5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBFeGl0cyB0aGUgY3VycmVudCBzdGF0ZSwgYW5kIGV4ZWN1dGVzIGFueSBuZWNlc3NhcnkgY2xlYW51cCBmdW5jdGlvbnMuXG4gICAqIENhbGwgdGhpcyBiZWZvcmUgY2hhbmdpbmcgdGhlIGN1cnJlbnQgc3RhdGUgdG8gdGhlIG5leHQgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBsZXZlbHMgRGVmaW5lcyBob3cgbWFueSBcImxldmVsc1wiIG9mIG5lc3Rpbmcgd2lsbCBiZVxuICAgKiBleGl0ZWQuIEZvciBleGFtcGxlLCBpZiB5b3UgdHJhbnNpdGlvbiBmcm9tIGBmb28uYmFyLnF1eGAgdG9cbiAgICogYGZvby5iYXIuYmF6YCwgdGhlbiB0aGUgbGV2ZWwgaXMgMS4gQnV0IGlmIHlvdSB0cmFuc2l0aW9uIGZyb21cbiAgICogYGZvby5iYXIucXV4YCB0byBgYmxhLmJsYWAsIHRoZW4gdGhlIGxldmVsIGlzIDMuXG4gICAqIElmIGBudWxsYCwgaXQgd2lsbCBleGl0IGFsbCBsZXZlbHMuXG4gICAqL1xuICBleGl0KGxldmVscykge1xuICAgIHRoaXMuZXZlbnRIdWIud2lsbEV4aXRTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgbGV2ZWxzID0gbGV2ZWxzID8/IHRoaXMuY2xlYW51cFN0YWNrLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzOyBpKyspIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwU3RhY2sucG9wKCk/LihwYXRjaGFibGVDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW50ZXJzIHRoZSBjdXJyZW50IHN0YXRlLCBhbmQgZXhlY3V0ZXMgYW55IG5lY2Vzc2FyeSBvbkVudGVyIGhhbmRsZXJzLlxuICAgKiBDYWxsIHRoaXMgZGlyZWN0bHkgX2FmdGVyXyBzZXR0aW5nIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKi9cbiAgZW50ZXIobGV2ZWxzKSB7XG4gICAgY29uc3QgZW50ZXJQYXR0ZXJucyA9IHBhdHRlcm5zKFxuICAgICAgdGhpcy5jdXJyZW50U3RhdGUsXG4gICAgICBsZXZlbHMgPz8gdGhpcy5jdXJyZW50U3RhdGUuc3BsaXQoXCIuXCIpLmxlbmd0aCArIDFcbiAgICApO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGVudGVyUGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgZW50ZXJGbiA9IHRoaXMuZW50ZXJGbnMuZ2V0KHBhdHRlcm4pO1xuICAgICAgICBjb25zdCBjbGVhbnVwRm4gPSBlbnRlckZuPy4ocGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYW51cEZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLmNsZWFudXBTdGFjay5wdXNoKGNsZWFudXBGbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jbGVhbnVwU3RhY2sucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZXZlbnRIdWIuZGlkRW50ZXJTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhbiBldmVudCB0byB0aGUgbWFjaGluZSwgd2hpY2ggbWF5IGNhdXNlIGFuIGludGVybmFsIHN0YXRlXG4gICAqIHRyYW5zaXRpb24gdG8gaGFwcGVuLiBXaGVuIHRoYXQgaGFwcGVucywgd2lsbCB0cmlnZ2VyIHNpZGUgZWZmZWN0cy5cbiAgICovXG4gIHNlbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMua25vd25FdmVudFR5cGVzLmhhcyhldmVudC50eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGV2ZW50ICR7SlNPTi5zdHJpbmdpZnkoZXZlbnQudHlwZSl9YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSA9PT0gMiAvKiBTVE9QUEVEICovKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEZuID0gdGhpcy5nZXRUYXJnZXRGbihldmVudC50eXBlKTtcbiAgICBpZiAodGFyZ2V0Rm4gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbihldmVudCwgdGFyZ2V0Rm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV2ZW50SHViLmRpZElnbm9yZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgfVxuICB9XG4gIHRyYW5zaXRpb24oZXZlbnQsIHRhcmdldCkge1xuICAgIHRoaXMuZXZlbnRIdWIuZGlkUmVjZWl2ZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLmN1cnJlbnRTdGF0ZTtcbiAgICBjb25zdCB0YXJnZXRGbiA9IHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRhcmdldCA6ICgpID0+IHRhcmdldDtcbiAgICBjb25zdCBuZXh0VGFyZ2V0ID0gdGFyZ2V0Rm4oZXZlbnQsIHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudCk7XG4gICAgbGV0IG5leHRTdGF0ZTtcbiAgICBsZXQgZWZmZWN0cyA9IHZvaWQgMDtcbiAgICBpZiAobmV4dFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5ldmVudEh1Yi5kaWRJZ25vcmVFdmVudC5ub3RpZnkoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5leHRUYXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQudGFyZ2V0O1xuICAgICAgZWZmZWN0cyA9IEFycmF5LmlzQXJyYXkobmV4dFRhcmdldC5lZmZlY3QpID8gbmV4dFRhcmdldC5lZmZlY3QgOiBbbmV4dFRhcmdldC5lZmZlY3RdO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc3RhdGVzLmhhcyhuZXh0U3RhdGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbmV4dCBzdGF0ZSBuYW1lOiAke0pTT04uc3RyaW5naWZ5KG5leHRTdGF0ZSl9YCk7XG4gICAgfVxuICAgIHRoaXMuZXZlbnRIdWIud2lsbFRyYW5zaXRpb24ubm90aWZ5KHsgZnJvbTogb2xkU3RhdGUsIHRvOiBuZXh0U3RhdGUgfSk7XG4gICAgY29uc3QgW3VwLCBkb3duXSA9IGRpc3RhbmNlKHRoaXMuY3VycmVudFN0YXRlLCBuZXh0U3RhdGUpO1xuICAgIGlmICh1cCA+IDApIHtcbiAgICAgIHRoaXMuZXhpdCh1cCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbmV4dFN0YXRlO1xuICAgIGlmIChlZmZlY3RzICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGVmZmVjdHNUb1J1biA9IGVmZmVjdHM7XG4gICAgICB0aGlzLmN1cnJlbnRDb250ZXh0LmFsbG93UGF0Y2hpbmcoKHBhdGNoYWJsZUNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgZWZmZWN0c1RvUnVuKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZWZmZWN0KHBhdGNoYWJsZUNvbnRleHQsIGV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0Y2hhYmxlQ29udGV4dC5wYXRjaChlZmZlY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkb3duID4gMCkge1xuICAgICAgdGhpcy5lbnRlcihkb3duKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvdXRpbHMudHNcbmZ1bmN0aW9uIHJhaXNlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoYmxvYikge1xuICByZXR1cm4gYmxvYiAhPT0gbnVsbCAmJiB0eXBlb2YgYmxvYiA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYmxvYikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBlbnRyaWVzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKTtcbn1cbmZ1bmN0aW9uIHRyeVBhcnNlSnNvbihyYXdNZXNzYWdlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UocmF3TWVzc2FnZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5mdW5jdGlvbiBkZWVwQ2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGI2NGRlY29kZShiNjR2YWx1ZSkge1xuICB0cnkge1xuICAgIGNvbnN0IGZvcm1hdHRlZFZhbHVlID0gYjY0dmFsdWUucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gICAgY29uc3QgZGVjb2RlZFZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KFxuICAgICAgYXRvYihmb3JtYXR0ZWRWYWx1ZSkuc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIFwiJVwiICsgKFwiMDBcIiArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICAgIH0pLmpvaW4oXCJcIilcbiAgICApO1xuICAgIHJldHVybiBkZWNvZGVkVmFsdWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBhdG9iKGI2NHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcGFjdChpdGVtcykge1xuICByZXR1cm4gaXRlbXMuZmlsdGVyKFxuICAgIChpdGVtKSA9PiBpdGVtICE9PSBudWxsICYmIGl0ZW0gIT09IHZvaWQgMFxuICApO1xufVxuZnVuY3Rpb24gY29tcGFjdE9iamVjdChvYmopIHtcbiAgY29uc3QgbmV3T2JqID0geyAuLi5vYmogfTtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gaztcbiAgICBpZiAobmV3T2JqW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgZGVsZXRlIG5ld09ialtrZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXdPYmo7XG59XG5hc3luYyBmdW5jdGlvbiB3aXRoVGltZW91dChwcm9taXNlLCBtaWxsaXMsIGVycm1zZykge1xuICBsZXQgdGltZXJJRDtcbiAgY29uc3QgdGltZXIkID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgIHRpbWVySUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJybXNnKSk7XG4gICAgfSwgbWlsbGlzKTtcbiAgfSk7XG4gIHJldHVybiBQcm9taXNlLnJhY2UoW3Byb21pc2UsIHRpbWVyJF0pLmZpbmFsbHkoKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVySUQpKTtcbn1cblxuLy8gc3JjL3Byb3RvY29sL1NlcnZlck1zZy50c1xudmFyIFNlcnZlck1zZ0NvZGUgPSAvKiBAX19QVVJFX18gKi8gKChTZXJ2ZXJNc2dDb2RlMikgPT4ge1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVQREFURV9QUkVTRU5DRVwiXSA9IDEwMF0gPSBcIlVQREFURV9QUkVTRU5DRVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVTRVJfSk9JTkVEXCJdID0gMTAxXSA9IFwiVVNFUl9KT0lORURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVU0VSX0xFRlRcIl0gPSAxMDJdID0gXCJVU0VSX0xFRlRcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJCUk9BRENBU1RFRF9FVkVOVFwiXSA9IDEwM10gPSBcIkJST0FEQ0FTVEVEX0VWRU5UXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiUk9PTV9TVEFURVwiXSA9IDEwNF0gPSBcIlJPT01fU1RBVEVcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJJTklUSUFMX1NUT1JBR0VfU1RBVEVcIl0gPSAyMDBdID0gXCJJTklUSUFMX1NUT1JBR0VfU1RBVEVcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVUERBVEVfU1RPUkFHRVwiXSA9IDIwMV0gPSBcIlVQREFURV9TVE9SQUdFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiUkVKRUNUX1NUT1JBR0VfT1BcIl0gPSAyOTldID0gXCJSRUpFQ1RfU1RPUkFHRV9PUFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVQREFURV9ZRE9DXCJdID0gMzAwXSA9IFwiVVBEQVRFX1lET0NcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfQ1JFQVRFRFwiXSA9IDQwMF0gPSBcIlRIUkVBRF9DUkVBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVEhSRUFEX01FVEFEQVRBX1VQREFURURcIl0gPSA0MDFdID0gXCJUSFJFQURfTUVUQURBVEFfVVBEQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfQ1JFQVRFRFwiXSA9IDQwMl0gPSBcIkNPTU1FTlRfQ1JFQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfRURJVEVEXCJdID0gNDAzXSA9IFwiQ09NTUVOVF9FRElURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX0RFTEVURURcIl0gPSA0MDRdID0gXCJDT01NRU5UX0RFTEVURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX1JFQUNUSU9OX0FEREVEXCJdID0gNDA1XSA9IFwiQ09NTUVOVF9SRUFDVElPTl9BRERFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfUkVBQ1RJT05fUkVNT1ZFRFwiXSA9IDQwNl0gPSBcIkNPTU1FTlRfUkVBQ1RJT05fUkVNT1ZFRFwiO1xuICByZXR1cm4gU2VydmVyTXNnQ29kZTI7XG59KShTZXJ2ZXJNc2dDb2RlIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL0lXZWJTb2NrZXQudHNcbnZhciBXZWJzb2NrZXRDbG9zZUNvZGVzID0gLyogQF9fUFVSRV9fICovICgoV2Vic29ja2V0Q2xvc2VDb2RlczIpID0+IHtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJDTE9TRV9BQk5PUk1BTFwiXSA9IDEwMDZdID0gXCJDTE9TRV9BQk5PUk1BTFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlVORVhQRUNURURfQ09ORElUSU9OXCJdID0gMTAxMV0gPSBcIlVORVhQRUNURURfQ09ORElUSU9OXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiVFJZX0FHQUlOX0xBVEVSXCJdID0gMTAxM10gPSBcIlRSWV9BR0FJTl9MQVRFUlwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIklOVkFMSURfTUVTU0FHRV9GT1JNQVRcIl0gPSA0ZTNdID0gXCJJTlZBTElEX01FU1NBR0VfRk9STUFUXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTk9UX0FMTE9XRURcIl0gPSA0MDAxXSA9IFwiTk9UX0FMTE9XRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9TRUNPTkRTXCJdID0gNDAwMl0gPSBcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX1NFQ09ORFNcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNcIl0gPSA0MDAzXSA9IFwiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfREFZX1BFUl9BUFBcIl0gPSA0MDA0XSA9IFwiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfREFZX1BFUl9BUFBcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNfUEVSX1JPT01cIl0gPSA0MDA1XSA9IFwiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TX1BFUl9ST09NXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiVE9LRU5fRVhQSVJFRFwiXSA9IDQxMDldID0gXCJUT0tFTl9FWFBJUkVEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiQ0xPU0VfV0lUSE9VVF9SRVRSWVwiXSA9IDQ5OTldID0gXCJDTE9TRV9XSVRIT1VUX1JFVFJZXCI7XG4gIHJldHVybiBXZWJzb2NrZXRDbG9zZUNvZGVzMjtcbn0pKFdlYnNvY2tldENsb3NlQ29kZXMgfHwge30pO1xuZnVuY3Rpb24gc2hvdWxkRGlzY29ubmVjdChjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSA0OTk5IC8qIENMT1NFX1dJVEhPVVRfUkVUUlkgKi8gfHwgY29kZSA+PSA0ZTMgJiYgY29kZSA8IDQxMDA7XG59XG5mdW5jdGlvbiBzaG91bGRSZWF1dGgoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSA0MTAwICYmIGNvZGUgPCA0MjAwO1xufVxuZnVuY3Rpb24gc2hvdWxkUmV0cnlXaXRob3V0UmVhdXRoKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwMTMgLyogVFJZX0FHQUlOX0xBVEVSICovIHx8IGNvZGUgPj0gNDIwMCAmJiBjb2RlIDwgNDMwMDtcbn1cblxuLy8gc3JjL2Nvbm5lY3Rpb24udHNcbmZ1bmN0aW9uIGlzSWRsZShzdGF0dXMpIHtcbiAgcmV0dXJuIHN0YXR1cyA9PT0gXCJpbml0aWFsXCIgfHwgc3RhdHVzID09PSBcImRpc2Nvbm5lY3RlZFwiO1xufVxuZnVuY3Rpb24gbmV3VG9MZWdhY3lTdGF0dXMoc3RhdHVzKSB7XG4gIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgY2FzZSBcImNvbm5lY3RpbmdcIjpcbiAgICAgIHJldHVybiBcImNvbm5lY3RpbmdcIjtcbiAgICBjYXNlIFwiY29ubmVjdGVkXCI6XG4gICAgICByZXR1cm4gXCJvcGVuXCI7XG4gICAgY2FzZSBcInJlY29ubmVjdGluZ1wiOlxuICAgICAgcmV0dXJuIFwidW5hdmFpbGFibGVcIjtcbiAgICBjYXNlIFwiZGlzY29ubmVjdGVkXCI6XG4gICAgICByZXR1cm4gXCJmYWlsZWRcIjtcbiAgICBjYXNlIFwiaW5pdGlhbFwiOlxuICAgICAgcmV0dXJuIFwiY2xvc2VkXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcImNsb3NlZFwiO1xuICB9XG59XG5mdW5jdGlvbiB0b05ld0Nvbm5lY3Rpb25TdGF0dXMobWFjaGluZSkge1xuICBjb25zdCBzdGF0ZSA9IG1hY2hpbmUuY3VycmVudFN0YXRlO1xuICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgY2FzZSBcIkBvay5jb25uZWN0ZWRcIjpcbiAgICBjYXNlIFwiQG9rLmF3YWl0aW5nLXBvbmdcIjpcbiAgICAgIHJldHVybiBcImNvbm5lY3RlZFwiO1xuICAgIGNhc2UgXCJAaWRsZS5pbml0aWFsXCI6XG4gICAgICByZXR1cm4gXCJpbml0aWFsXCI7XG4gICAgY2FzZSBcIkBhdXRoLmJ1c3lcIjpcbiAgICBjYXNlIFwiQGF1dGguYmFja29mZlwiOlxuICAgIGNhc2UgXCJAY29ubmVjdGluZy5idXN5XCI6XG4gICAgY2FzZSBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIjpcbiAgICBjYXNlIFwiQGlkbGUuem9tYmllXCI6XG4gICAgICByZXR1cm4gbWFjaGluZS5jb250ZXh0LnN1Y2Nlc3NDb3VudCA+IDAgPyBcInJlY29ubmVjdGluZ1wiIDogXCJjb25uZWN0aW5nXCI7XG4gICAgY2FzZSBcIkBpZGxlLmZhaWxlZFwiOlxuICAgICAgcmV0dXJuIFwiZGlzY29ubmVjdGVkXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihzdGF0ZSwgXCJVbmtub3duIHN0YXRlXCIpO1xuICB9XG59XG52YXIgQkFDS09GRl9ERUxBWVMgPSBbMjUwLCA1MDAsIDFlMywgMmUzLCA0ZTMsIDhlMywgMWU0XTtcbnZhciBSRVNFVF9ERUxBWSA9IEJBQ0tPRkZfREVMQVlTWzBdIC0gMTtcbnZhciBCQUNLT0ZGX0RFTEFZU19TTE9XID0gWzJlMywgM2U0LCA2ZTQsIDNlNV07XG52YXIgSEVBUlRCRUFUX0lOVEVSVkFMID0gM2U0O1xudmFyIFBPTkdfVElNRU9VVCA9IDJlMztcbnZhciBBVVRIX1RJTUVPVVQgPSAxZTQ7XG52YXIgU09DS0VUX0NPTk5FQ1RfVElNRU9VVCA9IDFlNDtcbnZhciBTdG9wUmV0cnlpbmcgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIocmVhc29uKTtcbiAgfVxufTtcbnZhciBMaXZlYmxvY2tzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cbn07XG5mdW5jdGlvbiBuZXh0QmFja29mZkRlbGF5KGN1cnJlbnREZWxheSwgZGVsYXlzID0gQkFDS09GRl9ERUxBWVMpIHtcbiAgcmV0dXJuIGRlbGF5cy5maW5kKChkZWxheSkgPT4gZGVsYXkgPiBjdXJyZW50RGVsYXkpID8/IGRlbGF5c1tkZWxheXMubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBpbmNyZWFzZUJhY2tvZmZEZWxheShjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goeyBiYWNrb2ZmRGVsYXk6IG5leHRCYWNrb2ZmRGVsYXkoY29udGV4dC5iYWNrb2ZmRGVsYXkpIH0pO1xufVxuZnVuY3Rpb24gaW5jcmVhc2VCYWNrb2ZmRGVsYXlBZ2dyZXNzaXZlbHkoY29udGV4dCkge1xuICBjb250ZXh0LnBhdGNoKHtcbiAgICBiYWNrb2ZmRGVsYXk6IG5leHRCYWNrb2ZmRGVsYXkoY29udGV4dC5iYWNrb2ZmRGVsYXksIEJBQ0tPRkZfREVMQVlTX1NMT1cpXG4gIH0pO1xufVxuZnVuY3Rpb24gcmVzZXRTdWNjZXNzQ291bnQoY29udGV4dCkge1xuICBjb250ZXh0LnBhdGNoKHsgc3VjY2Vzc0NvdW50OiAwIH0pO1xufVxuZnVuY3Rpb24gbG9nKGxldmVsLCBtZXNzYWdlKSB7XG4gIGNvbnN0IGxvZ2dlciA9IGxldmVsID09PSAyIC8qIEVSUk9SICovID8gZXJyb3IyIDogbGV2ZWwgPT09IDEgLyogV0FSTiAqLyA/IHdhcm4gOiAoXG4gICAgLyogYmxhY2sgaG9sZSAqL1xuICAgICgpID0+IHtcbiAgICB9XG4gICk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbG9nZ2VyKG1lc3NhZ2UpO1xuICB9O1xufVxuZnVuY3Rpb24gbG9nUHJlbWF0dXJlRXJyb3JPckNsb3NlRXZlbnQoZSkge1xuICBjb25zdCBjb25uID0gXCJDb25uZWN0aW9uIHRvIExpdmVibG9ja3Mgd2Vic29ja2V0IHNlcnZlclwiO1xuICByZXR1cm4gKGN0eCkgPT4ge1xuICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHdhcm4oYCR7Y29ubn0gY291bGQgbm90IGJlIGVzdGFibGlzaGVkLiAke1N0cmluZyhlKX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcbiAgICAgICAgaXNDbG9zZUV2ZW50KGUpID8gYCR7Y29ubn0gY2xvc2VkIHByZW1hdHVyZWx5IChjb2RlOiAke2UuY29kZX0pLiBSZXRyeWluZyBpbiAke2N0eC5iYWNrb2ZmRGVsYXl9bXMuYCA6IGAke2Nvbm59IGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZC5gXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGxvZ0Nsb3NlRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIChjdHgpID0+IHtcbiAgICB3YXJuKFxuICAgICAgYENvbm5lY3Rpb24gdG8gTGl2ZWJsb2NrcyB3ZWJzb2NrZXQgc2VydmVyIGNsb3NlZCAoY29kZTogJHtldmVudC5jb2RlfSkuIFJldHJ5aW5nIGluICR7Y3R4LmJhY2tvZmZEZWxheX1tcy5gXG4gICAgKTtcbiAgfTtcbn1cbnZhciBsb2dQZXJtYW5lbnRDbG9zZSA9IGxvZyhcbiAgMSAvKiBXQVJOICovLFxuICBcIkNvbm5lY3Rpb24gdG8gV2ViU29ja2V0IGNsb3NlZCBwZXJtYW5lbnRseS4gV29uJ3QgcmV0cnkuXCJcbik7XG5mdW5jdGlvbiBpc0Nsb3NlRXZlbnQoZXJyb3IzKSB7XG4gIHJldHVybiAhKGVycm9yMyBpbnN0YW5jZW9mIEVycm9yKSAmJiBlcnJvcjMudHlwZSA9PT0gXCJjbG9zZVwiO1xufVxuZnVuY3Rpb24gZW5hYmxlVHJhY2luZyhtYWNoaW5lKSB7XG4gIGNvbnN0IHN0YXJ0ID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIGZ1bmN0aW9uIGxvZzIoLi4uYXJncykge1xuICAgIHdhcm4oXG4gICAgICBgJHsoKCgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnQpIC8gMWUzKS50b0ZpeGVkKDIpfSBbRlNNICMke21hY2hpbmUuaWR9XWAsXG4gICAgICAuLi5hcmdzXG4gICAgKTtcbiAgfVxuICBjb25zdCB1bnN1YnMgPSBbXG4gICAgbWFjaGluZS5ldmVudHMuZGlkUmVjZWl2ZUV2ZW50LnN1YnNjcmliZSgoZSkgPT4gbG9nMihgRXZlbnQgJHtlLnR5cGV9YCkpLFxuICAgIG1hY2hpbmUuZXZlbnRzLndpbGxUcmFuc2l0aW9uLnN1YnNjcmliZShcbiAgICAgICh7IGZyb20sIHRvIH0pID0+IGxvZzIoXCJUcmFuc2l0aW9uaW5nXCIsIGZyb20sIFwiXFx1MjE5MlwiLCB0bylcbiAgICApLFxuICAgIG1hY2hpbmUuZXZlbnRzLmRpZElnbm9yZUV2ZW50LnN1YnNjcmliZShcbiAgICAgIChlKSA9PiBsb2cyKFwiSWdub3JlZCBldmVudFwiLCBlLnR5cGUsIGUsIFwiKGN1cnJlbnQgc3RhdGUgd29uJ3QgaGFuZGxlIGl0KVwiKVxuICAgIClcbiAgICAvLyBtYWNoaW5lLmV2ZW50cy53aWxsRXhpdFN0YXRlLnN1YnNjcmliZSgocykgPT4gbG9nKFwiRXhpdGluZyBzdGF0ZVwiLCBzKSksXG4gICAgLy8gbWFjaGluZS5ldmVudHMuZGlkRW50ZXJTdGF0ZS5zdWJzY3JpYmUoKHMpID0+IGxvZyhcIkVudGVyaW5nIHN0YXRlXCIsIHMpKSxcbiAgXTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IHVuc3ViIG9mIHVuc3Vicykge1xuICAgICAgdW5zdWIoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkZWZpbmVDb25uZWN0aXZpdHlFdmVudHMobWFjaGluZSkge1xuICBjb25zdCBzdGF0dXNEaWRDaGFuZ2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgY29uc3QgZGlkQ29ubmVjdCA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBjb25zdCBkaWREaXNjb25uZWN0ID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGxldCBsYXN0U3RhdHVzID0gbnVsbDtcbiAgY29uc3QgdW5zdWJzY3JpYmUgPSBtYWNoaW5lLmV2ZW50cy5kaWRFbnRlclN0YXRlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgY29uc3QgY3VyclN0YXR1cyA9IHRvTmV3Q29ubmVjdGlvblN0YXR1cyhtYWNoaW5lKTtcbiAgICBpZiAoY3VyclN0YXR1cyAhPT0gbGFzdFN0YXR1cykge1xuICAgICAgc3RhdHVzRGlkQ2hhbmdlLm5vdGlmeShjdXJyU3RhdHVzKTtcbiAgICB9XG4gICAgaWYgKGxhc3RTdGF0dXMgPT09IFwiY29ubmVjdGVkXCIgJiYgY3VyclN0YXR1cyAhPT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgZGlkRGlzY29ubmVjdC5ub3RpZnkoKTtcbiAgICB9IGVsc2UgaWYgKGxhc3RTdGF0dXMgIT09IFwiY29ubmVjdGVkXCIgJiYgY3VyclN0YXR1cyA9PT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgZGlkQ29ubmVjdC5ub3RpZnkoKTtcbiAgICB9XG4gICAgbGFzdFN0YXR1cyA9IGN1cnJTdGF0dXM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHN0YXR1c0RpZENoYW5nZTogc3RhdHVzRGlkQ2hhbmdlLm9ic2VydmFibGUsXG4gICAgZGlkQ29ubmVjdDogZGlkQ29ubmVjdC5vYnNlcnZhYmxlLFxuICAgIGRpZERpc2Nvbm5lY3Q6IGRpZERpc2Nvbm5lY3Qub2JzZXJ2YWJsZSxcbiAgICB1bnN1YnNjcmliZVxuICB9O1xufVxudmFyIGFzc2lnbiA9IChwYXRjaCkgPT4gKGN0eCkgPT4gY3R4LnBhdGNoKHBhdGNoKTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb25TdGF0ZU1hY2hpbmUoZGVsZWdhdGVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9uTWVzc2FnZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBvbk1lc3NhZ2UucGF1c2UoKTtcbiAgY29uc3Qgb25MaXZlYmxvY2tzRXJyb3IgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgZnVuY3Rpb24gZmlyZUVycm9yRXZlbnQoZXJybXNnLCBlcnJjb2RlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBMaXZlYmxvY2tzRXJyb3IoZXJybXNnLCBlcnJjb2RlKTtcbiAgICAgIG9uTGl2ZWJsb2Nrc0Vycm9yLm5vdGlmeShlcnIpO1xuICAgIH07XG4gIH1cbiAgY29uc3QgaW5pdGlhbENvbnRleHQgPSB7XG4gICAgc3VjY2Vzc0NvdW50OiAwLFxuICAgIGF1dGhWYWx1ZTogbnVsbCxcbiAgICBzb2NrZXQ6IG51bGwsXG4gICAgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWVxuICB9O1xuICBjb25zdCBtYWNoaW5lID0gbmV3IEZTTShpbml0aWFsQ29udGV4dCkuYWRkU3RhdGUoXCJAaWRsZS5pbml0aWFsXCIpLmFkZFN0YXRlKFwiQGlkbGUuZmFpbGVkXCIpLmFkZFN0YXRlKFwiQGlkbGUuem9tYmllXCIpLmFkZFN0YXRlKFwiQGF1dGguYnVzeVwiKS5hZGRTdGF0ZShcIkBhdXRoLmJhY2tvZmZcIikuYWRkU3RhdGUoXCJAY29ubmVjdGluZy5idXN5XCIpLmFkZFN0YXRlKFwiQGNvbm5lY3RpbmcuYmFja29mZlwiKS5hZGRTdGF0ZShcIkBvay5jb25uZWN0ZWRcIikuYWRkU3RhdGUoXCJAb2suYXdhaXRpbmctcG9uZ1wiKTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIipcIiwge1xuICAgIFJFQ09OTkVDVDoge1xuICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCByZXNldFN1Y2Nlc3NDb3VudF1cbiAgICB9LFxuICAgIERJU0NPTk5FQ1Q6IFwiQGlkbGUuaW5pdGlhbFwiXG4gIH0pO1xuICBtYWNoaW5lLm9uRW50ZXIoXCJAaWRsZS4qXCIsIHJlc2V0U3VjY2Vzc0NvdW50KS5hZGRUcmFuc2l0aW9ucyhcIkBpZGxlLipcIiwge1xuICAgIENPTk5FQ1Q6IChfLCBjdHgpID0+IChcbiAgICAgIC8vIElmIHdlIHN0aWxsIGhhdmUgYSBrbm93biBhdXRoVmFsdWUsIHRyeSB0byByZWNvbm5lY3QgdG8gdGhlIHNvY2tldCBkaXJlY3RseSxcbiAgICAgIC8vIG90aGVyd2lzZSwgdHJ5IHRvIG9idGFpbiBhIG5ldyBhdXRoVmFsdWVcbiAgICAgIGN0eC5hdXRoVmFsdWUgIT09IG51bGwgPyBcIkBjb25uZWN0aW5nLmJ1c3lcIiA6IFwiQGF1dGguYnVzeVwiXG4gICAgKVxuICB9KTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIkBhdXRoLmJhY2tvZmZcIiwge1xuICAgIE5BVklHQVRPUl9PTkxJTkU6IHtcbiAgICAgIHRhcmdldDogXCJAYXV0aC5idXN5XCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7IGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVkgfSlcbiAgICB9XG4gIH0pLmFkZFRpbWVkVHJhbnNpdGlvbihcbiAgICBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAoY3R4KSA9PiBjdHguYmFja29mZkRlbGF5LFxuICAgIFwiQGF1dGguYnVzeVwiXG4gICkub25FbnRlckFzeW5jKFxuICAgIFwiQGF1dGguYnVzeVwiLFxuICAgICgpID0+IHdpdGhUaW1lb3V0KFxuICAgICAgZGVsZWdhdGVzLmF1dGhlbnRpY2F0ZSgpLFxuICAgICAgQVVUSF9USU1FT1VULFxuICAgICAgXCJUaW1lZCBvdXQgZHVyaW5nIGF1dGhcIlxuICAgICksXG4gICAgLy8gT24gc3VjY2Vzc2Z1bCBhdXRoZW50aWNhdGlvblxuICAgIChva0V2ZW50KSA9PiAoe1xuICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHtcbiAgICAgICAgYXV0aFZhbHVlOiBva0V2ZW50LmRhdGEsXG4gICAgICAgIGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVlcbiAgICAgIH0pXG4gICAgfSksXG4gICAgLy8gQXV0aCBmYWlsZWRcbiAgICAoZmFpbGVkRXZlbnQpID0+IHtcbiAgICAgIGlmIChmYWlsZWRFdmVudC5yZWFzb24gaW5zdGFuY2VvZiBTdG9wUmV0cnlpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZmFpbGVkRXZlbnQucmVhc29uLm1lc3NhZ2UpLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZmFpbGVkRXZlbnQucmVhc29uLm1lc3NhZ2UsIC0xKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgIGluY3JlYXNlQmFja29mZkRlbGF5LFxuICAgICAgICAgIGxvZyhcbiAgICAgICAgICAgIDIgLyogRVJST1IgKi8sXG4gICAgICAgICAgICBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2ZhaWxlZEV2ZW50LnJlYXNvbiBpbnN0YW5jZW9mIEVycm9yID8gZmFpbGVkRXZlbnQucmVhc29uLm1lc3NhZ2UgOiBTdHJpbmcoZmFpbGVkRXZlbnQucmVhc29uKX1gXG4gICAgICAgICAgKVxuICAgICAgICBdXG4gICAgICB9O1xuICAgIH1cbiAgKTtcbiAgY29uc3Qgb25Tb2NrZXRFcnJvciA9IChldmVudCkgPT4gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJFWFBMSUNJVF9TT0NLRVRfRVJST1JcIiwgZXZlbnQgfSk7XG4gIGNvbnN0IG9uU29ja2V0Q2xvc2UgPSAoZXZlbnQpID0+IG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiRVhQTElDSVRfU09DS0VUX0NMT1NFXCIsIGV2ZW50IH0pO1xuICBjb25zdCBvblNvY2tldE1lc3NhZ2UgPSAoZXZlbnQpID0+IGV2ZW50LmRhdGEgPT09IFwicG9uZ1wiID8gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJQT05HXCIgfSkgOiBvbk1lc3NhZ2Uubm90aWZ5KGV2ZW50KTtcbiAgZnVuY3Rpb24gdGVhcmRvd25Tb2NrZXQoc29ja2V0KSB7XG4gICAgaWYgKHNvY2tldCkge1xuICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvblNvY2tldEVycm9yKTtcbiAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgb25Tb2NrZXRDbG9zZSk7XG4gICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25Tb2NrZXRNZXNzYWdlKTtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgIH1cbiAgfVxuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLCB7XG4gICAgTkFWSUdBVE9SX09OTElORToge1xuICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHsgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWSB9KVxuICAgIH1cbiAgfSkuYWRkVGltZWRUcmFuc2l0aW9uKFxuICAgIFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgIChjdHgpID0+IGN0eC5iYWNrb2ZmRGVsYXksXG4gICAgXCJAY29ubmVjdGluZy5idXN5XCJcbiAgKS5vbkVudGVyQXN5bmMoXG4gICAgXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgLy9cbiAgICAvLyBVc2UgdGhlIFwiY3JlYXRlU29ja2V0XCIgZGVsZWdhdGUgZnVuY3Rpb24gKHByb3ZpZGVkIHRvIHRoZVxuICAgIC8vIE1hbmFnZWRTb2NrZXQpIHRvIGNyZWF0ZSB0aGUgYWN0dWFsIFdlYlNvY2tldCBjb25uZWN0aW9uIGluc3RhbmNlLlxuICAgIC8vIFRoZW4sIHNldCB1cCBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMsIGFuZCB3YWl0IGZvciB0aGVcbiAgICAvLyBcIm9wZW5cIiBldmVudCB0byBvY2N1ci5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIFwib3BlblwiIGV2ZW50IGhhcHBlbnMsIHdlJ3JlIHJlYWR5IHRvIHRyYW5zaXRpb24gdG8gdGhlXG4gICAgLy8gT0sgc3RhdGUuIFRoaXMgaXMgZG9uZSBieSByZXNvbHZpbmcgdGhlIFByb21pc2UuXG4gICAgLy9cbiAgICBhc3luYyAoY3R4KSA9PiB7XG4gICAgICBsZXQgY2FwdHVyZWRQcmVtYXR1cmVFdmVudCA9IG51bGw7XG4gICAgICBjb25zdCBjb25uZWN0JCA9IG5ldyBQcm9taXNlKFxuICAgICAgICAocmVzb2x2ZSwgcmVqKSA9PiB7XG4gICAgICAgICAgaWYgKGN0eC5hdXRoVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGF1dGggYXV0aFZhbHVlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzb2NrZXQgPSBkZWxlZ2F0ZXMuY3JlYXRlU29ja2V0KGN0eC5hdXRoVmFsdWUpO1xuICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdChldmVudCkge1xuICAgICAgICAgICAgY2FwdHVyZWRQcmVtYXR1cmVFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uU29ja2V0TWVzc2FnZSk7XG4gICAgICAgICAgICByZWooZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBbYWN0b3IkLCBkaWRSZWNlaXZlQWN0b3JdID0gY29udHJvbGxlZFByb21pc2UoKTtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMud2FpdEZvckFjdG9ySWQpIHtcbiAgICAgICAgICAgIGRpZFJlY2VpdmVBY3RvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiB3YWl0Rm9yQWN0b3JJZChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc2VydmVyTXNnID0gdHJ5UGFyc2VKc29uKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgaWYgKHNlcnZlck1zZz8udHlwZSA9PT0gMTA0IC8qIFJPT01fU1RBVEUgKi8pIHtcbiAgICAgICAgICAgICAgZGlkUmVjZWl2ZUFjdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvblNvY2tldE1lc3NhZ2UpO1xuICAgICAgICAgIGlmIChvcHRpb25zLndhaXRGb3JBY3RvcklkKSB7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgd2FpdEZvckFjdG9ySWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCByZWplY3QpO1xuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uU29ja2V0RXJyb3IpO1xuICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCBvblNvY2tldENsb3NlKTtcbiAgICAgICAgICAgIGNvbnN0IHVuc3ViID0gKCkgPT4ge1xuICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHdhaXRGb3JBY3RvcklkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2b2lkIGFjdG9yJC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShbc29ja2V0LCB1bnN1Yl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gd2l0aFRpbWVvdXQoXG4gICAgICAgIGNvbm5lY3QkLFxuICAgICAgICBTT0NLRVRfQ09OTkVDVF9USU1FT1VULFxuICAgICAgICBcIlRpbWVkIG91dCBkdXJpbmcgd2Vic29ja2V0IGNvbm5lY3Rpb25cIlxuICAgICAgKS50aGVuKFxuICAgICAgICAvL1xuICAgICAgICAvLyBQYXJ0IDM6XG4gICAgICAgIC8vIEJ5IG5vdywgb3VyIFwib3BlblwiIGV2ZW50IGhhcyBmaXJlZCwgYW5kIHRoZSBwcm9taXNlIGhhcyBiZWVuXG4gICAgICAgIC8vIHJlc29sdmVkLiBUd28gcG9zc2libGUgc2NlbmFyaW9zOlxuICAgICAgICAvL1xuICAgICAgICAvLyAxLiBUaGUgaGFwcHkgcGF0aC4gTW9zdCBsaWtlbHkuXG4gICAgICAgIC8vIDIuIFVoLW9oLiBBIHByZW1hdHVyZSBjbG9zZS9lcnJvciBldmVudCBoYXMgYmVlbiBvYnNlcnZlZC4gTGV0J3NcbiAgICAgICAgLy8gICAgcmVqZWN0IHRoZSBwcm9taXNlIGFmdGVyIGFsbC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQW55IGNsb3NlL2Vycm9yIGV2ZW50IHRoYXQgd2lsbCBnZXQgc2NoZWR1bGVkIGFmdGVyIHRoaXMgcG9pbnRcbiAgICAgICAgLy8gb253YXJkcywgd2lsbCBiZSBjYXVnaHQgaW4gdGhlIE9LIHN0YXRlLCBhbmQgZGVhbHQgd2l0aFxuICAgICAgICAvLyBhY2NvcmRpbmdseS5cbiAgICAgICAgLy9cbiAgICAgICAgKFtzb2NrZXQsIHVuc3ViXSkgPT4ge1xuICAgICAgICAgIHVuc3ViKCk7XG4gICAgICAgICAgaWYgKGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQpIHtcbiAgICAgICAgICAgIHRocm93IGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzb2NrZXQ7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICAvLyBPbmx5IHRyYW5zaXRpb24gdG8gT0sgc3RhdGUgYWZ0ZXIgYSBzdWNjZXNzZnVsbHkgb3BlbmVkIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gICAgKG9rRXZlbnQpID0+ICh7XG4gICAgICB0YXJnZXQ6IFwiQG9rLmNvbm5lY3RlZFwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oe1xuICAgICAgICBzb2NrZXQ6IG9rRXZlbnQuZGF0YSxcbiAgICAgICAgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWVxuICAgICAgfSlcbiAgICB9KSxcbiAgICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2Fubm90IGJlIGVzdGFibGlzaGVkXG4gICAgKGZhaWx1cmUpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IGZhaWx1cmUucmVhc29uO1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFN0b3BSZXRyeWluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgIGxvZygyIC8qIEVSUk9SICovLCBlcnIubWVzc2FnZSksXG4gICAgICAgICAgICBmaXJlRXJyb3JFdmVudChlcnIubWVzc2FnZSwgLTEpXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2xvc2VFdmVudChlcnIpKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gNDEwOSAvKiBUT0tFTl9FWFBJUkVEICovKSB7XG4gICAgICAgICAgcmV0dXJuIFwiQGF1dGguYnVzeVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRSZXRyeVdpdGhvdXRSZWF1dGgoZXJyLmNvZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgICAgaW5jcmVhc2VCYWNrb2ZmRGVsYXlBZ2dyZXNzaXZlbHksXG4gICAgICAgICAgICAgIGxvZ1ByZW1hdHVyZUVycm9yT3JDbG9zZUV2ZW50KGVycilcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGREaXNjb25uZWN0KGVyci5jb2RlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgICAgbG9nKDIgLyogRVJST1IgKi8sIGVyci5yZWFzb24pLFxuICAgICAgICAgICAgICBmaXJlRXJyb3JFdmVudChlcnIucmVhc29uLCBlcnIuY29kZSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheSwgbG9nUHJlbWF0dXJlRXJyb3JPckNsb3NlRXZlbnQoZXJyKV1cbiAgICAgIH07XG4gICAgfVxuICApO1xuICBjb25zdCBzZW5kSGVhcnRiZWF0ID0ge1xuICAgIHRhcmdldDogXCJAb2suYXdhaXRpbmctcG9uZ1wiLFxuICAgIGVmZmVjdDogKGN0eCkgPT4ge1xuICAgICAgY3R4LnNvY2tldD8uc2VuZChcInBpbmdcIik7XG4gICAgfVxuICB9O1xuICBjb25zdCBtYXliZUhlYXJ0YmVhdCA9ICgpID0+IHtcbiAgICBjb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHZvaWQgMDtcbiAgICBjb25zdCBjYW5ab21iaWUgPSBkb2M/LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJoaWRkZW5cIiAmJiBkZWxlZ2F0ZXMuY2FuWm9tYmllKCk7XG4gICAgcmV0dXJuIGNhblpvbWJpZSA/IFwiQGlkbGUuem9tYmllXCIgOiBzZW5kSGVhcnRiZWF0O1xuICB9O1xuICBtYWNoaW5lLmFkZFRpbWVkVHJhbnNpdGlvbihcIkBvay5jb25uZWN0ZWRcIiwgSEVBUlRCRUFUX0lOVEVSVkFMLCBtYXliZUhlYXJ0YmVhdCkuYWRkVHJhbnNpdGlvbnMoXCJAb2suY29ubmVjdGVkXCIsIHtcbiAgICBOQVZJR0FUT1JfT0ZGTElORTogbWF5YmVIZWFydGJlYXQsXG4gICAgLy8gRG9uJ3QgdGFrZSB0aGUgYnJvd3NlcidzIHdvcmQgZm9yIGl0IHdoZW4gaXQgc2F5cyBpdCdzIG9mZmxpbmUuIERvIGEgcGluZy9wb25nIHRvIG1ha2Ugc3VyZS5cbiAgICBXSU5ET1dfR09UX0ZPQ1VTOiBzZW5kSGVhcnRiZWF0XG4gIH0pO1xuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiQGlkbGUuem9tYmllXCIsIHtcbiAgICBXSU5ET1dfR09UX0ZPQ1VTOiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIlxuICAgIC8vIFdoZW4gaW4gem9tYmllIHN0YXRlLCB0aGUgY2xpZW50IHdpbGwgdHJ5IHRvIHdha2UgdXAgYXV0b21hdGljYWxseSB3aGVuIHRoZSB3aW5kb3cgcmVnYWlucyBmb2N1c1xuICB9KTtcbiAgbWFjaGluZS5vbkVudGVyKFwiQG9rLipcIiwgKGN0eCkgPT4ge1xuICAgIGN0eC5wYXRjaCh7IHN1Y2Nlc3NDb3VudDogY3R4LnN1Y2Nlc3NDb3VudCArIDEgfSk7XG4gICAgY29uc3QgdGltZXJJRCA9IHNldFRpbWVvdXQoXG4gICAgICAvLyBPbiB0aGUgbmV4dCB0aWNrLCBzdGFydCBkZWxpdmVyaW5nIGFsbCBtZXNzYWdlcyB0aGF0IGhhdmUgYWxyZWFkeVxuICAgICAgLy8gYmVlbiByZWNlaXZlZCwgYW5kIGNvbnRpbnVlIHN5bmNocm9ub3VzIGRlbGl2ZXJ5IG9mIGFsbCBmdXR1cmVcbiAgICAgIC8vIGluY29taW5nIG1lc3NhZ2VzLlxuICAgICAgb25NZXNzYWdlLnVucGF1c2UsXG4gICAgICAwXG4gICAgKTtcbiAgICByZXR1cm4gKGN0eDIpID0+IHtcbiAgICAgIHRlYXJkb3duU29ja2V0KGN0eDIuc29ja2V0KTtcbiAgICAgIGN0eDIucGF0Y2goeyBzb2NrZXQ6IG51bGwgfSk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJRCk7XG4gICAgICBvbk1lc3NhZ2UucGF1c2UoKTtcbiAgICB9O1xuICB9KS5hZGRUcmFuc2l0aW9ucyhcIkBvay5hd2FpdGluZy1wb25nXCIsIHsgUE9ORzogXCJAb2suY29ubmVjdGVkXCIgfSkuYWRkVGltZWRUcmFuc2l0aW9uKFwiQG9rLmF3YWl0aW5nLXBvbmdcIiwgUE9OR19USU1FT1VULCB7XG4gICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAvLyBMb2cgaW1wbGljaXQgY29ubmVjdGlvbiBsb3NzIGFuZCBkcm9wIHRoZSBjdXJyZW50IG9wZW4gc29ja2V0XG4gICAgZWZmZWN0OiBsb2coXG4gICAgICAxIC8qIFdBUk4gKi8sXG4gICAgICBcIlJlY2VpdmVkIG5vIHBvbmcgZnJvbSBzZXJ2ZXIsIGFzc3VtZSBpbXBsaWNpdCBjb25uZWN0aW9uIGxvc3MuXCJcbiAgICApXG4gIH0pLmFkZFRyYW5zaXRpb25zKFwiQG9rLipcIiwge1xuICAgIC8vIFdoZW4gYSBzb2NrZXQgcmVjZWl2ZXMgYW4gZXJyb3IsIHRoaXMgY2FuIGNhdXNlIHRoZSBjbG9zaW5nIG9mIHRoZVxuICAgIC8vIHNvY2tldCwgb3Igbm90LiBTbyBhbHdheXMgY2hlY2sgdG8gc2VlIGlmIHRoZSBzb2NrZXQgaXMgc3RpbGwgT1BFTiBvclxuICAgIC8vIG5vdC4gV2hlbiBzdGlsbCBPUEVOLCBkb24ndCB0cmFuc2l0aW9uLlxuICAgIEVYUExJQ0lUX1NPQ0tFVF9FUlJPUjogKF8sIGNvbnRleHQpID0+IHtcbiAgICAgIGlmIChjb250ZXh0LnNvY2tldD8ucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogaW5jcmVhc2VCYWNrb2ZmRGVsYXlcbiAgICAgIH07XG4gICAgfSxcbiAgICBFWFBMSUNJVF9TT0NLRVRfQ0xPU0U6IChlKSA9PiB7XG4gICAgICBpZiAoc2hvdWxkRGlzY29ubmVjdChlLmV2ZW50LmNvZGUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgbG9nUGVybWFuZW50Q2xvc2UsXG4gICAgICAgICAgICBmaXJlRXJyb3JFdmVudChlLmV2ZW50LnJlYXNvbiwgZS5ldmVudC5jb2RlKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZWF1dGgoZS5ldmVudC5jb2RlKSkge1xuICAgICAgICBpZiAoZS5ldmVudC5jb2RlID09PSA0MTA5IC8qIFRPS0VOX0VYUElSRUQgKi8pIHtcbiAgICAgICAgICByZXR1cm4gXCJAYXV0aC5idXN5XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheSwgbG9nQ2xvc2VFdmVudChlLmV2ZW50KV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmV0cnlXaXRob3V0UmVhdXRoKGUuZXZlbnQuY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5QWdncmVzc2l2ZWx5LCBsb2dDbG9zZUV2ZW50KGUuZXZlbnQpXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIGxvZ0Nsb3NlRXZlbnQoZS5ldmVudCldXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHZvaWQgMDtcbiAgICBjb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdm9pZCAwO1xuICAgIGNvbnN0IHJvb3QgPSB3aW4gPz8gZG9jO1xuICAgIG1hY2hpbmUub25FbnRlcihcIipcIiwgKGN0eCkgPT4ge1xuICAgICAgZnVuY3Rpb24gb25OZXR3b3JrT2ZmbGluZSgpIHtcbiAgICAgICAgbWFjaGluZS5zZW5kKHsgdHlwZTogXCJOQVZJR0FUT1JfT0ZGTElORVwiIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25OZXR3b3JrQmFja09ubGluZSgpIHtcbiAgICAgICAgbWFjaGluZS5zZW5kKHsgdHlwZTogXCJOQVZJR0FUT1JfT05MSU5FXCIgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvblZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgICAgIGlmIChkb2M/LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgICAgICBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIldJTkRPV19HT1RfRk9DVVNcIiB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2luPy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIG9uTmV0d29ya0JhY2tPbmxpbmUpO1xuICAgICAgd2luPy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBvbk5ldHdvcmtPZmZsaW5lKTtcbiAgICAgIHJvb3Q/LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByb290Py5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgICB3aW4/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgb25OZXR3b3JrQmFja09ubGluZSk7XG4gICAgICAgIHdpbj8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgb25OZXR3b3JrT2ZmbGluZSk7XG4gICAgICAgIHRlYXJkb3duU29ja2V0KGN0eC5zb2NrZXQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBjbGVhbnVwcyA9IFtdO1xuICBjb25zdCB7IHN0YXR1c0RpZENoYW5nZSwgZGlkQ29ubmVjdCwgZGlkRGlzY29ubmVjdCwgdW5zdWJzY3JpYmUgfSA9IGRlZmluZUNvbm5lY3Rpdml0eUV2ZW50cyhtYWNoaW5lKTtcbiAgY2xlYW51cHMucHVzaCh1bnN1YnNjcmliZSk7XG4gIGlmIChvcHRpb25zLmVuYWJsZURlYnVnTG9nZ2luZykge1xuICAgIGNsZWFudXBzLnB1c2goZW5hYmxlVHJhY2luZyhtYWNoaW5lKSk7XG4gIH1cbiAgbWFjaGluZS5zdGFydCgpO1xuICByZXR1cm4ge1xuICAgIG1hY2hpbmUsXG4gICAgY2xlYW51cHMsXG4gICAgLy8gT2JzZXJ2YWJsZSBldmVudHMgdGhhdCB3aWxsIGJlIGVtaXR0ZWQgYnkgdGhpcyBtYWNoaW5lXG4gICAgZXZlbnRzOiB7XG4gICAgICBzdGF0dXNEaWRDaGFuZ2UsXG4gICAgICBkaWRDb25uZWN0LFxuICAgICAgZGlkRGlzY29ubmVjdCxcbiAgICAgIG9uTWVzc2FnZTogb25NZXNzYWdlLm9ic2VydmFibGUsXG4gICAgICBvbkxpdmVibG9ja3NFcnJvcjogb25MaXZlYmxvY2tzRXJyb3Iub2JzZXJ2YWJsZVxuICAgIH1cbiAgfTtcbn1cbnZhciBNYW5hZ2VkU29ja2V0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihkZWxlZ2F0ZXMsIGVuYWJsZURlYnVnTG9nZ2luZyA9IGZhbHNlLCB3YWl0Rm9yQWN0b3JJZCA9IHRydWUpIHtcbiAgICBjb25zdCB7IG1hY2hpbmUsIGV2ZW50cywgY2xlYW51cHMgfSA9IGNyZWF0ZUNvbm5lY3Rpb25TdGF0ZU1hY2hpbmUoXG4gICAgICBkZWxlZ2F0ZXMsXG4gICAgICB7IHdhaXRGb3JBY3RvcklkLCBlbmFibGVEZWJ1Z0xvZ2dpbmcgfVxuICAgICk7XG4gICAgdGhpcy5tYWNoaW5lID0gbWFjaGluZTtcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICB0aGlzLmNsZWFudXBzID0gY2xlYW51cHM7XG4gIH1cbiAgZ2V0TGVnYWN5U3RhdHVzKCkge1xuICAgIHJldHVybiBuZXdUb0xlZ2FjeVN0YXR1cyh0aGlzLmdldFN0YXR1cygpKTtcbiAgfVxuICBnZXRTdGF0dXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0b05ld0Nvbm5lY3Rpb25TdGF0dXModGhpcy5tYWNoaW5lKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBcImluaXRpYWxcIjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYXV0aCBhdXRoVmFsdWUuXG4gICAqL1xuICBnZXQgYXV0aFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLm1hY2hpbmUuY29udGV4dC5hdXRoVmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgdGhpcyBtZXRob2QgdG8gdHJ5IHRvIGNvbm5lY3QgdG8gYSBXZWJTb2NrZXQuIFRoaXMgb25seSBoYXMgYW4gZWZmZWN0XG4gICAqIGlmIHRoZSBtYWNoaW5lIGlzIGlkbGUgYXQgdGhlIG1vbWVudCwgb3RoZXJ3aXNlIHRoaXMgaXMgYSBuby1vcC5cbiAgICovXG4gIGNvbm5lY3QoKSB7XG4gICAgdGhpcy5tYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkNPTk5FQ1RcIiB9KTtcbiAgfVxuICAvKipcbiAgICogSWYgaWRsZSwgd2lsbCB0cnkgdG8gY29ubmVjdC4gT3RoZXJ3aXNlLCBpdCB3aWxsIGF0dGVtcHQgdG8gcmVjb25uZWN0IHRvXG4gICAqIHRoZSBzb2NrZXQsIHBvdGVudGlhbGx5IG9idGFpbmluZyBhIG5ldyBhdXRoVmFsdWUgZmlyc3QsIGlmIG5lZWRlZC5cbiAgICovXG4gIHJlY29ubmVjdCgpIHtcbiAgICB0aGlzLm1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiUkVDT05ORUNUXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgdGhpcyBtZXRob2QgdG8gZGlzY29ubmVjdCBmcm9tIHRoZSBjdXJyZW50IFdlYlNvY2tldC4gSXMgZ29pbmcgdG8gYmVcbiAgICogYSBuby1vcCBpZiB0aGVyZSBpcyBubyBhY3RpdmUgY29ubmVjdGlvbi5cbiAgICovXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5tYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkRJU0NPTk5FQ1RcIiB9KTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIHRvIHN0b3AgdGhlIG1hY2hpbmUgYW5kIHJ1biBuZWNlc3NhcnkgY2xlYW51cCBmdW5jdGlvbnMuIEFmdGVyXG4gICAqIGNhbGxpbmcgZGVzdHJveSgpLCB5b3UgY2FuIG5vIGxvbmdlciB1c2UgdGhpcyBpbnN0YW5jZS4gQ2FsbCB0aGlzIGJlZm9yZVxuICAgKiBsZXR0aW5nIHRoZSBpbnN0YW5jZSBnZXQgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMubWFjaGluZS5zdG9wKCk7XG4gICAgbGV0IGNsZWFudXA7XG4gICAgd2hpbGUgKGNsZWFudXAgPSB0aGlzLmNsZWFudXBzLnBvcCgpKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTYWZlbHkgc2VuZCBhIG1lc3NhZ2UgdG8gdGhlIGN1cnJlbnQgV2ViU29ja2V0IGNvbm5lY3Rpb24uIFdpbGwgZW1pdCBhIGxvZ1xuICAgKiBtZXNzYWdlIGlmIHRoaXMgaXMgc29tZWhvdyBpbXBvc3NpYmxlLlxuICAgKi9cbiAgc2VuZChkYXRhKSB7XG4gICAgY29uc3Qgc29ja2V0ID0gdGhpcy5tYWNoaW5lLmNvbnRleHQ/LnNvY2tldDtcbiAgICBpZiAoc29ja2V0ID09PSBudWxsKSB7XG4gICAgICB3YXJuKFwiQ2Fubm90IHNlbmQ6IG5vdCBjb25uZWN0ZWQgeWV0XCIsIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IDEpIHtcbiAgICAgIHdhcm4oXCJDYW5ub3Qgc2VuZDogV2ViU29ja2V0IG5vIGxvbmdlciBvcGVuXCIsIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb2NrZXQuc2VuZChkYXRhKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE5PVEU6IFVzZWQgYnkgdGhlIEUyRSBhcHAgb25seSwgdG8gc2ltdWxhdGUgZXhwbGljaXQgZXZlbnRzLlxuICAgKiBOb3QgaWRlYWwgdG8ga2VlcCBleHBvc2VkIDooXG4gICAqL1xuICBfcHJpdmF0ZVNlbmRNYWNoaW5lRXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLm1hY2hpbmUuc2VuZChldmVudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm90b2NvbC9BdXRoVG9rZW4udHNcbmZ1bmN0aW9uIGNhbldyaXRlU3RvcmFnZShzY29wZXMpIHtcbiAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG59XG5mdW5jdGlvbiBjYW5Db21tZW50KHNjb3Blcykge1xuICByZXR1cm4gc2NvcGVzLmluY2x1ZGVzKFwiY29tbWVudHM6d3JpdGVcIiAvKiBDb21tZW50c1dyaXRlICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xufVxuZnVuY3Rpb24gaXNWYWxpZEF1dGhUb2tlblBheWxvYWQoZGF0YSkge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdChkYXRhKSAmJiAoZGF0YS5rID09PSBcImFjY1wiIC8qIEFDQ0VTU19UT0tFTiAqLyB8fCBkYXRhLmsgPT09IFwiaWRcIiAvKiBJRF9UT0tFTiAqLyB8fCBkYXRhLmsgPT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8pO1xufVxuZnVuY3Rpb24gcGFyc2VBdXRoVG9rZW4ocmF3VG9rZW5TdHJpbmcpIHtcbiAgY29uc3QgdG9rZW5QYXJ0cyA9IHJhd1Rva2VuU3RyaW5nLnNwbGl0KFwiLlwiKTtcbiAgaWYgKHRva2VuUGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0aGVudGljYXRpb24gZXJyb3I6IGludmFsaWQgSldUIHRva2VuXCIpO1xuICB9XG4gIGNvbnN0IHBheWxvYWQgPSB0cnlQYXJzZUpzb24oYjY0ZGVjb2RlKHRva2VuUGFydHNbMV0pKTtcbiAgaWYgKCEocGF5bG9hZCAmJiBpc1ZhbGlkQXV0aFRva2VuUGF5bG9hZChwYXlsb2FkKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkF1dGhlbnRpY2F0aW9uIGVycm9yOiBleHBlY3RlZCBhIHZhbGlkIHRva2VuIGJ1dCBkaWQgbm90IGdldCBvbmUuIEhpbnQ6IGlmIHlvdSBhcmUgdXNpbmcgYSBjYWxsYmFjaywgZW5zdXJlIHRoZSByb29tIGlzIHBhc3NlZCB3aGVuIGNyZWF0aW5nIHRoZSB0b2tlbi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50Q2FsbGJhY2tcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByYXc6IHJhd1Rva2VuU3RyaW5nLFxuICAgIHBhcnNlZDogcGF5bG9hZFxuICB9O1xufVxuXG4vLyBzcmMvYXV0aC1tYW5hZ2VyLnRzXG5mdW5jdGlvbiBjcmVhdGVBdXRoTWFuYWdlcihhdXRoT3B0aW9ucykge1xuICBjb25zdCBhdXRoZW50aWNhdGlvbiA9IHByZXBhcmVBdXRoZW50aWNhdGlvbihhdXRoT3B0aW9ucyk7XG4gIGNvbnN0IHNlZW5Ub2tlbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgY29uc3QgZXhwaXJ5VGltZXMgPSBbXTtcbiAgY29uc3QgcmVxdWVzdFByb21pc2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgc2VlblRva2Vucy5jbGVhcigpO1xuICAgIHRva2Vucy5sZW5ndGggPSAwO1xuICAgIGV4cGlyeVRpbWVzLmxlbmd0aCA9IDA7XG4gICAgcmVxdWVzdFByb21pc2VzLmNsZWFyKCk7XG4gIH1cbiAgZnVuY3Rpb24gaGFzQ29ycmVzcG9uZGluZ1Njb3BlcyhyZXF1ZXN0ZWRTY29wZSwgc2NvcGVzKSB7XG4gICAgaWYgKHJlcXVlc3RlZFNjb3BlID09PSBcImNvbW1lbnRzOnJlYWRcIikge1xuICAgICAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcImNvbW1lbnRzOnJlYWRcIiAvKiBDb21tZW50c1JlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcImNvbW1lbnRzOndyaXRlXCIgLyogQ29tbWVudHNXcml0ZSAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwicm9vbTpyZWFkXCIgLyogUmVhZCAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwicm9vbTp3cml0ZVwiIC8qIFdyaXRlICovKTtcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3RlZFNjb3BlID09PSBcInJvb206cmVhZFwiKSB7XG4gICAgICByZXR1cm4gc2NvcGVzLmluY2x1ZGVzKFwicm9vbTpyZWFkXCIgLyogUmVhZCAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwicm9vbTp3cml0ZVwiIC8qIFdyaXRlICovKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGdldENhY2hlZFRva2VuKHJlcXVlc3RlZFNjb3BlLCByb29tSWQpIHtcbiAgICBjb25zdCBub3cgPSBNYXRoLmNlaWwoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgZm9yIChsZXQgaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBleHBpcnlUaW1lc1tpXTtcbiAgICAgIGlmIChleHBpcmVzQXQgPD0gbm93KSB7XG4gICAgICAgIHRva2Vucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGV4cGlyeVRpbWVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4ucGFyc2VkLmsgPT09IFwiaWRcIiAvKiBJRF9UT0tFTiAqLykge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnBhcnNlZC5rID09PSBcImFjY1wiIC8qIEFDQ0VTU19UT0tFTiAqLykge1xuICAgICAgICBmb3IgKGNvbnN0IFtyZXNvdXJjZSwgc2NvcGVzXSBvZiBPYmplY3QuZW50cmllcyh0b2tlbi5wYXJzZWQucGVybXMpKSB7XG4gICAgICAgICAgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiByb29tSWQuc3RhcnRzV2l0aChyZXNvdXJjZS5yZXBsYWNlKFwiKlwiLCBcIlwiKSkgfHwgcm9vbUlkID09PSByZXNvdXJjZSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RlZFNjb3BlLCBzY29wZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFrZUF1dGhSZXF1ZXN0KHJvb21JZCkge1xuICAgIGNvbnN0IGZldGNoZXIgPSBhdXRoT3B0aW9ucy5wb2x5ZmlsbHM/LmZldGNoID8/ICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gdm9pZCAwIDogd2luZG93LmZldGNoKTtcbiAgICBpZiAoYXV0aGVudGljYXRpb24udHlwZSA9PT0gXCJwcml2YXRlXCIpIHtcbiAgICAgIGlmIChmZXRjaGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhcbiAgICAgICAgICBcIlRvIHVzZSBMaXZlYmxvY2tzIGNsaWVudCBpbiBhIG5vbi1ET00gZW52aXJvbm1lbnQgd2l0aCBhIHVybCBhcyBhdXRoIGVuZHBvaW50LCB5b3UgbmVlZCB0byBwcm92aWRlIGEgZmV0Y2ggcG9seWZpbGwuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hBdXRoRW5kcG9pbnQoZmV0Y2hlciwgYXV0aGVudGljYXRpb24udXJsLCB7XG4gICAgICAgIHJvb206IHJvb21JZFxuICAgICAgfSk7XG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUF1dGhUb2tlbihyZXNwb25zZS50b2tlbik7XG4gICAgICBpZiAoc2VlblRva2Vucy5oYXMocGFyc2VkLnJhdykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhcbiAgICAgICAgICBcIlRoZSBzYW1lIExpdmVibG9ja3MgYXV0aCB0b2tlbiB3YXMgaXNzdWVkIGZyb20gdGhlIGJhY2tlbmQgYmVmb3JlLiBDYWNoaW5nIExpdmVibG9ja3MgdG9rZW5zIGlzIG5vdCBzdXBwb3J0ZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIGlmIChhdXRoZW50aWNhdGlvbi50eXBlID09PSBcImN1c3RvbVwiKSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhlbnRpY2F0aW9uLmNhbGxiYWNrKHJvb21JZCk7XG4gICAgICBpZiAocmVzcG9uc2UgJiYgdHlwZW9mIHJlc3BvbnNlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UudG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VBdXRoVG9rZW4ocmVzcG9uc2UudG9rZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZS5lcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7XCJyZWFzb25cIiBpbiByZXNwb25zZSAmJiB0eXBlb2YgcmVzcG9uc2UucmVhc29uID09PSBcInN0cmluZ1wiID8gcmVzcG9uc2UucmVhc29uIDogXCJGb3JiaWRkZW5cIn1gO1xuICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvciA9PT0gXCJmb3JiaWRkZW5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhyZWFzb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1lvdXIgYXV0aGVudGljYXRpb24gY2FsbGJhY2sgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIHRva2VuLCBidXQgaXQgZGlkIG5vdC4gSGludDogdGhlIHJldHVybiB2YWx1ZSBzaG91bGQgbG9vayBsaWtlOiB7IHRva2VuOiBcIi4uLlwiIH0nXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlVuZXhwZWN0ZWQgYXV0aGVudGljYXRpb24gdHlwZS4gTXVzdCBiZSBwcml2YXRlIG9yIGN1c3RvbS5cIlxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aFZhbHVlKHJlcXVlc3RlZFNjb3BlLCByb29tSWQpIHtcbiAgICBpZiAoYXV0aGVudGljYXRpb24udHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJwdWJsaWNcIiwgcHVibGljQXBpS2V5OiBhdXRoZW50aWNhdGlvbi5wdWJsaWNBcGlLZXkgfTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVkVG9rZW4gPSBnZXRDYWNoZWRUb2tlbihyZXF1ZXN0ZWRTY29wZSwgcm9vbUlkKTtcbiAgICBpZiAoY2FjaGVkVG9rZW4gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzZWNyZXRcIiwgdG9rZW46IGNhY2hlZFRva2VuIH07XG4gICAgfVxuICAgIGxldCBjdXJyZW50UHJvbWlzZSA9IHJlcXVlc3RQcm9taXNlcy5nZXQocm9vbUlkKTtcbiAgICBpZiAoY3VycmVudFByb21pc2UgPT09IHZvaWQgMCkge1xuICAgICAgY3VycmVudFByb21pc2UgPSBtYWtlQXV0aFJlcXVlc3Qocm9vbUlkKTtcbiAgICAgIHJlcXVlc3RQcm9taXNlcy5zZXQocm9vbUlkLCBjdXJyZW50UHJvbWlzZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IGN1cnJlbnRQcm9taXNlO1xuICAgICAgY29uc3QgQlVGRkVSID0gMzA7XG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpICsgKHRva2VuLnBhcnNlZC5leHAgLSB0b2tlbi5wYXJzZWQuaWF0KSAtIEJVRkZFUjtcbiAgICAgIHNlZW5Ub2tlbnMuYWRkKHRva2VuLnJhdyk7XG4gICAgICBpZiAodG9rZW4ucGFyc2VkLmsgIT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8pIHtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBleHBpcnlUaW1lcy5wdXNoKGV4cGlyZXNBdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0eXBlOiBcInNlY3JldFwiLCB0b2tlbiB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZXF1ZXN0UHJvbWlzZXMuZGVsZXRlKHJvb21JZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcmVzZXQsXG4gICAgZ2V0QXV0aFZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlQXV0aGVudGljYXRpb24oYXV0aE9wdGlvbnMpIHtcbiAgY29uc3QgeyBwdWJsaWNBcGlLZXksIGF1dGhFbmRwb2ludCB9ID0gYXV0aE9wdGlvbnM7XG4gIGlmIChhdXRoRW5kcG9pbnQgIT09IHZvaWQgMCAmJiBwdWJsaWNBcGlLZXkgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiWW91IGNhbm5vdCBzaW11bHRhbmVvdXNseSB1c2UgYHB1YmxpY0FwaUtleWAgYW5kIGBhdXRoRW5kcG9pbnRgIG9wdGlvbnMuIFBsZWFzZSBwaWNrIG9uZSBhbmQgbGVhdmUgdGhlIG90aGVyIG9wdGlvbiB1bnNwZWNpZmllZC4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50XCJcbiAgICApO1xuICB9XG4gIGlmICh0eXBlb2YgcHVibGljQXBpS2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKHB1YmxpY0FwaUtleS5zdGFydHNXaXRoKFwic2tfXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiSW52YWxpZCBgcHVibGljQXBpS2V5YCBvcHRpb24uIFRoZSB2YWx1ZSB5b3UgcGFzc2VkIGlzIGEgc2VjcmV0IGtleSwgd2hpY2ggc2hvdWxkIG5vdCBiZSB1c2VkIGZyb20gdGhlIGNsaWVudC4gUGxlYXNlIG9ubHkgZXZlciBwYXNzIGEgcHVibGljIGtleSBoZXJlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRQdWJsaWNLZXlcIlxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFwdWJsaWNBcGlLZXkuc3RhcnRzV2l0aChcInBrX1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkludmFsaWQga2V5LiBQbGVhc2UgdXNlIHRoZSBwdWJsaWMga2V5IGZvcm1hdDogcGtfPHB1YmxpYyBrZXk+LiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRQdWJsaWNLZXlcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicHVibGljXCIsXG4gICAgICBwdWJsaWNBcGlLZXlcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgYXV0aEVuZHBvaW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicHJpdmF0ZVwiLFxuICAgICAgdXJsOiBhdXRoRW5kcG9pbnRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhdXRoRW5kcG9pbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImN1c3RvbVwiLFxuICAgICAgY2FsbGJhY2s6IGF1dGhFbmRwb2ludFxuICAgIH07XG4gIH0gZWxzZSBpZiAoYXV0aEVuZHBvaW50ICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSBgYXV0aEVuZHBvaW50YCBvcHRpb24gbXVzdCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRBdXRoRW5kcG9pbnRcIlxuICAgICk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIFwiSW52YWxpZCBMaXZlYmxvY2tzIGNsaWVudCBvcHRpb25zLiBQbGVhc2UgcHJvdmlkZSBlaXRoZXIgYSBgcHVibGljQXBpS2V5YCBvciBgYXV0aEVuZHBvaW50YCBvcHRpb24uIFRoZXkgY2Fubm90IGJvdGggYmUgZW1wdHkuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFwiXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaEF1dGhFbmRwb2ludChmZXRjaDIsIGVuZHBvaW50LCBib2R5KSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoMihlbmRwb2ludCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9LFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gIH0pO1xuICBpZiAoIXJlcy5vaykge1xuICAgIGNvbnN0IHJlYXNvbiA9IGAkeyhhd2FpdCByZXMudGV4dCgpKS50cmltKCkgfHwgXCJyZWFzb24gbm90IHByb3ZpZGVkIGluIGF1dGggcmVzcG9uc2VcIn0gKCR7cmVzLnN0YXR1c30gcmV0dXJuZWQgYnkgUE9TVCAke2VuZHBvaW50fSlgO1xuICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDEgfHwgcmVzLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKGBVbmF1dGhvcml6ZWQ6ICR7cmVhc29ufWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhdXRoZW50aWNhdGU6ICR7cmVhc29ufWApO1xuICAgIH1cbiAgfVxuICBsZXQgZGF0YTtcbiAgdHJ5IHtcbiAgICBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBKU09OIHJlc3BvbnNlIHdoZW4gZG9pbmcgYSBQT1NUIHJlcXVlc3Qgb24gXCIke2VuZHBvaW50fVwiLiAke1N0cmluZyhcbiAgICAgICAgZXJcbiAgICAgICl9YFxuICAgICk7XG4gIH1cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpIHx8IHR5cGVvZiBkYXRhLnRva2VuICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIGEgSlNPTiByZXNwb25zZSBvZiB0aGUgZm9ybSBcXGB7IHRva2VuOiBcIi4uLlwiIH1cXGAgd2hlbiBkb2luZyBhIFBPU1QgcmVxdWVzdCBvbiBcIiR7ZW5kcG9pbnR9XCIsIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgZGF0YVxuICAgICAgKX1gXG4gICAgKTtcbiAgfVxuICBjb25zdCB7IHRva2VuIH0gPSBkYXRhO1xuICByZXR1cm4geyB0b2tlbiB9O1xufVxuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgREVGQVVMVF9CQVNFX1VSTCA9IFwiaHR0cHM6Ly9hcGkubGl2ZWJsb2Nrcy5pb1wiO1xuXG4vLyBzcmMvZGV2dG9vbHMvYnJpZGdlLnRzXG52YXIgX2JyaWRnZUFjdGl2ZSA9IGZhbHNlO1xuZnVuY3Rpb24gYWN0aXZhdGVCcmlkZ2UoYWxsb3dlZCkge1xuICBfYnJpZGdlQWN0aXZlID0gYWxsb3dlZDtcbn1cbmZ1bmN0aW9uIHNlbmRUb1BhbmVsKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZ1bGxNc2cgPSB7XG4gICAgLi4ubWVzc2FnZSxcbiAgICBzb3VyY2U6IFwibGl2ZWJsb2Nrcy1kZXZ0b29scy1jbGllbnRcIlxuICB9O1xuICBpZiAoIShvcHRpb25zPy5mb3JjZSB8fCBfYnJpZGdlQWN0aXZlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cucG9zdE1lc3NhZ2UoZnVsbE1zZywgXCIqXCIpO1xufVxudmFyIGV2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlKCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5zb3VyY2UgPT09IHdpbmRvdyAmJiBldmVudC5kYXRhPy5zb3VyY2UgPT09IFwibGl2ZWJsb2Nrcy1kZXZ0b29scy1wYW5lbFwiKSB7XG4gICAgICBldmVudFNvdXJjZS5ub3RpZnkoZXZlbnQuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICB9XG4gIH0pO1xufVxudmFyIG9uTWVzc2FnZUZyb21QYW5lbCA9IGV2ZW50U291cmNlLm9ic2VydmFibGU7XG5cbi8vIHNyYy9kZXZ0b29scy9pbmRleC50c1xudmFyIFZFUlNJT04gPSBQS0dfVkVSU0lPTiB8fCBcImRldlwiO1xudmFyIF9kZXZ0b29sc1NldHVwSGFzUnVuID0gZmFsc2U7XG5mdW5jdGlvbiBzZXR1cERldlRvb2xzKGdldEFsbFJvb21zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoX2RldnRvb2xzU2V0dXBIYXNSdW4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgX2RldnRvb2xzU2V0dXBIYXNSdW4gPSB0cnVlO1xuICBvbk1lc3NhZ2VGcm9tUGFuZWwuc3Vic2NyaWJlKChtc2cpID0+IHtcbiAgICBzd2l0Y2ggKG1zZy5tc2cpIHtcbiAgICAgIGNhc2UgXCJjb25uZWN0XCI6IHtcbiAgICAgICAgYWN0aXZhdGVCcmlkZ2UodHJ1ZSk7XG4gICAgICAgIGZvciAoY29uc3Qgcm9vbUlkIG9mIGdldEFsbFJvb21zKCkpIHtcbiAgICAgICAgICBzZW5kVG9QYW5lbCh7XG4gICAgICAgICAgICBtc2c6IFwicm9vbTo6YXZhaWxhYmxlXCIsXG4gICAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgICBjbGllbnRWZXJzaW9uOiBWRVJTSU9OXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VuZFRvUGFuZWwoeyBtc2c6IFwid2FrZS11cC1kZXZ0b29sc1wiIH0sIHsgZm9yY2U6IHRydWUgfSk7XG59XG52YXIgdW5zdWJzQnlSb29tSWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gc3RvcFN5bmNTdHJlYW0ocm9vbUlkKSB7XG4gIGNvbnN0IHVuc3VicyA9IHVuc3Vic0J5Um9vbUlkLmdldChyb29tSWQpID8/IFtdO1xuICB1bnN1YnNCeVJvb21JZC5kZWxldGUocm9vbUlkKTtcbiAgZm9yIChjb25zdCB1bnN1YiBvZiB1bnN1YnMpIHtcbiAgICB1bnN1YigpO1xuICB9XG59XG5mdW5jdGlvbiBzdGFydFN5bmNTdHJlYW0ocm9vbSkge1xuICBzdG9wU3luY1N0cmVhbShyb29tLmlkKTtcbiAgZnVsbFN5bmMocm9vbSk7XG4gIHVuc3Vic0J5Um9vbUlkLnNldChyb29tLmlkLCBbXG4gICAgLy8gV2hlbiB0aGUgY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlc1xuICAgIHJvb20uZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNDb25uZWN0aW9uKHJvb20pKSxcbiAgICAvLyBXaGVuIHN0b3JhZ2UgaW5pdGlhbGl6ZXMsIHNlbmQgdGhlIHVwZGF0ZVxuICAgIHJvb20uZXZlbnRzLnN0b3JhZ2VEaWRMb2FkLnN1YnNjcmliZU9uY2UoKCkgPT4gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSBzdG9yYWdlIHVwZGF0ZXMsIHNlbmQgdGhlIG5ldyBzdG9yYWdlIHJvb3RcbiAgICByb29tLmV2ZW50cy5zdG9yYWdlLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY1N0b3JhZ2Uocm9vbSkpLFxuICAgIC8vIEFueSB0aW1lIFwibWVcIiBvciBcIm90aGVyc1wiIHVwZGF0ZXMsIHNlbmQgdGhlIG5ldyB2YWx1ZXMgYWNjb3JkaW5nbHlcbiAgICByb29tLmV2ZW50cy5zZWxmLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY01lKHJvb20pKSxcbiAgICByb29tLmV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jT3RoZXJzKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSB5ZG9jIGlzIHVwZGF0ZWQsIGZvcndhcmQgdGhlIHVwZGF0ZVxuICAgIHJvb20uZXZlbnRzLnlkb2Muc3Vic2NyaWJlKCh1cGRhdGUpID0+IHN5bmNZZG9jVXBkYXRlKHJvb20sIHVwZGF0ZSkpLFxuICAgIC8vIEFueSB0aW1lIGEgY3VzdG9tIHJvb20gZXZlbnQgaXMgcmVjZWl2ZWQsIGZvcndhcmQgaXRcbiAgICByb29tLmV2ZW50cy5jdXN0b21FdmVudC5zdWJzY3JpYmUoXG4gICAgICAoZXZlbnREYXRhKSA9PiBmb3J3YXJkRXZlbnQocm9vbSwgZXZlbnREYXRhKVxuICAgIClcbiAgXSk7XG59XG5mdW5jdGlvbiBzeW5jWWRvY1VwZGF0ZShyb29tLCB1cGRhdGUpIHtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpzeW5jOjp5ZG9jXCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIHVwZGF0ZVxuICB9KTtcbn1cbnZhciBsb2FkZWRBdCA9IERhdGUubm93KCk7XG52YXIgZXZlbnRDb3VudGVyID0gMDtcbmZ1bmN0aW9uIG5leHRFdmVudElkKCkge1xuICByZXR1cm4gYGV2ZW50LSR7bG9hZGVkQXR9LSR7ZXZlbnRDb3VudGVyKyt9YDtcbn1cbmZ1bmN0aW9uIGZvcndhcmRFdmVudChyb29tLCBldmVudERhdGEpIHtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpldmVudHM6OmN1c3RvbS1ldmVudFwiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICBldmVudDoge1xuICAgICAgdHlwZTogXCJDdXN0b21FdmVudFwiLFxuICAgICAgaWQ6IG5leHRFdmVudElkKCksXG4gICAgICBrZXk6IFwiRXZlbnRcIixcbiAgICAgIGNvbm5lY3Rpb25JZDogZXZlbnREYXRhLmNvbm5lY3Rpb25JZCxcbiAgICAgIHBheWxvYWQ6IGV2ZW50RGF0YS5ldmVudFxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY0Nvbm5lY3Rpb24ocm9vbSkge1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgc3RhdHVzOiByb29tLmdldFN0YXR1cygpXG4gIH0pO1xufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pIHtcbiAgY29uc3Qgcm9vdCA9IHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90KCk7XG4gIGlmIChyb290KSB7XG4gICAgc2VuZFRvUGFuZWwoe1xuICAgICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgIHN0b3JhZ2U6IHJvb3QudG9UcmVlTm9kZShcInJvb3RcIikucGF5bG9hZFxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY01lKHJvb20pIHtcbiAgY29uc3QgbWUgPSByb29tLl9faW50ZXJuYWwuZ2V0U2VsZl9mb3JEZXZUb29scygpO1xuICBpZiAobWUpIHtcbiAgICBzZW5kVG9QYW5lbCh7XG4gICAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgbWVcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNPdGhlcnMocm9vbSkge1xuICBjb25zdCBvdGhlcnMgPSByb29tLl9faW50ZXJuYWwuZ2V0T3RoZXJzX2ZvckRldlRvb2xzKCk7XG4gIGlmIChvdGhlcnMpIHtcbiAgICBzZW5kVG9QYW5lbCh7XG4gICAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgb3RoZXJzXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZ1bGxTeW5jKHJvb20pIHtcbiAgY29uc3Qgcm9vdCA9IHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90KCk7XG4gIGNvbnN0IG1lID0gcm9vbS5fX2ludGVybmFsLmdldFNlbGZfZm9yRGV2VG9vbHMoKTtcbiAgY29uc3Qgb3RoZXJzID0gcm9vbS5fX2ludGVybmFsLmdldE90aGVyc19mb3JEZXZUb29scygpO1xuICByb29tLmZldGNoWURvYyhcIlwiKTtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpzeW5jOjpmdWxsXCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIHN0YXR1czogcm9vbS5nZXRTdGF0dXMoKSxcbiAgICBzdG9yYWdlOiByb290Py50b1RyZWVOb2RlKFwicm9vdFwiKS5wYXlsb2FkID8/IG51bGwsXG4gICAgbWUsXG4gICAgb3RoZXJzXG4gIH0pO1xufVxudmFyIHJvb21DaGFubmVsTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHN0b3BSb29tQ2hhbm5lbExpc3RlbmVyKHJvb21JZCkge1xuICBjb25zdCBsaXN0ZW5lciA9IHJvb21DaGFubmVsTGlzdGVuZXJzLmdldChyb29tSWQpO1xuICByb29tQ2hhbm5lbExpc3RlbmVycy5kZWxldGUocm9vbUlkKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgbGlzdGVuZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gbGlua0RldlRvb2xzKHJvb21JZCwgcm9vbSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2VuZFRvUGFuZWwoeyBtc2c6IFwicm9vbTo6YXZhaWxhYmxlXCIsIHJvb21JZCwgY2xpZW50VmVyc2lvbjogVkVSU0lPTiB9KTtcbiAgc3RvcFJvb21DaGFubmVsTGlzdGVuZXIocm9vbUlkKTtcbiAgcm9vbUNoYW5uZWxMaXN0ZW5lcnMuc2V0KFxuICAgIHJvb21JZCxcbiAgICAvLyBSZXR1cm5zIHRoZSB1bnN1YnNjcmliZSBjYWxsYmFjaywgdGhhdCB3ZSBzdG9yZSBpbiB0aGVcbiAgICAvLyByb29tQ2hhbm5lbExpc3RlbmVycyByZWdpc3RyeVxuICAgIG9uTWVzc2FnZUZyb21QYW5lbC5zdWJzY3JpYmUoKG1zZykgPT4ge1xuICAgICAgc3dpdGNoIChtc2cubXNnKSB7XG4gICAgICAgIGNhc2UgXCJyb29tOjpzdWJzY3JpYmVcIjoge1xuICAgICAgICAgIGlmIChtc2cucm9vbUlkID09PSByb29tSWQpIHtcbiAgICAgICAgICAgIHN0YXJ0U3luY1N0cmVhbShyb29tKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJvb206OnVuc3Vic2NyaWJlXCI6IHtcbiAgICAgICAgICBpZiAobXNnLnJvb21JZCA9PT0gcm9vbUlkKSB7XG4gICAgICAgICAgICBzdG9wU3luY1N0cmVhbShyb29tSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiB1bmxpbmtEZXZUb29scyhyb29tSWQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN0b3BTeW5jU3RyZWFtKHJvb21JZCk7XG4gIHN0b3BSb29tQ2hhbm5lbExpc3RlbmVyKHJvb21JZCk7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6dW5hdmFpbGFibGVcIixcbiAgICByb29tSWRcbiAgfSk7XG59XG5cbi8vIHNyYy9saWIvZGVwcmVjYXRpb24udHNcbnZhciBfZW1pdHRlZERlcHJlY2F0aW9uV2FybmluZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuZnVuY3Rpb24gZGVwcmVjYXRlKG1lc3NhZ2UsIGtleSA9IG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzLmhhcyhrZXkpKSB7XG4gICAgICBfZW1pdHRlZERlcHJlY2F0aW9uV2FybmluZ3MuYWRkKGtleSk7XG4gICAgICBlcnJvcldpdGhUaXRsZShcIkRlcHJlY2F0aW9uIHdhcm5pbmdcIiwgbWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZXByZWNhdGVJZihjb25kaXRpb24sIG1lc3NhZ2UsIGtleSA9IG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIGRlcHJlY2F0ZShtZXNzYWdlLCBrZXkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdGhyb3dVc2FnZUVycm9yKG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IHVzYWdlRXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgdXNhZ2VFcnJvci5uYW1lID0gXCJVc2FnZSBlcnJvclwiO1xuICAgIGVycm9yV2l0aFRpdGxlKFwiVXNhZ2UgZXJyb3JcIiwgbWVzc2FnZSk7XG4gICAgdGhyb3cgdXNhZ2VFcnJvcjtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JJZihjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHRocm93VXNhZ2VFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL2NvbW1lbnRzL2NvbW1lbnQtYm9keS50c1xuZnVuY3Rpb24gaXNDb21tZW50Qm9keVBhcmFncmFwaChlbGVtZW50KSB7XG4gIHJldHVybiBcInR5cGVcIiBpbiBlbGVtZW50ICYmIGVsZW1lbnQudHlwZSA9PT0gXCJtZW50aW9uXCI7XG59XG5mdW5jdGlvbiBpc0NvbW1lbnRCb2R5VGV4dChlbGVtZW50KSB7XG4gIHJldHVybiBcInRleHRcIiBpbiBlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LnRleHQgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc0NvbW1lbnRCb2R5TWVudGlvbihlbGVtZW50KSB7XG4gIHJldHVybiBcInR5cGVcIiBpbiBlbGVtZW50ICYmIGVsZW1lbnQudHlwZSA9PT0gXCJtZW50aW9uXCI7XG59XG5mdW5jdGlvbiBpc0NvbW1lbnRCb2R5TGluayhlbGVtZW50KSB7XG4gIHJldHVybiBcInR5cGVcIiBpbiBlbGVtZW50ICYmIGVsZW1lbnQudHlwZSA9PT0gXCJsaW5rXCI7XG59XG52YXIgY29tbWVudEJvZHlFbGVtZW50c0d1YXJkcyA9IHtcbiAgcGFyYWdyYXBoOiBpc0NvbW1lbnRCb2R5UGFyYWdyYXBoLFxuICB0ZXh0OiBpc0NvbW1lbnRCb2R5VGV4dCxcbiAgbGluazogaXNDb21tZW50Qm9keUxpbmssXG4gIG1lbnRpb246IGlzQ29tbWVudEJvZHlNZW50aW9uXG59O1xudmFyIGNvbW1lbnRCb2R5RWxlbWVudHNUeXBlcyA9IHtcbiAgcGFyYWdyYXBoOiBcImJsb2NrXCIsXG4gIHRleHQ6IFwiaW5saW5lXCIsXG4gIGxpbms6IFwiaW5saW5lXCIsXG4gIG1lbnRpb246IFwiaW5saW5lXCJcbn07XG5mdW5jdGlvbiB0cmF2ZXJzZUNvbW1lbnRCb2R5KGJvZHksIGVsZW1lbnRPclZpc2l0b3IsIHBvc3NpYmx5VmlzaXRvcikge1xuICBpZiAoIWJvZHkgfHwgIWJvZHk/LmNvbnRlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZWxlbWVudCA9IHR5cGVvZiBlbGVtZW50T3JWaXNpdG9yID09PSBcInN0cmluZ1wiID8gZWxlbWVudE9yVmlzaXRvciA6IHZvaWQgMDtcbiAgY29uc3QgdHlwZSA9IGVsZW1lbnQgPyBjb21tZW50Qm9keUVsZW1lbnRzVHlwZXNbZWxlbWVudF0gOiBcImFsbFwiO1xuICBjb25zdCBndWFyZCA9IGVsZW1lbnQgPyBjb21tZW50Qm9keUVsZW1lbnRzR3VhcmRzW2VsZW1lbnRdIDogKCkgPT4gdHJ1ZTtcbiAgY29uc3QgdmlzaXRvciA9IHR5cGVvZiBlbGVtZW50T3JWaXNpdG9yID09PSBcImZ1bmN0aW9uXCIgPyBlbGVtZW50T3JWaXNpdG9yIDogcG9zc2libHlWaXNpdG9yO1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIGJvZHkuY29udGVudCkge1xuICAgIGlmICh0eXBlID09PSBcImFsbFwiIHx8IHR5cGUgPT09IFwiYmxvY2tcIikge1xuICAgICAgaWYgKGd1YXJkKGJsb2NrKSkge1xuICAgICAgICB2aXNpdG9yPy4oYmxvY2spO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJhbGxcIiB8fCB0eXBlID09PSBcImlubGluZVwiKSB7XG4gICAgICBmb3IgKGNvbnN0IGlubGluZSBvZiBibG9jay5jaGlsZHJlbikge1xuICAgICAgICBpZiAoZ3VhcmQoaW5saW5lKSkge1xuICAgICAgICAgIHZpc2l0b3I/LihpbmxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRNZW50aW9uZWRJZHNGcm9tQ29tbWVudEJvZHkoYm9keSkge1xuICBjb25zdCBtZW50aW9uZWRJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB0cmF2ZXJzZUNvbW1lbnRCb2R5KFxuICAgIGJvZHksXG4gICAgXCJtZW50aW9uXCIsXG4gICAgKG1lbnRpb24pID0+IG1lbnRpb25lZElkcy5hZGQobWVudGlvbi5pZClcbiAgKTtcbiAgcmV0dXJuIEFycmF5LmZyb20obWVudGlvbmVkSWRzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVVc2Vyc0luQ29tbWVudEJvZHkoYm9keSwgcmVzb2x2ZVVzZXJzKSB7XG4gIGNvbnN0IHJlc29sdmVkVXNlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBpZiAoIXJlc29sdmVVc2Vycykge1xuICAgIHJldHVybiByZXNvbHZlZFVzZXJzO1xuICB9XG4gIGNvbnN0IHVzZXJJZHMgPSBnZXRNZW50aW9uZWRJZHNGcm9tQ29tbWVudEJvZHkoYm9keSk7XG4gIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzb2x2ZVVzZXJzKHtcbiAgICB1c2VySWRzXG4gIH0pO1xuICBmb3IgKGNvbnN0IFtpbmRleCwgdXNlcklkXSBvZiB1c2VySWRzLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IHVzZXIgPSB1c2Vycz8uW2luZGV4XTtcbiAgICBpZiAodXNlcikge1xuICAgICAgcmVzb2x2ZWRVc2Vycy5zZXQodXNlcklkLCB1c2VyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkVXNlcnM7XG59XG52YXIgaHRtbEVzY2FwYWJsZXMgPSB7XG4gIFwiJlwiOiBcIiZhbXA7XCIsXG4gIFwiPFwiOiBcIiZsdDtcIixcbiAgXCI+XCI6IFwiJmd0O1wiLFxuICAnXCInOiBcIiZxdW90O1wiLFxuICBcIidcIjogXCImIzM5O1wiXG59O1xudmFyIGh0bWxFc2NhcGFibGVzUmVnZXggPSBuZXcgUmVnRXhwKFxuICBPYmplY3Qua2V5cyhodG1sRXNjYXBhYmxlcykubWFwKChlbnRpdHkpID0+IGBcXFxcJHtlbnRpdHl9YCkuam9pbihcInxcIiksXG4gIFwiZ1wiXG4pO1xuZnVuY3Rpb24gaHRtbFNhZmUodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhbU3RyaW5nKHZhbHVlKV0sIFtdKTtcbn1cbmZ1bmN0aW9uIGpvaW5IdG1sKHN0cmluZ3MpIHtcbiAgaWYgKHN0cmluZ3MubGVuZ3RoIDw9IDApIHtcbiAgICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKFtcIlwiXSwgW10pO1xuICB9XG4gIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoXG4gICAgW1wiXCIsIC4uLkFycmF5KHN0cmluZ3MubGVuZ3RoIC0gMSkuZmlsbChcIlwiKSwgXCJcIl0sXG4gICAgc3RyaW5nc1xuICApO1xufVxuZnVuY3Rpb24gZXNjYXBlSHRtbCh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBIdG1sU2FmZVN0cmluZykge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBqb2luSHRtbCh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKHZhbHVlKS5yZXBsYWNlKFxuICAgIGh0bWxFc2NhcGFibGVzUmVnZXgsXG4gICAgKGNoYXJhY3RlcikgPT4gaHRtbEVzY2FwYWJsZXNbY2hhcmFjdGVyXVxuICApO1xufVxudmFyIEh0bWxTYWZlU3RyaW5nID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzdHJpbmdzLCB2YWx1ZXMpIHtcbiAgICB0aGlzLl9zdHJpbmdzID0gc3RyaW5ncztcbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmluZ3MucmVkdWNlKChyZXN1bHQsIHN0ciwgaSkgPT4ge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZUh0bWwobm4odGhpcy5fdmFsdWVzW2kgLSAxXSkpICsgc3RyO1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gaHRtbChzdHJpbmdzLCAuLi52YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhzdHJpbmdzLCB2YWx1ZXMpO1xufVxudmFyIG1hcmtkb3duRXNjYXBhYmxlcyA9IHtcbiAgXzogXCJcXFxcX1wiLFxuICBcIipcIjogXCJcXFxcKlwiLFxuICBcIiNcIjogXCJcXFxcI1wiLFxuICBcImBcIjogXCJcXFxcYFwiLFxuICBcIn5cIjogXCJcXFxcflwiLFxuICBcIiFcIjogXCJcXFxcIVwiLFxuICBcInxcIjogXCJcXFxcfFwiLFxuICBcIihcIjogXCJcXFxcKFwiLFxuICBcIilcIjogXCJcXFxcKVwiLFxuICBcIntcIjogXCJcXFxce1wiLFxuICBcIn1cIjogXCJcXFxcfVwiLFxuICBcIltcIjogXCJcXFxcW1wiLFxuICBcIl1cIjogXCJcXFxcXVwiXG59O1xudmFyIG1hcmtkb3duRXNjYXBhYmxlc1JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgT2JqZWN0LmtleXMobWFya2Rvd25Fc2NhcGFibGVzKS5tYXAoKGVudGl0eSkgPT4gYFxcXFwke2VudGl0eX1gKS5qb2luKFwifFwiKSxcbiAgXCJnXCJcbik7XG5mdW5jdGlvbiBqb2luTWFya2Rvd24oc3RyaW5ncykge1xuICBpZiAoc3RyaW5ncy5sZW5ndGggPD0gMCkge1xuICAgIHJldHVybiBuZXcgTWFya2Rvd25TYWZlU3RyaW5nKFtcIlwiXSwgW10pO1xuICB9XG4gIHJldHVybiBuZXcgTWFya2Rvd25TYWZlU3RyaW5nKFxuICAgIFtcIlwiLCAuLi5BcnJheShzdHJpbmdzLmxlbmd0aCAtIDEpLmZpbGwoXCJcIiksIFwiXCJdLFxuICAgIHN0cmluZ3NcbiAgKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZU1hcmtkb3duKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcmtkb3duU2FmZVN0cmluZykge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBqb2luTWFya2Rvd24odmFsdWUpLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSkucmVwbGFjZShcbiAgICBtYXJrZG93bkVzY2FwYWJsZXNSZWdleCxcbiAgICAoY2hhcmFjdGVyKSA9PiBtYXJrZG93bkVzY2FwYWJsZXNbY2hhcmFjdGVyXVxuICApO1xufVxudmFyIE1hcmtkb3duU2FmZVN0cmluZyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc3RyaW5ncywgdmFsdWVzKSB7XG4gICAgdGhpcy5fc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJpbmdzLnJlZHVjZSgocmVzdWx0LCBzdHIsIGkpID0+IHtcbiAgICAgIHJldHVybiByZXN1bHQgKyBlc2NhcGVNYXJrZG93bihubih0aGlzLl92YWx1ZXNbaSAtIDFdKSkgKyBzdHI7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBtYXJrZG93bihzdHJpbmdzLCAuLi52YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBNYXJrZG93blNhZmVTdHJpbmcoc3RyaW5ncywgdmFsdWVzKTtcbn1cbmZ1bmN0aW9uIHRvQWJzb2x1dGVVcmwodXJsKSB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHwgdXJsLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSkge1xuICAgIHJldHVybiB1cmw7XG4gIH0gZWxzZSBpZiAodXJsLnN0YXJ0c1dpdGgoXCJ3d3cuXCIpKSB7XG4gICAgcmV0dXJuIFwiaHR0cHM6Ly9cIiArIHVybDtcbiAgfVxuICByZXR1cm47XG59XG52YXIgc3RyaW5naWZ5Q29tbWVudEJvZHlQbGFpbkVsZW1lbnRzID0ge1xuICBwYXJhZ3JhcGg6ICh7IGNoaWxkcmVuIH0pID0+IGNoaWxkcmVuLFxuICB0ZXh0OiAoeyBlbGVtZW50IH0pID0+IGVsZW1lbnQudGV4dCxcbiAgbGluazogKHsgZWxlbWVudCB9KSA9PiBlbGVtZW50LnVybCxcbiAgbWVudGlvbjogKHsgZWxlbWVudCwgdXNlciB9KSA9PiB7XG4gICAgcmV0dXJuIGBAJHt1c2VyPy5uYW1lID8/IGVsZW1lbnQuaWR9YDtcbiAgfVxufTtcbnZhciBzdHJpbmdpZnlDb21tZW50Qm9keUh0bWxFbGVtZW50cyA9IHtcbiAgcGFyYWdyYXBoOiAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gICAgcmV0dXJuIGNoaWxkcmVuID8gaHRtbGA8cD4ke2h0bWxTYWZlKGNoaWxkcmVuKX08L3A+YCA6IGNoaWxkcmVuO1xuICB9LFxuICB0ZXh0OiAoeyBlbGVtZW50IH0pID0+IHtcbiAgICBsZXQgY2hpbGRyZW4gPSBlbGVtZW50LnRleHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5ib2xkKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPHN0cm9uZz4ke2NoaWxkcmVufTwvc3Ryb25nPmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lml0YWxpYykge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxlbT4ke2NoaWxkcmVufTwvZW0+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuc3RyaWtldGhyb3VnaCkge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxzPiR7Y2hpbGRyZW59PC9zPmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmNvZGUpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8Y29kZT4ke2NoaWxkcmVufTwvY29kZT5gO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH0sXG4gIGxpbms6ICh7IGVsZW1lbnQsIGhyZWYgfSkgPT4ge1xuICAgIHJldHVybiBodG1sYDxhIGhyZWY9XCIke2hyZWZ9XCIgdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiPiR7ZWxlbWVudC51cmx9PC9hPmA7XG4gIH0sXG4gIG1lbnRpb246ICh7IGVsZW1lbnQsIHVzZXIgfSkgPT4ge1xuICAgIHJldHVybiBodG1sYDxzcGFuIGRhdGEtbWVudGlvbj5AJHt1c2VyPy5uYW1lID8/IGVsZW1lbnQuaWR9PC9zcGFuPmA7XG4gIH1cbn07XG52YXIgc3RyaW5naWZ5Q29tbWVudEJvZHlNYXJrZG93bkVsZW1lbnRzID0ge1xuICBwYXJhZ3JhcGg6ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH0sXG4gIHRleHQ6ICh7IGVsZW1lbnQgfSkgPT4ge1xuICAgIGxldCBjaGlsZHJlbiA9IGVsZW1lbnQudGV4dDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmJvbGQpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gKioke2NoaWxkcmVufSoqYDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaXRhbGljKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYF8ke2NoaWxkcmVufV9gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5zdHJpa2V0aHJvdWdoKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYH5+JHtjaGlsZHJlbn1+fmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmNvZGUpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gXFxgJHtjaGlsZHJlbn1cXGBgO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH0sXG4gIGxpbms6ICh7IGVsZW1lbnQsIGhyZWYgfSkgPT4ge1xuICAgIHJldHVybiBtYXJrZG93bmBbJHtlbGVtZW50LnVybH1dKCR7aHJlZn0pYDtcbiAgfSxcbiAgbWVudGlvbjogKHsgZWxlbWVudCwgdXNlciB9KSA9PiB7XG4gICAgcmV0dXJuIG1hcmtkb3duYEAke3VzZXI/Lm5hbWUgPz8gZWxlbWVudC5pZH1gO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gc3RyaW5naWZ5Q29tbWVudEJvZHkoYm9keSwgb3B0aW9ucykge1xuICBjb25zdCBmb3JtYXQgPSBvcHRpb25zPy5mb3JtYXQgPz8gXCJwbGFpblwiO1xuICBjb25zdCBzZXBhcmF0b3IgPSBvcHRpb25zPy5zZXBhcmF0b3IgPz8gKGZvcm1hdCA9PT0gXCJtYXJrZG93blwiID8gXCJcXG5cXG5cIiA6IFwiXFxuXCIpO1xuICBjb25zdCBlbGVtZW50cyA9IHtcbiAgICAuLi5mb3JtYXQgPT09IFwiaHRtbFwiID8gc3RyaW5naWZ5Q29tbWVudEJvZHlIdG1sRWxlbWVudHMgOiBmb3JtYXQgPT09IFwibWFya2Rvd25cIiA/IHN0cmluZ2lmeUNvbW1lbnRCb2R5TWFya2Rvd25FbGVtZW50cyA6IHN0cmluZ2lmeUNvbW1lbnRCb2R5UGxhaW5FbGVtZW50cyxcbiAgICAuLi5vcHRpb25zPy5lbGVtZW50c1xuICB9O1xuICBjb25zdCByZXNvbHZlZFVzZXJzID0gYXdhaXQgcmVzb2x2ZVVzZXJzSW5Db21tZW50Qm9keShcbiAgICBib2R5LFxuICAgIG9wdGlvbnM/LnJlc29sdmVVc2Vyc1xuICApO1xuICBjb25zdCBibG9ja3MgPSBib2R5LmNvbnRlbnQuZmxhdE1hcCgoYmxvY2ssIGJsb2NrSW5kZXgpID0+IHtcbiAgICBzd2l0Y2ggKGJsb2NrLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJwYXJhZ3JhcGhcIjoge1xuICAgICAgICBjb25zdCBpbmxpbmVzID0gYmxvY2suY2hpbGRyZW4uZmxhdE1hcCgoaW5saW5lLCBpbmxpbmVJbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChpc0NvbW1lbnRCb2R5TWVudGlvbihpbmxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5saW5lLmlkID8gW1xuICAgICAgICAgICAgICBlbGVtZW50cy5tZW50aW9uKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGlubGluZSxcbiAgICAgICAgICAgICAgICAgIHVzZXI6IHJlc29sdmVkVXNlcnMuZ2V0KGlubGluZS5pZClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlubGluZUluZGV4XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF0gOiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ29tbWVudEJvZHlMaW5rKGlubGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIGVsZW1lbnRzLmxpbmsoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudDogaW5saW5lLFxuICAgICAgICAgICAgICAgICAgaHJlZjogdG9BYnNvbHV0ZVVybChpbmxpbmUudXJsKSA/PyBpbmxpbmUudXJsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmxpbmVJbmRleFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keVRleHQoaW5saW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtlbGVtZW50cy50ZXh0KHsgZWxlbWVudDogaW5saW5lIH0sIGlubGluZUluZGV4KV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgZWxlbWVudHMucGFyYWdyYXBoKFxuICAgICAgICAgICAgeyBlbGVtZW50OiBibG9jaywgY2hpbGRyZW46IGlubGluZXMuam9pbihcIlwiKSB9LFxuICAgICAgICAgICAgYmxvY2tJbmRleFxuICAgICAgICAgIClcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYmxvY2tzLmpvaW4oc2VwYXJhdG9yKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0NvbW1lbnREYXRhKGRhdGEpIHtcbiAgY29uc3QgZWRpdGVkQXQgPSBkYXRhLmVkaXRlZEF0ID8gbmV3IERhdGUoZGF0YS5lZGl0ZWRBdCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgY29uc3QgcmVhY3Rpb25zID0gZGF0YS5yZWFjdGlvbnMubWFwKChyZWFjdGlvbikgPT4gKHtcbiAgICAuLi5yZWFjdGlvbixcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKHJlYWN0aW9uLmNyZWF0ZWRBdClcbiAgfSkpO1xuICBpZiAoZGF0YS5ib2R5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICByZWFjdGlvbnMsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBlZGl0ZWRBdFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgcmVhY3Rpb25zLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgZWRpdGVkQXQsXG4gICAgICBkZWxldGVkQXRcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UaHJlYWREYXRhKGRhdGEpIHtcbiAgY29uc3QgdXBkYXRlZEF0ID0gZGF0YS51cGRhdGVkQXQgPyBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgY29uc3QgY29tbWVudHMgPSBkYXRhLmNvbW1lbnRzLm1hcChcbiAgICAoY29tbWVudCkgPT4gY29udmVydFRvQ29tbWVudERhdGEoY29tbWVudClcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGNyZWF0ZWRBdCxcbiAgICB1cGRhdGVkQXQsXG4gICAgY29tbWVudHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24oZGF0YSkge1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdClcbiAgfTtcbn1cblxuLy8gc3JjL2NvbW1lbnRzL2luZGV4LnRzXG5mdW5jdGlvbiBnZXRBdXRoQmVhcmVySGVhZGVyRnJvbUF1dGhWYWx1ZShhdXRoVmFsdWUpIHtcbiAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgcmV0dXJuIGF1dGhWYWx1ZS5wdWJsaWNBcGlLZXk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGF1dGhWYWx1ZS50b2tlbi5yYXc7XG4gIH1cbn1cbnZhciBDb21tZW50c0FwaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRzQXBpKHJvb21JZCwgZ2V0QXV0aFZhbHVlLCBjb25maWcpIHtcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hKc29uKGVuZHBvaW50LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEFwaShyb29tSWQsIGVuZHBvaW50LCBvcHRpb25zKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgbGV0IGVycm9yMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IENvbW1lbnRzQXBpRXJyb3IoXG4gICAgICAgICAgICBlcnJvckJvZHkubWVzc2FnZSxcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIGVycm9yQm9keVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGVycm9yMyA9IG5ldyBDb21tZW50c0FwaUVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IzO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYm9keTtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGJvZHkgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hBcGkocm9vbUlkMiwgZW5kcG9pbnQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBnZXRBdXRoVmFsdWUoKTtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKFxuICAgICAgYC92Mi9jL3Jvb21zLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHJvb21JZDIpfSR7ZW5kcG9pbnR9YCxcbiAgICAgIGNvbmZpZy5iYXNlVXJsXG4gICAgKTtcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtnZXRBdXRoQmVhcmVySGVhZGVyRnJvbUF1dGhWYWx1ZShhdXRoVmFsdWUpfWBcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzKG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQXBpKHJvb21JZCwgXCIvdGhyZWFkcy9zZWFyY2hcIiwge1xuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAuLi5vcHRpb25zPy5xdWVyeT8ubWV0YWRhdGEgJiYgeyBtZXRhZGF0YTogb3B0aW9ucy5xdWVyeS5tZXRhZGF0YSB9XG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH0sXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIGpzb24uZGF0YS5tYXAoKHRocmVhZCkgPT4gY29udmVydFRvVGhyZWFkRGF0YSh0aHJlYWQpKTtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRocmVhZHMuXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUaHJlYWQoe1xuICAgIG1ldGFkYXRhLFxuICAgIGJvZHksXG4gICAgY29tbWVudElkLFxuICAgIHRocmVhZElkXG4gIH0pIHtcbiAgICBjb25zdCB0aHJlYWQgPSBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBcIi90aHJlYWRzXCIsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgaWQ6IHRocmVhZElkLFxuICAgICAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb1RocmVhZERhdGEodGhyZWFkKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBlZGl0VGhyZWFkTWV0YWRhdGEoe1xuICAgIG1ldGFkYXRhLFxuICAgIHRocmVhZElkXG4gIH0pIHtcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vbWV0YWRhdGFgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb21tZW50KHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgYm9keVxuICB9KSB7XG4gICAgY29uc3QgY29tbWVudCA9IGF3YWl0IGZldGNoSnNvbihcbiAgICAgIGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9L2NvbW1lbnRzYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICAgIGJvZHlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50RGF0YShjb21tZW50KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBlZGl0Q29tbWVudCh7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkLFxuICAgIGJvZHlcbiAgfSkge1xuICAgIGNvbnN0IGNvbW1lbnQgPSBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9jb21tZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY29tbWVudElkXG4gICAgICApfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgYm9keVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUNvbW1lbnQoe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZFxuICB9KSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vY29tbWVudHMvJHtlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgIGNvbW1lbnRJZFxuICAgICAgKX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGFkZFJlYWN0aW9uKHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgZW1vamlcbiAgfSkge1xuICAgIGNvbnN0IHJlYWN0aW9uID0gYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vY29tbWVudHMvJHtlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgIGNvbW1lbnRJZFxuICAgICAgKX0vcmVhY3Rpb25zYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1vamkgfSlcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uKHJlYWN0aW9uKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZW1vdmVSZWFjdGlvbih7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkLFxuICAgIGVtb2ppXG4gIH0pIHtcbiAgICBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9jb21tZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY29tbWVudElkXG4gICAgICApfS9yZWFjdGlvbnMvJHtlbmNvZGVVUklDb21wb25lbnQoZW1vamkpfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJERUxFVEVcIlxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRUaHJlYWRzLFxuICAgIGNyZWF0ZVRocmVhZCxcbiAgICBlZGl0VGhyZWFkTWV0YWRhdGEsXG4gICAgY3JlYXRlQ29tbWVudCxcbiAgICBlZGl0Q29tbWVudCxcbiAgICBkZWxldGVDb21tZW50LFxuICAgIGFkZFJlYWN0aW9uLFxuICAgIHJlbW92ZVJlYWN0aW9uXG4gIH07XG59XG5cbi8vIHNyYy9saWIvcG9zaXRpb24udHNcbnZhciBNSU5fQ09ERSA9IDMyO1xudmFyIE1BWF9DT0RFID0gMTI2O1xudmFyIE5VTV9ESUdJVFMgPSBNQVhfQ09ERSAtIE1JTl9DT0RFICsgMTtcbnZhciBaRVJPID0gbnRoRGlnaXQoMCk7XG52YXIgT05FID0gbnRoRGlnaXQoMSk7XG52YXIgWkVST19OSU5FID0gWkVSTyArIG50aERpZ2l0KC0xKTtcbmZ1bmN0aW9uIG50aERpZ2l0KG4pIHtcbiAgY29uc3QgY29kZSA9IE1JTl9DT0RFICsgKG4gPCAwID8gTlVNX0RJR0lUUyArIG4gOiBuKTtcbiAgaWYgKGNvZGUgPCBNSU5fQ09ERSB8fCBjb2RlID4gTUFYX0NPREUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbiB2YWx1ZTogJHtufWApO1xuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xufVxuZnVuY3Rpb24gbWFrZVBvc2l0aW9uKHgsIHkpIHtcbiAgaWYgKHggIT09IHZvaWQgMCAmJiB5ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gYmV0d2Vlbih4LCB5KTtcbiAgfSBlbHNlIGlmICh4ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gYWZ0ZXIoeCk7XG4gIH0gZWxzZSBpZiAoeSAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGJlZm9yZSh5KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gT05FO1xuICB9XG59XG5mdW5jdGlvbiBiZWZvcmUocG9zKSB7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHBvcy5sZW5ndGggLSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBsYXN0SW5kZXg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBwb3MuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA8PSBNSU5fQ09ERSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpID09PSBsYXN0SW5kZXgpIHtcbiAgICAgIGlmIChjb2RlID09PSBNSU5fQ09ERSArIDEpIHtcbiAgICAgICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSkgKyBaRVJPX05JTkU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpICsgMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBPTkU7XG59XG5mdW5jdGlvbiBhZnRlcihwb3MpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcG9zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBwb3MuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA+PSBNQVhfQ09ERSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlICsgMSk7XG4gIH1cbiAgcmV0dXJuIHBvcyArIE9ORTtcbn1cbmZ1bmN0aW9uIGJldHdlZW4obG8sIGhpKSB7XG4gIGlmIChsbyA8IGhpKSB7XG4gICAgcmV0dXJuIF9iZXR3ZWVuKGxvLCBoaSk7XG4gIH0gZWxzZSBpZiAobG8gPiBoaSkge1xuICAgIHJldHVybiBfYmV0d2VlbihoaSwgbG8pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wdXRlIHZhbHVlIGJldHdlZW4gdHdvIGVxdWFsIHBvc2l0aW9uc1wiKTtcbiAgfVxufVxuZnVuY3Rpb24gX2JldHdlZW4obG8sIGhpKSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGNvbnN0IGxvTGVuID0gbG8ubGVuZ3RoO1xuICBjb25zdCBoaUxlbiA9IGhpLmxlbmd0aDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBsb0NvZGUgPSBpbmRleCA8IGxvTGVuID8gbG8uY2hhckNvZGVBdChpbmRleCkgOiBNSU5fQ09ERTtcbiAgICBjb25zdCBoaUNvZGUgPSBpbmRleCA8IGhpTGVuID8gaGkuY2hhckNvZGVBdChpbmRleCkgOiBNQVhfQ09ERTtcbiAgICBpZiAobG9Db2RlID09PSBoaUNvZGUpIHtcbiAgICAgIGluZGV4Kys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGhpQ29kZSAtIGxvQ29kZSA9PT0gMSkge1xuICAgICAgY29uc3Qgc2l6ZSA9IGluZGV4ICsgMTtcbiAgICAgIGxldCBwcmVmaXggPSBsby5zdWJzdHJpbmcoMCwgc2l6ZSk7XG4gICAgICBpZiAocHJlZml4Lmxlbmd0aCA8IHNpemUpIHtcbiAgICAgICAgcHJlZml4ICs9IFpFUk8ucmVwZWF0KHNpemUgLSBwcmVmaXgubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1ZmZpeCA9IGxvLnN1YnN0cmluZyhzaXplKTtcbiAgICAgIGNvbnN0IG5pbmVzID0gXCJcIjtcbiAgICAgIHJldHVybiBwcmVmaXggKyBfYmV0d2VlbihzdWZmaXgsIG5pbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRha2VOKGxvLCBpbmRleCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGhpQ29kZSArIGxvQ29kZSA+PiAxKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRha2VOKHBvcywgbikge1xuICByZXR1cm4gbiA8IHBvcy5sZW5ndGggPyBwb3Muc3Vic3RyaW5nKDAsIG4pIDogcG9zICsgWkVSTy5yZXBlYXQobiAtIHBvcy5sZW5ndGgpO1xufVxudmFyIE1JTl9OT05fWkVST19DT0RFID0gTUlOX0NPREUgKyAxO1xuZnVuY3Rpb24gaXNQb3Moc3RyKSB7XG4gIGlmIChzdHIgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbGFzdElkeCA9IHN0ci5sZW5ndGggLSAxO1xuICBjb25zdCBsYXN0ID0gc3RyLmNoYXJDb2RlQXQobGFzdElkeCk7XG4gIGlmIChsYXN0IDwgTUlOX05PTl9aRVJPX0NPREUgfHwgbGFzdCA+IE1BWF9DT0RFKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGFzdElkeDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlIDwgTUlOX0NPREUgfHwgY29kZSA+IE1BWF9DT0RFKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY29udmVydFRvUG9zKHN0cikge1xuICBjb25zdCBjb2RlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBjb2Rlcy5wdXNoKGNvZGUgPCBNSU5fQ09ERSA/IE1JTl9DT0RFIDogY29kZSA+IE1BWF9DT0RFID8gTUFYX0NPREUgOiBjb2RlKTtcbiAgfVxuICB3aGlsZSAoY29kZXMubGVuZ3RoID4gMCAmJiBjb2Rlc1tjb2Rlcy5sZW5ndGggLSAxXSA9PT0gTUlOX0NPREUpIHtcbiAgICBjb2Rlcy5sZW5ndGgtLTtcbiAgfVxuICByZXR1cm4gY29kZXMubGVuZ3RoID4gMCA/IFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uY29kZXMpIDogKFxuICAgIC8vIEVkZ2UgY2FzZTogdGhlIHN0ciB3YXMgYSAwLW9ubHkgc3RyaW5nLCB3aGljaCBpcyBpbnZhbGlkLiBEZWZhdWx0IGJhY2sgdG8gLjFcbiAgICBPTkVcbiAgKTtcbn1cbmZ1bmN0aW9uIGFzUG9zKHN0cikge1xuICByZXR1cm4gaXNQb3Moc3RyKSA/IHN0ciA6IGNvbnZlcnRUb1BvcyhzdHIpO1xufVxuXG4vLyBzcmMvcHJvdG9jb2wvT3AudHNcbnZhciBPcENvZGUgPSAvKiBAX19QVVJFX18gKi8gKChPcENvZGUyKSA9PiB7XG4gIE9wQ29kZTJbT3BDb2RlMltcIklOSVRcIl0gPSAwXSA9IFwiSU5JVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJTRVRfUEFSRU5UX0tFWVwiXSA9IDFdID0gXCJTRVRfUEFSRU5UX0tFWVwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfTElTVFwiXSA9IDJdID0gXCJDUkVBVEVfTElTVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJVUERBVEVfT0JKRUNUXCJdID0gM10gPSBcIlVQREFURV9PQkpFQ1RcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX09CSkVDVFwiXSA9IDRdID0gXCJDUkVBVEVfT0JKRUNUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkRFTEVURV9DUkRUXCJdID0gNV0gPSBcIkRFTEVURV9DUkRUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkRFTEVURV9PQkpFQ1RfS0VZXCJdID0gNl0gPSBcIkRFTEVURV9PQkpFQ1RfS0VZXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9NQVBcIl0gPSA3XSA9IFwiQ1JFQVRFX01BUFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfUkVHSVNURVJcIl0gPSA4XSA9IFwiQ1JFQVRFX1JFR0lTVEVSXCI7XG4gIHJldHVybiBPcENvZGUyO1xufSkoT3BDb2RlIHx8IHt9KTtcbmZ1bmN0aW9uIGFja09wKG9wSWQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgIGlkOiBcIkFDS1wiLFxuICAgIC8vIChIKUFDS1xuICAgIG9wSWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQWNrT3Aob3ApIHtcbiAgcmV0dXJuIG9wLnR5cGUgPT09IDUgLyogREVMRVRFX0NSRFQgKi8gJiYgb3AuaWQgPT09IFwiQUNLXCI7XG59XG5cbi8vIHNyYy9jcmR0cy9BYnN0cmFjdENyZHQudHNcbmZ1bmN0aW9uIGNyZHRBc0xpdmVOb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIEhhc1BhcmVudChub2RlLCBrZXksIHBvcyA9IGFzUG9zKGtleSkpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyB0eXBlOiBcIkhhc1BhcmVudFwiLCBub2RlLCBrZXksIHBvcyB9KTtcbn1cbnZhciBOb1BhcmVudCA9IE9iamVjdC5mcmVlemUoeyB0eXBlOiBcIk5vUGFyZW50XCIgfSk7XG5mdW5jdGlvbiBPcnBoYW5lZChvbGRLZXksIG9sZFBvcyA9IGFzUG9zKG9sZEtleSkpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyB0eXBlOiBcIk9ycGhhbmVkXCIsIG9sZEtleSwgb2xkUG9zIH0pO1xufVxudmFyIEFic3RyYWN0Q3JkdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3BhcmVudCA9IE5vUGFyZW50O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2dldFBhcmVudEtleU9yVGhyb3coKSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5rZXk7XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IGtleSBpcyBtaXNzaW5nXCIpO1xuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5vbGRLZXk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX3BhcmVudFBvcygpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnBvcztcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQga2V5IGlzIG1pc3NpbmdcIik7XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm9sZFBvcztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfcG9vbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3Bvb2w7XG4gIH1cbiAgZ2V0IHJvb21JZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3Bvb2wgPyB0aGlzLl9fcG9vbC5yb29tSWQgOiBudWxsO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9pZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2lkO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IHBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9wYXJlbnRLZXkoKSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5rZXk7XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm9sZEtleTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgX2lzTG9jYWwpIHtcbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgNSAvKiBERUxFVEVfQ1JEVCAqLzoge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5ub2RlLl9kZXRhY2hDaGlsZChjcmR0QXNMaXZlTm9kZSh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NldFBhcmVudExpbmsobmV3UGFyZW50Tm9kZSwgbmV3UGFyZW50S2V5KSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6XG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5ub2RlICE9PSBuZXdQYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBwYXJlbnQ6IG5vZGUgYWxyZWFkeSBoYXMgYSBwYXJlbnRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcGFyZW50ID0gSGFzUGFyZW50KG5ld1BhcmVudE5vZGUsIG5ld1BhcmVudEtleSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjpcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOiB7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IEhhc1BhcmVudChuZXdQYXJlbnROb2RlLCBuZXdQYXJlbnRLZXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX19pZCB8fCB0aGlzLl9fcG9vbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGF0dGFjaCBub2RlOiBhbHJlYWR5IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBwb29sLmFkZE5vZGUoaWQsIGNyZHRBc0xpdmVOb2RlKHRoaXMpKTtcbiAgICB0aGlzLl9faWQgPSBpZDtcbiAgICB0aGlzLl9fcG9vbCA9IHBvb2w7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoKCkge1xuICAgIGlmICh0aGlzLl9fcG9vbCAmJiB0aGlzLl9faWQpIHtcbiAgICAgIHRoaXMuX19wb29sLmRlbGV0ZU5vZGUodGhpcy5fX2lkKTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6IHtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gT3JwaGFuZWQodGhpcy5wYXJlbnQua2V5LCB0aGlzLnBhcmVudC5wb3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOiB7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IE5vUGFyZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOiB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gICAgdGhpcy5fX3Bvb2wgPSB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBDbGVhciB0aGUgSW1tdXRhYmxlIGNhY2hlLCBzbyB0aGF0IHRoZSBuZXh0IGNhbGwgdG8gYC50b0ltbXV0YWJsZSgpYCB3aWxsXG4gICAqIHJlY29tcHV0ZSB0aGUgZXF1aXZhbGVudCBJbW11dGFibGUgdmFsdWUgYWdhaW4uICBDYWxsIHRoaXMgYWZ0ZXIgZXZlcnlcbiAgICogbXV0YXRpb24gdG8gdGhlIExpdmUgbm9kZS5cbiAgICovXG4gIGludmFsaWRhdGUoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZEltbXV0YWJsZSAhPT0gdm9pZCAwIHx8IHRoaXMuX2NhY2hlZFRyZWVOb2RlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX2NhY2hlZEltbXV0YWJsZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX2NhY2hlZFRyZWVOb2RlID0gdm9pZCAwO1xuICAgICAgaWYgKHRoaXMucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQubm9kZS5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogUmV0dXJuIGFuIHNuYXBzaG90IG9mIHRoaXMgTGl2ZSB0cmVlIGZvciB1c2UgaW4gRGV2VG9vbHMuXG4gICAqL1xuICB0b1RyZWVOb2RlKGtleSkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRUcmVlTm9kZSA9PT0gdm9pZCAwIHx8IHRoaXMuX2NhY2hlZFRyZWVOb2RlS2V5ICE9PSBrZXkpIHtcbiAgICAgIHRoaXMuX2NhY2hlZFRyZWVOb2RlS2V5ID0ga2V5O1xuICAgICAgdGhpcy5fY2FjaGVkVHJlZU5vZGUgPSB0aGlzLl90b1RyZWVOb2RlKGtleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRUcmVlTm9kZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIGltbXV0YWJsZSBzbmFwc2hvdCBvZiB0aGlzIExpdmUgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLlxuICAgKi9cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZEltbXV0YWJsZSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9jYWNoZWRJbW11dGFibGUgPSB0aGlzLl90b0ltbXV0YWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkSW1tdXRhYmxlO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdG9jb2wvU2VyaWFsaXplZENyZHQudHNcbnZhciBDcmR0VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKENyZHRUeXBlMikgPT4ge1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiT0JKRUNUXCJdID0gMF0gPSBcIk9CSkVDVFwiO1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiTElTVFwiXSA9IDFdID0gXCJMSVNUXCI7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJNQVBcIl0gPSAyXSA9IFwiTUFQXCI7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJSRUdJU1RFUlwiXSA9IDNdID0gXCJSRUdJU1RFUlwiO1xuICByZXR1cm4gQ3JkdFR5cGUyO1xufSkoQ3JkdFR5cGUgfHwge30pO1xuZnVuY3Rpb24gaXNSb290Q3JkdChjcmR0KSB7XG4gIHJldHVybiBjcmR0LnR5cGUgPT09IDAgLyogT0JKRUNUICovICYmICFpc0NoaWxkQ3JkdChjcmR0KTtcbn1cbmZ1bmN0aW9uIGlzQ2hpbGRDcmR0KGNyZHQpIHtcbiAgcmV0dXJuIGNyZHQucGFyZW50SWQgIT09IHZvaWQgMCAmJiBjcmR0LnBhcmVudEtleSAhPT0gdm9pZCAwO1xufVxuXG4vLyBzcmMvbGliL25hbm9pZC50c1xuZnVuY3Rpb24gbmFub2lkKGxlbmd0aCA9IDcpIHtcbiAgY29uc3QgYWxwaGFiZXQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LC4vO1tdfiFAIyQlJiooKV8rPS1cIjtcbiAgY29uc3QgbGVuID0gYWxwaGFiZXQubGVuZ3RoO1xuICByZXR1cm4gQXJyYXkuZnJvbShcbiAgICB7IGxlbmd0aCB9LFxuICAgICgpID0+IGFscGhhYmV0LmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsZW4pKVxuICApLmpvaW4oXCJcIik7XG59XG5cbi8vIHNyYy9jcmR0cy9MaXZlUmVnaXN0ZXIudHNcbnZhciBMaXZlUmVnaXN0ZXIgPSBjbGFzcyBfTGl2ZVJlZ2lzdGVyIGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZCwgaXRlbV0sIF9wYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgcmVnaXN0ZXIgPSBuZXcgX0xpdmVSZWdpc3RlcihpdGVtLmRhdGEpO1xuICAgIHJlZ2lzdGVyLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIHJldHVybiByZWdpc3RlcjtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDYW5ub3Qgc2VyaWFsaXplIHJlZ2lzdGVyIGlmIHBhcmVudElkIG9yIHBhcmVudEtleSBpcyB1bmRlZmluZWRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogOCAvKiBDUkVBVEVfUkVHSVNURVIgKi8sXG4gICAgICAgIG9wSWQ6IHBvb2w/LmdlbmVyYXRlT3BJZCgpLFxuICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgIHBhcmVudElkLFxuICAgICAgICBwYXJlbnRLZXksXG4gICAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLnBhcmVudC50eXBlICE9PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIExpdmVSZWdpc3RlciBpZiBwYXJlbnQgaXMgbWlzc2luZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IDMgLyogUkVHSVNURVIgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5LFxuICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChfb3ApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2hDaGlsZChfY3JkdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5KG9wLCBpc0xvY2FsKSB7XG4gICAgcmV0dXJuIHN1cGVyLl9hcHBseShvcCwgaXNMb2NhbCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJKc29uXCIsXG4gICAgICBpZDogdGhpcy5faWQgPz8gbmFub2lkKCksXG4gICAgICBrZXksXG4gICAgICBwYXlsb2FkOiB0aGlzLl9kYXRhXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gZGVlcENsb25lKHRoaXMuZGF0YSk7XG4gIH1cbn07XG5cbi8vIHNyYy9jcmR0cy9MaXZlTGlzdC50c1xuZnVuY3Rpb24gY29tcGFyZU5vZGVQb3NpdGlvbihpdGVtQSwgaXRlbUIpIHtcbiAgY29uc3QgcG9zQSA9IGl0ZW1BLl9wYXJlbnRQb3M7XG4gIGNvbnN0IHBvc0IgPSBpdGVtQi5fcGFyZW50UG9zO1xuICByZXR1cm4gcG9zQSA9PT0gcG9zQiA/IDAgOiBwb3NBIDwgcG9zQiA/IC0xIDogMTtcbn1cbnZhciBMaXZlTGlzdCA9IGNsYXNzIF9MaXZlTGlzdCBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gIGNvbnN0cnVjdG9yKGl0ZW1zID0gW10pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IHBvc2l0aW9uID0gdm9pZCAwO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSBtYWtlUG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgY29uc3Qgbm9kZSA9IGxzb25Ub0xpdmVOb2RlKGl0ZW0pO1xuICAgICAgbm9kZS5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdQb3NpdGlvbik7XG4gICAgICB0aGlzLl9pdGVtcy5wdXNoKG5vZGUpO1xuICAgICAgcG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBsaXN0ID0gbmV3IF9MaXZlTGlzdCgpO1xuICAgIGxpc3QuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRUb0NoaWxkcmVuLmdldChpZCk7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZDIsIGNyZHRdIG9mIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGRlc2VyaWFsaXplKFtpZDIsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKGxpc3QsIGNyZHQucGFyZW50S2V5KTtcbiAgICAgIGxpc3QuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IHRoZSByZXN1bHRpbmcgb3BzIHdpbGwgYmUgc2VudCB0byB0aGUgc2VydmVyIGlmIHRoZXkgaGF2ZSBhbiAnb3BJZCdcbiAgICogc28gd2UgbXV0YXRlIF91bmFja25vd2xlZGdlZFNldHMgdG8gYXZvaWQgcG90ZW50aWFsIGZsaWNrZXJpbmdcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2xpdmVibG9ja3MvbGl2ZWJsb2Nrcy9wdWxsLzExNzdcbiAgICpcbiAgICogVGhpcyBpcyBxdWl0ZSB1bmludHVpdGl2ZSBhbmQgc2hvdWxkIGRpc2FwcGVhciBhcyBzb29uIGFzXG4gICAqIHdlIGludHJvZHVjZSBhbiBleHBsaWNpdCBMaXZlTGlzdC5TZXQgb3BlcmF0aW9uXG4gICAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIGl0ZW0gaXMgbm90IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBjb25zdCBvcCA9IHtcbiAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgIG9wSWQ6IHBvb2w/LmdlbmVyYXRlT3BJZCgpLFxuICAgICAgdHlwZTogMiAvKiBDUkVBVEVfTElTVCAqLyxcbiAgICAgIHBhcmVudElkLFxuICAgICAgcGFyZW50S2V5XG4gICAgfTtcbiAgICBvcHMucHVzaChvcCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICBjb25zdCBwYXJlbnRLZXkyID0gaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpO1xuICAgICAgY29uc3QgY2hpbGRPcHMgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICBpdGVtLl90b09wcyh0aGlzLl9pZCwgcGFyZW50S2V5MiwgcG9vbCksXG4gICAgICAgIHZvaWQgMFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGNoaWxkT3BJZCA9IGNoaWxkT3BzWzBdLm9wSWQ7XG4gICAgICBpZiAoY2hpbGRPcElkICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5fdW5hY2tub3dsZWRnZWRTZXRzLnNldChwYXJlbnRLZXkyLCBjaGlsZE9wSWQpO1xuICAgICAgfVxuICAgICAgb3BzLnB1c2goLi4uY2hpbGRPcHMpO1xuICAgIH1cbiAgICByZXR1cm4gb3BzO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogQWRkcyBhIG5ldyBpdGVtIGludG8gdGhlIHNvcnRlZCBsaXN0LCBpbiB0aGUgY29ycmVjdCBwb3NpdGlvbi5cbiAgICovXG4gIF9pbnNlcnRBbmRTb3J0KGl0ZW0pIHtcbiAgICB0aGlzLl9pdGVtcy5wdXNoKGl0ZW0pO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NvcnRJdGVtcygpIHtcbiAgICB0aGlzLl9pdGVtcy5zb3J0KGNvbXBhcmVOb2RlUG9zaXRpb24pO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2luZGV4T2ZQb3NpdGlvbihwb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5maW5kSW5kZXgoXG4gICAgICAoaXRlbSkgPT4gaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpID09PSBwb3NpdGlvblxuICAgICk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgc3VwZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICBpdGVtLl9hdHRhY2gocG9vbC5nZW5lcmF0ZUlkKCksIHBvb2wpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2goKSB7XG4gICAgc3VwZXIuX2RldGFjaCgpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xuICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0UmVtb3RlKG9wKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY29uc3QgZGVsZXRlZElkID0gb3AuZGVsZXRlZElkO1xuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGlmIChpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gIT09IC0xKSB7XG4gICAgICBjb25zdCBpdGVtV2l0aFNhbWVQb3NpdGlvbiA9IHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl07XG4gICAgICBpZiAoaXRlbVdpdGhTYW1lUG9zaXRpb24uX2lkID09PSBkZWxldGVkSWQpIHtcbiAgICAgICAgaXRlbVdpdGhTYW1lUG9zaXRpb24uX2RldGFjaCgpO1xuICAgICAgICB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb25dID0gY2hpbGQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgc2V0RGVsdGEoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCBjaGlsZClcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5hZGQoaXRlbVdpdGhTYW1lUG9zaXRpb24pO1xuICAgICAgICB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb25dID0gY2hpbGQ7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gW1xuICAgICAgICAgIHNldERlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiwgY2hpbGQpXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGRlbGV0ZURlbHRhMiA9IHRoaXMuX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oXG4gICAgICAgICAgb3AuZGVsZXRlZElkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChkZWxldGVEZWx0YTIpIHtcbiAgICAgICAgICBkZWx0YS5wdXNoKGRlbGV0ZURlbHRhMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdXBkYXRlcyA9IFtdO1xuICAgICAgY29uc3QgZGVsZXRlRGVsdGEyID0gdGhpcy5fZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihcbiAgICAgICAgb3AuZGVsZXRlZElkXG4gICAgICApO1xuICAgICAgaWYgKGRlbGV0ZURlbHRhMikge1xuICAgICAgICB1cGRhdGVzLnB1c2goZGVsZXRlRGVsdGEyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgICAgdXBkYXRlcy5wdXNoKGluc2VydERlbHRhKHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpLCBjaGlsZCkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmV2ZXJzZTogW10sXG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIHVwZGF0ZXMpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVNldEFjayhvcCkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlbHRhID0gW107XG4gICAgY29uc3QgZGVsZXRlZERlbHRhID0gdGhpcy5fZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihvcC5kZWxldGVkSWQpO1xuICAgIGlmIChkZWxldGVkRGVsdGEpIHtcbiAgICAgIGRlbHRhLnB1c2goZGVsZXRlZERlbHRhKTtcbiAgICB9XG4gICAgY29uc3QgdW5hY2tub3dsZWRnZWRPcElkID0gdGhpcy5fdW5hY2tub3dsZWRnZWRTZXRzLmdldChvcC5wYXJlbnRLZXkpO1xuICAgIGlmICh1bmFja25vd2xlZGdlZE9wSWQgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHVuYWNrbm93bGVkZ2VkT3BJZCAhPT0gb3Aub3BJZCkge1xuICAgICAgICByZXR1cm4gZGVsdGEubGVuZ3RoID09PSAwID8geyBtb2RpZmllZDogZmFsc2UgfSA6IHsgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpLCByZXZlcnNlOiBbXSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdW5hY2tub3dsZWRnZWRTZXRzLmRlbGV0ZShvcC5wYXJlbnRLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPSB0aGlzLl9pbmRleE9mUG9zaXRpb24ob3AucGFyZW50S2V5KTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtcy5maW5kKChpdGVtKSA9PiBpdGVtLl9pZCA9PT0gb3AuaWQpO1xuICAgIGlmIChleGlzdGluZ0l0ZW0gIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbS5fcGFyZW50S2V5ID09PSBvcC5wYXJlbnRLZXkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZGVsdGEubGVuZ3RoID4gMCA/IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpIDogZmFsc2UsXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuYWRkKFxuICAgICAgICAgIHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl1cbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5faXRlbXMuc3BsaWNlKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiwgMSk7XG4gICAgICAgIGRlbHRhLnB1c2goZGVsZXRlRGVsdGEoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihleGlzdGluZ0l0ZW0pO1xuICAgICAgZXhpc3RpbmdJdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG9wLnBhcmVudEtleSk7XG4gICAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihleGlzdGluZ0l0ZW0pO1xuICAgICAgaWYgKG5ld0luZGV4ICE9PSBwcmV2aW91c0luZGV4KSB7XG4gICAgICAgIGRlbHRhLnB1c2gobW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBleGlzdGluZ0l0ZW0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBkZWx0YS5sZW5ndGggPiAwID8gbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSkgOiBmYWxzZSxcbiAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9ycGhhbiA9IHRoaXMuX3Bvb2wuZ2V0Tm9kZShvcC5pZCk7XG4gICAgICBpZiAob3JwaGFuICYmIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKG9ycGhhbikpIHtcbiAgICAgICAgb3JwaGFuLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG9wLnBhcmVudEtleSk7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKG9ycGhhbik7XG4gICAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQob3JwaGFuKTtcbiAgICAgICAgY29uc3QgcmVjcmVhdGVkSXRlbUluZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihvcnBoYW4pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhpcyBwb3NpdGlvbiwgdXBkYXRlIGlzIGEgc2V0LCBlbHNlIGl0J3MgYW4gaW5zZXJ0XG4gICAgICAgICAgICBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPT09IC0xID8gaW5zZXJ0RGVsdGEocmVjcmVhdGVkSXRlbUluZGV4LCBvcnBoYW4pIDogc2V0RGVsdGEocmVjcmVhdGVkSXRlbUluZGV4LCBvcnBoYW4pLFxuICAgICAgICAgICAgLi4uZGVsdGFcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG5ld0l0ZW0sIG5ld0luZGV4IH0gPSB0aGlzLl9jcmVhdGVBdHRhY2hJdGVtQW5kU29ydChcbiAgICAgICAgICBvcCxcbiAgICAgICAgICBvcC5wYXJlbnRLZXlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBpdGVtIGF0IHRoaXMgcG9zaXRpb24sIHVwZGF0ZSBpcyBhIHNldCwgZWxzZSBpdCdzIGFuIGluc2VydFxuICAgICAgICAgICAgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID09PSAtMSA/IGluc2VydERlbHRhKG5ld0luZGV4LCBuZXdJdGVtKSA6IHNldERlbHRhKG5ld0luZGV4LCBuZXdJdGVtKSxcbiAgICAgICAgICAgIC4uLmRlbHRhXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVwZGF0ZSBkZWx0YSBvZiB0aGUgZGVsZXRpb24gb3IgbnVsbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKGRlbGV0ZWRJZCkge1xuICAgIGlmIChkZWxldGVkSWQgPT09IHZvaWQgMCB8fCB0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkZWxldGVkSXRlbSA9IHRoaXMuX3Bvb2wuZ2V0Tm9kZShkZWxldGVkSWQpO1xuICAgIGlmIChkZWxldGVkSXRlbSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGV0YWNoQ2hpbGQoZGVsZXRlZEl0ZW0pO1xuICAgIGlmIChyZXN1bHQubW9kaWZpZWQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5tb2RpZmllZC51cGRhdGVzWzBdO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5UmVtb3RlSW5zZXJ0KG9wKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gYXNQb3Mob3AucGFyZW50S2V5KTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX3NoaWZ0SXRlbVBvc2l0aW9uKGV4aXN0aW5nSXRlbUluZGV4LCBrZXkpO1xuICAgIH1cbiAgICBjb25zdCB7IG5ld0l0ZW0sIG5ld0luZGV4IH0gPSB0aGlzLl9jcmVhdGVBdHRhY2hJdGVtQW5kU29ydChvcCwga2V5KTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBuZXdJdGVtKV0pLFxuICAgICAgcmV2ZXJzZTogW11cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5SW5zZXJ0QWNrKG9wKSB7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtID0gdGhpcy5faXRlbXMuZmluZCgoaXRlbSkgPT4gaXRlbS5faWQgPT09IG9wLmlkKTtcbiAgICBjb25zdCBrZXkgPSBhc1BvcyhvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGl0ZW1JbmRleEF0UG9zaXRpb24gPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtKSB7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtLl9wYXJlbnRLZXkgPT09IGtleSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb2xkUG9zaXRpb25JbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoZXhpc3RpbmdJdGVtKTtcbiAgICAgICAgaWYgKGl0ZW1JbmRleEF0UG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5fc2hpZnRJdGVtUG9zaXRpb24oaXRlbUluZGV4QXRQb3NpdGlvbiwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBleGlzdGluZ0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgICAgIGlmIChuZXdJbmRleCA9PT0gb2xkUG9zaXRpb25JbmRleCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgbW92ZURlbHRhKG9sZFBvc2l0aW9uSW5kZXgsIG5ld0luZGV4LCBleGlzdGluZ0l0ZW0pXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JwaGFuID0gbm4odGhpcy5fcG9vbCkuZ2V0Tm9kZShvcC5pZCk7XG4gICAgICBpZiAob3JwaGFuICYmIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKG9ycGhhbikpIHtcbiAgICAgICAgb3JwaGFuLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKG9ycGhhbik7XG4gICAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQob3JwaGFuKTtcbiAgICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG9ycGhhbildKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGl0ZW1JbmRleEF0UG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5fc2hpZnRJdGVtUG9zaXRpb24oaXRlbUluZGV4QXRQb3NpdGlvbiwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG5ld0l0ZW0sIG5ld0luZGV4IH0gPSB0aGlzLl9jcmVhdGVBdHRhY2hJdGVtQW5kU29ydChvcCwga2V5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlJbnNlcnRVbmRvUmVkbyhvcCkge1xuICAgIGNvbnN0IHsgaWQsIHBhcmVudEtleToga2V5IH0gPSBvcDtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBpZiAodGhpcy5fcG9vbD8uZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNoaWxkLl9hdHRhY2goaWQsIG5uKHRoaXMuX3Bvb2wpKTtcbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgbGV0IG5ld0tleSA9IGtleTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICBjb25zdCBiZWZvcmUyID0gdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXhdPy5fcGFyZW50UG9zO1xuICAgICAgY29uc3QgYWZ0ZXIyID0gdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcztcbiAgICAgIG5ld0tleSA9IG1ha2VQb3NpdGlvbihiZWZvcmUyLCBhZnRlcjIpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICB9XG4gICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgIHJldmVyc2U6IFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVNldFVuZG9SZWRvKG9wKSB7XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGlmICh0aGlzLl9wb29sPy5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgdGhpcy5fdW5hY2tub3dsZWRnZWRTZXRzLnNldChrZXksIG5uKG9wLm9wSWQpKTtcbiAgICBjb25zdCBpbmRleE9mSXRlbVdpdGhTYW1lS2V5ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY29uc3QgbmV3S2V5ID0ga2V5O1xuICAgIGlmIChpbmRleE9mSXRlbVdpdGhTYW1lS2V5ICE9PSAtMSkge1xuICAgICAgY29uc3QgZXhpc3RpbmdJdGVtID0gdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZUtleV07XG4gICAgICBleGlzdGluZ0l0ZW0uX2RldGFjaCgpO1xuICAgICAgdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZUtleV0gPSBjaGlsZDtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICBleGlzdGluZ0l0ZW0uX3RvT3BzKG5uKHRoaXMuX2lkKSwga2V5LCB0aGlzLl9wb29sKSxcbiAgICAgICAgb3AuaWRcbiAgICAgICk7XG4gICAgICBjb25zdCBkZWx0YSA9IFtzZXREZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lS2V5LCBjaGlsZCldO1xuICAgICAgY29uc3QgZGVsZXRlZERlbHRhID0gdGhpcy5fZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihcbiAgICAgICAgb3AuZGVsZXRlZElkXG4gICAgICApO1xuICAgICAgaWYgKGRlbGV0ZWREZWx0YSkge1xuICAgICAgICBkZWx0YS5wdXNoKGRlbGV0ZWREZWx0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSksXG4gICAgICAgIHJldmVyc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgICAgdGhpcy5fZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihvcC5kZWxldGVkSWQpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJldmVyc2U6IFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dLFxuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAob3AuaW50ZW50ID09PSBcInNldFwiKSB7XG4gICAgICBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVNldFJlbW90ZShvcCk7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlTZXRBY2sob3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlTZXRVbmRvUmVkbyhvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5UmVtb3RlSW5zZXJ0KG9wKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseUluc2VydEFjayhvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseUluc2VydFVuZG9SZWRvKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3VsdC5tb2RpZmllZCAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMobm4odGhpcy5faWQpLCBwYXJlbnRLZXksIHRoaXMuX3Bvb2wpO1xuICAgICAgY29uc3QgaW5kZXhUb0RlbGV0ZSA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKGluZGV4VG9EZWxldGUgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXhUb0RlbGV0ZSwgMSk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIGNoaWxkLl9kZXRhY2goKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtkZWxldGVEZWx0YShpbmRleFRvRGVsZXRlKV0pLFxuICAgICAgICByZXZlcnNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVNldENoaWxkS2V5UmVtb3RlKG5ld0tleSwgY2hpbGQpIHtcbiAgICBpZiAodGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMoY2hpbGQpKSB7XG4gICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShjaGlsZCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHByZXZpb3VzS2V5ID0gY2hpbGQuX3BhcmVudEtleTtcbiAgICBpZiAobmV3S2V5ID09PSBwcmV2aW91c0tleSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCA9PT0gLTEpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAobmV3SW5kZXggPT09IHByZXZpb3VzSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFttb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXhdLl9zZXRQYXJlbnRMaW5rKFxuICAgICAgICB0aGlzLFxuICAgICAgICBtYWtlUG9zaXRpb24obmV3S2V5LCB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAobmV3SW5kZXggPT09IHByZXZpb3VzSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFttb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRDaGlsZEtleUFjayhuZXdLZXksIGNoaWxkKSB7XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBpZiAodGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMoY2hpbGQpKSB7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUoY2hpbGQpO1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBtYWtlUG9zaXRpb24obmV3S2V5LCB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV3S2V5ID09PSBwcmV2aW91c0tleSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXhdLl9zZXRQYXJlbnRMaW5rKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAocHJldmlvdXNJbmRleCA9PT0gbmV3SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZClcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVNldENoaWxkS2V5VW5kb1JlZG8obmV3S2V5LCBjaGlsZCkge1xuICAgIGNvbnN0IHByZXZpb3VzS2V5ID0gbm4oY2hpbGQuX3BhcmVudEtleSk7XG4gICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXhdLl9zZXRQYXJlbnRMaW5rKFxuICAgICAgICB0aGlzLFxuICAgICAgICBtYWtlUG9zaXRpb24obmV3S2V5LCB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zKVxuICAgICAgKTtcbiAgICB9XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgIGlmIChwcmV2aW91c0luZGV4ID09PSBuZXdJbmRleCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICByZXZlcnNlOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAxIC8qIFNFVF9QQVJFTlRfS0VZICovLFxuICAgICAgICAgIGlkOiBubihjaGlsZC5faWQpLFxuICAgICAgICAgIHBhcmVudEtleTogcHJldmlvdXNLZXlcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2V0Q2hpbGRLZXkobmV3S2V5LCBjaGlsZCwgc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseVNldENoaWxkS2V5UmVtb3RlKG5ld0tleSwgY2hpbGQpO1xuICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2V0Q2hpbGRLZXlBY2sobmV3S2V5LCBjaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseVNldENoaWxkS2V5VW5kb1JlZG8obmV3S2V5LCBjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5KG9wLCBpc0xvY2FsKSB7XG4gICAgcmV0dXJuIHN1cGVyLl9hcHBseShvcCwgaXNMb2NhbCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLnBhcmVudC50eXBlICE9PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIExpdmVMaXN0IGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMSAvKiBMSVNUICovLFxuICAgICAgcGFyZW50SWQ6IG5uKHRoaXMucGFyZW50Lm5vZGUuX2lkLCBcIlBhcmVudCBub2RlIGV4cGVjdGVkIHRvIGhhdmUgSURcIiksXG4gICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cy5cbiAgICovXG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvbmUgZWxlbWVudCB0byB0aGUgZW5kIG9mIHRoZSBMaXZlTGlzdC5cbiAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBlbmQgb2YgdGhlIExpdmVMaXN0LlxuICAgKi9cbiAgcHVzaChlbGVtZW50KSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoZWxlbWVudCwgdGhpcy5sZW5ndGgpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIG9uZSBlbGVtZW50IGF0IGEgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBpbnNlcnQuXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggeW91IHdhbnQgdG8gaW5zZXJ0IHRoZSBlbGVtZW50LlxuICAgKi9cbiAgaW5zZXJ0KGVsZW1lbnQsIGluZGV4KSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgaW5zZXJ0IGxpc3QgaXRlbSBhdCBpbmRleCBcIlx1MDAxZCR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy5faXRlbXMubGVuZ3RofWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGJlZm9yZTIgPSB0aGlzLl9pdGVtc1tpbmRleCAtIDFdID8gdGhpcy5faXRlbXNbaW5kZXggLSAxXS5fcGFyZW50UG9zIDogdm9pZCAwO1xuICAgIGNvbnN0IGFmdGVyMiA9IHRoaXMuX2l0ZW1zW2luZGV4XSA/IHRoaXMuX2l0ZW1zW2luZGV4XS5fcGFyZW50UG9zIDogdm9pZCAwO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gbWFrZVBvc2l0aW9uKGJlZm9yZTIsIGFmdGVyMik7XG4gICAgY29uc3QgdmFsdWUgPSBsc29uVG9MaXZlTm9kZShlbGVtZW50KTtcbiAgICB2YWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBwb3NpdGlvbik7XG4gICAgdGhpcy5faW5zZXJ0QW5kU29ydCh2YWx1ZSk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgdGhpcy5faWQpIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCk7XG4gICAgICB2YWx1ZS5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgIHZhbHVlLl90b09wcyh0aGlzLl9pZCwgcG9zaXRpb24sIHRoaXMuX3Bvb2wpLFxuICAgICAgICBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICAgIFt0aGlzLl9pZCwgbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEoaW5kZXgsIHZhbHVlKV0pXVxuICAgICAgICBdKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgb25lIGVsZW1lbnQgZnJvbSBvbmUgaW5kZXggdG8gYW5vdGhlci5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byBtb3ZlXG4gICAqIEBwYXJhbSB0YXJnZXRJbmRleCBUaGUgaW5kZXggd2hlcmUgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIGFmdGVyIG1vdmluZy5cbiAgICovXG4gIG1vdmUoaW5kZXgsIHRhcmdldEluZGV4KSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXRJbmRleCBjYW5ub3QgYmUgbGVzcyB0aGFuIDBcIik7XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJ0YXJnZXRJbmRleCBjYW5ub3QgYmUgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHRoZSBsaXN0IGxlbmd0aFwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBjYW5ub3QgYmUgbGVzcyB0aGFuIDBcIik7XG4gICAgfVxuICAgIGlmIChpbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4IGNhbm5vdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRoYW4gdGhlIGxpc3QgbGVuZ3RoXCIpO1xuICAgIH1cbiAgICBsZXQgYmVmb3JlUG9zaXRpb24gPSBudWxsO1xuICAgIGxldCBhZnRlclBvc2l0aW9uID0gbnVsbDtcbiAgICBpZiAoaW5kZXggPCB0YXJnZXRJbmRleCkge1xuICAgICAgYWZ0ZXJQb3NpdGlvbiA9IHRhcmdldEluZGV4ID09PSB0aGlzLl9pdGVtcy5sZW5ndGggLSAxID8gdm9pZCAwIDogdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXggKyAxXS5fcGFyZW50UG9zO1xuICAgICAgYmVmb3JlUG9zaXRpb24gPSB0aGlzLl9pdGVtc1t0YXJnZXRJbmRleF0uX3BhcmVudFBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJQb3NpdGlvbiA9IHRoaXMuX2l0ZW1zW3RhcmdldEluZGV4XS5fcGFyZW50UG9zO1xuICAgICAgYmVmb3JlUG9zaXRpb24gPSB0YXJnZXRJbmRleCA9PT0gMCA/IHZvaWQgMCA6IHRoaXMuX2l0ZW1zW3RhcmdldEluZGV4IC0gMV0uX3BhcmVudFBvcztcbiAgICB9XG4gICAgY29uc3QgcG9zaXRpb24gPSBtYWtlUG9zaXRpb24oYmVmb3JlUG9zaXRpb24sIGFmdGVyUG9zaXRpb24pO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleF07XG4gICAgY29uc3QgcHJldmlvdXNQb3NpdGlvbiA9IGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKTtcbiAgICBpdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHBvc2l0aW9uKTtcbiAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFt0aGlzLl9pZCwgbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKGluZGV4LCB0YXJnZXRJbmRleCwgaXRlbSldKV1cbiAgICAgIF0pO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgICBpZDogbm4oaXRlbS5faWQpLFxuICAgICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgICAgICAgIHBhcmVudEtleTogcG9zaXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAxIC8qIFNFVF9QQVJFTlRfS0VZICovLFxuICAgICAgICAgICAgaWQ6IG5uKGl0ZW0uX2lkKSxcbiAgICAgICAgICAgIHBhcmVudEtleTogcHJldmlvdXNQb3NpdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIGRlbGV0ZVxuICAgKi9cbiAgZGVsZXRlKGluZGV4KSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGRlbGV0ZSBsaXN0IGl0ZW0gYXQgaW5kZXggXCIke2luZGV4fVwiLiBpbmRleCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAke3RoaXMuX2l0ZW1zLmxlbmd0aCAtIDF9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4XTtcbiAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sKSB7XG4gICAgICBjb25zdCBjaGlsZFJlY29yZElkID0gaXRlbS5faWQ7XG4gICAgICBpZiAoY2hpbGRSZWNvcmRJZCkge1xuICAgICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICBubih0aGlzLl9pZCksXG4gICAgICAgICAgbWFrZVVwZGF0ZSh0aGlzLCBbZGVsZXRlRGVsdGEoaW5kZXgpXSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgICBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlkOiBjaGlsZFJlY29yZElkLFxuICAgICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpLFxuICAgICAgICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICBpdGVtLl90b09wcyhubih0aGlzLl9pZCksIGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKSksXG4gICAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCkge1xuICAgICAgY29uc3Qgb3BzID0gW107XG4gICAgICBjb25zdCByZXZlcnNlT3BzID0gW107XG4gICAgICBjb25zdCB1cGRhdGVEZWx0YSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgICAgICBjb25zdCBjaGlsZElkID0gaXRlbS5faWQ7XG4gICAgICAgIGlmIChjaGlsZElkKSB7XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICAgICAgICAgIGlkOiBjaGlsZElkLFxuICAgICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldmVyc2VPcHMucHVzaChcbiAgICAgICAgICAgIC4uLml0ZW0uX3RvT3BzKG5uKHRoaXMuX2lkKSwgaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgdXBkYXRlRGVsdGEucHVzaChkZWxldGVEZWx0YSgwKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldChubih0aGlzLl9pZCksIG1ha2VVcGRhdGUodGhpcywgdXBkYXRlRGVsdGEpKTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2gob3BzLCByZXZlcnNlT3BzLCBzdG9yYWdlVXBkYXRlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xuICAgICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gIH1cbiAgc2V0KGluZGV4LCBpdGVtKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHNldCBsaXN0IGl0ZW0gYXQgaW5kZXggXCJcdTAwMWQke2luZGV4fVwiLiBpbmRleCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAke3RoaXMuX2l0ZW1zLmxlbmd0aCAtIDF9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtID0gdGhpcy5faXRlbXNbaW5kZXhdO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gZXhpc3RpbmdJdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCk7XG4gICAgY29uc3QgZXhpc3RpbmdJZCA9IGV4aXN0aW5nSXRlbS5faWQ7XG4gICAgZXhpc3RpbmdJdGVtLl9kZXRhY2goKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxzb25Ub0xpdmVOb2RlKGl0ZW0pO1xuICAgIHZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHBvc2l0aW9uKTtcbiAgICB0aGlzLl9pdGVtc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIHZhbHVlLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFtzZXREZWx0YShpbmRleCwgdmFsdWUpXSkpO1xuICAgICAgY29uc3Qgb3BzID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgdmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBwb3NpdGlvbiwgdGhpcy5fcG9vbCksXG4gICAgICAgIGV4aXN0aW5nSWRcbiAgICAgICk7XG4gICAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuc2V0KHBvc2l0aW9uLCBubihvcHNbMF0ub3BJZCkpO1xuICAgICAgY29uc3QgcmV2ZXJzZU9wcyA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGV4aXN0aW5nSXRlbS5fdG9PcHModGhpcy5faWQsIHBvc2l0aW9uLCB2b2lkIDApLFxuICAgICAgICBpZFxuICAgICAgKTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2gob3BzLCByZXZlcnNlT3BzLCBzdG9yYWdlVXBkYXRlcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIEFycmF5IG9mIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIExpdmVMaXN0LlxuICAgKi9cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMubWFwKFxuICAgICAgKGVudHJ5KSA9PiBsaXZlTm9kZVRvTHNvbihlbnRyeSlcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXl5eXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGSVhNRSEgVGhpcyBpc24ndCBzYWZlLlxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRlc3RzIHdoZXRoZXIgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIHRlc3QgZm9yIGVhY2ggZWxlbWVudCwgdGFraW5nIHR3byBhcmd1bWVudHMgKHRoZSBlbGVtZW50IGFuZCBpdHMgaW5kZXgpLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZSBmb3IgZXZlcnkgZWxlbWVudC4gT3RoZXJ3aXNlLCBmYWxzZS5cbiAgICovXG4gIGV2ZXJ5KHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5ldmVyeShwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGVsZW1lbnRzIHRoYXQgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gdGVzdCBlYWNoIGVsZW1lbnQgb2YgdGhlIExpdmVMaXN0LiBSZXR1cm4gYSB2YWx1ZSB0aGF0IGNvZXJjZXMgdG8gdHJ1ZSB0byBrZWVwIHRoZSBlbGVtZW50LCBvciB0byBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyB0aGUgdGVzdC5cbiAgICovXG4gIGZpbHRlcihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmlsdGVyKHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHZhbHVlLlxuICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLiBPdGhlcndpc2UsIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cbiAgICovXG4gIGZpbmQocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZpbmQocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB2YWx1ZSB1bnRpbCB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlLCBpbmRpY2F0aW5nIHRoYXQgdGhlIHNhdGlzZnlpbmcgZWxlbWVudCB3YXMgZm91bmQuXG4gICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBwYXNzZXMgdGhlIHRlc3QuIE90aGVyd2lzZSwgLTEuXG4gICAqL1xuICBmaW5kSW5kZXgocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZpbmRJbmRleChwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgZm9yIGVhY2ggZWxlbWVudC5cbiAgICogQHBhcmFtIGNhbGxiYWNrZm4gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrZm4pIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZm9yRWFjaChjYWxsYmFja2ZuKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb24gdGhlIGVsZW1lbnQgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyBUaGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IG9yIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldChpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gbGl2ZU5vZGVUb0xzb24odGhpcy5faXRlbXNbaW5kZXhdKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50IGNhbiBiZSBmb3VuZCBpbiB0aGUgTGl2ZUxpc3QsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICAgKiBAcGFyYW0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGxvY2F0ZS5cbiAgICogQHBhcmFtIGZyb21JbmRleCBUaGUgaW5kZXggdG8gc3RhcnQgdGhlIHNlYXJjaCBhdC5cbiAgICogQHJldHVybnMgVGhlIGZpcnN0IGluZGV4IG9mIHRoZSBlbGVtZW50IGluIHRoZSBMaXZlTGlzdDsgLTEgaWYgbm90IGZvdW5kLlxuICAgKi9cbiAgaW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuaW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYXN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIExpdmVMaXN0LCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC4gVGhlIExpdmVMc2l0IGlzIHNlYXJjaGVkIGJhY2t3YXJkcywgc3RhcnRpbmcgYXQgZnJvbUluZGV4LlxuICAgKiBAcGFyYW0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGxvY2F0ZS5cbiAgICogQHBhcmFtIGZyb21JbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nIGJhY2t3YXJkcy5cbiAgICogQHJldHVybnNcbiAgICovXG4gIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5sYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IHBvcHVsYXRlZCB3aXRoIHRoZSByZXN1bHRzIG9mIGNhbGxpbmcgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBldmVyeSBlbGVtZW50LlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgZm9yIGV2ZXJ5IGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggZWFjaCBlbGVtZW50IGJlaW5nIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKi9cbiAgbWFwKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLm1hcChcbiAgICAgIChlbnRyeSwgaSkgPT4gY2FsbGJhY2soXG4gICAgICAgIGxpdmVOb2RlVG9Mc29uKGVudHJ5KSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIF5eXl5eXl5eXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBGSVhNRSEgVGhpcyBpc24ndCBzYWZlLlxuICAgICAgICBpXG4gICAgICApXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVGVzdHMgd2hldGhlciBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgcGFzc2VzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byB0ZXN0IGZvciBlYWNoIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgZm9yIGF0IGxlYXN0IG9uZSBlbGVtZW50LiBPdGhlcndpc2UsIGZhbHNlLlxuICAgKi9cbiAgc29tZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuc29tZShwcmVkaWNhdGUpO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBuZXcgTGl2ZUxpc3RJdGVyYXRvcih0aGlzLl9pdGVtcyk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY3JlYXRlQXR0YWNoSXRlbUFuZFNvcnQob3AsIGtleSkge1xuICAgIGNvbnN0IG5ld0l0ZW0gPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgbmV3SXRlbS5fYXR0YWNoKG9wLmlkLCBubih0aGlzLl9wb29sKSk7XG4gICAgbmV3SXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIHRoaXMuX2luc2VydEFuZFNvcnQobmV3SXRlbSk7XG4gICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICByZXR1cm4geyBuZXdJdGVtLCBuZXdJbmRleCB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NoaWZ0SXRlbVBvc2l0aW9uKGluZGV4LCBrZXkpIHtcbiAgICBjb25zdCBzaGlmdGVkUG9zaXRpb24gPSBtYWtlUG9zaXRpb24oXG4gICAgICBrZXksXG4gICAgICB0aGlzLl9pdGVtcy5sZW5ndGggPiBpbmRleCArIDEgPyB0aGlzLl9pdGVtc1tpbmRleCArIDFdPy5fcGFyZW50UG9zIDogdm9pZCAwXG4gICAgKTtcbiAgICB0aGlzLl9pdGVtc1tpbmRleF0uX3NldFBhcmVudExpbmsodGhpcywgc2hpZnRlZFBvc2l0aW9uKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkxpdmVMaXN0XCIsXG4gICAgICBpZDogdGhpcy5faWQgPz8gbmFub2lkKCksXG4gICAgICBrZXksXG4gICAgICBwYXlsb2FkOiB0aGlzLl9pdGVtcy5tYXAoXG4gICAgICAgIChpdGVtLCBpbmRleCkgPT4gaXRlbS50b1RyZWVOb2RlKGluZGV4LnRvU3RyaW5nKCkpXG4gICAgICApXG4gICAgfTtcbiAgfVxuICB0b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gc3VwZXIudG9JbW11dGFibGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9pdGVtcy5tYXAoKG5vZGUpID0+IG5vZGUudG9JbW11dGFibGUoKSk7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IHJlc3VsdCA6IE9iamVjdC5mcmVlemUocmVzdWx0KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlTGlzdCh0aGlzLl9pdGVtcy5tYXAoKGl0ZW0pID0+IGl0ZW0uY2xvbmUoKSkpO1xuICB9XG59O1xudmFyIExpdmVMaXN0SXRlcmF0b3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGl0ZW1zKSB7XG4gICAgdGhpcy5faW5uZXJJdGVyYXRvciA9IGl0ZW1zW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBuZXh0KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2lubmVySXRlcmF0b3IubmV4dCgpO1xuICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBsaXZlTm9kZVRvTHNvbihyZXN1bHQudmFsdWUpO1xuICAgIHJldHVybiB7IHZhbHVlIH07XG4gIH1cbn07XG5mdW5jdGlvbiBtYWtlVXBkYXRlKGxpdmVMaXN0LCBkZWx0YVVwZGF0ZXMpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiBsaXZlTGlzdCxcbiAgICB0eXBlOiBcIkxpdmVMaXN0XCIsXG4gICAgdXBkYXRlczogZGVsdGFVcGRhdGVzXG4gIH07XG59XG5mdW5jdGlvbiBzZXREZWx0YShpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwic2V0XCIsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZURlbHRhKGluZGV4KSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXgsXG4gICAgdHlwZTogXCJkZWxldGVcIlxuICB9O1xufVxuZnVuY3Rpb24gaW5zZXJ0RGVsdGEoaW5kZXgsIGl0ZW0pIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleCxcbiAgICB0eXBlOiBcImluc2VydFwiLFxuICAgIGl0ZW06IGl0ZW0gaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIgPyBpdGVtLmRhdGEgOiBpdGVtXG4gIH07XG59XG5mdW5jdGlvbiBtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgaW5kZXgsIGl0ZW0pIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleCxcbiAgICB0eXBlOiBcIm1vdmVcIixcbiAgICBwcmV2aW91c0luZGV4LFxuICAgIGl0ZW06IGl0ZW0gaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIgPyBpdGVtLmRhdGEgOiBpdGVtXG4gIH07XG59XG5mdW5jdGlvbiBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKG9wcywgZGVsZXRlZElkKSB7XG4gIHJldHVybiBvcHMubWFwKChvcCwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIGNvbnN0IGZpcnN0T3AgPSBvcDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmZpcnN0T3AsXG4gICAgICAgIGludGVudDogXCJzZXRcIixcbiAgICAgICAgZGVsZXRlZElkXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3A7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2xpYi9mcmVlemUudHNcbnZhciBmcmVlemUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyAoXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICh4KSA9PiB4XG4pIDogT2JqZWN0LmZyZWV6ZTtcblxuLy8gc3JjL2NyZHRzL0xpdmVNYXAudHNcbnZhciBMaXZlTWFwID0gY2xhc3MgX0xpdmVNYXAgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICBjb25zdHJ1Y3RvcihlbnRyaWVzMikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy51bmFja25vd2xlZGdlZFNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKGVudHJpZXMyKSB7XG4gICAgICBjb25zdCBtYXBwZWRFbnRyaWVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzMikge1xuICAgICAgICBjb25zdCBub2RlID0gbHNvblRvTGl2ZU5vZGUodmFsdWUpO1xuICAgICAgICBub2RlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIG1hcHBlZEVudHJpZXMucHVzaChba2V5LCBub2RlXSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKG1hcHBlZEVudHJpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9tYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIGl0ZW0gaXMgbm90IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBjb25zdCBvcCA9IHtcbiAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgIG9wSWQ6IHBvb2w/LmdlbmVyYXRlT3BJZCgpLFxuICAgICAgdHlwZTogNyAvKiBDUkVBVEVfTUFQICovLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXlcbiAgICB9O1xuICAgIG9wcy5wdXNoKG9wKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIG9wcy5wdXNoKC4uLnZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCBwb29sKSk7XG4gICAgfVxuICAgIHJldHVybiBvcHM7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZShbaWQsIF9pdGVtXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBfTGl2ZU1hcCgpO1xuICAgIG1hcC5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGlkKTtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWQyLCBjcmR0XSBvZiBjaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGQgPSBkZXNlcmlhbGl6ZShbaWQyLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhtYXAsIGNyZHQucGFyZW50S2V5KTtcbiAgICAgIG1hcC5fbWFwLnNldChjcmR0LnBhcmVudEtleSwgY2hpbGQpO1xuICAgICAgbWFwLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgc3VwZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgZm9yIChjb25zdCBbX2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9hdHRhY2gocG9vbC5nZW5lcmF0ZUlkKCksIHBvb2wpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfYXR0YWNoQ2hpbGQob3AsIHNvdXJjZSkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIHBhcmVudEtleSwgb3BJZCB9ID0gb3A7XG4gICAgY29uc3Qga2V5ID0gcGFyZW50S2V5O1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGlmICh0aGlzLl9wb29sLmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgY29uc3QgbGFzdFVwZGF0ZU9wSWQgPSB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LmdldChrZXkpO1xuICAgICAgaWYgKGxhc3RVcGRhdGVPcElkID09PSBvcElkKSB7XG4gICAgICAgIHRoaXMudW5hY2tub3dsZWRnZWRTZXQuZGVsZXRlKGtleSk7XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfSBlbHNlIGlmIChsYXN0VXBkYXRlT3BJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgdGhpcy51bmFja25vd2xlZGdlZFNldC5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBsZXQgcmV2ZXJzZTtcbiAgICBpZiAocHJldmlvdXNWYWx1ZSkge1xuICAgICAgY29uc3QgdGhpc0lkID0gbm4odGhpcy5faWQpO1xuICAgICAgcmV2ZXJzZSA9IHByZXZpb3VzVmFsdWUuX3RvT3BzKHRoaXNJZCwga2V5KTtcbiAgICAgIHByZXZpb3VzVmFsdWUuX2RldGFjaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXZlcnNlID0gW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV07XG4gICAgfVxuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgdGhpcy5fbWFwLnNldChrZXksIGNoaWxkKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJ1cGRhdGVcIiB9IH1cbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZGV0YWNoKCkge1xuICAgIHN1cGVyLl9kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5fbWFwLnZhbHVlcygpKSB7XG4gICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2RldGFjaENoaWxkKGNoaWxkKSB7XG4gICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgY29uc3QgcGFyZW50S2V5ID0gbm4oY2hpbGQuX3BhcmVudEtleSk7XG4gICAgY29uc3QgcmV2ZXJzZSA9IGNoaWxkLl90b09wcyhpZCwgcGFyZW50S2V5LCB0aGlzLl9wb29sKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gY2hpbGQpIHtcbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2hpbGQuX2RldGFjaCgpO1xuICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGUgPSB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICB1cGRhdGVzOiB7IFtwYXJlbnRLZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgfTtcbiAgICByZXR1cm4geyBtb2RpZmllZDogc3RvcmFnZVVwZGF0ZSwgcmV2ZXJzZSB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZU1hcCBpZiBwYXJlbnQgaXMgbWlzc2luZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IDIgLyogTUFQICovLFxuICAgICAgcGFyZW50SWQ6IG5uKHRoaXMucGFyZW50Lm5vZGUuX2lkLCBcIlBhcmVudCBub2RlIGV4cGVjdGVkIHRvIGhhdmUgSURcIiksXG4gICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgZWxlbWVudCBmcm9tIHRoZSBMaXZlTWFwLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgKiBAcmV0dXJucyBUaGUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBrZXksIG9yIHVuZGVmaW5lZCBpZiB0aGUga2V5IGNhbid0IGJlIGZvdW5kIGluIHRoZSBMaXZlTWFwLlxuICAgKi9cbiAgZ2V0KGtleSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gbGl2ZU5vZGVUb0xzb24odmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYW4gZWxlbWVudCB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgYSB2YWx1ZS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIGFkZC4gU2hvdWxkIGJlIGEgc3RyaW5nLlxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IHRvIGFkZC4gU2hvdWxkIGJlIHNlcmlhbGl6YWJsZSB0byBKU09OLlxuICAgKi9cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gbHNvblRvTGl2ZU5vZGUodmFsdWUpO1xuICAgIGl0ZW0uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICB0aGlzLl9tYXAuc2V0KGtleSwgaXRlbSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgdGhpcy5faWQpIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCk7XG4gICAgICBpdGVtLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwidXBkYXRlXCIgfSB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG9wcyA9IGl0ZW0uX3RvT3BzKHRoaXMuX2lkLCBrZXksIHRoaXMuX3Bvb2wpO1xuICAgICAgdGhpcy51bmFja25vd2xlZGdlZFNldC5zZXQoa2V5LCBubihvcHNbMF0ub3BJZCkpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgaXRlbS5fdG9PcHModGhpcy5faWQsIGtleSwgdGhpcy5fcG9vbCksXG4gICAgICAgIG9sZFZhbHVlID8gb2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXkpIDogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBMaXZlTWFwLlxuICAgKi9cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5zaXplO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IGV4aXN0cyBvciBub3QuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byB0ZXN0IGZvciBwcmVzZW5jZS5cbiAgICovXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyhrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBieSBrZXkuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgYW4gZWxlbWVudCBleGlzdGVkIGFuZCBoYXMgYmVlbiByZW1vdmVkLCBvciBmYWxzZSBpZiB0aGUgZWxlbWVudCBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgaWYgKGl0ZW0gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgaXRlbS5faWQpIHtcbiAgICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzSWQsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgICAgICAgICBpZDogaXRlbS5faWQsXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBpdGVtLl90b09wcyh0aGlzSWQsIGtleSksXG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgW2tleSwgdmFsdWVdIHBhaXJzIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICBlbnRyaWVzKCkge1xuICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0aGlzLl9tYXAuZW50cmllcygpO1xuICAgIHJldHVybiB7XG4gICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3JWYWx1ZSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoaXRlcmF0b3JWYWx1ZS5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnRyeSA9IGl0ZXJhdG9yVmFsdWUudmFsdWU7XG4gICAgICAgIGNvbnN0IGtleSA9IGVudHJ5WzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGxpdmVOb2RlVG9Mc29uKGl0ZXJhdG9yVmFsdWUudmFsdWVbMV0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBba2V5LCB2YWx1ZV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTYW1lIGZ1bmN0aW9uIG9iamVjdCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgZW50cmllcyBtZXRob2QuXG4gICAqL1xuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGtleXMgZm9yIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5rZXlzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHZhbHVlcyBmb3IgZWFjaCBlbGVtZW50LlxuICAgKi9cbiAgdmFsdWVzKCkge1xuICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0aGlzLl9tYXAudmFsdWVzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvclZhbHVlID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVyYXRvclZhbHVlLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24oaXRlcmF0b3JWYWx1ZS52YWx1ZSk7XG4gICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIHBlciBlYWNoIGtleS92YWx1ZSBwYWlyIGluIHRoZSBNYXAgb2JqZWN0LCBpbiBpbnNlcnRpb24gb3JkZXIuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVudHJ5IGluIHRoZSBtYXAuXG4gICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzKSB7XG4gICAgICBjYWxsYmFjayhlbnRyeVsxXSwgZW50cnlbMF0sIHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IEFycmF5LmZyb20odGhpcy5fbWFwLmVudHJpZXMoKSkubWFwKFxuICAgICAgICAoW2tleTIsIHZhbF0pID0+IHZhbC50b1RyZWVOb2RlKGtleTIpXG4gICAgICApXG4gICAgfTtcbiAgfVxuICB0b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gc3VwZXIudG9JbW11dGFibGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlLnRvSW1tdXRhYmxlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZU1hcChcbiAgICAgIEFycmF5LmZyb20odGhpcy5fbWFwKS5tYXAoKFtrZXksIG5vZGVdKSA9PiBba2V5LCBub2RlLmNsb25lKCldKVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jcmR0cy9MaXZlT2JqZWN0LnRzXG52YXIgTGl2ZU9iamVjdCA9IGNsYXNzIF9MaXZlT2JqZWN0IGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgY29uc3RydWN0b3Iob2JqID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKG9iaikpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9idWlsZFJvb3RBbmRQYXJlbnRUb0NoaWxkcmVuKGl0ZW1zKSB7XG4gICAgY29uc3QgcGFyZW50VG9DaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IHJvb3QgPSBudWxsO1xuICAgIGZvciAoY29uc3QgW2lkLCBjcmR0XSBvZiBpdGVtcykge1xuICAgICAgaWYgKGlzUm9vdENyZHQoY3JkdCkpIHtcbiAgICAgICAgcm9vdCA9IFtpZCwgY3JkdF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0dXBsZSA9IFtpZCwgY3JkdF07XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQoY3JkdC5wYXJlbnRJZCk7XG4gICAgICAgIGlmIChjaGlsZHJlbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh0dXBsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyZW50VG9DaGlsZHJlbi5zZXQoY3JkdC5wYXJlbnRJZCwgW3R1cGxlXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJvb3QgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb3QgY2FuJ3QgYmUgbnVsbFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFtyb290LCBwYXJlbnRUb0NoaWxkcmVuXTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZnJvbUl0ZW1zKGl0ZW1zLCBwb29sKSB7XG4gICAgY29uc3QgW3Jvb3QsIHBhcmVudFRvQ2hpbGRyZW5dID0gX0xpdmVPYmplY3QuX2J1aWxkUm9vdEFuZFBhcmVudFRvQ2hpbGRyZW4oaXRlbXMpO1xuICAgIHJldHVybiBfTGl2ZU9iamVjdC5fZGVzZXJpYWxpemUoXG4gICAgICByb290LFxuICAgICAgcGFyZW50VG9DaGlsZHJlbixcbiAgICAgIHBvb2xcbiAgICApO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBpdGVtIGlzIG5vdCBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgb3BJZCA9IHBvb2w/LmdlbmVyYXRlT3BJZCgpO1xuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgdHlwZTogNCAvKiBDUkVBVEVfT0JKRUNUICovLFxuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZCxcbiAgICAgIHBhcmVudElkLFxuICAgICAgcGFyZW50S2V5LFxuICAgICAgZGF0YToge31cbiAgICB9O1xuICAgIG9wcy5wdXNoKG9wKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICBvcHMucHVzaCguLi52YWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSwgcG9vbCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3AuZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHM7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZCwgaXRlbV0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBsaXZlT2JqID0gbmV3IF9MaXZlT2JqZWN0KGl0ZW0uZGF0YSk7XG4gICAgbGl2ZU9iai5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVDaGlsZHJlbihsaXZlT2JqLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemVDaGlsZHJlbihsaXZlT2JqLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRUb0NoaWxkcmVuLmdldChubihsaXZlT2JqLl9pZCkpO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGl2ZU9iajtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWQsIGNyZHRdIG9mIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGRlc2VyaWFsaXplVG9Mc29uKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgICAgaWYgKGlzTGl2ZVN0cnVjdHVyZShjaGlsZCkpIHtcbiAgICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsobGl2ZU9iaiwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgfVxuICAgICAgbGl2ZU9iai5fbWFwLnNldChjcmR0LnBhcmVudEtleSwgY2hpbGQpO1xuICAgICAgbGl2ZU9iai5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBsaXZlT2JqO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIHN1cGVyLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGZvciAoY29uc3QgW19rZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5fYXR0YWNoKHBvb2wuZ2VuZXJhdGVJZCgpLCBwb29sKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoQ2hpbGQob3AsIHNvdXJjZSkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIG9wSWQsIHBhcmVudEtleToga2V5IH0gPSBvcDtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xzb24ob3ApO1xuICAgIGlmICh0aGlzLl9wb29sLmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSBvcElkKSB7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZSA9PT0gMCAvKiBVTkRPUkVET19SRUNPTk5FQ1QgKi8pIHtcbiAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgbm4ob3BJZCkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gdm9pZCAwKSB7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSBvcElkKSB7XG4gICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmRlbGV0ZShrZXkpO1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBjb25zdCB0aGlzSWQgPSBubih0aGlzLl9pZCk7XG4gICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBsZXQgcmV2ZXJzZTtcbiAgICBpZiAoaXNMaXZlTm9kZShwcmV2aW91c1ZhbHVlKSkge1xuICAgICAgcmV2ZXJzZSA9IHByZXZpb3VzVmFsdWUuX3RvT3BzKHRoaXNJZCwga2V5KTtcbiAgICAgIHByZXZpb3VzVmFsdWUuX2RldGFjaCgpO1xuICAgIH0gZWxzZSBpZiAocHJldmlvdXNWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXZlcnNlID0gW3sgdHlwZTogNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLywgaWQ6IHRoaXNJZCwga2V5IH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXZlcnNlID0gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICAgIGlkOiB0aGlzSWQsXG4gICAgICAgICAgZGF0YTogeyBba2V5XTogcHJldmlvdXNWYWx1ZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMuX21hcC5zZXQoa2V5LCBjaGlsZCk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKGlzTGl2ZVN0cnVjdHVyZShjaGlsZCkpIHtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICBjaGlsZC5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJldmVyc2UsXG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcInVwZGF0ZVwiIH0gfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgICAgY29uc3QgcGFyZW50S2V5ID0gbm4oY2hpbGQuX3BhcmVudEtleSk7XG4gICAgICBjb25zdCByZXZlcnNlID0gY2hpbGQuX3RvT3BzKGlkLCBwYXJlbnRLZXksIHRoaXMuX3Bvb2wpO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gY2hpbGQpIHtcbiAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoaWxkLl9kZXRhY2goKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGUgPSB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgICB1cGRhdGVzOiB7XG4gICAgICAgICAgW3BhcmVudEtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogc3RvcmFnZVVwZGF0ZSwgcmV2ZXJzZSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZGV0YWNoKCkge1xuICAgIHN1cGVyLl9kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuX21hcC52YWx1ZXMoKSkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICBpZiAob3AudHlwZSA9PT0gMyAvKiBVUERBVEVfT0JKRUNUICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlVcGRhdGUob3AsIGlzTG9jYWwpO1xuICAgIH0gZWxzZSBpZiAob3AudHlwZSA9PT0gNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5RGVsZXRlT2JqZWN0S2V5KG9wLCBpc0xvY2FsKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLl9hcHBseShvcCwgaXNMb2NhbCk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBpZiAoIWlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIiAmJiB0aGlzLnBhcmVudC5ub2RlLl9pZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMCAvKiBPQkpFQ1QgKi8sXG4gICAgICAgIHBhcmVudElkOiB0aGlzLnBhcmVudC5ub2RlLl9pZCxcbiAgICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXksXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDAgLyogT0JKRUNUICovLFxuICAgICAgICBkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVVwZGF0ZShvcCwgaXNMb2NhbCkge1xuICAgIGxldCBpc01vZGlmaWVkID0gZmFsc2U7XG4gICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgY29uc3QgcmV2ZXJzZSA9IFtdO1xuICAgIGNvbnN0IHJldmVyc2VVcGRhdGUgPSB7XG4gICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICBpZCxcbiAgICAgIGRhdGE6IHt9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICByZXZlcnNlLnB1c2goLi4ub2xkVmFsdWUuX3RvT3BzKGlkLCBrZXkpKTtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2VVcGRhdGUuZGF0YVtrZXldID0gb2xkVmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV2ZXJzZS5wdXNoKHsgdHlwZTogNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLywgaWQsIGtleSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXBkYXRlRGVsdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9wLmRhdGFba2V5XTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzTG9jYWwpIHtcbiAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihvcC5vcElkKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IHZvaWQgMCkge1xuICAgICAgICBpc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gb3Aub3BJZCkge1xuICAgICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmRlbGV0ZShrZXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICB1cGRhdGVEZWx0YVtrZXldID0geyB0eXBlOiBcInVwZGF0ZVwiIH07XG4gICAgICB0aGlzLl9tYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhyZXZlcnNlVXBkYXRlLmRhdGEpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV2ZXJzZS51bnNoaWZ0KHJldmVyc2VVcGRhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gaXNNb2RpZmllZCA/IHtcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgICB1cGRhdGVzOiB1cGRhdGVEZWx0YVxuICAgICAgfSxcbiAgICAgIHJldmVyc2VcbiAgICB9IDogeyBtb2RpZmllZDogZmFsc2UgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseURlbGV0ZU9iamVjdEtleShvcCwgaXNMb2NhbCkge1xuICAgIGNvbnN0IGtleSA9IG9wLmtleTtcbiAgICBpZiAodGhpcy5fbWFwLmhhcyhrZXkpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGlmICghaXNMb2NhbCAmJiB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBsZXQgcmV2ZXJzZSA9IFtdO1xuICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgcmV2ZXJzZSA9IG9sZFZhbHVlLl90b09wcyhpZCwgb3Aua2V5KTtcbiAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICB9IGVsc2UgaWYgKG9sZFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgZGF0YTogeyBba2V5XTogb2xkVmFsdWUgfVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtvcC5rZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgICB9LFxuICAgICAgcmV2ZXJzZVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0aGUgTGl2ZU9iamVjdCBpbnRvIGEgamF2YXNjcmlwdCBvYmplY3RcbiAgICovXG4gIHRvT2JqZWN0KCkge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXModGhpcy5fbWFwKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIGEgcHJvcGVydHkgd2l0aCBhIHNwZWNpZmllZCBrZXkgYW5kIGEgdmFsdWUuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYWRkXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHRvIGFkZFxuICAgKi9cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIHRoaXMudXBkYXRlKHsgW2tleV06IHZhbHVlIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIHByb3BlcnR5IGZyb20gdGhlIExpdmVPYmplY3QuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0XG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhIGtleSBmcm9tIHRoZSBMaXZlT2JqZWN0XG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUoa2V5KSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBjb25zdCBrZXlBc1N0cmluZyA9IGtleTtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5QXNTdHJpbmcpO1xuICAgIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDAgfHwgdGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5QXNTdHJpbmcpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgcmV2ZXJzZSA9IG9sZFZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5QXNTdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXZlcnNlID0gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICAgIGRhdGE6IHsgW2tleUFzU3RyaW5nXTogb2xkVmFsdWUgfSxcbiAgICAgICAgICBpZDogdGhpcy5faWRcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy5fbWFwLmRlbGV0ZShrZXlBc1N0cmluZyk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzLl9pZCwge1xuICAgICAgbm9kZTogdGhpcyxcbiAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH0gfVxuICAgIH0pO1xuICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLFxuICAgICAgICAgIGtleToga2V5QXNTdHJpbmcsXG4gICAgICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKClcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHJldmVyc2UsXG4gICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2Ugd2l0aCBhbiBvYmplY3QuXG4gICAqIEBwYXJhbSBwYXRjaCBUaGUgb2JqZWN0IHVzZWQgdG8gb3ZlcnJpZGVzIHByb3BlcnRpZXNcbiAgICovXG4gIHVwZGF0ZShwYXRjaCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCB8fCB0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXRjaCkge1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHBhdGNoW2tleV07XG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMaXZlTm9kZShuZXdWYWx1ZSkpIHtcbiAgICAgICAgICBuZXdWYWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBjb25zdCByZXZlcnNlT3BzID0gW107XG4gICAgY29uc3Qgb3BJZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKCk7XG4gICAgY29uc3QgdXBkYXRlZFByb3BzID0ge307XG4gICAgY29uc3QgcmV2ZXJzZVVwZGF0ZU9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgZGF0YToge31cbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZURlbHRhID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGF0Y2gpIHtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgcmV2ZXJzZU9wcy5wdXNoKC4uLm9sZFZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5KSk7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICByZXZlcnNlT3BzLnB1c2goeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZDogdGhpcy5faWQsIGtleSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldmVyc2VVcGRhdGVPcC5kYXRhW2tleV0gPSBvbGRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xpdmVOb2RlKG5ld1ZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICBuZXdWYWx1ZS5fYXR0YWNoKHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpLCB0aGlzLl9wb29sKTtcbiAgICAgICAgY29uc3QgbmV3QXR0YWNoQ2hpbGRPcHMgPSBuZXdWYWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSwgdGhpcy5fcG9vbCk7XG4gICAgICAgIGNvbnN0IGNyZWF0ZUNyZHRPcCA9IG5ld0F0dGFjaENoaWxkT3BzLmZpbmQoXG4gICAgICAgICAgKG9wKSA9PiBvcC5wYXJlbnRJZCA9PT0gdGhpcy5faWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGNyZWF0ZUNyZHRPcCkge1xuICAgICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgbm4oY3JlYXRlQ3JkdE9wLm9wSWQpKTtcbiAgICAgICAgfVxuICAgICAgICBvcHMucHVzaCguLi5uZXdBdHRhY2hDaGlsZE9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVkUHJvcHNba2V5XSA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLnNldChrZXksIG9wSWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwLnNldChrZXksIG5ld1ZhbHVlKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgdXBkYXRlRGVsdGFba2V5XSA9IHsgdHlwZTogXCJ1cGRhdGVcIiB9O1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMocmV2ZXJzZVVwZGF0ZU9wLmRhdGEpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV2ZXJzZU9wcy51bnNoaWZ0KHJldmVyc2VVcGRhdGVPcCk7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyh1cGRhdGVkUHJvcHMpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgb3BzLnVuc2hpZnQoe1xuICAgICAgICBvcElkLFxuICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgZGF0YTogdXBkYXRlZFByb3BzXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzLl9pZCwge1xuICAgICAgbm9kZTogdGhpcyxcbiAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgdXBkYXRlczogdXBkYXRlRGVsdGFcbiAgICB9KTtcbiAgICB0aGlzLl9wb29sLmRpc3BhdGNoKG9wcywgcmV2ZXJzZU9wcywgc3RvcmFnZVVwZGF0ZXMpO1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdG9UcmVlTm9kZShrZXkpIHtcbiAgICByZXR1cm4gc3VwZXIudG9UcmVlTm9kZShrZXkpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgY29uc3Qgbm9kZUlkID0gdGhpcy5faWQgPz8gbmFub2lkKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgaWQ6IG5vZGVJZCxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IEFycmF5LmZyb20odGhpcy5fbWFwLmVudHJpZXMoKSkubWFwKFxuICAgICAgICAoW2tleTIsIHZhbHVlXSkgPT4gaXNMaXZlTm9kZSh2YWx1ZSkgPyB2YWx1ZS50b1RyZWVOb2RlKGtleTIpIDogeyB0eXBlOiBcIkpzb25cIiwgaWQ6IGAke25vZGVJZH06JHtrZXkyfWAsIGtleToga2V5MiwgcGF5bG9hZDogdmFsdWUgfVxuICAgICAgKVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMuX21hcCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBpc0xpdmVTdHJ1Y3R1cmUodmFsKSA/IHZhbC50b0ltbXV0YWJsZSgpIDogdmFsO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gcmVzdWx0IDogT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0xpdmVPYmplY3QoXG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIEFycmF5LmZyb20odGhpcy5fbWFwKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpID8gdmFsdWUuY2xvbmUoKSA6IGRlZXBDbG9uZSh2YWx1ZSlcbiAgICAgICAgXSlcbiAgICAgIClcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvY3JkdHMvbGl2ZWJsb2Nrcy1oZWxwZXJzLnRzXG5mdW5jdGlvbiBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCkge1xuICByZXR1cm4gbHNvblRvTGl2ZU5vZGUoY3JlYXRpb25PcFRvTHNvbihvcCkpO1xufVxuZnVuY3Rpb24gY3JlYXRpb25PcFRvTHNvbihvcCkge1xuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlIDggLyogQ1JFQVRFX1JFR0lTVEVSICovOlxuICAgICAgcmV0dXJuIG9wLmRhdGE7XG4gICAgY2FzZSA0IC8qIENSRUFURV9PQkpFQ1QgKi86XG4gICAgICByZXR1cm4gbmV3IExpdmVPYmplY3Qob3AuZGF0YSk7XG4gICAgY2FzZSA3IC8qIENSRUFURV9NQVAgKi86XG4gICAgICByZXR1cm4gbmV3IExpdmVNYXAoKTtcbiAgICBjYXNlIDIgLyogQ1JFQVRFX0xJU1QgKi86XG4gICAgICByZXR1cm4gbmV3IExpdmVMaXN0KCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihvcCwgXCJVbmtub3duIGNyZWF0aW9uIE9wXCIpO1xuICB9XG59XG5mdW5jdGlvbiBpc1NhbWVOb2RlT3JDaGlsZE9mKG5vZGUsIHBhcmVudCkge1xuICBpZiAobm9kZSA9PT0gcGFyZW50KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICByZXR1cm4gaXNTYW1lTm9kZU9yQ2hpbGRPZihub2RlLnBhcmVudC5ub2RlLCBwYXJlbnQpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgc3dpdGNoIChjcmR0LnR5cGUpIHtcbiAgICBjYXNlIDAgLyogT0JKRUNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU9iamVjdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMSAvKiBMSVNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZUxpc3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDIgLyogTUFQICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU1hcC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzoge1xuICAgICAgcmV0dXJuIExpdmVSZWdpc3Rlci5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgQ1JEVCB0eXBlXCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVUb0xzb24oW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICBzd2l0Y2ggKGNyZHQudHlwZSkge1xuICAgIGNhc2UgMCAvKiBPQkpFQ1QgKi86IHtcbiAgICAgIHJldHVybiBMaXZlT2JqZWN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAxIC8qIExJU1QgKi86IHtcbiAgICAgIHJldHVybiBMaXZlTGlzdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMiAvKiBNQVAgKi86IHtcbiAgICAgIHJldHVybiBMaXZlTWFwLl9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAzIC8qIFJFR0lTVEVSICovOiB7XG4gICAgICByZXR1cm4gY3JkdC5kYXRhO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIENSRFQgdHlwZVwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkge1xuICByZXR1cm4gaXNMaXZlTGlzdCh2YWx1ZSkgfHwgaXNMaXZlTWFwKHZhbHVlKSB8fCBpc0xpdmVPYmplY3QodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNMaXZlTm9kZSh2YWx1ZSkge1xuICByZXR1cm4gaXNMaXZlU3RydWN0dXJlKHZhbHVlKSB8fCBpc0xpdmVSZWdpc3Rlcih2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0xpdmVMaXN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIExpdmVMaXN0O1xufVxuZnVuY3Rpb24gaXNMaXZlTWFwKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIExpdmVNYXA7XG59XG5mdW5jdGlvbiBpc0xpdmVPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTGl2ZU9iamVjdDtcbn1cbmZ1bmN0aW9uIGlzTGl2ZVJlZ2lzdGVyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcjtcbn1cbmZ1bmN0aW9uIGNsb25lTHNvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgPyB2YWx1ZS5jbG9uZSgpIDogZGVlcENsb25lKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGxpdmVOb2RlVG9Mc29uKG9iaikge1xuICBpZiAob2JqIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyKSB7XG4gICAgcmV0dXJuIG9iai5kYXRhO1xuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExpdmVMaXN0IHx8IG9iaiBpbnN0YW5jZW9mIExpdmVNYXAgfHwgb2JqIGluc3RhbmNlb2YgTGl2ZU9iamVjdCkge1xuICAgIHJldHVybiBvYmo7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFzc2VydE5ldmVyKG9iaiwgXCJVbmtub3duIEFic3RyYWN0Q3JkdFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gbHNvblRvTGl2ZU5vZGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZU9iamVjdCB8fCB2YWx1ZSBpbnN0YW5jZW9mIExpdmVNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBMaXZlTGlzdCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IExpdmVSZWdpc3Rlcih2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRyZWVzRGlmZk9wZXJhdGlvbnMoY3VycmVudEl0ZW1zLCBuZXdJdGVtcykge1xuICBjb25zdCBvcHMgPSBbXTtcbiAgY3VycmVudEl0ZW1zLmZvckVhY2goKF8sIGlkKSA9PiB7XG4gICAgaWYgKCFuZXdJdGVtcy5nZXQoaWQpKSB7XG4gICAgICBvcHMucHVzaCh7XG4gICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgICAgIGlkXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBuZXdJdGVtcy5mb3JFYWNoKChjcmR0LCBpZCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRDcmR0ID0gY3VycmVudEl0ZW1zLmdldChpZCk7XG4gICAgaWYgKGN1cnJlbnRDcmR0KSB7XG4gICAgICBpZiAoY3JkdC50eXBlID09PSAwIC8qIE9CSkVDVCAqLykge1xuICAgICAgICBpZiAoY3VycmVudENyZHQudHlwZSAhPT0gMCAvKiBPQkpFQ1QgKi8gfHwgSlNPTi5zdHJpbmdpZnkoY3JkdC5kYXRhKSAhPT0gSlNPTi5zdHJpbmdpZnkoY3VycmVudENyZHQuZGF0YSkpIHtcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGRhdGE6IGNyZHQuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3JkdC5wYXJlbnRLZXkgIT09IGN1cnJlbnRDcmR0LnBhcmVudEtleSkge1xuICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXJlbnRLZXk6IG5uKGNyZHQucGFyZW50S2V5LCBcIlBhcmVudCBrZXkgbXVzdCBub3QgYmUgbWlzc2luZ1wiKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjcmR0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAzIC8qIFJFR0lTVEVSICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDggLyogQ1JFQVRFX1JFR0lTVEVSICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXJlbnRJZDogY3JkdC5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBhcmVudEtleTogY3JkdC5wYXJlbnRLZXksXG4gICAgICAgICAgICBkYXRhOiBjcmR0LmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIC8qIExJU1QgKi86XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMiAvKiBDUkVBVEVfTElTVCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMCAvKiBPQkpFQ1QgKi86XG4gICAgICAgICAgaWYgKGNyZHQucGFyZW50SWQgPT09IHZvaWQgMCB8fCBjcmR0LnBhcmVudEtleSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiSW50ZXJuYWwgZXJyb3IuIENhbm5vdCBzZXJpYWxpemUgc3RvcmFnZSByb290IGludG8gYW4gb3BlcmF0aW9uXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDQgLyogQ1JFQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5LFxuICAgICAgICAgICAgZGF0YTogY3JkdC5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMiAvKiBNQVAgKi86XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogNyAvKiBDUkVBVEVfTUFQICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXJlbnRJZDogY3JkdC5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBhcmVudEtleTogY3JkdC5wYXJlbnRLZXlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3BzO1xufVxuZnVuY3Rpb24gbWVyZ2VPYmplY3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKSB7XG4gIGNvbnN0IHVwZGF0ZXMgPSBmaXJzdC51cGRhdGVzO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzKHNlY29uZC51cGRhdGVzKSkge1xuICAgIHVwZGF0ZXNba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uc2Vjb25kLFxuICAgIHVwZGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlTWFwU3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcyhzZWNvbmQudXBkYXRlcykpIHtcbiAgICB1cGRhdGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNlY29uZCxcbiAgICB1cGRhdGVzXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZUxpc3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKSB7XG4gIGNvbnN0IHVwZGF0ZXMgPSBmaXJzdC51cGRhdGVzO1xuICByZXR1cm4ge1xuICAgIC4uLnNlY29uZCxcbiAgICB1cGRhdGVzOiB1cGRhdGVzLmNvbmNhdChzZWNvbmQudXBkYXRlcylcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlU3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBpZiAoZmlyc3QgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBzZWNvbmQ7XG4gIH1cbiAgaWYgKGZpcnN0LnR5cGUgPT09IFwiTGl2ZU9iamVjdFwiICYmIHNlY29uZC50eXBlID09PSBcIkxpdmVPYmplY3RcIikge1xuICAgIHJldHVybiBtZXJnZU9iamVjdFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpO1xuICB9IGVsc2UgaWYgKGZpcnN0LnR5cGUgPT09IFwiTGl2ZU1hcFwiICYmIHNlY29uZC50eXBlID09PSBcIkxpdmVNYXBcIikge1xuICAgIHJldHVybiBtZXJnZU1hcFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpO1xuICB9IGVsc2UgaWYgKGZpcnN0LnR5cGUgPT09IFwiTGl2ZUxpc3RcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlTGlzdFwiKSB7XG4gICAgcmV0dXJuIG1lcmdlTGlzdFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpO1xuICB9IGVsc2Uge1xuICB9XG4gIHJldHVybiBzZWNvbmQ7XG59XG5mdW5jdGlvbiBpc1BsYWluKHZhbHVlKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIiB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSh2YWx1ZSwgcGF0aCA9IFwiXCIpIHtcbiAgaWYgKCFpc1BsYWluKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHBhdGggfHwgXCJyb290XCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIG5lc3RlZFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICBjb25zdCBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICBpZiAoIWlzUGxhaW4obmVzdGVkVmFsdWUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiBuZXN0ZWRQYXRoLFxuICAgICAgICB2YWx1ZTogbmVzdGVkVmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmVzdGVkVmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IG5vblNlcmlhbGl6YWJsZU5lc3RlZFZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKFxuICAgICAgICBuZXN0ZWRWYWx1ZSxcbiAgICAgICAgbmVzdGVkUGF0aFxuICAgICAgKTtcbiAgICAgIGlmIChub25TZXJpYWxpemFibGVOZXN0ZWRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbm9uU2VyaWFsaXphYmxlTmVzdGVkVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc3JjL2xpYi9kZWJ1Zy50c1xuZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2UobXNnLCB0cmFjZVJvb3QpIHtcbiAgY29uc3QgZXJyb3JMaWtlID0geyBuYW1lOiBtc2cgfTtcbiAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnJvckxpa2UsIHRyYWNlUm9vdCk7XG4gIHJldHVybiBlcnJvckxpa2Uuc3RhY2s7XG59XG5cbi8vIHNyYy9saWIvSnNvbi50c1xuZnVuY3Rpb24gaXNKc29uU2NhbGFyKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09IG51bGwgfHwgdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGRhdGEgPT09IFwiYm9vbGVhblwiO1xufVxuZnVuY3Rpb24gaXNKc29uQXJyYXkoZGF0YSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkYXRhKTtcbn1cbmZ1bmN0aW9uIGlzSnNvbk9iamVjdChkYXRhKSB7XG4gIHJldHVybiAhaXNKc29uU2NhbGFyKGRhdGEpICYmICFpc0pzb25BcnJheShkYXRhKTtcbn1cblxuLy8gc3JjL3Byb3RvY29sL0NsaWVudE1zZy50c1xudmFyIENsaWVudE1zZ0NvZGUgPSAvKiBAX19QVVJFX18gKi8gKChDbGllbnRNc2dDb2RlMikgPT4ge1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9QUkVTRU5DRVwiXSA9IDEwMF0gPSBcIlVQREFURV9QUkVTRU5DRVwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIkJST0FEQ0FTVF9FVkVOVFwiXSA9IDEwM10gPSBcIkJST0FEQ0FTVF9FVkVOVFwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIkZFVENIX1NUT1JBR0VcIl0gPSAyMDBdID0gXCJGRVRDSF9TVE9SQUdFXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiVVBEQVRFX1NUT1JBR0VcIl0gPSAyMDFdID0gXCJVUERBVEVfU1RPUkFHRVwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIkZFVENIX1lET0NcIl0gPSAzMDBdID0gXCJGRVRDSF9ZRE9DXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiVVBEQVRFX1lET0NcIl0gPSAzMDFdID0gXCJVUERBVEVfWURPQ1wiO1xuICByZXR1cm4gQ2xpZW50TXNnQ29kZTI7XG59KShDbGllbnRNc2dDb2RlIHx8IHt9KTtcblxuLy8gc3JjL3JlZnMvSW1tdXRhYmxlUmVmLnRzXG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHBhdGNoKSB7XG4gIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gIGNvbnN0IG5ld1ZhbHVlID0geyAuLi50YXJnZXQgfTtcbiAgT2JqZWN0LmtleXMocGF0Y2gpLmZvckVhY2goKGspID0+IHtcbiAgICBjb25zdCBrZXkgPSBrO1xuICAgIGNvbnN0IHZhbCA9IHBhdGNoW2tleV07XG4gICAgaWYgKG5ld1ZhbHVlW2tleV0gIT09IHZhbCkge1xuICAgICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlbGV0ZSBuZXdWYWx1ZVtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWVba2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB1cGRhdGVkID8gbmV3VmFsdWUgOiB0YXJnZXQ7XG59XG52YXIgSW1tdXRhYmxlUmVmID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9ldiA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICB9XG4gIGdldCBkaWRJbnZhbGlkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9ldi5vYnNlcnZhYmxlO1xuICB9XG4gIGludmFsaWRhdGUoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX2NhY2hlID0gdm9pZCAwO1xuICAgICAgdGhpcy5fZXYubm90aWZ5KCk7XG4gICAgfVxuICB9XG4gIGdldCBjdXJyZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZSA/PyAodGhpcy5fY2FjaGUgPSB0aGlzLl90b0ltbXV0YWJsZSgpKTtcbiAgfVxufTtcblxuLy8gc3JjL3JlZnMvT3RoZXJzUmVmLnRzXG5mdW5jdGlvbiBtYWtlVXNlcihjb25uLCBwcmVzZW5jZSkge1xuICBjb25zdCB7IGNvbm5lY3Rpb25JZCwgaWQsIGluZm8gfSA9IGNvbm47XG4gIGNvbnN0IGNhbldyaXRlID0gY2FuV3JpdGVTdG9yYWdlKGNvbm4uc2NvcGVzKTtcbiAgcmV0dXJuIGZyZWV6ZShcbiAgICBjb21wYWN0T2JqZWN0KHtcbiAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgIGlkLFxuICAgICAgaW5mbyxcbiAgICAgIGNhbldyaXRlLFxuICAgICAgY2FuQ29tbWVudDogY2FuQ29tbWVudChjb25uLnNjb3BlcyksXG4gICAgICBpc1JlYWRPbmx5OiAhY2FuV3JpdGUsXG4gICAgICAvLyBEZXByZWNhdGVkLCBrZXB0IGZvciBiYWNrd2FyZC1jb21wYXRpYmlsaXR5XG4gICAgICBwcmVzZW5jZVxuICAgIH0pXG4gICk7XG59XG52YXIgT3RoZXJzUmVmID0gY2xhc3MgZXh0ZW5kcyBJbW11dGFibGVSZWYge1xuICAvL1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9wcmVzZW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3VzZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBjb25uZWN0aW9uSWRzKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9ucy5rZXlzKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgY29uc3QgdXNlcnMgPSBjb21wYWN0KFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLl9wcmVzZW5jZXMua2V5cygpKS5tYXAoXG4gICAgICAgIChjb25uZWN0aW9uSWQpID0+IHRoaXMuZ2V0VXNlcihOdW1iZXIoY29ubmVjdGlvbklkKSlcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiB1c2VycztcbiAgfVxuICBjbGVhck90aGVycygpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcHJlc2VuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl91c2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZ2V0VXNlcihjb25uZWN0aW9uSWQpIHtcbiAgICBjb25zdCBjb25uID0gdGhpcy5fY29ubmVjdGlvbnMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgY29uc3QgcHJlc2VuY2UgPSB0aGlzLl9wcmVzZW5jZXMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNvbm4gIT09IHZvaWQgMCAmJiBwcmVzZW5jZSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbWFrZVVzZXIoY29ubiwgcHJlc2VuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGdldFVzZXIoY29ubmVjdGlvbklkKSB7XG4gICAgY29uc3QgY2FjaGVkVXNlciA9IHRoaXMuX3VzZXJzLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjYWNoZWRVc2VyKSB7XG4gICAgICByZXR1cm4gY2FjaGVkVXNlcjtcbiAgICB9XG4gICAgY29uc3QgY29tcHV0ZWRVc2VyID0gdGhpcy5fZ2V0VXNlcihjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjb21wdXRlZFVzZXIpIHtcbiAgICAgIHRoaXMuX3VzZXJzLnNldChjb25uZWN0aW9uSWQsIGNvbXB1dGVkVXNlcik7XG4gICAgICByZXR1cm4gY29tcHV0ZWRVc2VyO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGlmICh0aGlzLl91c2Vycy5oYXMoY29ubmVjdGlvbklkKSkge1xuICAgICAgdGhpcy5fdXNlcnMuZGVsZXRlKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZWNvcmRzIGEga25vd24gY29ubmVjdGlvbi4gVGhpcyByZWNvcmRzIHRoZSBjb25uZWN0aW9uIElEIGFuZCB0aGVcbiAgICogYXNzb2NpYXRlZCBtZXRhZGF0YS5cbiAgICovXG4gIHNldENvbm5lY3Rpb24oY29ubmVjdGlvbklkLCBtZXRhVXNlcklkLCBtZXRhVXNlckluZm8sIHNjb3Blcykge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zLnNldChcbiAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgIGZyZWV6ZSh7XG4gICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgaWQ6IG1ldGFVc2VySWQsXG4gICAgICAgIGluZm86IG1ldGFVc2VySW5mbyxcbiAgICAgICAgc2NvcGVzXG4gICAgICB9KVxuICAgICk7XG4gICAgaWYgKHRoaXMuX3ByZXNlbmNlcy5oYXMoY29ubmVjdGlvbklkKSkge1xuICAgICAgdGhpcy5faW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBrbm93biBjb25uZWN0aW9uSWQuIFJlbW92ZXMgYm90aCB0aGUgY29ubmVjdGlvbidzIG1ldGFkYXRhIGFuZFxuICAgKiB0aGUgcHJlc2VuY2UgaW5mb3JtYXRpb24uXG4gICAqL1xuICByZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgIHRoaXMuX3ByZXNlbmNlcy5kZWxldGUoY29ubmVjdGlvbklkKTtcbiAgICB0aGlzLl9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpO1xuICB9XG4gIC8qKlxuICAgKiBTdG9yZXMgYSBuZXcgdXNlciBmcm9tIGEgZnVsbCBwcmVzZW5jZSB1cGRhdGUuIElmIHRoZSB1c2VyIGFscmVhZHkgZXhpc3RzLFxuICAgKiBpdHMga25vd24gcHJlc2VuY2UgZGF0YSBpcyBvdmVyd3JpdHRlbi5cbiAgICovXG4gIHNldE90aGVyKGNvbm5lY3Rpb25JZCwgcHJlc2VuY2UpIHtcbiAgICB0aGlzLl9wcmVzZW5jZXMuc2V0KGNvbm5lY3Rpb25JZCwgZnJlZXplKGNvbXBhY3RPYmplY3QocHJlc2VuY2UpKSk7XG4gICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25zLmhhcyhjb25uZWN0aW9uSWQpKSB7XG4gICAgICB0aGlzLl9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGF0Y2hlcyB0aGUgcHJlc2VuY2UgZGF0YSBmb3IgYW4gZXhpc3RpbmcgXCJvdGhlclwiLiBJZiB3ZSBkb24ndCBrbm93IHRoZVxuICAgKiBpbml0aWFsIHByZXNlbmNlIGRhdGEgZm9yIHRoaXMgdXNlciB5ZXQsIGRpc2NhcmQgdGhpcyBwYXRjaCBhbmQgYXdhaXQgdGhlXG4gICAqIGZ1bGwgLnNldE90aGVyKCkgY2FsbCBmaXJzdC5cbiAgICovXG4gIHBhdGNoT3RoZXIoY29ubmVjdGlvbklkLCBwYXRjaCkge1xuICAgIGNvbnN0IG9sZFByZXNlbmNlID0gdGhpcy5fcHJlc2VuY2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGlmIChvbGRQcmVzZW5jZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld1ByZXNlbmNlID0gbWVyZ2Uob2xkUHJlc2VuY2UsIHBhdGNoKTtcbiAgICBpZiAob2xkUHJlc2VuY2UgIT09IG5ld1ByZXNlbmNlKSB7XG4gICAgICB0aGlzLl9wcmVzZW5jZXMuc2V0KGNvbm5lY3Rpb25JZCwgZnJlZXplKG5ld1ByZXNlbmNlKSk7XG4gICAgICB0aGlzLl9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3JlZnMvUGF0Y2hhYmxlUmVmLnRzXG52YXIgUGF0Y2hhYmxlUmVmID0gY2xhc3MgZXh0ZW5kcyBJbW11dGFibGVSZWYge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kYXRhID0gZnJlZXplKGNvbXBhY3RPYmplY3QoZGF0YSkpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIC8qKlxuICAgKiBQYXRjaGVzIHRoZSBjdXJyZW50IG9iamVjdC5cbiAgICovXG4gIHBhdGNoKHBhdGNoKSB7XG4gICAgY29uc3Qgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgY29uc3QgbmV3RGF0YSA9IG1lcmdlKG9sZERhdGEsIHBhdGNoKTtcbiAgICBpZiAob2xkRGF0YSAhPT0gbmV3RGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGZyZWV6ZShuZXdEYXRhKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3JlZnMvVmFsdWVSZWYudHNcbnZhciBWYWx1ZVJlZiA9IGNsYXNzIGV4dGVuZHMgSW1tdXRhYmxlUmVmIHtcbiAgY29uc3RydWN0b3IoaW5pdGlhbFZhbHVlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl92YWx1ZSA9IGZyZWV6ZShpbml0aWFsVmFsdWUpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBzZXQobmV3VmFsdWUpIHtcbiAgICB0aGlzLl92YWx1ZSA9IGZyZWV6ZShuZXdWYWx1ZSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbn07XG52YXIgRGVyaXZlZFJlZiA9IGNsYXNzIGV4dGVuZHMgSW1tdXRhYmxlUmVmIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgdHJhbnNmb3JtRm4gPSBhcmdzLnBvcCgpO1xuICAgIGNvbnN0IG90aGVyUmVmcyA9IGFyZ3M7XG4gICAgdGhpcy5fcmVmcyA9IG90aGVyUmVmcztcbiAgICB0aGlzLl9yZWZzLmZvckVhY2goKHJlZikgPT4ge1xuICAgICAgcmVmLmRpZEludmFsaWRhdGUuc3Vic2NyaWJlKCgpID0+IHRoaXMuaW52YWxpZGF0ZSgpKTtcbiAgICB9KTtcbiAgICB0aGlzLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1GbjtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtKFxuICAgICAgLi4udGhpcy5fcmVmcy5tYXAoKHJlZikgPT4gcmVmLmN1cnJlbnQpXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL3Jvb20udHNcbnZhciBNQVhfU09DS0VUX01FU1NBR0VfU0laRSA9IDEwMjQgKiAxMDI0IC0gMTAyNDtcbmZ1bmN0aW9uIG1ha2VJZEZhY3RvcnkoY29ubmVjdGlvbklkKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIHJldHVybiAoKSA9PiBgJHtjb25uZWN0aW9uSWR9OiR7Y291bnQrK31gO1xufVxuZnVuY3Rpb24gdXNlclRvVHJlZU5vZGUoa2V5LCB1c2VyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJVc2VyXCIsXG4gICAgaWQ6IGAke3VzZXIuY29ubmVjdGlvbklkfWAsXG4gICAga2V5LFxuICAgIHBheWxvYWQ6IHVzZXJcbiAgfTtcbn1cbmZ1bmN0aW9uIGluc3RhbGxCYWNrZ3JvdW5kVGFiU3B5KCkge1xuICBjb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHZvaWQgMDtcbiAgY29uc3QgaW5CYWNrZ3JvdW5kU2luY2UgPSB7IGN1cnJlbnQ6IG51bGwgfTtcbiAgZnVuY3Rpb24gb25WaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgIGlmIChkb2M/LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCA9IGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPz8gRGF0ZS5ub3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG4gIGRvYz8uYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgY29uc3QgdW5zdWIgPSAoKSA9PiB7XG4gICAgZG9jPy5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICB9O1xuICByZXR1cm4gW2luQmFja2dyb3VuZFNpbmNlLCB1bnN1Yl07XG59XG5mdW5jdGlvbiBjcmVhdGVSb29tKG9wdGlvbnMsIGNvbmZpZykge1xuICBjb25zdCBpbml0aWFsUHJlc2VuY2UgPSB0eXBlb2Ygb3B0aW9ucy5pbml0aWFsUHJlc2VuY2UgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMuaW5pdGlhbFByZXNlbmNlKGNvbmZpZy5yb29tSWQpIDogb3B0aW9ucy5pbml0aWFsUHJlc2VuY2U7XG4gIGNvbnN0IGluaXRpYWxTdG9yYWdlID0gdHlwZW9mIG9wdGlvbnMuaW5pdGlhbFN0b3JhZ2UgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMuaW5pdGlhbFN0b3JhZ2UoY29uZmlnLnJvb21JZCkgOiBvcHRpb25zLmluaXRpYWxTdG9yYWdlO1xuICBjb25zdCBbaW5CYWNrZ3JvdW5kU2luY2UsIHVuaW5zdGFsbEJnVGFiU3B5XSA9IGluc3RhbGxCYWNrZ3JvdW5kVGFiU3B5KCk7XG4gIGNvbnN0IGRlbGVnYXRlcyA9IHtcbiAgICAuLi5jb25maWcuZGVsZWdhdGVzLFxuICAgIC8vIEEgY29ubmVjdGlvbiBpcyBhbGxvd2VkIHRvIGdvIGludG8gXCJ6b21iaWUgc3RhdGVcIiBvbmx5IGlmIGFsbCBvZiB0aGVcbiAgICAvLyBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcHBseTpcbiAgICAvL1xuICAgIC8vIC0gVGhlIGBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dGAgY2xpZW50IG9wdGlvbiBpcyBjb25maWd1cmVkXG4gICAgLy8gLSBUaGUgYnJvd3NlciB3aW5kb3cgaGFzIGJlZW4gaW4gdGhlIGJhY2tncm91bmQgZm9yIGF0IGxlYXN0XG4gICAgLy8gICBgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRgIG1pbGxpc2Vjb25kc1xuICAgIC8vIC0gVGhlcmUgYXJlIG5vIHBlbmRpbmcgY2hhbmdlc1xuICAgIC8vXG4gICAgY2FuWm9tYmllKCkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCAhPT0gdm9pZCAwICYmIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgIT09IG51bGwgJiYgRGF0ZS5ub3coKSA+IGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgKyBjb25maWcuYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQgJiYgZ2V0U3RvcmFnZVN0YXR1cygpICE9PSBcInN5bmNocm9uaXppbmdcIjtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1hbmFnZWRTb2NrZXQgPSBuZXcgTWFuYWdlZFNvY2tldChcbiAgICBkZWxlZ2F0ZXMsXG4gICAgY29uZmlnLmVuYWJsZURlYnVnTG9nZ2luZ1xuICApO1xuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIGJ1ZmZlcjoge1xuICAgICAgZmx1c2hUaW1lcklEOiB2b2lkIDAsXG4gICAgICBsYXN0Rmx1c2hlZEF0OiAwLFxuICAgICAgcHJlc2VuY2VVcGRhdGVzOiAoXG4gICAgICAgIC8vIFF1ZXVlIHVwIHRoZSBpbml0aWFsIHByZXNlbmNlIG1lc3NhZ2UgYXMgYSBGdWxsIFByZXNlbmNl4oSiIHVwZGF0ZVxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJmdWxsXCIsXG4gICAgICAgICAgZGF0YTogaW5pdGlhbFByZXNlbmNlXG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBtZXNzYWdlczogW10sXG4gICAgICBzdG9yYWdlT3BlcmF0aW9uczogW11cbiAgICB9LFxuICAgIHN0YXRpY1Nlc3Npb25JbmZvOiBuZXcgVmFsdWVSZWYobnVsbCksXG4gICAgZHluYW1pY1Nlc3Npb25JbmZvOiBuZXcgVmFsdWVSZWYobnVsbCksXG4gICAgbXlQcmVzZW5jZTogbmV3IFBhdGNoYWJsZVJlZihpbml0aWFsUHJlc2VuY2UpLFxuICAgIG90aGVyczogbmV3IE90aGVyc1JlZigpLFxuICAgIGluaXRpYWxTdG9yYWdlLFxuICAgIGlkRmFjdG9yeTogbnVsbCxcbiAgICAvLyBTdG9yYWdlXG4gICAgY2xvY2s6IDAsXG4gICAgb3BDbG9jazogMCxcbiAgICBub2RlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICByb290OiB2b2lkIDAsXG4gICAgdW5kb1N0YWNrOiBbXSxcbiAgICByZWRvU3RhY2s6IFtdLFxuICAgIHBhdXNlZEhpc3Rvcnk6IG51bGwsXG4gICAgYWN0aXZlQmF0Y2g6IG51bGwsXG4gICAgdW5hY2tub3dsZWRnZWRPcHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgLy8gRGVidWdcbiAgICBvcFN0YWNrVHJhY2VzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpIDogdm9pZCAwXG4gIH07XG4gIGNvbnN0IGRvTm90QmF0Y2hVcGRhdGVzID0gKGNiKSA9PiBjYigpO1xuICBjb25zdCBiYXRjaFVwZGF0ZXMgPSBjb25maWcudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPz8gZG9Ob3RCYXRjaFVwZGF0ZXM7XG4gIGxldCBsYXN0VG9rZW5LZXk7XG4gIGZ1bmN0aW9uIG9uU3RhdHVzRGlkQ2hhbmdlKG5ld1N0YXR1cykge1xuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlO1xuICAgIGlmIChhdXRoVmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHRva2VuS2V5ID0gYXV0aFZhbHVlLnR5cGUgPT09IFwic2VjcmV0XCIgPyBhdXRoVmFsdWUudG9rZW4ucmF3IDogYXV0aFZhbHVlLnB1YmxpY0FwaUtleTtcbiAgICAgIGlmICh0b2tlbktleSAhPT0gbGFzdFRva2VuS2V5KSB7XG4gICAgICAgIGxhc3RUb2tlbktleSA9IHRva2VuS2V5O1xuICAgICAgICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwic2VjcmV0XCIpIHtcbiAgICAgICAgICBjb25zdCB0b2tlbiA9IGF1dGhWYWx1ZS50b2tlbi5wYXJzZWQ7XG4gICAgICAgICAgY29udGV4dC5zdGF0aWNTZXNzaW9uSW5mby5zZXQoe1xuICAgICAgICAgICAgdXNlcklkOiB0b2tlbi5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovID8gdG9rZW4uaWQgOiB0b2tlbi51aWQsXG4gICAgICAgICAgICB1c2VySW5mbzogdG9rZW4uayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyA/IHRva2VuLmluZm8gOiB0b2tlbi51aVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm8uc2V0KHtcbiAgICAgICAgICAgIHVzZXJJZDogdm9pZCAwLFxuICAgICAgICAgICAgdXNlckluZm86IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBldmVudEh1Yi5zdGF0dXMubm90aWZ5KG5ld1N0YXR1cyk7XG4gICAgICBub3RpZnlTZWxmQ2hhbmdlZChkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgfSk7XG4gIH1cbiAgbGV0IF9jb25uZWN0aW9uTG9zc1RpbWVySWQ7XG4gIGxldCBfaGFzTG9zdENvbm5lY3Rpb24gPSBmYWxzZTtcbiAgZnVuY3Rpb24gaGFuZGxlQ29ubmVjdGlvbkxvc3NFdmVudChuZXdTdGF0dXMpIHtcbiAgICBpZiAobmV3U3RhdHVzID09PSBcInJlY29ubmVjdGluZ1wiKSB7XG4gICAgICBfY29ubmVjdGlvbkxvc3NUaW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwibG9zdFwiKTtcbiAgICAgICAgICBfaGFzTG9zdENvbm5lY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIGNvbnRleHQub3RoZXJzLmNsZWFyT3RoZXJzKCk7XG4gICAgICAgICAgbm90aWZ5KHsgb3RoZXJzOiBbeyB0eXBlOiBcInJlc2V0XCIgfV0gfSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGNvbmZpZy5sb3N0Q29ubmVjdGlvblRpbWVvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQoX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZCk7XG4gICAgICBpZiAoX2hhc0xvc3RDb25uZWN0aW9uKSB7XG4gICAgICAgIGlmIChuZXdTdGF0dXMgPT09IFwiZGlzY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwiZmFpbGVkXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgICBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5ub3RpZnkoXCJyZXN0b3JlZFwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfaGFzTG9zdENvbm5lY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25EaWRDb25uZWN0KCkge1xuICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9IHtcbiAgICAgIHR5cGU6IFwiZnVsbFwiLFxuICAgICAgZGF0YTogKFxuICAgICAgICAvLyBCZWNhdXNlIGNvbnRleHQubWUuY3VycmVudCBpcyBhIHJlYWRvbmx5IG9iamVjdCwgd2UnbGwgaGF2ZSB0b1xuICAgICAgICAvLyBtYWtlIGEgY29weSBoZXJlLiBPdGhlcndpc2UsIHR5cGUgZXJyb3JzIGhhcHBlbiBsYXRlciB3aGVuXG4gICAgICAgIC8vIFwicGF0Y2hpbmdcIiBteSBwcmVzZW5jZS5cbiAgICAgICAgeyAuLi5jb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudCB9XG4gICAgICApXG4gICAgfTtcbiAgICBpZiAoX2dldFN0b3JhZ2UkICE9PSBudWxsKSB7XG4gICAgICByZWZyZXNoU3RvcmFnZSh7IGZsdXNoOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBvbkRpZERpc2Nvbm5lY3QoKSB7XG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCk7XG4gIH1cbiAgbWFuYWdlZFNvY2tldC5ldmVudHMub25NZXNzYWdlLnN1YnNjcmliZShoYW5kbGVTZXJ2ZXJNZXNzYWdlKTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuc3RhdHVzRGlkQ2hhbmdlLnN1YnNjcmliZShvblN0YXR1c0RpZENoYW5nZSk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLnN0YXR1c0RpZENoYW5nZS5zdWJzY3JpYmUoaGFuZGxlQ29ubmVjdGlvbkxvc3NFdmVudCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZENvbm5lY3Quc3Vic2NyaWJlKG9uRGlkQ29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZERpc2Nvbm5lY3Quc3Vic2NyaWJlKG9uRGlkRGlzY29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLm9uTGl2ZWJsb2Nrc0Vycm9yLnN1YnNjcmliZSgoZXJyKSA9PiB7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZXJyb3IyKFxuICAgICAgICAgIGBDb25uZWN0aW9uIHRvIHdlYnNvY2tldCBzZXJ2ZXIgY2xvc2VkLiBSZWFzb246ICR7ZXJyLm1lc3NhZ2V9IChjb2RlOiAke2Vyci5jb2RlfSkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZXZlbnRIdWIuZXJyb3Iubm90aWZ5KGVycik7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBwb29sID0ge1xuICAgIHJvb21JZDogY29uZmlnLnJvb21JZCxcbiAgICBnZXROb2RlOiAoaWQpID0+IGNvbnRleHQubm9kZXMuZ2V0KGlkKSxcbiAgICBhZGROb2RlOiAoaWQsIG5vZGUpID0+IHZvaWQgY29udGV4dC5ub2Rlcy5zZXQoaWQsIG5vZGUpLFxuICAgIGRlbGV0ZU5vZGU6IChpZCkgPT4gdm9pZCBjb250ZXh0Lm5vZGVzLmRlbGV0ZShpZCksXG4gICAgZ2VuZXJhdGVJZDogKCkgPT4gYCR7Z2V0Q29ubmVjdGlvbklkKCl9OiR7Y29udGV4dC5jbG9jaysrfWAsXG4gICAgZ2VuZXJhdGVPcElkOiAoKSA9PiBgJHtnZXRDb25uZWN0aW9uSWQoKX06JHtjb250ZXh0Lm9wQ2xvY2srK31gLFxuICAgIGRpc3BhdGNoKG9wcywgcmV2ZXJzZSwgc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUJhdGNoID0gY29udGV4dC5hY3RpdmVCYXRjaDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc3RhY2tUcmFjZSA9IGNhcHR1cmVTdGFja1RyYWNlKFwiU3RvcmFnZSBtdXRhdGlvblwiLCB0aGlzLmRpc3BhdGNoKTtcbiAgICAgICAgaWYgKHN0YWNrVHJhY2UpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgICAgICAgaWYgKG9wLm9wSWQpIHtcbiAgICAgICAgICAgICAgbm4oY29udGV4dC5vcFN0YWNrVHJhY2VzKS5zZXQob3Aub3BJZCwgc3RhY2tUcmFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlQmF0Y2gpIHtcbiAgICAgICAgYWN0aXZlQmF0Y2gub3BzLnB1c2goLi4ub3BzKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgICAgICBhY3RpdmVCYXRjaC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXMoXG4gICAgICAgICAgICAgIGFjdGl2ZUJhdGNoLnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuZ2V0KGtleSksXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVCYXRjaC5yZXZlcnNlT3BzLnVuc2hpZnQoLi4ucmV2ZXJzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgIGFkZFRvVW5kb1N0YWNrKHJldmVyc2UsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgICBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPSAwO1xuICAgICAgICAgIGRpc3BhdGNoT3BzKG9wcyk7XG4gICAgICAgICAgbm90aWZ5KHsgc3RvcmFnZVVwZGF0ZXMgfSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlOiAoKSA9PiB7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mby5jdXJyZW50Py5zY29wZXM7XG4gICAgICBpZiAoc2NvcGVzID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKTtcbiAgICAgIGlmICghY2FuV3JpdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ2Fubm90IHdyaXRlIHRvIHN0b3JhZ2Ugd2l0aCBhIHJlYWQgb25seSB1c2VyLCBwbGVhc2UgZW5zdXJlIHRoZSB1c2VyIGhhcyB3cml0ZSBwZXJtaXNzaW9uc1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBldmVudEh1YiA9IHtcbiAgICBjb25uZWN0aW9uOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAvLyBPbGQvZGVwcmVjYXRlZCBBUElcbiAgICBzdGF0dXM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIC8vIE5ldy9yZWNvbW1lbmRlZCBBUElcbiAgICBsb3N0Q29ubmVjdGlvbjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgY3VzdG9tRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHNlbGY6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIG15UHJlc2VuY2U6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIG90aGVyczogbWFrZUV2ZW50U291cmNlKCksXG4gICAgZXJyb3I6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2U6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGhpc3Rvcnk6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VEaWRMb2FkOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBzdG9yYWdlU3RhdHVzOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICB5ZG9jOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBjb21tZW50czogbWFrZUV2ZW50U291cmNlKClcbiAgfTtcbiAgYXN5bmMgZnVuY3Rpb24gc3RyZWFtRmV0Y2goYXV0aFRva2VuT3JQdWJsaWNBcGlLZXksIHJvb21JZCkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoXG4gICAgICBgL3YyL2Mvcm9vbXMvJHtlbmNvZGVVUklDb21wb25lbnQocm9vbUlkKX0vc3RvcmFnZWAsXG4gICAgICBjb25maWcuYmFzZVVybFxuICAgICkudG9TdHJpbmcoKTtcbiAgICBjb25zdCBmZXRjaGVyID0gY29uZmlnLnBvbHlmaWxscz8uZmV0Y2ggfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmZXRjaDtcbiAgICByZXR1cm4gZmV0Y2hlcih1cmwudG9TdHJpbmcoKSwge1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2F1dGhUb2tlbk9yUHVibGljQXBpS2V5fWBcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBodHRwUG9zdFRvUm9vbShlbmRwb2ludCwgYm9keSkge1xuICAgIGlmICghbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBhdXRob3JpemVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBhdXRoVG9rZW5PclB1YmxpY0FwaUtleSA9IG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLnR5cGUgPT09IFwicHVibGljXCIgPyBtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZS5wdWJsaWNBcGlLZXkgOiBtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZS50b2tlbi5yYXc7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChcbiAgICAgIGAvdjIvYy9yb29tcy8ke2VuY29kZVVSSUNvbXBvbmVudChjb25maWcucm9vbUlkKX0ke2VuZHBvaW50fWAsXG4gICAgICBjb25maWcuYmFzZVVybFxuICAgICkudG9TdHJpbmcoKTtcbiAgICBjb25zdCBmZXRjaGVyID0gY29uZmlnLnBvbHlmaWxscz8uZmV0Y2ggfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmZXRjaDtcbiAgICByZXR1cm4gZmV0Y2hlcih1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YXV0aFRva2VuT3JQdWJsaWNBcGlLZXl9YFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc2VuZE1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShtZXNzYWdlcyk7XG4gICAgY29uc3Qgbm9uY2UgPSBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mby5jdXJyZW50Py5ub25jZTtcbiAgICBpZiAoY29uZmlnLnVuc3RhYmxlX2ZhbGxiYWNrVG9IVFRQICYmIG5vbmNlKSB7XG4gICAgICBjb25zdCBzaXplID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlcmlhbGl6ZWRQYXlsb2FkKS5sZW5ndGg7XG4gICAgICBpZiAoc2l6ZSA+IE1BWF9TT0NLRVRfTUVTU0FHRV9TSVpFKSB7XG4gICAgICAgIHZvaWQgaHR0cFBvc3RUb1Jvb20oXCIvc2VuZC1tZXNzYWdlXCIsIHsgbm9uY2UsIG1lc3NhZ2VzIH0pLnRoZW4oXG4gICAgICAgICAgKHJlc3ApID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzcC5vayAmJiByZXNwLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgICAgIG1hbmFnZWRTb2NrZXQucmVjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWVzc2FnZSB3YXMgdG9vIGxhcmdlIGZvciB3ZWJzb2NrZXRzIGFuZCBzZW50IG92ZXIgSFRUUCBpbnN0ZWFkXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBtYW5hZ2VkU29ja2V0LnNlbmQoc2VyaWFsaXplZFBheWxvYWQpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSBuZXcgRGVyaXZlZFJlZihcbiAgICBjb250ZXh0LnN0YXRpY1Nlc3Npb25JbmZvLFxuICAgIGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLFxuICAgIGNvbnRleHQubXlQcmVzZW5jZSxcbiAgICAoc3RhdGljU2Vzc2lvbiwgZHluYW1pY1Nlc3Npb24sIG15UHJlc2VuY2UpID0+IHtcbiAgICAgIGlmIChzdGF0aWNTZXNzaW9uID09PSBudWxsIHx8IGR5bmFtaWNTZXNzaW9uID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2UoZHluYW1pY1Nlc3Npb24uc2NvcGVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb25uZWN0aW9uSWQ6IGR5bmFtaWNTZXNzaW9uLmFjdG9yLFxuICAgICAgICAgIGlkOiBzdGF0aWNTZXNzaW9uLnVzZXJJZCxcbiAgICAgICAgICBpbmZvOiBzdGF0aWNTZXNzaW9uLnVzZXJJbmZvLFxuICAgICAgICAgIHByZXNlbmNlOiBteVByZXNlbmNlLFxuICAgICAgICAgIGNhbldyaXRlLFxuICAgICAgICAgIGNhbkNvbW1lbnQ6IGNhbkNvbW1lbnQoZHluYW1pY1Nlc3Npb24uc2NvcGVzKSxcbiAgICAgICAgICBpc1JlYWRPbmx5OiAhY2FuV3JpdGVcbiAgICAgICAgICAvLyBEZXByZWNhdGVkLCBrZXB0IGZvciBiYWNrd2FyZC1jb21wYXRpYmlsaXR5XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICApO1xuICBsZXQgX2xhc3RTZWxmO1xuICBmdW5jdGlvbiBub3RpZnlTZWxmQ2hhbmdlZChiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBjb25zdCBjdXJyU2VsZiA9IHNlbGYuY3VycmVudDtcbiAgICBpZiAoY3VyclNlbGYgIT09IG51bGwgJiYgY3VyclNlbGYgIT09IF9sYXN0U2VsZikge1xuICAgICAgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKCgpID0+IHtcbiAgICAgICAgZXZlbnRIdWIuc2VsZi5ub3RpZnkoY3VyclNlbGYpO1xuICAgICAgfSk7XG4gICAgICBfbGFzdFNlbGYgPSBjdXJyU2VsZjtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2VsZkFzVHJlZU5vZGUgPSBuZXcgRGVyaXZlZFJlZihcbiAgICBzZWxmLFxuICAgIChtZSkgPT4gbWUgIT09IG51bGwgPyB1c2VyVG9UcmVlTm9kZShcIk1lXCIsIG1lKSA6IG51bGxcbiAgKTtcbiAgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVSb290RnJvbU1lc3NhZ2UobWVzc2FnZSwgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKG1lc3NhZ2UuaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvcjogY2Fubm90IGxvYWQgc3RvcmFnZSB3aXRob3V0IGl0ZW1zXCIpO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5yb290ICE9PSB2b2lkIDApIHtcbiAgICAgIHVwZGF0ZVJvb3QobWVzc2FnZS5pdGVtcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5yb290ID0gTGl2ZU9iamVjdC5fZnJvbUl0ZW1zKG1lc3NhZ2UuaXRlbXMsIHBvb2wpO1xuICAgIH1cbiAgICBjb25zdCBzdGFja1NpemVCZWZvcmUgPSBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGg7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY29udGV4dC5pbml0aWFsU3RvcmFnZSkge1xuICAgICAgaWYgKGNvbnRleHQucm9vdC5nZXQoa2V5KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRleHQucm9vdC5zZXQoa2V5LCBjbG9uZUxzb24oY29udGV4dC5pbml0aWFsU3RvcmFnZVtrZXldKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA9IHN0YWNrU2l6ZUJlZm9yZTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVSb290KGl0ZW1zLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAoY29udGV4dC5yb290ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEl0ZW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgbm9kZV0gb2YgY29udGV4dC5ub2Rlcykge1xuICAgICAgY3VycmVudEl0ZW1zLnNldChpZCwgbm9kZS5fc2VyaWFsaXplKCkpO1xuICAgIH1cbiAgICBjb25zdCBvcHMgPSBnZXRUcmVlc0RpZmZPcGVyYXRpb25zKGN1cnJlbnRJdGVtcywgbmV3IE1hcChpdGVtcykpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKG9wcywgZmFsc2UpO1xuICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgfVxuICBmdW5jdGlvbiBfYWRkVG9SZWFsVW5kb1N0YWNrKGhpc3RvcnlPcHMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPj0gNTApIHtcbiAgICAgIGNvbnRleHQudW5kb1N0YWNrLnNoaWZ0KCk7XG4gICAgfVxuICAgIGNvbnRleHQudW5kb1N0YWNrLnB1c2goaGlzdG9yeU9wcyk7XG4gICAgb25IaXN0b3J5Q2hhbmdlKGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gIH1cbiAgZnVuY3Rpb24gYWRkVG9VbmRvU3RhY2soaGlzdG9yeU9wcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKGNvbnRleHQucGF1c2VkSGlzdG9yeSAhPT0gbnVsbCkge1xuICAgICAgY29udGV4dC5wYXVzZWRIaXN0b3J5LnVuc2hpZnQoLi4uaGlzdG9yeU9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hZGRUb1JlYWxVbmRvU3RhY2soaGlzdG9yeU9wcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5KHVwZGF0ZXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gdXBkYXRlcy5zdG9yYWdlVXBkYXRlcztcbiAgICBjb25zdCBvdGhlcnNVcGRhdGVzID0gdXBkYXRlcy5vdGhlcnM7XG4gICAgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKCgpID0+IHtcbiAgICAgIGlmIChvdGhlcnNVcGRhdGVzICE9PSB2b2lkIDAgJiYgb3RoZXJzVXBkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG90aGVycyA9IGNvbnRleHQub3RoZXJzLmN1cnJlbnQ7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2Ygb3RoZXJzVXBkYXRlcykge1xuICAgICAgICAgIGV2ZW50SHViLm90aGVycy5ub3RpZnkoeyAuLi5ldmVudCwgb3RoZXJzIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodXBkYXRlcy5wcmVzZW5jZSA/PyBmYWxzZSkge1xuICAgICAgICBub3RpZnlTZWxmQ2hhbmdlZChkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIGV2ZW50SHViLm15UHJlc2VuY2Uubm90aWZ5KGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdG9yYWdlVXBkYXRlcyAhPT0gdm9pZCAwICYmIHN0b3JhZ2VVcGRhdGVzLnNpemUgPiAwKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMyID0gQXJyYXkuZnJvbShzdG9yYWdlVXBkYXRlcy52YWx1ZXMoKSk7XG4gICAgICAgIGV2ZW50SHViLnN0b3JhZ2Uubm90aWZ5KHVwZGF0ZXMyKTtcbiAgICAgIH1cbiAgICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDb25uZWN0aW9uSWQoKSB7XG4gICAgY29uc3QgaW5mbyA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLmN1cnJlbnQ7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLmFjdG9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludGVybmFsLiBUcmllZCB0byBnZXQgY29ubmVjdGlvbiBpZCBidXQgY29ubmVjdGlvbiB3YXMgbmV2ZXIgb3BlblwiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseU9wcyhyYXdPcHMsIGlzTG9jYWwpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICByZXZlcnNlOiBbXSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgcHJlc2VuY2U6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVkTm9kZUlkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgb3BzID0gcmF3T3BzLm1hcCgob3ApID0+IHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIgJiYgIW9wLm9wSWQpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ub3AsIG9wSWQ6IHBvb2wuZ2VuZXJhdGVPcElkKCkgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgPT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb25zdCByZXZlcnNlID0ge1xuICAgICAgICAgIHR5cGU6IFwicHJlc2VuY2VcIixcbiAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICAgICAgcmV2ZXJzZS5kYXRhW2tleV0gPSBjb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQubXlQcmVzZW5jZS5wYXRjaChvcC5kYXRhKTtcbiAgICAgICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9IHsgdHlwZTogXCJwYXJ0aWFsXCIsIGRhdGE6IG9wLmRhdGEgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVtrZXldID0gb3AuZGF0YVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQucmV2ZXJzZS51bnNoaWZ0KHJldmVyc2UpO1xuICAgICAgICBvdXRwdXQucHJlc2VuY2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHNvdXJjZTtcbiAgICAgICAgaWYgKGlzTG9jYWwpIHtcbiAgICAgICAgICBzb3VyY2UgPSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBvcElkID0gbm4ob3Aub3BJZCk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgbm4oY29udGV4dC5vcFN0YWNrVHJhY2VzKS5kZWxldGUob3BJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGRlbGV0ZWQgPSBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLmRlbGV0ZShvcElkKTtcbiAgICAgICAgICBzb3VyY2UgPSBkZWxldGVkID8gMiAvKiBBQ0sgKi8gOiAxIC8qIFJFTU9URSAqLztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBseU9wUmVzdWx0ID0gYXBwbHlPcChvcCwgc291cmNlKTtcbiAgICAgICAgaWYgKGFwcGx5T3BSZXN1bHQubW9kaWZpZWQpIHtcbiAgICAgICAgICBjb25zdCBub2RlSWQgPSBhcHBseU9wUmVzdWx0Lm1vZGlmaWVkLm5vZGUuX2lkO1xuICAgICAgICAgIGlmICghKG5vZGVJZCAmJiBjcmVhdGVkTm9kZUlkcy5oYXMobm9kZUlkKSkpIHtcbiAgICAgICAgICAgIG91dHB1dC5zdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgICAgIG5uKGFwcGx5T3BSZXN1bHQubW9kaWZpZWQubm9kZS5faWQpLFxuICAgICAgICAgICAgICBtZXJnZVN0b3JhZ2VVcGRhdGVzKFxuICAgICAgICAgICAgICAgIG91dHB1dC5zdG9yYWdlVXBkYXRlcy5nZXQobm4oYXBwbHlPcFJlc3VsdC5tb2RpZmllZC5ub2RlLl9pZCkpLFxuICAgICAgICAgICAgICAgIGFwcGx5T3BSZXN1bHQubW9kaWZpZWRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG91dHB1dC5yZXZlcnNlLnVuc2hpZnQoLi4uYXBwbHlPcFJlc3VsdC5yZXZlcnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wLnR5cGUgPT09IDIgLyogQ1JFQVRFX0xJU1QgKi8gfHwgb3AudHlwZSA9PT0gNyAvKiBDUkVBVEVfTUFQICovIHx8IG9wLnR5cGUgPT09IDQgLyogQ1JFQVRFX09CSkVDVCAqLykge1xuICAgICAgICAgICAgY3JlYXRlZE5vZGVJZHMuYWRkKG5uKG9wLmlkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvcHMsXG4gICAgICByZXZlcnNlOiBvdXRwdXQucmV2ZXJzZSxcbiAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXM6IG91dHB1dC5zdG9yYWdlVXBkYXRlcyxcbiAgICAgICAgcHJlc2VuY2U6IG91dHB1dC5wcmVzZW5jZVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlPcChvcCwgc291cmNlKSB7XG4gICAgaWYgKGlzQWNrT3Aob3ApKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlIDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi86XG4gICAgICBjYXNlIDMgLyogVVBEQVRFX09CSkVDVCAqLzpcbiAgICAgIGNhc2UgNSAvKiBERUxFVEVfQ1JEVCAqLzoge1xuICAgICAgICBjb25zdCBub2RlID0gY29udGV4dC5ub2Rlcy5nZXQob3AuaWQpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuX2FwcGx5KG9wLCBzb3VyY2UgPT09IDAgLyogVU5ET1JFRE9fUkVDT05ORUNUICovKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgMSAvKiBTRVRfUEFSRU5UX0tFWSAqLzoge1xuICAgICAgICBjb25zdCBub2RlID0gY29udGV4dC5ub2Rlcy5nZXQob3AuaWQpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIgJiYgaXNMaXZlTGlzdChub2RlLnBhcmVudC5ub2RlKSkge1xuICAgICAgICAgIHJldHVybiBub2RlLnBhcmVudC5ub2RlLl9zZXRDaGlsZEtleShcbiAgICAgICAgICAgIGFzUG9zKG9wLnBhcmVudEtleSksXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgc291cmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgNCAvKiBDUkVBVEVfT0JKRUNUICovOlxuICAgICAgY2FzZSAyIC8qIENSRUFURV9MSVNUICovOlxuICAgICAgY2FzZSA3IC8qIENSRUFURV9NQVAgKi86XG4gICAgICBjYXNlIDggLyogQ1JFQVRFX1JFR0lTVEVSICovOiB7XG4gICAgICAgIGlmIChvcC5wYXJlbnRJZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGNvbnRleHQubm9kZXMuZ2V0KG9wLnBhcmVudElkKTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnROb2RlLl9hdHRhY2hDaGlsZChvcCwgc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUHJlc2VuY2UocGF0Y2gsIG9wdGlvbnMyKSB7XG4gICAgY29uc3Qgb2xkVmFsdWVzID0ge307XG4gICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID0ge1xuICAgICAgICB0eXBlOiBcInBhcnRpYWxcIixcbiAgICAgICAgZGF0YToge31cbiAgICAgIH07XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICBjb25zdCBvdmVycmlkZVZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgIGlmIChvdmVycmlkZVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVtrZXldID0gb3ZlcnJpZGVWYWx1ZTtcbiAgICAgIG9sZFZhbHVlc1trZXldID0gY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnRba2V5XTtcbiAgICB9XG4gICAgY29udGV4dC5teVByZXNlbmNlLnBhdGNoKHBhdGNoKTtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgaWYgKG9wdGlvbnMyPy5hZGRUb0hpc3RvcnkpIHtcbiAgICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC5yZXZlcnNlT3BzLnVuc2hpZnQoe1xuICAgICAgICAgIHR5cGU6IFwicHJlc2VuY2VcIixcbiAgICAgICAgICBkYXRhOiBvbGRWYWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmFjdGl2ZUJhdGNoLnVwZGF0ZXMucHJlc2VuY2UgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbHVzaE5vd09yU29vbigpO1xuICAgICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMyPy5hZGRUb0hpc3RvcnkpIHtcbiAgICAgICAgICBhZGRUb1VuZG9TdGFjayhcbiAgICAgICAgICAgIFt7IHR5cGU6IFwicHJlc2VuY2VcIiwgZGF0YTogb2xkVmFsdWVzIH1dLFxuICAgICAgICAgICAgZG9Ob3RCYXRjaFVwZGF0ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIG5vdGlmeSh7IHByZXNlbmNlOiB0cnVlIH0sIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvblVwZGF0ZVByZXNlbmNlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UudGFyZ2V0QWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qgb2xkVXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgICBjb250ZXh0Lm90aGVycy5zZXRPdGhlcihtZXNzYWdlLmFjdG9yLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgY29uc3QgbmV3VXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgICBpZiAob2xkVXNlciA9PT0gdm9pZCAwICYmIG5ld1VzZXIgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVudGVyXCIsIHVzZXI6IG5ld1VzZXIgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5vdGhlcnMucGF0Y2hPdGhlcihtZXNzYWdlLmFjdG9yLCBtZXNzYWdlLmRhdGEpLCBtZXNzYWdlO1xuICAgIH1cbiAgICBjb25zdCB1c2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgdXBkYXRlczogbWVzc2FnZS5kYXRhLFxuICAgICAgICB1c2VyXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvblVzZXJMZWZ0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIGNvbnRleHQub3RoZXJzLnJlbW92ZUNvbm5lY3Rpb24obWVzc2FnZS5hY3Rvcik7XG4gICAgICByZXR1cm4geyB0eXBlOiBcImxlYXZlXCIsIHVzZXIgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gb25Sb29tU3RhdGVNZXNzYWdlKG1lc3NhZ2UsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLnNldCh7XG4gICAgICBhY3RvcjogbWVzc2FnZS5hY3RvcixcbiAgICAgIG5vbmNlOiBtZXNzYWdlLm5vbmNlLFxuICAgICAgc2NvcGVzOiBtZXNzYWdlLnNjb3Blc1xuICAgIH0pO1xuICAgIGNvbnRleHQuaWRGYWN0b3J5ID0gbWFrZUlkRmFjdG9yeShtZXNzYWdlLmFjdG9yKTtcbiAgICBub3RpZnlTZWxmQ2hhbmdlZChiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICAgIGZvciAoY29uc3QgY29ubmVjdGlvbklkIG9mIGNvbnRleHQub3RoZXJzLmNvbm5lY3Rpb25JZHMoKSkge1xuICAgICAgY29uc3QgdXNlciA9IG1lc3NhZ2UudXNlcnNbY29ubmVjdGlvbklkXTtcbiAgICAgIGlmICh1c2VyID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGV4dC5vdGhlcnMucmVtb3ZlQ29ubmVjdGlvbihjb25uZWN0aW9uSWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXNzYWdlLnVzZXJzKSB7XG4gICAgICBjb25zdCB1c2VyID0gbWVzc2FnZS51c2Vyc1trZXldO1xuICAgICAgY29uc3QgY29ubmVjdGlvbklkID0gTnVtYmVyKGtleSk7XG4gICAgICBjb250ZXh0Lm90aGVycy5zZXRDb25uZWN0aW9uKFxuICAgICAgICBjb25uZWN0aW9uSWQsXG4gICAgICAgIHVzZXIuaWQsXG4gICAgICAgIHVzZXIuaW5mbyxcbiAgICAgICAgdXNlci5zY29wZXNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwicmVzZXRcIiB9O1xuICB9XG4gIGZ1bmN0aW9uIGNhblVuZG8oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA+IDA7XG4gIH1cbiAgZnVuY3Rpb24gY2FuUmVkbygpIHtcbiAgICByZXR1cm4gY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID4gMDtcbiAgfVxuICBmdW5jdGlvbiBvbkhpc3RvcnlDaGFuZ2UoYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKCgpID0+IHtcbiAgICAgIGV2ZW50SHViLmhpc3Rvcnkubm90aWZ5KHsgY2FuVW5kbzogY2FuVW5kbygpLCBjYW5SZWRvOiBjYW5SZWRvKCkgfSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gb25Vc2VySm9pbmVkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29udGV4dC5vdGhlcnMuc2V0Q29ubmVjdGlvbihcbiAgICAgIG1lc3NhZ2UuYWN0b3IsXG4gICAgICBtZXNzYWdlLmlkLFxuICAgICAgbWVzc2FnZS5pbmZvLFxuICAgICAgbWVzc2FnZS5zY29wZXNcbiAgICApO1xuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgIGRhdGE6IGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50LFxuICAgICAgdGFyZ2V0QWN0b3I6IG1lc3NhZ2UuYWN0b3JcbiAgICB9KTtcbiAgICBmbHVzaE5vd09yU29vbigpO1xuICAgIGNvbnN0IHVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgIHJldHVybiB1c2VyID8geyB0eXBlOiBcImVudGVyXCIsIHVzZXIgfSA6IHZvaWQgMDtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVNlcnZlck1lc3NhZ2UoZGF0YSkge1xuICAgIGlmICghaXNKc29uT2JqZWN0KGRhdGEpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VTZXJ2ZXJNZXNzYWdlcyh0ZXh0KSB7XG4gICAgY29uc3QgZGF0YSA9IHRyeVBhcnNlSnNvbih0ZXh0KTtcbiAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGlzSnNvbkFycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm4gY29tcGFjdChkYXRhLm1hcCgoaXRlbSkgPT4gcGFyc2VTZXJ2ZXJNZXNzYWdlKGl0ZW0pKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb21wYWN0KFtwYXJzZVNlcnZlck1lc3NhZ2UoZGF0YSldKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlBbmRTZW5kT3BzKG9mZmxpbmVPcHMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChvZmZsaW5lT3BzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBjb25zdCBvcHMgPSBBcnJheS5mcm9tKG9mZmxpbmVPcHMudmFsdWVzKCkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKG9wcywgdHJ1ZSk7XG4gICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICB0eXBlOiAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi8sXG4gICAgICBvcHM6IHJlc3VsdC5vcHNcbiAgICB9KTtcbiAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gICAgc2VuZE1lc3NhZ2VzKG1lc3NhZ2VzKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVTZXJ2ZXJNZXNzYWdlKGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gcGFyc2VTZXJ2ZXJNZXNzYWdlcyhldmVudC5kYXRhKTtcbiAgICBpZiAobWVzc2FnZXMgPT09IG51bGwgfHwgbWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZXMgPSB7XG4gICAgICBzdG9yYWdlVXBkYXRlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIG90aGVyczogW11cbiAgICB9O1xuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIDEwMSAvKiBVU0VSX0pPSU5FRCAqLzoge1xuICAgICAgICAgICAgY29uc3QgdXNlckpvaW5lZFVwZGF0ZSA9IG9uVXNlckpvaW5lZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAodXNlckpvaW5lZFVwZGF0ZSkge1xuICAgICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKHVzZXJKb2luZWRVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLzoge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJzUHJlc2VuY2VVcGRhdGUgPSBvblVwZGF0ZVByZXNlbmNlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChvdGhlcnNQcmVzZW5jZVVwZGF0ZSkge1xuICAgICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKG90aGVyc1ByZXNlbmNlVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwMyAvKiBCUk9BRENBU1RFRF9FVkVOVCAqLzoge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJzID0gY29udGV4dC5vdGhlcnMuY3VycmVudDtcbiAgICAgICAgICAgIGV2ZW50SHViLmN1c3RvbUV2ZW50Lm5vdGlmeSh7XG4gICAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogbWVzc2FnZS5hY3RvcixcbiAgICAgICAgICAgICAgdXNlcjogbWVzc2FnZS5hY3RvciA8IDAgPyBudWxsIDogb3RoZXJzLmZpbmQoKHUpID0+IHUuY29ubmVjdGlvbklkID09PSBtZXNzYWdlLmFjdG9yKSA/PyBudWxsLFxuICAgICAgICAgICAgICBldmVudDogbWVzc2FnZS5ldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMDIgLyogVVNFUl9MRUZUICovOiB7XG4gICAgICAgICAgICBjb25zdCBldmVudDIgPSBvblVzZXJMZWZ0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChldmVudDIpIHtcbiAgICAgICAgICAgICAgdXBkYXRlcy5vdGhlcnMucHVzaChldmVudDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMzAwIC8qIFVQREFURV9ZRE9DICovOiB7XG4gICAgICAgICAgICBldmVudEh1Yi55ZG9jLm5vdGlmeShtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwNCAvKiBST09NX1NUQVRFICovOiB7XG4gICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKG9uUm9vbVN0YXRlTWVzc2FnZShtZXNzYWdlLCBkb05vdEJhdGNoVXBkYXRlcykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjAwIC8qIElOSVRJQUxfU1RPUkFHRV9TVEFURSAqLzoge1xuICAgICAgICAgICAgcHJvY2Vzc0luaXRpYWxTdG9yYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjAxIC8qIFVQREFURV9TVE9SQUdFICovOiB7XG4gICAgICAgICAgICBjb25zdCBhcHBseVJlc3VsdCA9IGFwcGx5T3BzKG1lc3NhZ2Uub3BzLCBmYWxzZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBhcHBseVJlc3VsdC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBtZXJnZVN0b3JhZ2VVcGRhdGVzKHVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuZ2V0KGtleSksIHZhbHVlKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjk5IC8qIFJFSkVDVF9TVE9SQUdFX09QICovOiB7XG4gICAgICAgICAgICBlcnJvcldpdGhUaXRsZShcbiAgICAgICAgICAgICAgXCJTdG9yYWdlIG11dGF0aW9uIHJlamVjdGlvbiBlcnJvclwiLFxuICAgICAgICAgICAgICBtZXNzYWdlLnJlYXNvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgY29uc3QgdHJhY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBvcElkIG9mIG1lc3NhZ2Uub3BJZHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFjZSA9IGNvbnRleHQub3BTdGFja1RyYWNlcz8uZ2V0KG9wSWQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFjZSkge1xuICAgICAgICAgICAgICAgICAgdHJhY2VzLmFkZCh0cmFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0cmFjZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICB3YXJuV2l0aFRpdGxlKFxuICAgICAgICAgICAgICAgICAgXCJUaGUgZm9sbG93aW5nIGZ1bmN0aW9uIGNhbGxzIGNhdXNlZCB0aGUgcmVqZWN0ZWQgc3RvcmFnZSBtdXRhdGlvbnM6XCIsXG4gICAgICAgICAgICAgICAgICBgXG5cbiR7QXJyYXkuZnJvbSh0cmFjZXMpLmpvaW4oXCJcXG5cXG5cIil9YFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBTdG9yYWdlIG11dGF0aW9ucyByZWplY3RlZCBieSBzZXJ2ZXI6ICR7bWVzc2FnZS5yZWFzb259YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNDAwIC8qIFRIUkVBRF9DUkVBVEVEICovOlxuICAgICAgICAgIGNhc2UgNDAxIC8qIFRIUkVBRF9NRVRBREFUQV9VUERBVEVEICovOlxuICAgICAgICAgIGNhc2UgNDA1IC8qIENPTU1FTlRfUkVBQ1RJT05fQURERUQgKi86XG4gICAgICAgICAgY2FzZSA0MDYgLyogQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEICovOlxuICAgICAgICAgIGNhc2UgNDAyIC8qIENPTU1FTlRfQ1JFQVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwMyAvKiBDT01NRU5UX0VESVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwNCAvKiBDT01NRU5UX0RFTEVURUQgKi86IHtcbiAgICAgICAgICAgIGV2ZW50SHViLmNvbW1lbnRzLm5vdGlmeShtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm90aWZ5KHVwZGF0ZXMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBmbHVzaE5vd09yU29vbigpIHtcbiAgICBjb25zdCBzdG9yYWdlT3BzID0gY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnM7XG4gICAgaWYgKHN0b3JhZ2VPcHMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBvcCBvZiBzdG9yYWdlT3BzKSB7XG4gICAgICAgIGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMuc2V0KG5uKG9wLm9wSWQpLCBvcCk7XG4gICAgICB9XG4gICAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgfVxuICAgIGlmIChtYW5hZ2VkU29ja2V0LmdldFN0YXR1cygpICE9PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucyA9IFtdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWRNaWxsaXMgPSBub3cgLSBjb250ZXh0LmJ1ZmZlci5sYXN0Rmx1c2hlZEF0O1xuICAgIGlmIChlbGFwc2VkTWlsbGlzID49IGNvbmZpZy50aHJvdHRsZURlbGF5KSB7XG4gICAgICBjb25zdCBtZXNzYWdlc1RvRmx1c2ggPSBzZXJpYWxpemVCdWZmZXIoKTtcbiAgICAgIGlmIChtZXNzYWdlc1RvRmx1c2gubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlbmRNZXNzYWdlcyhtZXNzYWdlc1RvRmx1c2gpO1xuICAgICAgY29udGV4dC5idWZmZXIgPSB7XG4gICAgICAgIGZsdXNoVGltZXJJRDogdm9pZCAwLFxuICAgICAgICBsYXN0Rmx1c2hlZEF0OiBub3csXG4gICAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgICAgc3RvcmFnZU9wZXJhdGlvbnM6IFtdLFxuICAgICAgICBwcmVzZW5jZVVwZGF0ZXM6IG51bGxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyVGltZW91dChjb250ZXh0LmJ1ZmZlci5mbHVzaFRpbWVySUQpO1xuICAgICAgY29udGV4dC5idWZmZXIuZmx1c2hUaW1lcklEID0gc2V0VGltZW91dChcbiAgICAgICAgZmx1c2hOb3dPclNvb24sXG4gICAgICAgIGNvbmZpZy50aHJvdHRsZURlbGF5IC0gZWxhcHNlZE1pbGxpc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2VyaWFsaXplQnVmZmVyKCkge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcykge1xuICAgICAgbWVzc2FnZXMucHVzaChcbiAgICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLnR5cGUgPT09IFwiZnVsbFwiID8ge1xuICAgICAgICAgIHR5cGU6IDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi8sXG4gICAgICAgICAgLy8gUG9wdWxhdGluZyB0aGUgYHRhcmdldEFjdG9yYCBmaWVsZCB0dXJucyB0aGlzIG1lc3NhZ2UgaW50b1xuICAgICAgICAgIC8vIGEgRnVsbCBQcmVzZW5jZeKEoiB1cGRhdGUgbWVzc2FnZSAobm90IGEgcGF0Y2gpLCB3aGljaCB3aWxsIGdldFxuICAgICAgICAgIC8vIGludGVycHJldGVkIGJ5IG90aGVyIGNsaWVudHMgYXMgc3VjaC5cbiAgICAgICAgICB0YXJnZXRBY3RvcjogLTEsXG4gICAgICAgICAgZGF0YTogY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB0eXBlOiAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovLFxuICAgICAgICAgIGRhdGE6IGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgY29udGV4dC5idWZmZXIubWVzc2FnZXMpIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IDIwMSAvKiBVUERBVEVfU1RPUkFHRSAqLyxcbiAgICAgICAgb3BzOiBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlcztcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVZRG9jKHVwZGF0ZSwgZ3VpZCkge1xuICAgIGNvbnN0IGNsaWVudE1zZyA9IHtcbiAgICAgIHR5cGU6IDMwMSAvKiBVUERBVEVfWURPQyAqLyxcbiAgICAgIHVwZGF0ZSxcbiAgICAgIGd1aWRcbiAgICB9O1xuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goY2xpZW50TXNnKTtcbiAgICBldmVudEh1Yi55ZG9jLm5vdGlmeShjbGllbnRNc2cpO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gYnJvYWRjYXN0RXZlbnQoZXZlbnQsIG9wdGlvbnMyID0ge1xuICAgIHNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5OiBmYWxzZVxuICB9KSB7XG4gICAgaWYgKG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCkgIT09IFwiY29ubmVjdGVkXCIgJiYgIW9wdGlvbnMyLnNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMTAzIC8qIEJST0FEQ0FTVF9FVkVOVCAqLyxcbiAgICAgIGV2ZW50XG4gICAgfSk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaE9wcyhvcHMpIHtcbiAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKC4uLm9wcyk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBsZXQgX2dldFN0b3JhZ2UkID0gbnVsbDtcbiAgbGV0IF9yZXNvbHZlU3RvcmFnZVByb21pc2UgPSBudWxsO1xuICBmdW5jdGlvbiBwcm9jZXNzSW5pdGlhbFN0b3JhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IHVuYWNrbm93bGVkZ2VkT3BzID0gbmV3IE1hcChjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzKTtcbiAgICBjcmVhdGVPclVwZGF0ZVJvb3RGcm9tTWVzc2FnZShtZXNzYWdlLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgYXBwbHlBbmRTZW5kT3BzKHVuYWNrbm93bGVkZ2VkT3BzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZT8uKCk7XG4gICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIGV2ZW50SHViLnN0b3JhZ2VEaWRMb2FkLm5vdGlmeSgpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVN0b3JhZ2UoKSB7XG4gICAgaWYgKCFtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdHJlYW1GZXRjaChcbiAgICAgIG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLnR5cGUgPT09IFwicHVibGljXCIgPyBtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZS5wdWJsaWNBcGlLZXkgOiBtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZS50b2tlbi5yYXcsXG4gICAgICBjb25maWcucm9vbUlkXG4gICAgKTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgcHJvY2Vzc0luaXRpYWxTdG9yYWdlKHsgdHlwZTogMjAwIC8qIElOSVRJQUxfU1RPUkFHRV9TVEFURSAqLywgaXRlbXMgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVmcmVzaFN0b3JhZ2Uob3B0aW9uczIpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzO1xuICAgIGlmIChjb25maWcudW5zdGFibGVfc3RyZWFtRGF0YSkge1xuICAgICAgdm9pZCBzdHJlYW1TdG9yYWdlKCk7XG4gICAgfSBlbHNlIGlmICghbWVzc2FnZXMuc29tZSgobXNnKSA9PiBtc2cudHlwZSA9PT0gMjAwIC8qIEZFVENIX1NUT1JBR0UgKi8pKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKHsgdHlwZTogMjAwIC8qIEZFVENIX1NUT1JBR0UgKi8gfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zMi5mbHVzaCkge1xuICAgICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnRMb2FkaW5nU3RvcmFnZSgpIHtcbiAgICBpZiAoX2dldFN0b3JhZ2UkID09PSBudWxsKSB7XG4gICAgICByZWZyZXNoU3RvcmFnZSh7IGZsdXNoOiB0cnVlIH0pO1xuICAgICAgX2dldFN0b3JhZ2UkID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXRTdG9yYWdlJDtcbiAgfVxuICBmdW5jdGlvbiBnZXRTdG9yYWdlU25hcHNob3QoKSB7XG4gICAgY29uc3Qgcm9vdCA9IGNvbnRleHQucm9vdDtcbiAgICBpZiAocm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdm9pZCBzdGFydExvYWRpbmdTdG9yYWdlKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0U3RvcmFnZSgpIHtcbiAgICBpZiAoY29udGV4dC5yb290ICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICByb290OiBjb250ZXh0LnJvb3RcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBzdGFydExvYWRpbmdTdG9yYWdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IG5uKGNvbnRleHQucm9vdClcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGZldGNoWURvYyh2ZWN0b3IsIGd1aWQpIHtcbiAgICBpZiAoIWNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLmZpbmQoKG0pID0+IHtcbiAgICAgIHJldHVybiBtLnR5cGUgPT09IDMwMCAvKiBGRVRDSF9ZRE9DICovICYmIG0udmVjdG9yID09PSB2ZWN0b3IgJiYgbS5ndWlkID09PSBndWlkO1xuICAgIH0pKSB7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogMzAwIC8qIEZFVENIX1lET0MgKi8sXG4gICAgICAgIHZlY3RvcixcbiAgICAgICAgZ3VpZFxuICAgICAgfSk7XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gdW5kbygpIHtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5kbyBpcyBub3QgYWxsb3dlZCBkdXJpbmcgYSBiYXRjaFwiKTtcbiAgICB9XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQudW5kb1N0YWNrLnBvcCgpO1xuICAgIGlmIChoaXN0b3J5T3BzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gbnVsbDtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhoaXN0b3J5T3BzLCB0cnVlKTtcbiAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICBjb250ZXh0LnJlZG9TdGFjay5wdXNoKHJlc3VsdC5yZXZlcnNlKTtcbiAgICAgIG9uSGlzdG9yeUNoYW5nZShkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBvcCBvZiByZXN1bHQub3BzKSB7XG4gICAgICBpZiAob3AudHlwZSAhPT0gXCJwcmVzZW5jZVwiKSB7XG4gICAgICAgIGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zLnB1c2gob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIHJlZG8oKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJlZG8gaXMgbm90IGFsbG93ZWQgZHVyaW5nIGEgYmF0Y2hcIik7XG4gICAgfVxuICAgIGNvbnN0IGhpc3RvcnlPcHMgPSBjb250ZXh0LnJlZG9TdGFjay5wb3AoKTtcbiAgICBpZiAoaGlzdG9yeU9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IG51bGw7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMoaGlzdG9yeU9wcywgdHJ1ZSk7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgY29udGV4dC51bmRvU3RhY2sucHVzaChyZXN1bHQucmV2ZXJzZSk7XG4gICAgICBvbkhpc3RvcnlDaGFuZ2UoZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgb3Agb2YgcmVzdWx0Lm9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPSAwO1xuICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gIH1cbiAgZnVuY3Rpb24gYmF0Y2goY2FsbGJhY2spIHtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGxldCByZXR1cm5WYWx1ZSA9IHZvaWQgMDtcbiAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgY29udGV4dC5hY3RpdmVCYXRjaCA9IHtcbiAgICAgICAgb3BzOiBbXSxcbiAgICAgICAgdXBkYXRlczoge1xuICAgICAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgICAgIHByZXNlbmNlOiBmYWxzZSxcbiAgICAgICAgICBvdGhlcnM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHJldmVyc2VPcHM6IFtdXG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29uc3QgY3VycmVudEJhdGNoID0gY29udGV4dC5hY3RpdmVCYXRjaDtcbiAgICAgICAgY29udGV4dC5hY3RpdmVCYXRjaCA9IG51bGw7XG4gICAgICAgIGlmIChjdXJyZW50QmF0Y2gucmV2ZXJzZU9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYWRkVG9VbmRvU3RhY2soY3VycmVudEJhdGNoLnJldmVyc2VPcHMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudEJhdGNoLm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudEJhdGNoLm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZGlzcGF0Y2hPcHMoY3VycmVudEJhdGNoLm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgbm90aWZ5KGN1cnJlbnRCYXRjaC51cGRhdGVzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHBhdXNlSGlzdG9yeSgpIHtcbiAgICBpZiAoY29udGV4dC5wYXVzZWRIaXN0b3J5ID09PSBudWxsKSB7XG4gICAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBbXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVzdW1lSGlzdG9yeSgpIHtcbiAgICBjb25zdCBoaXN0b3J5T3BzID0gY29udGV4dC5wYXVzZWRIaXN0b3J5O1xuICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IG51bGw7XG4gICAgaWYgKGhpc3RvcnlPcHMgIT09IG51bGwgJiYgaGlzdG9yeU9wcy5sZW5ndGggPiAwKSB7XG4gICAgICBfYWRkVG9SZWFsVW5kb1N0YWNrKGhpc3RvcnlPcHMsIGJhdGNoVXBkYXRlcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFN0b3JhZ2VTdGF0dXMoKSB7XG4gICAgaWYgKGNvbnRleHQucm9vdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gX2dldFN0b3JhZ2UkID09PSBudWxsID8gXCJub3QtbG9hZGVkXCIgOiBcImxvYWRpbmdcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMuc2l6ZSA9PT0gMCA/IFwic3luY2hyb25pemVkXCIgOiBcInN5bmNocm9uaXppbmdcIjtcbiAgICB9XG4gIH1cbiAgbGV0IF9sYXN0U3RvcmFnZVN0YXR1cyA9IGdldFN0b3JhZ2VTdGF0dXMoKTtcbiAgZnVuY3Rpb24gbm90aWZ5U3RvcmFnZVN0YXR1cygpIHtcbiAgICBjb25zdCBzdG9yYWdlU3RhdHVzID0gZ2V0U3RvcmFnZVN0YXR1cygpO1xuICAgIGlmIChfbGFzdFN0b3JhZ2VTdGF0dXMgIT09IHN0b3JhZ2VTdGF0dXMpIHtcbiAgICAgIF9sYXN0U3RvcmFnZVN0YXR1cyA9IHN0b3JhZ2VTdGF0dXM7XG4gICAgICBldmVudEh1Yi5zdG9yYWdlU3RhdHVzLm5vdGlmeShzdG9yYWdlU3RhdHVzKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgb3RoZXJzX2ZvckRldlRvb2xzID0gbmV3IERlcml2ZWRSZWYoXG4gICAgY29udGV4dC5vdGhlcnMsXG4gICAgKG90aGVycykgPT4gb3RoZXJzLm1hcCgob3RoZXIsIGluZGV4KSA9PiB1c2VyVG9UcmVlTm9kZShgT3RoZXIgJHtpbmRleH1gLCBvdGhlcikpXG4gICk7XG4gIGNvbnN0IGV2ZW50cyA9IHtcbiAgICBzdGF0dXM6IGV2ZW50SHViLnN0YXR1cy5vYnNlcnZhYmxlLFxuICAgIGxvc3RDb25uZWN0aW9uOiBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5vYnNlcnZhYmxlLFxuICAgIGN1c3RvbUV2ZW50OiBldmVudEh1Yi5jdXN0b21FdmVudC5vYnNlcnZhYmxlLFxuICAgIG90aGVyczogZXZlbnRIdWIub3RoZXJzLm9ic2VydmFibGUsXG4gICAgc2VsZjogZXZlbnRIdWIuc2VsZi5vYnNlcnZhYmxlLFxuICAgIG15UHJlc2VuY2U6IGV2ZW50SHViLm15UHJlc2VuY2Uub2JzZXJ2YWJsZSxcbiAgICBlcnJvcjogZXZlbnRIdWIuZXJyb3Iub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlOiBldmVudEh1Yi5zdG9yYWdlLm9ic2VydmFibGUsXG4gICAgaGlzdG9yeTogZXZlbnRIdWIuaGlzdG9yeS5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VEaWRMb2FkOiBldmVudEh1Yi5zdG9yYWdlRGlkTG9hZC5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VTdGF0dXM6IGV2ZW50SHViLnN0b3JhZ2VTdGF0dXMub2JzZXJ2YWJsZSxcbiAgICB5ZG9jOiBldmVudEh1Yi55ZG9jLm9ic2VydmFibGUsXG4gICAgY29tbWVudHM6IGV2ZW50SHViLmNvbW1lbnRzLm9ic2VydmFibGVcbiAgfTtcbiAgY29uc3QgY29tbWVudHNBcGkgPSBjcmVhdGVDb21tZW50c0FwaShjb25maWcucm9vbUlkLCBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlLCB7XG4gICAgYmFzZVVybDogY29uZmlnLmJhc2VVcmxcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAge1xuICAgICAgLyogTk9URTogRXhwb3NpbmcgX19pbnRlcm5hbCBoZXJlIG9ubHkgdG8gYWxsb3cgdGVzdGluZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIGluIHVuaXQgdGVzdHMgKi9cbiAgICAgIF9faW50ZXJuYWw6IHtcbiAgICAgICAgZ2V0IHByZXNlbmNlQnVmZmVyKCkge1xuICAgICAgICAgIHJldHVybiBkZWVwQ2xvbmUoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzPy5kYXRhID8/IG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgZ2V0IHVuZG9TdGFjaygpIHtcbiAgICAgICAgICByZXR1cm4gZGVlcENsb25lKGNvbnRleHQudW5kb1N0YWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGdldCBub2RlQ291bnQoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQubm9kZXMuc2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIHRoZSBMaXZlYmxvY2tzIGJyb3dzZXIgZXh0ZW5zaW9uXG4gICAgICAgIGdldFNlbGZfZm9yRGV2VG9vbHM6ICgpID0+IHNlbGZBc1RyZWVOb2RlLmN1cnJlbnQsXG4gICAgICAgIGdldE90aGVyc19mb3JEZXZUb29sczogKCkgPT4gb3RoZXJzX2ZvckRldlRvb2xzLmN1cnJlbnQsXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBzaW11bGF0ZToge1xuICAgICAgICAgIC8vIFRoZXNlIGV4aXN0IG9ubHkgZm9yIG91ciBFMkUgdGVzdGluZyBhcHBcbiAgICAgICAgICBleHBsaWNpdENsb3NlOiAoZXZlbnQpID0+IG1hbmFnZWRTb2NrZXQuX3ByaXZhdGVTZW5kTWFjaGluZUV2ZW50KHsgdHlwZTogXCJFWFBMSUNJVF9TT0NLRVRfQ0xPU0VcIiwgZXZlbnQgfSksXG4gICAgICAgICAgcmF3U2VuZDogKGRhdGEpID0+IG1hbmFnZWRTb2NrZXQuc2VuZChkYXRhKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaWQ6IGNvbmZpZy5yb29tSWQsXG4gICAgICBzdWJzY3JpYmU6IG1ha2VDbGFzc2ljU3Vic2NyaWJlRm4oZXZlbnRzKSxcbiAgICAgIGNvbm5lY3Q6ICgpID0+IG1hbmFnZWRTb2NrZXQuY29ubmVjdCgpLFxuICAgICAgcmVjb25uZWN0OiAoKSA9PiBtYW5hZ2VkU29ja2V0LnJlY29ubmVjdCgpLFxuICAgICAgZGlzY29ubmVjdDogKCkgPT4gbWFuYWdlZFNvY2tldC5kaXNjb25uZWN0KCksXG4gICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgIHVuaW5zdGFsbEJnVGFiU3B5KCk7XG4gICAgICAgIG1hbmFnZWRTb2NrZXQuZGVzdHJveSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFByZXNlbmNlXG4gICAgICB1cGRhdGVQcmVzZW5jZSxcbiAgICAgIHVwZGF0ZVlEb2MsXG4gICAgICBicm9hZGNhc3RFdmVudCxcbiAgICAgIC8vIFN0b3JhZ2VcbiAgICAgIGJhdGNoLFxuICAgICAgaGlzdG9yeToge1xuICAgICAgICB1bmRvLFxuICAgICAgICByZWRvLFxuICAgICAgICBjYW5VbmRvLFxuICAgICAgICBjYW5SZWRvLFxuICAgICAgICBjbGVhcixcbiAgICAgICAgcGF1c2U6IHBhdXNlSGlzdG9yeSxcbiAgICAgICAgcmVzdW1lOiByZXN1bWVIaXN0b3J5XG4gICAgICB9LFxuICAgICAgZmV0Y2hZRG9jLFxuICAgICAgZ2V0U3RvcmFnZSxcbiAgICAgIGdldFN0b3JhZ2VTbmFwc2hvdCxcbiAgICAgIGdldFN0b3JhZ2VTdGF0dXMsXG4gICAgICBldmVudHMsXG4gICAgICAvLyBDb3JlXG4gICAgICBnZXRTdGF0dXM6ICgpID0+IG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCksXG4gICAgICBnZXRDb25uZWN0aW9uU3RhdGU6ICgpID0+IG1hbmFnZWRTb2NrZXQuZ2V0TGVnYWN5U3RhdHVzKCksXG4gICAgICBnZXRTZWxmOiAoKSA9PiBzZWxmLmN1cnJlbnQsXG4gICAgICAvLyBQcmVzZW5jZVxuICAgICAgZ2V0UHJlc2VuY2U6ICgpID0+IGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50LFxuICAgICAgZ2V0T3RoZXJzOiAoKSA9PiBjb250ZXh0Lm90aGVycy5jdXJyZW50LFxuICAgICAgLi4uY29tbWVudHNBcGlcbiAgICB9LFxuICAgIC8vIEV4cGxpY3RseSBtYWtlIHRoZSBfX2ludGVybmFsIGZpZWxkIG5vbi1lbnVtZXJhYmxlLCB0byBhdm9pZCBhZ2dyZXNzaXZlXG4gICAgLy8gZnJlZXppbmcgd2hlbiB1c2VkIHdpdGggSW1tZXJcbiAgICBcIl9faW50ZXJuYWxcIixcbiAgICB7IGVudW1lcmFibGU6IGZhbHNlIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIG1ha2VDbGFzc2ljU3Vic2NyaWJlRm4oZXZlbnRzKSB7XG4gIGZ1bmN0aW9uIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZURlZXBseShub2RlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBldmVudHMuc3RvcmFnZS5zdWJzY3JpYmUoKHVwZGF0ZXMpID0+IHtcbiAgICAgIGNvbnN0IHJlbGF0ZWRVcGRhdGVzID0gdXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICh1cGRhdGUpID0+IGlzU2FtZU5vZGVPckNoaWxkT2YodXBkYXRlLm5vZGUsIG5vZGUpXG4gICAgICApO1xuICAgICAgaWYgKHJlbGF0ZWRVcGRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2FsbGJhY2socmVsYXRlZFVwZGF0ZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZVNoYWxsb3dseShub2RlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBldmVudHMuc3RvcmFnZS5zdWJzY3JpYmUoKHVwZGF0ZXMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdXBkYXRlIG9mIHVwZGF0ZXMpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5ub2RlLl9pZCA9PT0gbm9kZS5faWQpIHtcbiAgICAgICAgICBjYWxsYmFjayh1cGRhdGUubm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUoZmlyc3QsIHNlY29uZCwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZmlyc3QgPT09IFwic3RyaW5nXCIgJiYgaXNSb29tRXZlbnROYW1lKGZpcnN0KSkge1xuICAgICAgaWYgKHR5cGVvZiBzZWNvbmQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FsbGJhY2sgPSBzZWNvbmQ7XG4gICAgICBzd2l0Y2ggKGZpcnN0KSB7XG4gICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuY3VzdG9tRXZlbnQuc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwibXktcHJlc2VuY2VcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLm15UHJlc2VuY2Uuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcIm90aGVyc1wiOiB7XG4gICAgICAgICAgY29uc3QgY2IgPSBjYWxsYmFjaztcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLm90aGVycy5zdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG90aGVycywgLi4uaW50ZXJuYWxFdmVudCB9ID0gZXZlbnQ7XG4gICAgICAgICAgICByZXR1cm4gY2Iob3RoZXJzLCBpbnRlcm5hbEV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmVycm9yLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJjb25uZWN0aW9uXCI6IHtcbiAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrO1xuICAgICAgICAgIHJldHVybiBldmVudHMuc3RhdHVzLnN1YnNjcmliZShcbiAgICAgICAgICAgIChzdGF0dXMpID0+IGNiKG5ld1RvTGVnYWN5U3RhdHVzKHN0YXR1cykpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwic3RhdHVzXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcImxvc3QtY29ubmVjdGlvblwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMubG9zdENvbm5lY3Rpb24uc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiaGlzdG9yeVwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuaGlzdG9yeS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwic3RvcmFnZS1zdGF0dXNcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2VTdGF0dXMuc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBhc3NlcnROZXZlcihcbiAgICAgICAgICAgIGZpcnN0LFxuICAgICAgICAgICAgYFwiJHtTdHJpbmcoZmlyc3QpfVwiIGlzIG5vdCBhIHZhbGlkIGV2ZW50IG5hbWVgXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlY29uZCA9PT0gdm9pZCAwIHx8IHR5cGVvZiBmaXJzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAodHlwZW9mIGZpcnN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNhbGxiYWNrID0gZmlyc3Q7XG4gICAgICAgIHJldHVybiBldmVudHMuc3RvcmFnZS5zdWJzY3JpYmUoc3RvcmFnZUNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBzcGVjaWZ5IGEgbGlzdGVuZXIgY2FsbGJhY2tcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0xpdmVOb2RlKGZpcnN0KSkge1xuICAgICAgY29uc3Qgbm9kZSA9IGZpcnN0O1xuICAgICAgaWYgKG9wdGlvbnM/LmlzRGVlcCkge1xuICAgICAgICBjb25zdCBzdG9yYWdlQ2FsbGJhY2sgPSBzZWNvbmQ7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVEZWVwbHkobm9kZSwgc3RvcmFnZUNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vZGVDYWxsYmFjayA9IHNlY29uZDtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZVNoYWxsb3dseShub2RlLCBub2RlQ2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgJHtTdHJpbmcoZmlyc3QpfSBpcyBub3QgYSB2YWx1ZSB0aGF0IGNhbiBiZSBzdWJzY3JpYmVkIHRvLmBcbiAgICApO1xuICB9XG4gIHJldHVybiBzdWJzY3JpYmU7XG59XG5mdW5jdGlvbiBpc1Jvb21FdmVudE5hbWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcIm15LXByZXNlbmNlXCIgfHwgdmFsdWUgPT09IFwib3RoZXJzXCIgfHwgdmFsdWUgPT09IFwiZXZlbnRcIiB8fCB2YWx1ZSA9PT0gXCJlcnJvclwiIHx8IHZhbHVlID09PSBcImhpc3RvcnlcIiB8fCB2YWx1ZSA9PT0gXCJzdGF0dXNcIiB8fCB2YWx1ZSA9PT0gXCJzdG9yYWdlLXN0YXR1c1wiIHx8IHZhbHVlID09PSBcImxvc3QtY29ubmVjdGlvblwiIHx8IHZhbHVlID09PSBcImNvbm5lY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIG1ha2VBdXRoRGVsZWdhdGVGb3JSb29tKHJvb21JZCwgYXV0aE1hbmFnZXIpIHtcbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICByZXR1cm4gYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKFwicm9vbTpyZWFkXCIsIHJvb21JZCk7XG4gIH07XG59XG5mdW5jdGlvbiBtYWtlQ3JlYXRlU29ja2V0RGVsZWdhdGVGb3JSb29tKHJvb21JZCwgYmFzZVVybCwgV2ViU29ja2V0UG9seWZpbGwpIHtcbiAgcmV0dXJuIChhdXRoVmFsdWUpID0+IHtcbiAgICBjb25zdCB3cyA9IFdlYlNvY2tldFBvbHlmaWxsID8/ICh0eXBlb2YgV2ViU29ja2V0ID09PSBcInVuZGVmaW5lZFwiID8gdm9pZCAwIDogV2ViU29ja2V0KTtcbiAgICBpZiAod3MgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhcbiAgICAgICAgXCJUbyB1c2UgTGl2ZWJsb2NrcyBjbGllbnQgaW4gYSBub24tRE9NIGVudmlyb25tZW50LCB5b3UgbmVlZCB0byBwcm92aWRlIGEgV2ViU29ja2V0IHBvbHlmaWxsLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGJhc2VVcmwpO1xuICAgIHVybC5wcm90b2NvbCA9IHVybC5wcm90b2NvbCA9PT0gXCJodHRwOlwiID8gXCJ3c1wiIDogXCJ3c3NcIjtcbiAgICB1cmwucGF0aG5hbWUgPSBcIi92N1wiO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwicm9vbUlkXCIsIHJvb21JZCk7XG4gICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInRva1wiLCBhdXRoVmFsdWUudG9rZW4ucmF3KTtcbiAgICB9IGVsc2UgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInB1YmtleVwiLCBhdXRoVmFsdWUucHVibGljQXBpS2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKGF1dGhWYWx1ZSwgXCJVbmhhbmRsZWQgY2FzZVwiKTtcbiAgICB9XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ2ZXJzaW9uXCIsIFBLR19WRVJTSU9OIHx8IFwiZGV2XCIpO1xuICAgIHJldHVybiBuZXcgd3ModXJsLnRvU3RyaW5nKCkpO1xuICB9O1xufVxuXG4vLyBzcmMvY2xpZW50LnRzXG52YXIgTUlOX1RIUk9UVExFID0gMTY7XG52YXIgTUFYX1RIUk9UVExFID0gMWUzO1xudmFyIERFRkFVTFRfVEhST1RUTEUgPSAxMDA7XG52YXIgTUlOX0JBQ0tHUk9VTkRfS0VFUF9BTElWRV9USU1FT1VUID0gMTVlMztcbnZhciBNSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAyMDA7XG52YXIgUkVDT01NRU5ERURfTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gMWUzO1xudmFyIE1BWF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDNlNDtcbnZhciBERUZBVUxUX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gNWUzO1xuZnVuY3Rpb24gZ2V0QmFzZVVybEZyb21DbGllbnRPcHRpb25zKGNsaWVudE9wdGlvbnMpIHtcbiAgaWYgKFwibGl2ZWJsb2Nrc1NlcnZlclwiIGluIGNsaWVudE9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDbGllbnQgb3B0aW9uIG5vIGxvbmdlciBzdXBwb3J0ZWRcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBjbGllbnRPcHRpb25zLmJhc2VVcmwgPT09IFwic3RyaW5nXCIgJiYgY2xpZW50T3B0aW9ucy5iYXNlVXJsLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgcmV0dXJuIGNsaWVudE9wdGlvbnMuYmFzZVVybDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gREVGQVVMVF9CQVNFX1VSTDtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50KG9wdGlvbnMpIHtcbiAgY29uc3QgY2xpZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gIGNvbnN0IHRocm90dGxlRGVsYXkgPSBnZXRUaHJvdHRsZShjbGllbnRPcHRpb25zLnRocm90dGxlID8/IERFRkFVTFRfVEhST1RUTEUpO1xuICBjb25zdCBsb3N0Q29ubmVjdGlvblRpbWVvdXQgPSBnZXRMb3N0Q29ubmVjdGlvblRpbWVvdXQoXG4gICAgY2xpZW50T3B0aW9ucy5sb3N0Q29ubmVjdGlvblRpbWVvdXQgPz8gREVGQVVMVF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVFxuICApO1xuICBjb25zdCBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCA9IGdldEJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0KFxuICAgIGNsaWVudE9wdGlvbnMuYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRcbiAgKTtcbiAgY29uc3QgYXV0aE1hbmFnZXIgPSBjcmVhdGVBdXRoTWFuYWdlcihvcHRpb25zKTtcbiAgY29uc3Qgcm9vbXNCeUlkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZnVuY3Rpb24gdGVhcmRvd25Sb29tKHJvb20pIHtcbiAgICB1bmxpbmtEZXZUb29scyhyb29tLmlkKTtcbiAgICByb29tc0J5SWQuZGVsZXRlKHJvb20uaWQpO1xuICAgIHJvb20uZGVzdHJveSgpO1xuICB9XG4gIGZ1bmN0aW9uIGxlYXNlUm9vbShpbmZvKSB7XG4gICAgY29uc3QgbGVhdmUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzZWxmID0gbGVhdmU7XG4gICAgICBpZiAoIWluZm8udW5zdWJzLmRlbGV0ZShzZWxmKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiVGhpcyBsZWF2ZSBmdW5jdGlvbiB3YXMgYWxyZWFkeSBjYWxsZWQuIENhbGxpbmcgaXQgbW9yZSB0aGFuIG9uY2UgaGFzIG5vIGVmZmVjdC5cIlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGluZm8udW5zdWJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICB0ZWFyZG93blJvb20oaW5mby5yb29tKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgaW5mby51bnN1YnMuYWRkKGxlYXZlKTtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vbTogaW5mby5yb29tLFxuICAgICAgbGVhdmVcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGVudGVyUm9vbShyb29tSWQsIG9wdGlvbnMyKSB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSByb29tc0J5SWQuZ2V0KHJvb21JZCk7XG4gICAgaWYgKGV4aXN0aW5nICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsZWFzZVJvb20oZXhpc3RpbmcpO1xuICAgIH1cbiAgICBkZXByZWNhdGVJZihcbiAgICAgIG9wdGlvbnMyLmluaXRpYWxQcmVzZW5jZSA9PT0gbnVsbCB8fCBvcHRpb25zMi5pbml0aWFsUHJlc2VuY2UgPT09IHZvaWQgMCxcbiAgICAgIFwiUGxlYXNlIHByb3ZpZGUgYW4gaW5pdGlhbCBwcmVzZW5jZSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgdXNlciB3aGVuIGVudGVyaW5nIHRoZSByb29tLlwiXG4gICAgKTtcbiAgICBjb25zdCBiYXNlVXJsID0gZ2V0QmFzZVVybEZyb21DbGllbnRPcHRpb25zKGNsaWVudE9wdGlvbnMpO1xuICAgIGNvbnN0IG5ld1Jvb20gPSBjcmVhdGVSb29tKFxuICAgICAge1xuICAgICAgICBpbml0aWFsUHJlc2VuY2U6IG9wdGlvbnMyLmluaXRpYWxQcmVzZW5jZSA/PyB7fSxcbiAgICAgICAgaW5pdGlhbFN0b3JhZ2U6IG9wdGlvbnMyLmluaXRpYWxTdG9yYWdlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByb29tSWQsXG4gICAgICAgIHRocm90dGxlRGVsYXksXG4gICAgICAgIGxvc3RDb25uZWN0aW9uVGltZW91dCxcbiAgICAgICAgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQsXG4gICAgICAgIHBvbHlmaWxsczogY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHMsXG4gICAgICAgIGRlbGVnYXRlczogY2xpZW50T3B0aW9ucy5tb2NrZWREZWxlZ2F0ZXMgPz8ge1xuICAgICAgICAgIGNyZWF0ZVNvY2tldDogbWFrZUNyZWF0ZVNvY2tldERlbGVnYXRlRm9yUm9vbShcbiAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgIGJhc2VVcmwsXG4gICAgICAgICAgICBjbGllbnRPcHRpb25zLnBvbHlmaWxscz8uV2ViU29ja2V0XG4gICAgICAgICAgKSxcbiAgICAgICAgICBhdXRoZW50aWNhdGU6IG1ha2VBdXRoRGVsZWdhdGVGb3JSb29tKHJvb21JZCwgYXV0aE1hbmFnZXIpXG4gICAgICAgIH0sXG4gICAgICAgIGVuYWJsZURlYnVnTG9nZ2luZzogY2xpZW50T3B0aW9ucy5lbmFibGVEZWJ1Z0xvZ2dpbmcsXG4gICAgICAgIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBvcHRpb25zMj8udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMsXG4gICAgICAgIGJhc2VVcmwsXG4gICAgICAgIHVuc3RhYmxlX2ZhbGxiYWNrVG9IVFRQOiAhIWNsaWVudE9wdGlvbnMudW5zdGFibGVfZmFsbGJhY2tUb0hUVFAsXG4gICAgICAgIHVuc3RhYmxlX3N0cmVhbURhdGE6ICEhY2xpZW50T3B0aW9ucy51bnN0YWJsZV9zdHJlYW1EYXRhXG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBuZXdSb29tSW5mbyA9IHtcbiAgICAgIHJvb206IG5ld1Jvb20sXG4gICAgICB1bnN1YnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgICB9O1xuICAgIHJvb21zQnlJZC5zZXQocm9vbUlkLCBuZXdSb29tSW5mbyk7XG4gICAgc2V0dXBEZXZUb29scygoKSA9PiBBcnJheS5mcm9tKHJvb21zQnlJZC5rZXlzKCkpKTtcbiAgICBsaW5rRGV2VG9vbHMocm9vbUlkLCBuZXdSb29tKTtcbiAgICBjb25zdCBzaG91bGRDb25uZWN0ID0gb3B0aW9uczIuYXV0b0Nvbm5lY3QgPz8gb3B0aW9uczIuc2hvdWxkSW5pdGlhbGx5Q29ubmVjdCA/PyB0cnVlO1xuICAgIGlmIChzaG91bGRDb25uZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIGF0b2IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKGNsaWVudE9wdGlvbnMucG9seWZpbGxzPy5hdG9iID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIllvdSBuZWVkIHRvIHBvbHlmaWxsIGF0b2IgdG8gdXNlIHRoZSBjbGllbnQgaW4geW91ciBlbnZpcm9ubWVudC4gUGxlYXNlIGZvbGxvdyB0aGUgaW5zdHJ1Y3Rpb25zIGF0IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2Vycm9ycy9saXZlYmxvY2tzLWNsaWVudC9hdG9iLXBvbHlmaWxsXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbC5hdG9iID0gY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHMuYXRvYjtcbiAgICAgIH1cbiAgICAgIG5ld1Jvb20uY29ubmVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gbGVhc2VSb29tKG5ld1Jvb21JbmZvKTtcbiAgfVxuICBmdW5jdGlvbiBlbnRlcihyb29tSWQsIG9wdGlvbnMyKSB7XG4gICAgY29uc3QgeyByb29tLCBsZWF2ZTogXyB9ID0gZW50ZXJSb29tKHJvb21JZCwgb3B0aW9uczIpO1xuICAgIHJldHVybiByb29tO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJvb20ocm9vbUlkKSB7XG4gICAgY29uc3Qgcm9vbSA9IHJvb21zQnlJZC5nZXQocm9vbUlkKT8ucm9vbTtcbiAgICByZXR1cm4gcm9vbSA/IHJvb20gOiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGZvcmNlTGVhdmUocm9vbUlkKSB7XG4gICAgY29uc3QgdW5zdWJzID0gcm9vbXNCeUlkLmdldChyb29tSWQpPy51bnN1YnMgPz8gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHVuc3ViIG9mIHVuc3Vicykge1xuICAgICAgdW5zdWIoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbG9nb3V0KCkge1xuICAgIGF1dGhNYW5hZ2VyLnJlc2V0KCk7XG4gICAgZm9yIChjb25zdCB7IHJvb20gfSBvZiByb29tc0J5SWQudmFsdWVzKCkpIHtcbiAgICAgIGlmICghaXNJZGxlKHJvb20uZ2V0U3RhdHVzKCkpKSB7XG4gICAgICAgIHJvb20ucmVjb25uZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbG9nb3V0LFxuICAgIC8vIE9sZCwgZGVwcmVjYXRlZCBBUElzXG4gICAgZW50ZXIsXG4gICAgZ2V0Um9vbSxcbiAgICBsZWF2ZTogZm9yY2VMZWF2ZSxcbiAgICAvLyBOZXcsIHByZWZlcnJlZCBBUElcbiAgICBlbnRlclJvb21cbiAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrQm91bmRzKG9wdGlvbiwgdmFsdWUsIG1pbiwgbWF4LCByZWNvbW1lbmRlZE1pbikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8IHZhbHVlIDwgbWluIHx8IG1heCAhPT0gdm9pZCAwICYmIHZhbHVlID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgbWF4ICE9PSB2b2lkIDAgPyBgJHtvcHRpb259IHNob3VsZCBiZSBiZXR3ZWVuICR7cmVjb21tZW5kZWRNaW4gPz8gbWlufSBhbmQgJHttYXh9LmAgOiBgJHtvcHRpb259IHNob3VsZCBiZSBhdCBsZWFzdCAke3JlY29tbWVuZGVkTWluID8/IG1pbn0uYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgcmV0dXJuIGNoZWNrQm91bmRzKFxuICAgIFwiYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRcIixcbiAgICB2YWx1ZSxcbiAgICBNSU5fQkFDS0dST1VORF9LRUVQX0FMSVZFX1RJTUVPVVRcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFRocm90dGxlKHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JvdW5kcyhcInRocm90dGxlXCIsIHZhbHVlLCBNSU5fVEhST1RUTEUsIE1BWF9USFJPVFRMRSk7XG59XG5mdW5jdGlvbiBnZXRMb3N0Q29ubmVjdGlvblRpbWVvdXQodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm91bmRzKFxuICAgIFwibG9zdENvbm5lY3Rpb25UaW1lb3V0XCIsXG4gICAgdmFsdWUsXG4gICAgTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VULFxuICAgIE1BWF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCxcbiAgICBSRUNPTU1FTkRFRF9NSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVRcbiAgKTtcbn1cblxuLy8gc3JjL2NyZHRzL3V0aWxzLnRzXG5mdW5jdGlvbiB0b1BsYWluTHNvbihsc29uKSB7XG4gIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZU9iamVjdCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICBkYXRhOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGxzb24udG9PYmplY3QoKSkuZmxhdE1hcChcbiAgICAgICAgICAoW2tleSwgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdm9pZCAwID8gW1trZXksIHRvUGxhaW5Mc29uKHZhbHVlKV1dIDogW11cbiAgICAgICAgKVxuICAgICAgKVxuICAgIH07XG4gIH0gZWxzZSBpZiAobHNvbiBpbnN0YW5jZW9mIExpdmVNYXApIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl2ZWJsb2Nrc1R5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgZGF0YTogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBbLi4ubHNvbl0ubWFwKChba2V5LCB2YWx1ZV0pID0+IFtrZXksIHRvUGxhaW5Mc29uKHZhbHVlKV0pXG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl2ZWJsb2Nrc1R5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICAgIGRhdGE6IFsuLi5sc29uXS5tYXAoKGl0ZW0pID0+IHRvUGxhaW5Mc29uKGl0ZW0pKVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxzb247XG4gIH1cbn1cblxuLy8gc3JjL2ltbXV0YWJsZS50c1xuZnVuY3Rpb24gbHNvbk9iamVjdFRvSnNvbihvYmopIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGNvbnN0IHZhbCA9IG9ialtrZXldO1xuICAgIGlmICh2YWwgIT09IHZvaWQgMCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBsc29uVG9Kc29uKHZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsaXZlT2JqZWN0VG9Kc29uKGxpdmVPYmplY3QpIHtcbiAgcmV0dXJuIGxzb25PYmplY3RUb0pzb24obGl2ZU9iamVjdC50b09iamVjdCgpKTtcbn1cbmZ1bmN0aW9uIGxpdmVNYXBUb0pzb24obWFwKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXAuZW50cmllcygpKSB7XG4gICAgcmVzdWx0W2tleV0gPSBsc29uVG9Kc29uKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbHNvbkxpc3RUb0pzb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLm1hcChsc29uVG9Kc29uKTtcbn1cbmZ1bmN0aW9uIGxpdmVMaXN0VG9Kc29uKHZhbHVlKSB7XG4gIHJldHVybiBsc29uTGlzdFRvSnNvbih2YWx1ZS50b0FycmF5KCkpO1xufVxuZnVuY3Rpb24gbHNvblRvSnNvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlT2JqZWN0KSB7XG4gICAgcmV0dXJuIGxpdmVPYmplY3RUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4gbGl2ZUxpc3RUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZU1hcCkge1xuICAgIHJldHVybiBsaXZlTWFwVG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcikge1xuICAgIHJldHVybiB2YWx1ZS5kYXRhO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBsc29uTGlzdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbHNvbk9iamVjdFRvSnNvbih2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZGVlcExpdmVpZnkodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlTGlzdCh2YWx1ZS5tYXAoZGVlcExpdmVpZnkpKTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIGNvbnN0IGluaXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgY29uc3QgdmFsID0gdmFsdWVba2V5XTtcbiAgICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGluaXRba2V5XSA9IGRlZXBMaXZlaWZ5KHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGl2ZU9iamVjdChpbml0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZUxpc3QobGl2ZUxpc3QsIHByZXYsIG5leHQpIHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgcHJldkVuZCA9IHByZXYubGVuZ3RoIC0gMTtcbiAgbGV0IG5leHRFbmQgPSBuZXh0Lmxlbmd0aCAtIDE7XG4gIGxldCBwcmV2Tm9kZSA9IHByZXZbMF07XG4gIGxldCBuZXh0Tm9kZSA9IG5leHRbMF07XG4gIG91dGVyOiB7XG4gICAgd2hpbGUgKHByZXZOb2RlID09PSBuZXh0Tm9kZSkge1xuICAgICAgKytpO1xuICAgICAgaWYgKGkgPiBwcmV2RW5kIHx8IGkgPiBuZXh0RW5kKSB7XG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgcHJldk5vZGUgPSBwcmV2W2ldO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W2ldO1xuICAgIH1cbiAgICBwcmV2Tm9kZSA9IHByZXZbcHJldkVuZF07XG4gICAgbmV4dE5vZGUgPSBuZXh0W25leHRFbmRdO1xuICAgIHdoaWxlIChwcmV2Tm9kZSA9PT0gbmV4dE5vZGUpIHtcbiAgICAgIHByZXZFbmQtLTtcbiAgICAgIG5leHRFbmQtLTtcbiAgICAgIGlmIChpID4gcHJldkVuZCB8fCBpID4gbmV4dEVuZCkge1xuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIHByZXZOb2RlID0gcHJldltwcmV2RW5kXTtcbiAgICAgIG5leHROb2RlID0gbmV4dFtuZXh0RW5kXTtcbiAgICB9XG4gIH1cbiAgaWYgKGkgPiBwcmV2RW5kKSB7XG4gICAgaWYgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgd2hpbGUgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgICBsaXZlTGlzdC5pbnNlcnQoZGVlcExpdmVpZnkobmV4dFtpXSksIGkpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGkgPiBuZXh0RW5kKSB7XG4gICAgbGV0IGxvY2FsSSA9IGk7XG4gICAgd2hpbGUgKGxvY2FsSSA8PSBwcmV2RW5kKSB7XG4gICAgICBsaXZlTGlzdC5kZWxldGUoaSk7XG4gICAgICBsb2NhbEkrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGkgPD0gcHJldkVuZCAmJiBpIDw9IG5leHRFbmQpIHtcbiAgICAgIHByZXZOb2RlID0gcHJldltpXTtcbiAgICAgIG5leHROb2RlID0gbmV4dFtpXTtcbiAgICAgIGNvbnN0IGxpdmVMaXN0Tm9kZSA9IGxpdmVMaXN0LmdldChpKTtcbiAgICAgIGlmIChpc0xpdmVPYmplY3QobGl2ZUxpc3ROb2RlKSAmJiBpc1BsYWluT2JqZWN0KHByZXZOb2RlKSAmJiBpc1BsYWluT2JqZWN0KG5leHROb2RlKSkge1xuICAgICAgICBwYXRjaExpdmVPYmplY3QobGl2ZUxpc3ROb2RlLCBwcmV2Tm9kZSwgbmV4dE5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGl2ZUxpc3Quc2V0KGksIGRlZXBMaXZlaWZ5KG5leHROb2RlKSk7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHdoaWxlIChpIDw9IG5leHRFbmQpIHtcbiAgICAgIGxpdmVMaXN0Lmluc2VydChkZWVwTGl2ZWlmeShuZXh0W2ldKSwgaSk7XG4gICAgICBpKys7XG4gICAgfVxuICAgIGxldCBsb2NhbEkgPSBpO1xuICAgIHdoaWxlIChsb2NhbEkgPD0gcHJldkVuZCkge1xuICAgICAgbGl2ZUxpc3QuZGVsZXRlKGkpO1xuICAgICAgbG9jYWxJKys7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwYXRjaExpdmVPYmplY3RLZXkobGl2ZU9iamVjdCwga2V5LCBwcmV2LCBuZXh0KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCBub25TZXJpYWxpemFibGVWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShuZXh0KTtcbiAgICBpZiAobm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcbiAgICAgIGVycm9yMihcbiAgICAgICAgYE5ldyBzdGF0ZSBwYXRoOiAnJHtub25TZXJpYWxpemFibGVWYWx1ZS5wYXRofScgdmFsdWU6ICcke1N0cmluZyhcbiAgICAgICAgICBub25TZXJpYWxpemFibGVWYWx1ZS52YWx1ZVxuICAgICAgICApfScgaXMgbm90IHNlcmlhbGl6YWJsZS5cbk9ubHkgc2VyaWFsaXphYmxlIHZhbHVlIGNhbiBiZSBzeW5jZWQgd2l0aCBMaXZlYmxvY2tzLmBcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGNvbnN0IHZhbHVlID0gbGl2ZU9iamVjdC5nZXQoa2V5KTtcbiAgaWYgKG5leHQgPT09IHZvaWQgMCkge1xuICAgIGxpdmVPYmplY3QuZGVsZXRlKGtleSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIGxpdmVPYmplY3Quc2V0KGtleSwgZGVlcExpdmVpZnkobmV4dCkpO1xuICB9IGVsc2UgaWYgKHByZXYgPT09IG5leHQpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoaXNMaXZlTGlzdCh2YWx1ZSkgJiYgQXJyYXkuaXNBcnJheShwcmV2KSAmJiBBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgcGF0Y2hMaXZlTGlzdCh2YWx1ZSwgcHJldiwgbmV4dCk7XG4gIH0gZWxzZSBpZiAoaXNMaXZlT2JqZWN0KHZhbHVlKSAmJiBpc1BsYWluT2JqZWN0KHByZXYpICYmIGlzUGxhaW5PYmplY3QobmV4dCkpIHtcbiAgICBwYXRjaExpdmVPYmplY3QodmFsdWUsIHByZXYsIG5leHQpO1xuICB9IGVsc2Uge1xuICAgIGxpdmVPYmplY3Quc2V0KGtleSwgZGVlcExpdmVpZnkobmV4dCkpO1xuICB9XG59XG5mdW5jdGlvbiBwYXRjaExpdmVPYmplY3Qocm9vdCwgcHJldiwgbmV4dCkge1xuICBjb25zdCB1cGRhdGVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcbiAgICBwYXRjaExpdmVPYmplY3RLZXkocm9vdCwga2V5LCBwcmV2W2tleV0sIG5leHRba2V5XSk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gcHJldikge1xuICAgIGlmIChuZXh0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgcm9vdC5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICByb290LnVwZGF0ZSh1cGRhdGVzKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UGFyZW50c1BhdGgobm9kZSkge1xuICBjb25zdCBwYXRoID0gW107XG4gIHdoaWxlIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgaWYgKGlzTGl2ZUxpc3Qobm9kZS5wYXJlbnQubm9kZSkpIHtcbiAgICAgIHBhdGgucHVzaChub2RlLnBhcmVudC5ub2RlLl9pbmRleE9mUG9zaXRpb24obm9kZS5wYXJlbnQua2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGgucHVzaChub2RlLnBhcmVudC5rZXkpO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnQubm9kZTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdChzdGF0ZSwgdXBkYXRlcykge1xuICByZXR1cm4gdXBkYXRlcy5yZWR1Y2UoXG4gICAgKHN0YXRlMiwgdXBkYXRlKSA9PiBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3RXaXRoVXBkYXRlKHN0YXRlMiwgdXBkYXRlKSxcbiAgICBzdGF0ZVxuICApO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0V2l0aFVwZGF0ZShzdGF0ZSwgdXBkYXRlKSB7XG4gIGNvbnN0IHBhdGggPSBnZXRQYXJlbnRzUGF0aCh1cGRhdGUubm9kZSk7XG4gIHJldHVybiBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKHN0YXRlLCBwYXRoLCB1cGRhdGUpO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShzdGF0ZSwgcGF0aCwgdXBkYXRlKSB7XG4gIGNvbnN0IHBhdGhJdGVtID0gcGF0aC5wb3AoKTtcbiAgaWYgKHBhdGhJdGVtID09PSB2b2lkIDApIHtcbiAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIFwiTGl2ZU9iamVjdFwiOiB7XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWw6IHJlY2VpdmVkIHVwZGF0ZSBvbiBMaXZlT2JqZWN0IGJ1dCBzdGF0ZSB3YXMgbm90IGFuIG9iamVjdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdXBkYXRlLnVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gdXBkYXRlLm5vZGUuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IGxzb25Ub0pzb24odmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTGl2ZUxpc3RcIjoge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbDogcmVjZWl2ZWQgdXBkYXRlIG9uIExpdmVMaXN0IGJ1dCBzdGF0ZSB3YXMgbm90IGFuIGFycmF5XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdTdGF0ZSA9IHN0YXRlLm1hcCgoeCkgPT4geCk7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdFVwZGF0ZSBvZiB1cGRhdGUudXBkYXRlcykge1xuICAgICAgICAgIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwic2V0XCIpIHtcbiAgICAgICAgICAgIG5ld1N0YXRlID0gbmV3U3RhdGUubWFwKFxuICAgICAgICAgICAgICAoaXRlbSwgaW5kZXgpID0+IGluZGV4ID09PSBsaXN0VXBkYXRlLmluZGV4ID8gbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pIDogaXRlbVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJpbnNlcnRcIikge1xuICAgICAgICAgICAgaWYgKGxpc3RVcGRhdGUuaW5kZXggPT09IG5ld1N0YXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZS5wdXNoKGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZSgwLCBsaXN0VXBkYXRlLmluZGV4KSxcbiAgICAgICAgICAgICAgICBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5pbmRleClcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgbmV3U3RhdGUuc3BsaWNlKGxpc3RVcGRhdGUuaW5kZXgsIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcIm1vdmVcIikge1xuICAgICAgICAgICAgaWYgKGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCA+IGxpc3RVcGRhdGUuaW5kZXgpIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoMCwgbGlzdFVwZGF0ZS5pbmRleCksXG4gICAgICAgICAgICAgICAgbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUuaW5kZXgsIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4ICsgMSlcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gW1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKDAsIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoXG4gICAgICAgICAgICAgICAgICBsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXggKyAxLFxuICAgICAgICAgICAgICAgICAgbGlzdFVwZGF0ZS5pbmRleCArIDFcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLmluZGV4ICsgMSlcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkxpdmVNYXBcIjoge1xuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChzdGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsOiByZWNlaXZlZCB1cGRhdGUgb24gTGl2ZU1hcCBidXQgc3RhdGUgd2FzIG5vdCBhbiBvYmplY3RcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHVwZGF0ZS51cGRhdGVzKSB7XG4gICAgICAgICAgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwidXBkYXRlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdXBkYXRlLm5vZGUuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gbHNvblRvSnNvbih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBkZWxldGUgbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICBjb25zdCBuZXdBcnJheSA9IFsuLi5zdGF0ZV07XG4gICAgbmV3QXJyYXlbcGF0aEl0ZW1dID0gbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShcbiAgICAgIHN0YXRlW3BhdGhJdGVtXSxcbiAgICAgIHBhdGgsXG4gICAgICB1cGRhdGVcbiAgICApO1xuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfSBlbHNlIGlmIChpc0pzb25PYmplY3Qoc3RhdGUpKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN0YXRlW3BhdGhJdGVtXTtcbiAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0YXRlQXNPYmogPSBzdGF0ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlQXNPYmosXG4gICAgICAgIFtwYXRoSXRlbV06IGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUobm9kZSwgcGF0aCwgdXBkYXRlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbi8vIHNyYy9saWIvc2hhbGxvdy50c1xuZnVuY3Rpb24gc2hhbGxvd0FycmF5KHhzLCB5cykge1xuICBpZiAoeHMubGVuZ3RoICE9PSB5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LmlzKHhzW2ldLCB5c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzaGFsbG93T2JqKG9iakEsIG9iakIpIHtcbiAgaWYgKHR5cGVvZiBvYmpBICE9PSBcIm9iamVjdFwiIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09IFwib2JqZWN0XCIgfHwgb2JqQiA9PT0gbnVsbCB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqQSkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iakIpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG9iakIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5c0EuZXZlcnkoXG4gICAgKGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleSkgJiYgT2JqZWN0LmlzKG9iakFba2V5XSwgb2JqQltrZXldKVxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvdyhhLCBiKSB7XG4gIGlmIChPYmplY3QuaXMoYSwgYikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gIGNvbnN0IGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgaWYgKGlzQXJyYXlBIHx8IGlzQXJyYXlCKSB7XG4gICAgaWYgKCFpc0FycmF5QSB8fCAhaXNBcnJheUIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWxsb3dBcnJheShhLCBiKTtcbiAgfVxuICByZXR1cm4gc2hhbGxvd09iaihhLCBiKTtcbn1cblxuLy8gc3JjL2xpYi9Bc3luY0NhY2hlLnRzXG52YXIgbm9vcCA9ICgpID0+IHtcbn07XG5mdW5jdGlvbiBpc1NoYWxsb3dFcXVhbChhLCBiKSB7XG4gIGlmIChhLmlzTG9hZGluZyAhPT0gYi5pc0xvYWRpbmcgfHwgYS5kYXRhID09PSB2b2lkIDAgIT09IChiLmRhdGEgPT09IHZvaWQgMCkgfHwgYS5lcnJvciA9PT0gdm9pZCAwICE9PSAoYi5lcnJvciA9PT0gdm9pZCAwKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2hhbGxvdyhhLmRhdGEsIGIuZGF0YSkgJiYgc2hhbGxvdyhhLmVycm9yLCBiLmVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVJdGVtKGtleSwgYXN5bmNGdW5jdGlvbiwgb3B0aW9ucykge1xuICBjb25zdCAkYXN5bmNGdW5jdGlvbiA9IGFzeW5jICgpID0+IGFzeW5jRnVuY3Rpb24oa2V5KTtcbiAgY29uc3QgY29udGV4dCA9IHtcbiAgICBpc0ludmFsaWQ6IHRydWVcbiAgfTtcbiAgbGV0IHN0YXRlID0geyBpc0xvYWRpbmc6IGZhbHNlIH07XG4gIGxldCBwcmV2aW91c1N0YXRlID0geyBpc0xvYWRpbmc6IGZhbHNlIH07XG4gIGNvbnN0IGV2ZW50U291cmNlMiA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBmdW5jdGlvbiBub3RpZnkoKSB7XG4gICAgY29uc3QgaXNFcXVhbCA9IG9wdGlvbnM/LmlzU3RhdGVFcXVhbCA/PyBpc1NoYWxsb3dFcXVhbDtcbiAgICBpZiAoIWlzRXF1YWwocHJldmlvdXNTdGF0ZSwgc3RhdGUpKSB7XG4gICAgICBwcmV2aW91c1N0YXRlID0gc3RhdGU7XG4gICAgICBldmVudFNvdXJjZTIubm90aWZ5KHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICBpZiAoIWNvbnRleHQucHJvbWlzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGNvbnRleHQucHJvbWlzZTtcbiAgICAgIGNvbnRleHQuaXNJbnZhbGlkID0gZmFsc2U7XG4gICAgICBzdGF0ZSA9IHtcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZGF0YVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcjMpIHtcbiAgICAgIHN0YXRlID0ge1xuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBkYXRhOiBzdGF0ZS5kYXRhLFxuICAgICAgICBlcnJvcjogZXJyb3IzXG4gICAgICB9O1xuICAgIH1cbiAgICBjb250ZXh0LnByb21pc2UgPSB2b2lkIDA7XG4gICAgbm90aWZ5KCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmV2YWxpZGF0ZSgpIHtcbiAgICBjb250ZXh0LmlzSW52YWxpZCA9IHRydWU7XG4gICAgcmV0dXJuIGdldCgpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAoY29udGV4dC5pc0ludmFsaWQpIHtcbiAgICAgIGlmICghY29udGV4dC5wcm9taXNlKSB7XG4gICAgICAgIGNvbnRleHQuaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgY29udGV4dC5wcm9taXNlID0gJGFzeW5jRnVuY3Rpb24oKTtcbiAgICAgICAgc3RhdGUgPSB7IGlzTG9hZGluZzogdHJ1ZSwgZGF0YTogc3RhdGUuZGF0YSB9O1xuICAgICAgICBub3RpZnkoKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHJlc29sdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldFN0YXRlKCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZXZlbnRTb3VyY2UyLm9ic2VydmFibGUsXG4gICAgZ2V0LFxuICAgIGdldFN0YXRlLFxuICAgIHJldmFsaWRhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jQ2FjaGUoYXN5bmNGdW5jdGlvbiwgb3B0aW9ucykge1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIGNyZWF0ZShrZXkpIHtcbiAgICBsZXQgY2FjaGVJdGVtID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKGNhY2hlSXRlbSkge1xuICAgICAgcmV0dXJuIGNhY2hlSXRlbTtcbiAgICB9XG4gICAgY2FjaGVJdGVtID0gY3JlYXRlQ2FjaGVJdGVtKGtleSwgYXN5bmNGdW5jdGlvbiwgb3B0aW9ucyk7XG4gICAgY2FjaGUuc2V0KGtleSwgY2FjaGVJdGVtKTtcbiAgICByZXR1cm4gY2FjaGVJdGVtO1xuICB9XG4gIGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICByZXR1cm4gY3JlYXRlKGtleSkuZ2V0KCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoa2V5KSB7XG4gICAgcmV0dXJuIGNhY2hlLmdldChrZXkpPy5nZXRTdGF0ZSgpO1xuICB9XG4gIGZ1bmN0aW9uIHJldmFsaWRhdGUoa2V5KSB7XG4gICAgcmV0dXJuIGNyZWF0ZShrZXkpLnJldmFsaWRhdGUoKTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUoa2V5LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBjcmVhdGUoa2V5KS5zdWJzY3JpYmUoY2FsbGJhY2spID8/IG5vb3A7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlT25jZShrZXksIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGNyZWF0ZShrZXkpLnN1YnNjcmliZU9uY2UoY2FsbGJhY2spID8/IG5vb3A7XG4gIH1cbiAgZnVuY3Rpb24gaGFzKGtleSkge1xuICAgIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBjYWNoZS5jbGVhcigpO1xuICB9XG4gIHJldHVybiB7XG4gICAgY3JlYXRlLFxuICAgIGdldCxcbiAgICBnZXRTdGF0ZSxcbiAgICByZXZhbGlkYXRlLFxuICAgIHN1YnNjcmliZSxcbiAgICBzdWJzY3JpYmVPbmNlLFxuICAgIGhhcyxcbiAgICBjbGVhclxuICB9O1xufVxuXG4vLyBzcmMvbGliL1BvbGxlci50c1xuZnVuY3Rpb24gbWFrZVBvbGxlcihjYWxsYmFjaykge1xuICBsZXQgY29udGV4dCA9IHtcbiAgICBzdGF0ZTogXCJzdG9wcGVkXCIsXG4gICAgdGltZW91dEhhbmRsZTogbnVsbCxcbiAgICBpbnRlcnZhbDogbnVsbCxcbiAgICBsYXN0U2NoZWR1bGVkQXQ6IG51bGwsXG4gICAgcmVtYWluaW5nSW50ZXJ2YWw6IG51bGxcbiAgfTtcbiAgZnVuY3Rpb24gcG9sbCgpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSA9PT0gXCJydW5uaW5nXCIpIHtcbiAgICAgIHNjaGVkdWxlKGNvbnRleHQuaW50ZXJ2YWwpO1xuICAgIH1cbiAgICB2b2lkIGNhbGxiYWNrKCk7XG4gIH1cbiAgZnVuY3Rpb24gc2NoZWR1bGUoaW50ZXJ2YWwpIHtcbiAgICBjb250ZXh0ID0ge1xuICAgICAgc3RhdGU6IFwicnVubmluZ1wiLFxuICAgICAgaW50ZXJ2YWw6IGNvbnRleHQuc3RhdGUgIT09IFwic3RvcHBlZFwiID8gY29udGV4dC5pbnRlcnZhbCA6IGludGVydmFsLFxuICAgICAgbGFzdFNjaGVkdWxlZEF0OiBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgIHRpbWVvdXRIYW5kbGU6IHNldFRpbWVvdXQocG9sbCwgaW50ZXJ2YWwpLFxuICAgICAgcmVtYWluaW5nSW50ZXJ2YWw6IG51bGxcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHNjaGVkdWxlUmVtYWluaW5nKHJlbWFpbmluZykge1xuICAgIGlmIChjb250ZXh0LnN0YXRlICE9PSBcInBhdXNlZFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQgPSB7XG4gICAgICBzdGF0ZTogXCJydW5uaW5nXCIsXG4gICAgICBpbnRlcnZhbDogY29udGV4dC5pbnRlcnZhbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRBdDogY29udGV4dC5sYXN0U2NoZWR1bGVkQXQsXG4gICAgICB0aW1lb3V0SGFuZGxlOiBzZXRUaW1lb3V0KHBvbGwsIHJlbWFpbmluZyksXG4gICAgICByZW1haW5pbmdJbnRlcnZhbDogbnVsbFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnQoaW50ZXJ2YWwpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSA9PT0gXCJydW5uaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2NoZWR1bGUoaW50ZXJ2YWwpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc3RhcnQoaW50ZXJ2YWwpIHtcbiAgICBzdG9wKCk7XG4gICAgc3RhcnQoaW50ZXJ2YWwpO1xuICB9XG4gIGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIGlmIChjb250ZXh0LnN0YXRlICE9PSBcInJ1bm5pbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQoY29udGV4dC50aW1lb3V0SGFuZGxlKTtcbiAgICBjb250ZXh0ID0ge1xuICAgICAgc3RhdGU6IFwicGF1c2VkXCIsXG4gICAgICBpbnRlcnZhbDogY29udGV4dC5pbnRlcnZhbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRBdDogY29udGV4dC5sYXN0U2NoZWR1bGVkQXQsXG4gICAgICB0aW1lb3V0SGFuZGxlOiBudWxsLFxuICAgICAgcmVtYWluaW5nSW50ZXJ2YWw6IGNvbnRleHQuaW50ZXJ2YWwgLSAocGVyZm9ybWFuY2Uubm93KCkgLSBjb250ZXh0Lmxhc3RTY2hlZHVsZWRBdClcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSAhPT0gXCJwYXVzZWRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzY2hlZHVsZVJlbWFpbmluZyhjb250ZXh0LnJlbWFpbmluZ0ludGVydmFsKTtcbiAgfVxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIGlmIChjb250ZXh0LnN0YXRlID09PSBcInN0b3BwZWRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC50aW1lb3V0SGFuZGxlKSB7XG4gICAgICBjbGVhclRpbWVvdXQoY29udGV4dC50aW1lb3V0SGFuZGxlKTtcbiAgICB9XG4gICAgY29udGV4dCA9IHtcbiAgICAgIHN0YXRlOiBcInN0b3BwZWRcIixcbiAgICAgIGludGVydmFsOiBudWxsLFxuICAgICAgbGFzdFNjaGVkdWxlZEF0OiBudWxsLFxuICAgICAgdGltZW91dEhhbmRsZTogbnVsbCxcbiAgICAgIHJlbWFpbmluZ0ludGVydmFsOiBudWxsXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0LFxuICAgIHJlc3RhcnQsXG4gICAgcGF1c2UsXG4gICAgcmVzdW1lLFxuICAgIHN0b3BcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9zdHJpbmdpZnkudHNcbmZ1bmN0aW9uIHN0cmluZ2lmeShvYmplY3QsIC4uLmFyZ3MpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgIT09IFwib2JqZWN0XCIgfHwgb2JqZWN0ID09PSBudWxsIHx8IEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmplY3QsIC4uLmFyZ3MpO1xuICB9XG4gIGNvbnN0IHNvcnRlZE9iamVjdCA9IE9iamVjdC5rZXlzKG9iamVjdCkuc29ydCgpLnJlZHVjZShcbiAgICAoc29ydGVkT2JqZWN0Miwga2V5KSA9PiB7XG4gICAgICBzb3J0ZWRPYmplY3QyW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgIHJldHVybiBzb3J0ZWRPYmplY3QyO1xuICAgIH0sXG4gICAge31cbiAgKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHNvcnRlZE9iamVjdCwgLi4uYXJncyk7XG59XG5cbi8vIHNyYy9pbmRleC50c1xuZGV0ZWN0RHVwZXMoUEtHX05BTUUsIFBLR19WRVJTSU9OLCBQS0dfRk9STUFUKTtcbmV4cG9ydCB7XG4gIENsaWVudE1zZ0NvZGUsXG4gIENvbW1lbnRzQXBpRXJyb3IsXG4gIENyZHRUeXBlLFxuICBMaXZlTGlzdCxcbiAgTGl2ZU1hcCxcbiAgTGl2ZU9iamVjdCxcbiAgT3BDb2RlLFxuICBTZXJ2ZXJNc2dDb2RlLFxuICBXZWJzb2NrZXRDbG9zZUNvZGVzLFxuICBhY2tPcCxcbiAgYXNQb3MsXG4gIGFzc2VydCxcbiAgYXNzZXJ0TmV2ZXIsXG4gIGI2NGRlY29kZSxcbiAgY2xvbmVMc29uLFxuICBmYW5jeV9jb25zb2xlX2V4cG9ydHMgYXMgY29uc29sZSxcbiAgY29udmVydFRvQ29tbWVudERhdGEsXG4gIGNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24sXG4gIGNvbnZlcnRUb1RocmVhZERhdGEsXG4gIGNyZWF0ZUFzeW5jQ2FjaGUsXG4gIGNyZWF0ZUNsaWVudCxcbiAgY3JlYXRlQ29tbWVudHNBcGksXG4gIGRlcHJlY2F0ZSxcbiAgZGVwcmVjYXRlSWYsXG4gIGRldGVjdER1cGVzLFxuICBlcnJvcklmLFxuICBmcmVlemUsXG4gIGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keSxcbiAgaXNDaGlsZENyZHQsXG4gIGlzSnNvbkFycmF5LFxuICBpc0pzb25PYmplY3QsXG4gIGlzSnNvblNjYWxhcixcbiAgaXNMaXZlTm9kZSxcbiAgaXNQbGFpbk9iamVjdCxcbiAgaXNSb290Q3JkdCxcbiAgbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0LFxuICBsc29uVG9Kc29uLFxuICBtYWtlRXZlbnRTb3VyY2UsXG4gIG1ha2VQb2xsZXIsXG4gIG1ha2VQb3NpdGlvbixcbiAgbm4sXG4gIHBhdGNoTGl2ZU9iamVjdEtleSxcbiAgcmFpc2UsXG4gIHNoYWxsb3csXG4gIHN0cmluZ2lmeSxcbiAgc3RyaW5naWZ5Q29tbWVudEJvZHksXG4gIHRocm93VXNhZ2VFcnJvcixcbiAgdG9QbGFpbkxzb24sXG4gIHRyeVBhcnNlSnNvbixcbiAgd2l0aFRpbWVvdXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZ2V0IiwiZW51bWVyYWJsZSIsIlBLR19OQU1FIiwiUEtHX1ZFUlNJT04iLCJQS0dfRk9STUFUIiwiZyIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJnbG9iYWwiLCJjcm9zc0xpbmtlZERvY3MiLCJkdXBlc0RvY3MiLCJTUEFDRSIsImVycm9yIiwibXNnIiwicHJvY2VzcyIsImNvbnNvbGUiLCJFcnJvciIsImRldGVjdER1cGVzIiwicGtnTmFtZSIsInBrZ1ZlcnNpb24iLCJwa2dGb3JtYXQiLCJwa2dJZCIsIlN5bWJvbCIsImZvciIsInBrZ0J1aWxkSW5mbyIsImpvaW4iLCJhc3NlcnROZXZlciIsIl92YWx1ZSIsImVycm1zZyIsImFzc2VydCIsImNvbmRpdGlvbiIsImVyciIsIm5uIiwidmFsdWUiLCJjb250cm9sbGVkUHJvbWlzZSIsImZsYWdnZXIiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlcyIsIm1ha2VFdmVudFNvdXJjZSIsIl9vbmV0aW1lT2JzZXJ2ZXJzIiwiU2V0IiwiX29ic2VydmVycyIsIl9idWZmZXIiLCJwYXVzZSIsInVucGF1c2UiLCJldmVudCIsIm5vdGlmeSIsInN1YnNjcmliZSIsImNhbGxiYWNrIiwiYWRkIiwiZGVsZXRlIiwic3Vic2NyaWJlT25jZSIsIndhaXRVbnRpbCIsInByZWRpY2F0ZSIsInVuc3ViIiwiZmluYWxseSIsIm5vdGlmeU9yQnVmZmVyIiwicHVzaCIsImZvckVhY2giLCJjbGVhciIsImNvdW50Iiwic2l6ZSIsIm9ic2VydmFibGUiLCJmYW5jeV9jb25zb2xlX2V4cG9ydHMiLCJlcnJvcjIiLCJlcnJvcldpdGhUaXRsZSIsIndhcm4iLCJ3YXJuV2l0aFRpdGxlIiwiYmFkZ2UiLCJib2xkIiwid3JhcCIsIm1ldGhvZCIsIm1lc3NhZ2UiLCJhcmdzIiwid3JhcFdpdGhUaXRsZSIsInRpdGxlIiwiZGlzdGFuY2UiLCJzdGF0ZTEiLCJzdGF0ZTIiLCJjaHVua3MxIiwic3BsaXQiLCJjaHVua3MyIiwibWluTGVuIiwiTWF0aCIsIm1pbiIsImxlbmd0aCIsInNoYXJlZCIsInVwIiwiZG93biIsInBhdHRlcm5zIiwidGFyZ2V0U3RhdGUiLCJsZXZlbHMiLCJwYXJ0cyIsInJlc3VsdCIsImkiLCJzbGljZSIsIlNhZmVDb250ZXh0IiwiY29uc3RydWN0b3IiLCJpbml0aWFsQ29udGV4dCIsImN1cnIiLCJjdXJyZW50IiwiYWxsb3dQYXRjaGluZyIsInNlbGYiLCJhbGxvd2VkIiwicGF0Y2hhYmxlQ29udGV4dCIsInBhdGNoIiwiYXNzaWduIiwicGFpciIsImVudHJpZXMiLCJrZXkiLCJuZXh0SWQiLCJGU00iLCJpbml0aWFsU3RhdGUiLCJzdGF0ZXMiLCJ2YWx1ZXMiLCJpdGVyYXRvciIsIm5leHQiLCJkb25lIiwiY3VycmVudFN0YXRlIiwiY3VycmVudFN0YXRlT3JOdWxsIiwicnVubmluZ1N0YXRlIiwic3RhcnQiLCJlbnRlciIsInN0b3AiLCJleGl0IiwiaWQiLCJlbnRlckZucyIsIk1hcCIsImNsZWFudXBTdGFjayIsImtub3duRXZlbnRUeXBlcyIsImFsbG93ZWRUcmFuc2l0aW9ucyIsImN1cnJlbnRDb250ZXh0IiwiZXZlbnRIdWIiLCJkaWRSZWNlaXZlRXZlbnQiLCJ3aWxsVHJhbnNpdGlvbiIsImRpZElnbm9yZUV2ZW50Iiwid2lsbEV4aXRTdGF0ZSIsImRpZEVudGVyU3RhdGUiLCJldmVudHMiLCJjb250ZXh0IiwiYWRkU3RhdGUiLCJzdGF0ZSIsIm9uRW50ZXIiLCJuYW1lT3JQYXR0ZXJuIiwiZW50ZXJGbiIsImhhcyIsInNldCIsIm9uRW50ZXJBc3luYyIsInByb21pc2VGbiIsIm9uT0siLCJvbkVycm9yIiwiY2FuY2VsbGVkIiwidGhlbiIsImRhdGEiLCJ0cmFuc2l0aW9uIiwidHlwZSIsInJlYXNvbiIsImdldFN0YXRlc01hdGNoaW5nIiwibWF0Y2hlcyIsImVuZHNXaXRoIiwicHJlZml4Iiwic3RhcnRzV2l0aCIsIkpTT04iLCJzdHJpbmdpZnkiLCJhZGRUcmFuc2l0aW9ucyIsIm1hcHBpbmciLCJzcmNTdGF0ZSIsIm1hcCIsInRhcmdldF8iLCJ0YXJnZXRGbiIsImFkZFRpbWVkVHJhbnNpdGlvbiIsInN0YXRlT3JQYXR0ZXJuIiwiYWZ0ZXIyIiwibXMiLCJ0aW1lb3V0SUQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiZ2V0VGFyZ2V0Rm4iLCJldmVudE5hbWUiLCJwb3AiLCJlbnRlclBhdHRlcm5zIiwicGF0dGVybiIsImNsZWFudXBGbiIsInNlbmQiLCJvbGRTdGF0ZSIsIm5leHRUYXJnZXQiLCJuZXh0U3RhdGUiLCJlZmZlY3RzIiwiQXJyYXkiLCJpc0FycmF5IiwiZWZmZWN0IiwiZnJvbSIsInRvIiwiZWZmZWN0c1RvUnVuIiwicmFpc2UiLCJpc1BsYWluT2JqZWN0IiwiYmxvYiIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsIm9iaiIsInRyeVBhcnNlSnNvbiIsInJhd01lc3NhZ2UiLCJwYXJzZSIsImUiLCJkZWVwQ2xvbmUiLCJiNjRkZWNvZGUiLCJiNjR2YWx1ZSIsImZvcm1hdHRlZFZhbHVlIiwicmVwbGFjZSIsImRlY29kZWRWYWx1ZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImF0b2IiLCJjIiwiY2hhckNvZGVBdCIsImNvbXBhY3QiLCJpdGVtcyIsImZpbHRlciIsIml0ZW0iLCJjb21wYWN0T2JqZWN0IiwibmV3T2JqIiwia2V5cyIsImsiLCJ3aXRoVGltZW91dCIsIm1pbGxpcyIsInRpbWVySUQiLCJ0aW1lciQiLCJfIiwicmVqZWN0IiwicmFjZSIsIlNlcnZlck1zZ0NvZGUiLCJTZXJ2ZXJNc2dDb2RlMiIsIldlYnNvY2tldENsb3NlQ29kZXMiLCJXZWJzb2NrZXRDbG9zZUNvZGVzMiIsInNob3VsZERpc2Nvbm5lY3QiLCJjb2RlIiwic2hvdWxkUmVhdXRoIiwic2hvdWxkUmV0cnlXaXRob3V0UmVhdXRoIiwiaXNJZGxlIiwic3RhdHVzIiwibmV3VG9MZWdhY3lTdGF0dXMiLCJ0b05ld0Nvbm5lY3Rpb25TdGF0dXMiLCJtYWNoaW5lIiwic3VjY2Vzc0NvdW50IiwiQkFDS09GRl9ERUxBWVMiLCJSRVNFVF9ERUxBWSIsIkJBQ0tPRkZfREVMQVlTX1NMT1ciLCJIRUFSVEJFQVRfSU5URVJWQUwiLCJQT05HX1RJTUVPVVQiLCJBVVRIX1RJTUVPVVQiLCJTT0NLRVRfQ09OTkVDVF9USU1FT1VUIiwiU3RvcFJldHJ5aW5nIiwiTGl2ZWJsb2Nrc0Vycm9yIiwibmV4dEJhY2tvZmZEZWxheSIsImN1cnJlbnREZWxheSIsImRlbGF5cyIsImZpbmQiLCJkZWxheSIsImluY3JlYXNlQmFja29mZkRlbGF5IiwiYmFja29mZkRlbGF5IiwiaW5jcmVhc2VCYWNrb2ZmRGVsYXlBZ2dyZXNzaXZlbHkiLCJyZXNldFN1Y2Nlc3NDb3VudCIsImxvZyIsImxldmVsIiwibG9nZ2VyIiwibG9nUHJlbWF0dXJlRXJyb3JPckNsb3NlRXZlbnQiLCJjb25uIiwiY3R4IiwiU3RyaW5nIiwiaXNDbG9zZUV2ZW50IiwibG9nQ2xvc2VFdmVudCIsImxvZ1Blcm1hbmVudENsb3NlIiwiZXJyb3IzIiwiZW5hYmxlVHJhY2luZyIsIkRhdGUiLCJnZXRUaW1lIiwibG9nMiIsInRvRml4ZWQiLCJ1bnN1YnMiLCJkZWZpbmVDb25uZWN0aXZpdHlFdmVudHMiLCJzdGF0dXNEaWRDaGFuZ2UiLCJkaWRDb25uZWN0IiwiZGlkRGlzY29ubmVjdCIsImxhc3RTdGF0dXMiLCJ1bnN1YnNjcmliZSIsImN1cnJTdGF0dXMiLCJjcmVhdGVDb25uZWN0aW9uU3RhdGVNYWNoaW5lIiwiZGVsZWdhdGVzIiwib3B0aW9ucyIsIm9uTWVzc2FnZSIsIm9uTGl2ZWJsb2Nrc0Vycm9yIiwiZmlyZUVycm9yRXZlbnQiLCJlcnJjb2RlIiwiYXV0aFZhbHVlIiwic29ja2V0IiwiUkVDT05ORUNUIiwiRElTQ09OTkVDVCIsIkNPTk5FQ1QiLCJOQVZJR0FUT1JfT05MSU5FIiwiYXV0aGVudGljYXRlIiwib2tFdmVudCIsImZhaWxlZEV2ZW50Iiwib25Tb2NrZXRFcnJvciIsIm9uU29ja2V0Q2xvc2UiLCJvblNvY2tldE1lc3NhZ2UiLCJ0ZWFyZG93blNvY2tldCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbG9zZSIsImNhcHR1cmVkUHJlbWF0dXJlRXZlbnQiLCJjb25uZWN0JCIsInJlc29sdmUiLCJyZWoiLCJjcmVhdGVTb2NrZXQiLCJhY3RvciQiLCJkaWRSZWNlaXZlQWN0b3IiLCJ3YWl0Rm9yQWN0b3JJZCIsInNlcnZlck1zZyIsImFkZEV2ZW50TGlzdGVuZXIiLCJmYWlsdXJlIiwic2VuZEhlYXJ0YmVhdCIsIm1heWJlSGVhcnRiZWF0IiwiZG9jIiwiZG9jdW1lbnQiLCJjYW5ab21iaWUiLCJ2aXNpYmlsaXR5U3RhdGUiLCJOQVZJR0FUT1JfT0ZGTElORSIsIldJTkRPV19HT1RfRk9DVVMiLCJjdHgyIiwiUE9ORyIsIkVYUExJQ0lUX1NPQ0tFVF9FUlJPUiIsInJlYWR5U3RhdGUiLCJFWFBMSUNJVF9TT0NLRVRfQ0xPU0UiLCJ3aW4iLCJyb290Iiwib25OZXR3b3JrT2ZmbGluZSIsIm9uTmV0d29ya0JhY2tPbmxpbmUiLCJvblZpc2liaWxpdHlDaGFuZ2UiLCJjbGVhbnVwcyIsImVuYWJsZURlYnVnTG9nZ2luZyIsIk1hbmFnZWRTb2NrZXQiLCJnZXRMZWdhY3lTdGF0dXMiLCJnZXRTdGF0dXMiLCJjb25uZWN0IiwicmVjb25uZWN0IiwiZGlzY29ubmVjdCIsImRlc3Ryb3kiLCJjbGVhbnVwIiwiX3ByaXZhdGVTZW5kTWFjaGluZUV2ZW50IiwiY2FuV3JpdGVTdG9yYWdlIiwic2NvcGVzIiwiaW5jbHVkZXMiLCJjYW5Db21tZW50IiwiaXNWYWxpZEF1dGhUb2tlblBheWxvYWQiLCJwYXJzZUF1dGhUb2tlbiIsInJhd1Rva2VuU3RyaW5nIiwidG9rZW5QYXJ0cyIsInBheWxvYWQiLCJyYXciLCJwYXJzZWQiLCJjcmVhdGVBdXRoTWFuYWdlciIsImF1dGhPcHRpb25zIiwiYXV0aGVudGljYXRpb24iLCJwcmVwYXJlQXV0aGVudGljYXRpb24iLCJzZWVuVG9rZW5zIiwidG9rZW5zIiwiZXhwaXJ5VGltZXMiLCJyZXF1ZXN0UHJvbWlzZXMiLCJyZXNldCIsImhhc0NvcnJlc3BvbmRpbmdTY29wZXMiLCJyZXF1ZXN0ZWRTY29wZSIsImdldENhY2hlZFRva2VuIiwicm9vbUlkIiwibm93IiwiY2VpbCIsInRva2VuIiwiZXhwaXJlc0F0Iiwic3BsaWNlIiwicmVzb3VyY2UiLCJwZXJtcyIsIm1ha2VBdXRoUmVxdWVzdCIsImZldGNoZXIiLCJwb2x5ZmlsbHMiLCJmZXRjaCIsInJlc3BvbnNlIiwiZmV0Y2hBdXRoRW5kcG9pbnQiLCJ1cmwiLCJyb29tIiwiZ2V0QXV0aFZhbHVlIiwicHVibGljQXBpS2V5IiwiY2FjaGVkVG9rZW4iLCJjdXJyZW50UHJvbWlzZSIsIkJVRkZFUiIsImZsb29yIiwiZXhwIiwiaWF0IiwiYXV0aEVuZHBvaW50IiwiZmV0Y2gyIiwiZW5kcG9pbnQiLCJib2R5IiwiaGVhZGVycyIsIm9rIiwidGV4dCIsInRyaW0iLCJqc29uIiwiZXIiLCJERUZBVUxUX0JBU0VfVVJMIiwiX2JyaWRnZUFjdGl2ZSIsImFjdGl2YXRlQnJpZGdlIiwic2VuZFRvUGFuZWwiLCJmdWxsTXNnIiwic291cmNlIiwiZm9yY2UiLCJwb3N0TWVzc2FnZSIsImV2ZW50U291cmNlIiwib25NZXNzYWdlRnJvbVBhbmVsIiwiVkVSU0lPTiIsIl9kZXZ0b29sc1NldHVwSGFzUnVuIiwic2V0dXBEZXZUb29scyIsImdldEFsbFJvb21zIiwiY2xpZW50VmVyc2lvbiIsInVuc3Vic0J5Um9vbUlkIiwic3RvcFN5bmNTdHJlYW0iLCJzdGFydFN5bmNTdHJlYW0iLCJmdWxsU3luYyIsInBhcnRpYWxTeW5jQ29ubmVjdGlvbiIsInN0b3JhZ2VEaWRMb2FkIiwicGFydGlhbFN5bmNTdG9yYWdlIiwic3RvcmFnZSIsInBhcnRpYWxTeW5jTWUiLCJvdGhlcnMiLCJwYXJ0aWFsU3luY090aGVycyIsInlkb2MiLCJ1cGRhdGUiLCJzeW5jWWRvY1VwZGF0ZSIsImN1c3RvbUV2ZW50IiwiZXZlbnREYXRhIiwiZm9yd2FyZEV2ZW50IiwibG9hZGVkQXQiLCJldmVudENvdW50ZXIiLCJuZXh0RXZlbnRJZCIsImNvbm5lY3Rpb25JZCIsImdldFN0b3JhZ2VTbmFwc2hvdCIsInRvVHJlZU5vZGUiLCJtZSIsIl9faW50ZXJuYWwiLCJnZXRTZWxmX2ZvckRldlRvb2xzIiwiZ2V0T3RoZXJzX2ZvckRldlRvb2xzIiwiZmV0Y2hZRG9jIiwicm9vbUNoYW5uZWxMaXN0ZW5lcnMiLCJzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lciIsImxpc3RlbmVyIiwibGlua0RldlRvb2xzIiwidW5saW5rRGV2VG9vbHMiLCJfZW1pdHRlZERlcHJlY2F0aW9uV2FybmluZ3MiLCJkZXByZWNhdGUiLCJkZXByZWNhdGVJZiIsInRocm93VXNhZ2VFcnJvciIsInVzYWdlRXJyb3IiLCJlcnJvcklmIiwiaXNDb21tZW50Qm9keVBhcmFncmFwaCIsImVsZW1lbnQiLCJpc0NvbW1lbnRCb2R5VGV4dCIsImlzQ29tbWVudEJvZHlNZW50aW9uIiwiaXNDb21tZW50Qm9keUxpbmsiLCJjb21tZW50Qm9keUVsZW1lbnRzR3VhcmRzIiwicGFyYWdyYXBoIiwibGluayIsIm1lbnRpb24iLCJjb21tZW50Qm9keUVsZW1lbnRzVHlwZXMiLCJ0cmF2ZXJzZUNvbW1lbnRCb2R5IiwiZWxlbWVudE9yVmlzaXRvciIsInBvc3NpYmx5VmlzaXRvciIsImNvbnRlbnQiLCJndWFyZCIsInZpc2l0b3IiLCJibG9jayIsImlubGluZSIsImNoaWxkcmVuIiwiZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5IiwibWVudGlvbmVkSWRzIiwicmVzb2x2ZVVzZXJzSW5Db21tZW50Qm9keSIsInJlc29sdmVVc2VycyIsInJlc29sdmVkVXNlcnMiLCJ1c2VySWRzIiwidXNlcnMiLCJpbmRleCIsInVzZXJJZCIsInVzZXIiLCJodG1sRXNjYXBhYmxlcyIsImh0bWxFc2NhcGFibGVzUmVnZXgiLCJSZWdFeHAiLCJlbnRpdHkiLCJodG1sU2FmZSIsIkh0bWxTYWZlU3RyaW5nIiwiam9pbkh0bWwiLCJzdHJpbmdzIiwiZmlsbCIsImVzY2FwZUh0bWwiLCJjaGFyYWN0ZXIiLCJfc3RyaW5ncyIsIl92YWx1ZXMiLCJyZWR1Y2UiLCJzdHIiLCJodG1sIiwibWFya2Rvd25Fc2NhcGFibGVzIiwibWFya2Rvd25Fc2NhcGFibGVzUmVnZXgiLCJqb2luTWFya2Rvd24iLCJNYXJrZG93blNhZmVTdHJpbmciLCJlc2NhcGVNYXJrZG93biIsIm1hcmtkb3duIiwidG9BYnNvbHV0ZVVybCIsInN0cmluZ2lmeUNvbW1lbnRCb2R5UGxhaW5FbGVtZW50cyIsInN0cmluZ2lmeUNvbW1lbnRCb2R5SHRtbEVsZW1lbnRzIiwiaXRhbGljIiwic3RyaWtldGhyb3VnaCIsImhyZWYiLCJzdHJpbmdpZnlDb21tZW50Qm9keU1hcmtkb3duRWxlbWVudHMiLCJzdHJpbmdpZnlDb21tZW50Qm9keSIsImZvcm1hdCIsInNlcGFyYXRvciIsImVsZW1lbnRzIiwiYmxvY2tzIiwiZmxhdE1hcCIsImJsb2NrSW5kZXgiLCJpbmxpbmVzIiwiaW5saW5lSW5kZXgiLCJjb252ZXJ0VG9Db21tZW50RGF0YSIsImVkaXRlZEF0IiwiY3JlYXRlZEF0IiwicmVhY3Rpb25zIiwicmVhY3Rpb24iLCJkZWxldGVkQXQiLCJjb252ZXJ0VG9UaHJlYWREYXRhIiwidXBkYXRlZEF0IiwiY29tbWVudHMiLCJjb21tZW50IiwiY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbiIsImdldEF1dGhCZWFyZXJIZWFkZXJGcm9tQXV0aFZhbHVlIiwiQ29tbWVudHNBcGlFcnJvciIsImRldGFpbHMiLCJjcmVhdGVDb21tZW50c0FwaSIsImNvbmZpZyIsImZldGNoSnNvbiIsImZldGNoQXBpIiwiZXJyb3JCb2R5Iiwic3RhdHVzVGV4dCIsInJvb21JZDIiLCJVUkwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJiYXNlVXJsIiwiQXV0aG9yaXphdGlvbiIsImdldFRocmVhZHMiLCJxdWVyeSIsIm1ldGFkYXRhIiwidGhyZWFkIiwiY3JlYXRlVGhyZWFkIiwiY29tbWVudElkIiwidGhyZWFkSWQiLCJlZGl0VGhyZWFkTWV0YWRhdGEiLCJjcmVhdGVDb21tZW50IiwiZWRpdENvbW1lbnQiLCJkZWxldGVDb21tZW50IiwiYWRkUmVhY3Rpb24iLCJlbW9qaSIsInJlbW92ZVJlYWN0aW9uIiwiTUlOX0NPREUiLCJNQVhfQ09ERSIsIk5VTV9ESUdJVFMiLCJaRVJPIiwibnRoRGlnaXQiLCJPTkUiLCJaRVJPX05JTkUiLCJuIiwiZnJvbUNoYXJDb2RlIiwibWFrZVBvc2l0aW9uIiwieCIsInkiLCJiZXR3ZWVuIiwiYWZ0ZXIiLCJiZWZvcmUiLCJwb3MiLCJsYXN0SW5kZXgiLCJzdWJzdHJpbmciLCJsbyIsImhpIiwiX2JldHdlZW4iLCJsb0xlbiIsImhpTGVuIiwibG9Db2RlIiwiaGlDb2RlIiwicmVwZWF0Iiwic3VmZml4IiwibmluZXMiLCJ0YWtlTiIsIk1JTl9OT05fWkVST19DT0RFIiwiaXNQb3MiLCJsYXN0SWR4IiwibGFzdCIsImNvbnZlcnRUb1BvcyIsImNvZGVzIiwiYXNQb3MiLCJPcENvZGUiLCJPcENvZGUyIiwiYWNrT3AiLCJvcElkIiwiaXNBY2tPcCIsIm9wIiwiY3JkdEFzTGl2ZU5vZGUiLCJIYXNQYXJlbnQiLCJub2RlIiwiZnJlZXplIiwiTm9QYXJlbnQiLCJPcnBoYW5lZCIsIm9sZEtleSIsIm9sZFBvcyIsIkFic3RyYWN0Q3JkdCIsIl9wYXJlbnQiLCJfZ2V0UGFyZW50S2V5T3JUaHJvdyIsInBhcmVudCIsIl9wYXJlbnRQb3MiLCJfcG9vbCIsIl9fcG9vbCIsIl9pZCIsIl9faWQiLCJfcGFyZW50S2V5IiwiX2FwcGx5IiwiX2lzTG9jYWwiLCJfZGV0YWNoQ2hpbGQiLCJtb2RpZmllZCIsIl9zZXRQYXJlbnRMaW5rIiwibmV3UGFyZW50Tm9kZSIsIm5ld1BhcmVudEtleSIsIl9hdHRhY2giLCJwb29sIiwiYWRkTm9kZSIsIl9kZXRhY2giLCJkZWxldGVOb2RlIiwiaW52YWxpZGF0ZSIsIl9jYWNoZWRJbW11dGFibGUiLCJfY2FjaGVkVHJlZU5vZGUiLCJfY2FjaGVkVHJlZU5vZGVLZXkiLCJfdG9UcmVlTm9kZSIsInRvSW1tdXRhYmxlIiwiX3RvSW1tdXRhYmxlIiwiQ3JkdFR5cGUiLCJDcmR0VHlwZTIiLCJpc1Jvb3RDcmR0IiwiY3JkdCIsImlzQ2hpbGRDcmR0IiwicGFyZW50SWQiLCJwYXJlbnRLZXkiLCJuYW5vaWQiLCJhbHBoYWJldCIsImxlbiIsImNoYXJBdCIsInJhbmRvbSIsIkxpdmVSZWdpc3RlciIsIl9MaXZlUmVnaXN0ZXIiLCJfZGF0YSIsIl9kZXNlcmlhbGl6ZSIsIl9wYXJlbnRUb0NoaWxkcmVuIiwicmVnaXN0ZXIiLCJfdG9PcHMiLCJnZW5lcmF0ZU9wSWQiLCJfc2VyaWFsaXplIiwiX2F0dGFjaENoaWxkIiwiX29wIiwiX2NyZHQiLCJpc0xvY2FsIiwiY2xvbmUiLCJjb21wYXJlTm9kZVBvc2l0aW9uIiwiaXRlbUEiLCJpdGVtQiIsInBvc0EiLCJwb3NCIiwiTGl2ZUxpc3QiLCJfTGl2ZUxpc3QiLCJfaXRlbXMiLCJfaW1wbGljaXRseURlbGV0ZWRJdGVtcyIsIldlYWtTZXQiLCJfdW5hY2tub3dsZWRnZWRTZXRzIiwicG9zaXRpb24iLCJuZXdQb3NpdGlvbiIsImxzb25Ub0xpdmVOb2RlIiwicGFyZW50VG9DaGlsZHJlbiIsImxpc3QiLCJpZDIiLCJjaGlsZCIsImRlc2VyaWFsaXplIiwiX2luc2VydEFuZFNvcnQiLCJvcHMiLCJwYXJlbnRLZXkyIiwiY2hpbGRPcHMiLCJIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uIiwiY2hpbGRPcElkIiwiX3NvcnRJdGVtcyIsInNvcnQiLCJfaW5kZXhPZlBvc2l0aW9uIiwiZmluZEluZGV4IiwiZ2VuZXJhdGVJZCIsIl9hcHBseVNldFJlbW90ZSIsImNyZWF0aW9uT3BUb0xpdmVOb2RlIiwiZGVsZXRlZElkIiwiaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uIiwiaXRlbVdpdGhTYW1lUG9zaXRpb24iLCJtYWtlVXBkYXRlIiwic2V0RGVsdGEiLCJyZXZlcnNlIiwiZGVsdGEiLCJkZWxldGVEZWx0YTIiLCJfZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbiIsInVwZGF0ZXMiLCJpbnNlcnREZWx0YSIsIl9hcHBseVNldEFjayIsImRlbGV0ZWREZWx0YSIsInVuYWNrbm93bGVkZ2VkT3BJZCIsImV4aXN0aW5nSXRlbSIsImRlbGV0ZURlbHRhIiwicHJldmlvdXNJbmRleCIsImluZGV4T2YiLCJuZXdJbmRleCIsIm1vdmVEZWx0YSIsIm9ycGhhbiIsImdldE5vZGUiLCJyZWNyZWF0ZWRJdGVtSW5kZXgiLCJuZXdJdGVtIiwiX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0IiwiZGVsZXRlZEl0ZW0iLCJfYXBwbHlSZW1vdGVJbnNlcnQiLCJleGlzdGluZ0l0ZW1JbmRleCIsIl9zaGlmdEl0ZW1Qb3NpdGlvbiIsIl9hcHBseUluc2VydEFjayIsIml0ZW1JbmRleEF0UG9zaXRpb24iLCJvbGRQb3NpdGlvbkluZGV4IiwiX2FwcGx5SW5zZXJ0VW5kb1JlZG8iLCJuZXdLZXkiLCJiZWZvcmUyIiwiX2FwcGx5U2V0VW5kb1JlZG8iLCJpbmRleE9mSXRlbVdpdGhTYW1lS2V5IiwiaW50ZW50IiwiaW5kZXhUb0RlbGV0ZSIsIl9hcHBseVNldENoaWxkS2V5UmVtb3RlIiwicHJldmlvdXNLZXkiLCJfYXBwbHlTZXRDaGlsZEtleUFjayIsIl9hcHBseVNldENoaWxkS2V5VW5kb1JlZG8iLCJfc2V0Q2hpbGRLZXkiLCJhc3NlcnRTdG9yYWdlSXNXcml0YWJsZSIsImluc2VydCIsImRpc3BhdGNoIiwibW92ZSIsInRhcmdldEluZGV4IiwiYmVmb3JlUG9zaXRpb24iLCJhZnRlclBvc2l0aW9uIiwicHJldmlvdXNQb3NpdGlvbiIsInN0b3JhZ2VVcGRhdGVzIiwiY2hpbGRSZWNvcmRJZCIsInJldmVyc2VPcHMiLCJ1cGRhdGVEZWx0YSIsImNoaWxkSWQiLCJleGlzdGluZ0lkIiwidG9BcnJheSIsImVudHJ5IiwibGl2ZU5vZGVUb0xzb24iLCJldmVyeSIsImNhbGxiYWNrZm4iLCJzZWFyY2hFbGVtZW50IiwiZnJvbUluZGV4IiwibGFzdEluZGV4T2YiLCJzb21lIiwiTGl2ZUxpc3RJdGVyYXRvciIsInNoaWZ0ZWRQb3NpdGlvbiIsIl9pbm5lckl0ZXJhdG9yIiwibGl2ZUxpc3QiLCJkZWx0YVVwZGF0ZXMiLCJmaXJzdE9wIiwiTGl2ZU1hcCIsIl9MaXZlTWFwIiwiZW50cmllczIiLCJ1bmFja25vd2xlZGdlZFNldCIsIm1hcHBlZEVudHJpZXMiLCJfbWFwIiwiX2l0ZW0iLCJfa2V5IiwiaXNMaXZlTm9kZSIsImxhc3RVcGRhdGVPcElkIiwicHJldmlvdXNWYWx1ZSIsInRoaXNJZCIsInN0b3JhZ2VVcGRhdGUiLCJvbGRWYWx1ZSIsImlubmVySXRlcmF0b3IiLCJpdGVyYXRvclZhbHVlIiwia2V5MiIsInZhbCIsIkxpdmVPYmplY3QiLCJfTGl2ZU9iamVjdCIsIl9wcm9wVG9MYXN0VXBkYXRlIiwiX2J1aWxkUm9vdEFuZFBhcmVudFRvQ2hpbGRyZW4iLCJ0dXBsZSIsIl9mcm9tSXRlbXMiLCJsaXZlT2JqIiwiX2Rlc2VyaWFsaXplQ2hpbGRyZW4iLCJkZXNlcmlhbGl6ZVRvTHNvbiIsImlzTGl2ZVN0cnVjdHVyZSIsImNyZWF0aW9uT3BUb0xzb24iLCJfYXBwbHlVcGRhdGUiLCJfYXBwbHlEZWxldGVPYmplY3RLZXkiLCJpc01vZGlmaWVkIiwicmV2ZXJzZVVwZGF0ZSIsInVuc2hpZnQiLCJ0b09iamVjdCIsImZyb21FbnRyaWVzIiwia2V5QXNTdHJpbmciLCJuZXdWYWx1ZSIsInVwZGF0ZWRQcm9wcyIsInJldmVyc2VVcGRhdGVPcCIsIm5ld0F0dGFjaENoaWxkT3BzIiwiY3JlYXRlQ3JkdE9wIiwibm9kZUlkIiwiaXNTYW1lTm9kZU9yQ2hpbGRPZiIsImlzTGl2ZUxpc3QiLCJpc0xpdmVNYXAiLCJpc0xpdmVPYmplY3QiLCJpc0xpdmVSZWdpc3RlciIsImNsb25lTHNvbiIsImdldFRyZWVzRGlmZk9wZXJhdGlvbnMiLCJjdXJyZW50SXRlbXMiLCJuZXdJdGVtcyIsImN1cnJlbnRDcmR0IiwibWVyZ2VPYmplY3RTdG9yYWdlVXBkYXRlcyIsImZpcnN0Iiwic2Vjb25kIiwibWVyZ2VNYXBTdG9yYWdlVXBkYXRlcyIsIm1lcmdlTGlzdFN0b3JhZ2VVcGRhdGVzIiwiY29uY2F0IiwibWVyZ2VTdG9yYWdlVXBkYXRlcyIsImlzUGxhaW4iLCJmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJwYXRoIiwibmVzdGVkVmFsdWUiLCJuZXN0ZWRQYXRoIiwibm9uU2VyaWFsaXphYmxlTmVzdGVkVmFsdWUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsInRyYWNlUm9vdCIsImVycm9yTGlrZSIsInN0YWNrIiwiaXNKc29uU2NhbGFyIiwiaXNKc29uQXJyYXkiLCJpc0pzb25PYmplY3QiLCJDbGllbnRNc2dDb2RlIiwiQ2xpZW50TXNnQ29kZTIiLCJtZXJnZSIsInVwZGF0ZWQiLCJJbW11dGFibGVSZWYiLCJfZXYiLCJkaWRJbnZhbGlkYXRlIiwiX2NhY2hlIiwibWFrZVVzZXIiLCJwcmVzZW5jZSIsImluZm8iLCJjYW5Xcml0ZSIsImlzUmVhZE9ubHkiLCJPdGhlcnNSZWYiLCJfY29ubmVjdGlvbnMiLCJfcHJlc2VuY2VzIiwiX3VzZXJzIiwiY29ubmVjdGlvbklkcyIsImdldFVzZXIiLCJOdW1iZXIiLCJjbGVhck90aGVycyIsIl9nZXRVc2VyIiwiY2FjaGVkVXNlciIsImNvbXB1dGVkVXNlciIsIl9pbnZhbGlkYXRlVXNlciIsInNldENvbm5lY3Rpb24iLCJtZXRhVXNlcklkIiwibWV0YVVzZXJJbmZvIiwicmVtb3ZlQ29ubmVjdGlvbiIsInNldE90aGVyIiwicGF0Y2hPdGhlciIsIm9sZFByZXNlbmNlIiwibmV3UHJlc2VuY2UiLCJQYXRjaGFibGVSZWYiLCJvbGREYXRhIiwibmV3RGF0YSIsIlZhbHVlUmVmIiwiaW5pdGlhbFZhbHVlIiwiRGVyaXZlZFJlZiIsInRyYW5zZm9ybUZuIiwib3RoZXJSZWZzIiwiX3JlZnMiLCJyZWYiLCJfdHJhbnNmb3JtIiwiTUFYX1NPQ0tFVF9NRVNTQUdFX1NJWkUiLCJtYWtlSWRGYWN0b3J5IiwidXNlclRvVHJlZU5vZGUiLCJpbnN0YWxsQmFja2dyb3VuZFRhYlNweSIsImluQmFja2dyb3VuZFNpbmNlIiwiY3JlYXRlUm9vbSIsImluaXRpYWxQcmVzZW5jZSIsImluaXRpYWxTdG9yYWdlIiwidW5pbnN0YWxsQmdUYWJTcHkiLCJiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCIsImdldFN0b3JhZ2VTdGF0dXMiLCJtYW5hZ2VkU29ja2V0IiwiYnVmZmVyIiwiZmx1c2hUaW1lcklEIiwibGFzdEZsdXNoZWRBdCIsInByZXNlbmNlVXBkYXRlcyIsIm1lc3NhZ2VzIiwic3RvcmFnZU9wZXJhdGlvbnMiLCJzdGF0aWNTZXNzaW9uSW5mbyIsImR5bmFtaWNTZXNzaW9uSW5mbyIsIm15UHJlc2VuY2UiLCJpZEZhY3RvcnkiLCJjbG9jayIsIm9wQ2xvY2siLCJub2RlcyIsInVuZG9TdGFjayIsInJlZG9TdGFjayIsInBhdXNlZEhpc3RvcnkiLCJhY3RpdmVCYXRjaCIsInVuYWNrbm93bGVkZ2VkT3BzIiwib3BTdGFja1RyYWNlcyIsImRvTm90QmF0Y2hVcGRhdGVzIiwiY2IiLCJiYXRjaFVwZGF0ZXMiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsImxhc3RUb2tlbktleSIsIm9uU3RhdHVzRGlkQ2hhbmdlIiwibmV3U3RhdHVzIiwidG9rZW5LZXkiLCJ1aWQiLCJ1c2VySW5mbyIsInVpIiwibm90aWZ5U2VsZkNoYW5nZWQiLCJfY29ubmVjdGlvbkxvc3NUaW1lcklkIiwiX2hhc0xvc3RDb25uZWN0aW9uIiwiaGFuZGxlQ29ubmVjdGlvbkxvc3NFdmVudCIsImxvc3RDb25uZWN0aW9uIiwibG9zdENvbm5lY3Rpb25UaW1lb3V0Iiwib25EaWRDb25uZWN0IiwiX2dldFN0b3JhZ2UkIiwicmVmcmVzaFN0b3JhZ2UiLCJmbHVzaCIsImZsdXNoTm93T3JTb29uIiwib25EaWREaXNjb25uZWN0IiwiaGFuZGxlU2VydmVyTWVzc2FnZSIsImdldENvbm5lY3Rpb25JZCIsInN0YWNrVHJhY2UiLCJhZGRUb1VuZG9TdGFjayIsImRpc3BhdGNoT3BzIiwiY29ubmVjdGlvbiIsImhpc3RvcnkiLCJzdG9yYWdlU3RhdHVzIiwic3RyZWFtRmV0Y2giLCJhdXRoVG9rZW5PclB1YmxpY0FwaUtleSIsImh0dHBQb3N0VG9Sb29tIiwic2VuZE1lc3NhZ2VzIiwic2VyaWFsaXplZFBheWxvYWQiLCJub25jZSIsInVuc3RhYmxlX2ZhbGxiYWNrVG9IVFRQIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJyZXNwIiwic3RhdGljU2Vzc2lvbiIsImR5bmFtaWNTZXNzaW9uIiwiYWN0b3IiLCJfbGFzdFNlbGYiLCJiYXRjaGVkVXBkYXRlc1dyYXBwZXIiLCJjdXJyU2VsZiIsInNlbGZBc1RyZWVOb2RlIiwiY3JlYXRlT3JVcGRhdGVSb290RnJvbU1lc3NhZ2UiLCJ1cGRhdGVSb290Iiwic3RhY2tTaXplQmVmb3JlIiwiYXBwbHlPcHMiLCJfYWRkVG9SZWFsVW5kb1N0YWNrIiwiaGlzdG9yeU9wcyIsInNoaWZ0Iiwib25IaXN0b3J5Q2hhbmdlIiwib3RoZXJzVXBkYXRlcyIsInVwZGF0ZXMyIiwibm90aWZ5U3RvcmFnZVN0YXR1cyIsInJhd09wcyIsIm91dHB1dCIsImNyZWF0ZWROb2RlSWRzIiwiZGVsZXRlZCIsImFwcGx5T3BSZXN1bHQiLCJhcHBseU9wIiwicGFyZW50Tm9kZSIsInVwZGF0ZVByZXNlbmNlIiwib3B0aW9uczIiLCJvbGRWYWx1ZXMiLCJvdmVycmlkZVZhbHVlIiwiYWRkVG9IaXN0b3J5Iiwib25VcGRhdGVQcmVzZW5jZU1lc3NhZ2UiLCJ0YXJnZXRBY3RvciIsIm9sZFVzZXIiLCJuZXdVc2VyIiwib25Vc2VyTGVmdE1lc3NhZ2UiLCJvblJvb21TdGF0ZU1lc3NhZ2UiLCJjYW5VbmRvIiwiY2FuUmVkbyIsIm9uVXNlckpvaW5lZE1lc3NhZ2UiLCJwYXJzZVNlcnZlck1lc3NhZ2UiLCJwYXJzZVNlcnZlck1lc3NhZ2VzIiwiYXBwbHlBbmRTZW5kT3BzIiwib2ZmbGluZU9wcyIsInVzZXJKb2luZWRVcGRhdGUiLCJvdGhlcnNQcmVzZW5jZVVwZGF0ZSIsInUiLCJldmVudDIiLCJwcm9jZXNzSW5pdGlhbFN0b3JhZ2UiLCJhcHBseVJlc3VsdCIsInRyYWNlcyIsIm9wSWRzIiwidHJhY2UiLCJzdG9yYWdlT3BzIiwiZWxhcHNlZE1pbGxpcyIsInRocm90dGxlRGVsYXkiLCJtZXNzYWdlc1RvRmx1c2giLCJzZXJpYWxpemVCdWZmZXIiLCJ1cGRhdGVZRG9jIiwiZ3VpZCIsImNsaWVudE1zZyIsImJyb2FkY2FzdEV2ZW50Iiwic2hvdWxkUXVldWVFdmVudElmTm90UmVhZHkiLCJfcmVzb2x2ZVN0b3JhZ2VQcm9taXNlIiwic3RyZWFtU3RvcmFnZSIsInVuc3RhYmxlX3N0cmVhbURhdGEiLCJzdGFydExvYWRpbmdTdG9yYWdlIiwiZ2V0U3RvcmFnZSIsInZlY3RvciIsIm0iLCJ1bmRvIiwicmVkbyIsImJhdGNoIiwicmV0dXJuVmFsdWUiLCJjdXJyZW50QmF0Y2giLCJwYXVzZUhpc3RvcnkiLCJyZXN1bWVIaXN0b3J5IiwiX2xhc3RTdG9yYWdlU3RhdHVzIiwib3RoZXJzX2ZvckRldlRvb2xzIiwib3RoZXIiLCJjb21tZW50c0FwaSIsInByZXNlbmNlQnVmZmVyIiwibm9kZUNvdW50Iiwic2ltdWxhdGUiLCJleHBsaWNpdENsb3NlIiwicmF3U2VuZCIsIm1ha2VDbGFzc2ljU3Vic2NyaWJlRm4iLCJyZXN1bWUiLCJnZXRDb25uZWN0aW9uU3RhdGUiLCJnZXRTZWxmIiwiZ2V0UHJlc2VuY2UiLCJnZXRPdGhlcnMiLCJzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVEZWVwbHkiLCJyZWxhdGVkVXBkYXRlcyIsInN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZVNoYWxsb3dseSIsImlzUm9vbUV2ZW50TmFtZSIsImludGVybmFsRXZlbnQiLCJzdG9yYWdlQ2FsbGJhY2siLCJpc0RlZXAiLCJub2RlQ2FsbGJhY2siLCJtYWtlQXV0aERlbGVnYXRlRm9yUm9vbSIsImF1dGhNYW5hZ2VyIiwibWFrZUNyZWF0ZVNvY2tldERlbGVnYXRlRm9yUm9vbSIsIldlYlNvY2tldFBvbHlmaWxsIiwid3MiLCJXZWJTb2NrZXQiLCJwcm90b2NvbCIsInBhdGhuYW1lIiwic2VhcmNoUGFyYW1zIiwiTUlOX1RIUk9UVExFIiwiTUFYX1RIUk9UVExFIiwiREVGQVVMVF9USFJPVFRMRSIsIk1JTl9CQUNLR1JPVU5EX0tFRVBfQUxJVkVfVElNRU9VVCIsIk1JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCIsIlJFQ09NTUVOREVEX01JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCIsIk1BWF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCIsIkRFRkFVTFRfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQiLCJnZXRCYXNlVXJsRnJvbUNsaWVudE9wdGlvbnMiLCJjbGllbnRPcHRpb25zIiwiY3JlYXRlQ2xpZW50IiwiZ2V0VGhyb3R0bGUiLCJ0aHJvdHRsZSIsImdldExvc3RDb25uZWN0aW9uVGltZW91dCIsImdldEJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0Iiwicm9vbXNCeUlkIiwidGVhcmRvd25Sb29tIiwibGVhc2VSb29tIiwibGVhdmUiLCJlbnRlclJvb20iLCJleGlzdGluZyIsIm5ld1Jvb20iLCJtb2NrZWREZWxlZ2F0ZXMiLCJuZXdSb29tSW5mbyIsInNob3VsZENvbm5lY3QiLCJhdXRvQ29ubmVjdCIsInNob3VsZEluaXRpYWxseUNvbm5lY3QiLCJnZXRSb29tIiwiZm9yY2VMZWF2ZSIsImxvZ291dCIsImNoZWNrQm91bmRzIiwib3B0aW9uIiwibWF4IiwicmVjb21tZW5kZWRNaW4iLCJ0b1BsYWluTHNvbiIsImxzb24iLCJsaXZlYmxvY2tzVHlwZSIsImxzb25PYmplY3RUb0pzb24iLCJsc29uVG9Kc29uIiwibGl2ZU9iamVjdFRvSnNvbiIsImxpdmVPYmplY3QiLCJsaXZlTWFwVG9Kc29uIiwibHNvbkxpc3RUb0pzb24iLCJsaXZlTGlzdFRvSnNvbiIsImRlZXBMaXZlaWZ5IiwiaW5pdCIsInBhdGNoTGl2ZUxpc3QiLCJwcmV2IiwicHJldkVuZCIsIm5leHRFbmQiLCJwcmV2Tm9kZSIsIm5leHROb2RlIiwib3V0ZXIiLCJsb2NhbEkiLCJsaXZlTGlzdE5vZGUiLCJwYXRjaExpdmVPYmplY3QiLCJwYXRjaExpdmVPYmplY3RLZXkiLCJub25TZXJpYWxpemFibGVWYWx1ZSIsImdldFBhcmVudHNQYXRoIiwibGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0IiwibGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0V2l0aFVwZGF0ZSIsImxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUiLCJwYXRoSXRlbSIsIm5ld1N0YXRlIiwibGlzdFVwZGF0ZSIsIm5ld0FycmF5Iiwic3RhdGVBc09iaiIsInNoYWxsb3dBcnJheSIsInhzIiwieXMiLCJpcyIsInNoYWxsb3dPYmoiLCJvYmpBIiwib2JqQiIsImtleXNBIiwiaGFzT3duUHJvcGVydHkiLCJzaGFsbG93IiwiYSIsImIiLCJpc0FycmF5QSIsImlzQXJyYXlCIiwibm9vcCIsImlzU2hhbGxvd0VxdWFsIiwiaXNMb2FkaW5nIiwiY3JlYXRlQ2FjaGVJdGVtIiwiYXN5bmNGdW5jdGlvbiIsIiRhc3luY0Z1bmN0aW9uIiwiaXNJbnZhbGlkIiwicHJldmlvdXNTdGF0ZSIsImV2ZW50U291cmNlMiIsImlzRXF1YWwiLCJpc1N0YXRlRXF1YWwiLCJyZXZhbGlkYXRlIiwiZ2V0U3RhdGUiLCJjcmVhdGVBc3luY0NhY2hlIiwiY2FjaGUiLCJjcmVhdGUiLCJjYWNoZUl0ZW0iLCJtYWtlUG9sbGVyIiwidGltZW91dEhhbmRsZSIsImludGVydmFsIiwibGFzdFNjaGVkdWxlZEF0IiwicmVtYWluaW5nSW50ZXJ2YWwiLCJwb2xsIiwic2NoZWR1bGUiLCJwZXJmb3JtYW5jZSIsInNjaGVkdWxlUmVtYWluaW5nIiwicmVtYWluaW5nIiwicmVzdGFydCIsIm9iamVjdCIsInNvcnRlZE9iamVjdCIsInNvcnRlZE9iamVjdDIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@liveblocks/react/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientSideSuspense: () => (/* binding */ ClientSideSuspense),\n/* harmony export */   createRoomContext: () => (/* binding */ createRoomContext),\n/* harmony export */   shallow: () => (/* reexport safe */ _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow),\n/* harmony export */   useRoomContextBundle: () => (/* binding */ useRoomContextBundle)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liveblocks/client */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! nanoid */ \"(ssr)/./node_modules/nanoid/index.js\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/index.js\");\n/* __next_internal_client_entry_do_not_use__ ClientSideSuspense,createRoomContext,shallow,useRoomContextBundle auto */ // src/index.ts\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/react\";\nvar PKG_VERSION = \"1.9.7\";\nvar PKG_FORMAT = \"esm\";\n// src/ClientSideSuspense.tsx\n\nfunction ClientSideSuspense(props) {\n    const [mounted, setMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        setMounted(true);\n    }, []);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n        fallback: props.fallback\n    }, mounted ? props.children() : props.fallback);\n}\n// src/factory.tsx\n\n\n\n\n// src/comments/CommentsRoom.tsx\n\n\n\n\n// src/comments/errors.ts\nvar CreateThreadError = class extends Error {\n    constructor(cause, context){\n        super(\"Create thread failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"CreateThreadError\";\n    }\n};\nvar EditThreadMetadataError = class extends Error {\n    constructor(cause, context){\n        super(\"Edit thread metadata failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"EditThreadMetadataError\";\n    }\n};\nvar CreateCommentError = class extends Error {\n    constructor(cause, context){\n        super(\"Create comment failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"CreateCommentError\";\n    }\n};\nvar EditCommentError = class extends Error {\n    constructor(cause, context){\n        super(\"Edit comment failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"EditCommentError\";\n    }\n};\nvar DeleteCommentError = class extends Error {\n    constructor(cause, context){\n        super(\"Delete comment failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"DeleteCommentError\";\n    }\n};\nvar AddReactionError = class extends Error {\n    constructor(cause, context){\n        super(\"Add reaction failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"AddReactionError\";\n    }\n};\nvar RemoveReactionError = class extends Error {\n    constructor(cause, context){\n        super(\"Remove reaction failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"RemoveReactionError\";\n    }\n};\n// src/comments/lib/revalidation.ts\n\n// src/comments/lib/use-is-document-visible.ts\n\nfunction useIsDocumentVisible() {\n    const isVisible = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(subscribe, getSnapshot, getSnapshot);\n    return isVisible;\n}\nfunction subscribe(onStoreChange) {\n    document.addEventListener(\"visibilitychange\", onStoreChange);\n    return ()=>{\n        document.removeEventListener(\"visibilitychange\", onStoreChange);\n    };\n}\nfunction getSnapshot() {\n    const isDocumentDefined = typeof document !== \"undefined\";\n    return isDocumentDefined ? document.visibilityState === \"visible\" : true;\n}\n// src/comments/lib/use-is-online.ts\n\n\nfunction useIsOnline() {\n    const isOnlineRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const subscribe2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((onStoreChange)=>{\n        function handleIsOnline() {\n            isOnlineRef.current = true;\n            onStoreChange();\n        }\n        function handleIsOffline() {\n            isOnlineRef.current = false;\n            onStoreChange();\n        }\n        window.addEventListener(\"online\", handleIsOnline);\n        window.addEventListener(\"offline\", handleIsOffline);\n        return ()=>{\n            window.removeEventListener(\"online\", handleIsOnline);\n            window.removeEventListener(\"offline\", handleIsOffline);\n        };\n    }, []);\n    const getSnapshot2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        return isOnlineRef.current;\n    }, []);\n    const isOnline = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(subscribe2, getSnapshot2, getSnapshot2);\n    return isOnline;\n}\n// src/comments/lib/revalidation.ts\nvar DEFAULT_ERROR_RETRY_INTERVAL = 5e3;\nvar DEFAULT_MAX_ERROR_RETRY_COUNT = 5;\nvar DEFAULT_DEDUPING_INTERVAL = 2e3;\nvar timestamp = 0;\nfunction useRevalidateCache(manager, fetcher, options = {}) {\n    const isOnlineRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const { dedupingInterval = DEFAULT_DEDUPING_INTERVAL, errorRetryInterval = DEFAULT_ERROR_RETRY_INTERVAL, errorRetryCount = DEFAULT_MAX_ERROR_RETRY_COUNT } = options;\n    const _revalidateCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ({ shouldDedupe, retryCount = 0 })=>{\n        let startAt;\n        const shouldStartRequest = !manager.getRequest() || !shouldDedupe;\n        function deleteActiveRequest() {\n            const activeRequest = manager.getRequest();\n            if (!activeRequest) return;\n            if (activeRequest.timestamp !== startAt) return;\n            manager.setRequest(void 0);\n        }\n        function handleError() {\n            const timeout = ~~((Math.random() + 0.5) * (1 << (retryCount < 8 ? retryCount : 8))) * errorRetryInterval;\n            if (retryCount > errorRetryCount) return;\n            setTimeout(()=>{\n                void _revalidateCache({\n                    shouldDedupe: false,\n                    retryCount: retryCount + 1\n                });\n            }, timeout);\n        }\n        if (shouldStartRequest) {\n            manager.setRequest({\n                fetcher: fetcher(),\n                timestamp: ++timestamp\n            });\n        }\n        try {\n            let activeRequest = manager.getRequest();\n            if (!activeRequest) return;\n            startAt = activeRequest.timestamp;\n            const newData = await activeRequest.fetcher;\n            if (shouldStartRequest) {\n                setTimeout(deleteActiveRequest, dedupingInterval);\n            }\n            activeRequest = manager.getRequest();\n            if (!activeRequest || activeRequest.timestamp !== startAt) return;\n            const activeMutation = manager.getMutation();\n            if (activeMutation && (activeMutation.startTime > startAt || activeMutation.endTime > startAt || activeMutation.endTime === 0)) {\n                return;\n            }\n            manager.setCache(newData);\n        } catch (err) {\n            deleteActiveRequest();\n            const isVisible = document.visibilityState === \"visible\";\n            const isOnline = isOnlineRef.current;\n            if (shouldStartRequest && isVisible && isOnline) handleError();\n            manager.setError(err);\n        }\n        return;\n    }, [\n        manager,\n        fetcher,\n        dedupingInterval,\n        errorRetryInterval,\n        errorRetryCount\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        function handleIsOnline() {\n            isOnlineRef.current = true;\n        }\n        function handleIsOffline() {\n            isOnlineRef.current = false;\n        }\n        window.addEventListener(\"online\", handleIsOnline);\n        window.addEventListener(\"offline\", handleIsOffline);\n        return ()=>{\n            window.removeEventListener(\"online\", handleIsOnline);\n            window.removeEventListener(\"offline\", handleIsOffline);\n        };\n    }, []);\n    const revalidateCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ shouldDedupe })=>{\n        return _revalidateCache({\n            shouldDedupe,\n            retryCount: 0\n        });\n    }, [\n        _revalidateCache\n    ]);\n    return revalidateCache;\n}\nfunction useMutate(manager, revalidateCache) {\n    const mutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (data, options)=>{\n        const beforeMutationTimestamp = ++timestamp;\n        manager.setMutation({\n            startTime: beforeMutationTimestamp,\n            endTime: 0\n        });\n        const currentCache = manager.getCache();\n        manager.setCache(options.optimisticData);\n        let error;\n        try {\n            await data;\n        } catch (err) {\n            error = err;\n        }\n        const activeMutation = manager.getMutation();\n        if (activeMutation && beforeMutationTimestamp !== activeMutation.startTime) {\n            if (error) throw error;\n            return;\n        }\n        if (error) {\n            manager.setCache(currentCache);\n        }\n        manager.setMutation({\n            startTime: beforeMutationTimestamp,\n            endTime: ++timestamp\n        });\n        manager.setRequest(void 0);\n        void revalidateCache({\n            shouldDedupe: false\n        });\n        if (error) throw error;\n    }, [\n        manager,\n        revalidateCache\n    ]);\n    return mutate;\n}\n// src/comments/CommentsRoom.tsx\nvar THREAD_ID_PREFIX = \"th\";\nvar COMMENT_ID_PREFIX = \"cm\";\nvar POLLING_INTERVAL_REALTIME = 3e4;\nvar POLLING_INTERVAL = 5e3;\nfunction createCommentsRoom(errorEventSource) {\n    const store = createClientCacheStore();\n    const FetcherContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\n    const RoomManagerContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\n    function getThreads(manager) {\n        const threads = manager.getCache();\n        if (!threads) {\n            throw new Error(\"Cannot update threads or comments before they are loaded.\");\n        }\n        return threads;\n    }\n    function CommentsRoomProvider({ room, children }) {\n        const manager = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n            return createRoomRevalidationManager(room.id, {\n                getCache: store.getThreads,\n                setCache: store.setThreads\n            });\n        }, [\n            room.id\n        ]);\n        const fetcher = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async ()=>{\n            const options = manager.getRevalidationManagers().filter(([key])=>manager.getReferenceCount(key) > 0).map(([_, manager2])=>manager2.getOptions());\n            const responses = await Promise.all(options.map(async (option)=>{\n                return await room.getThreads(option);\n            }));\n            const threads = Array.from(new Map(responses.flat().map((thread)=>[\n                    thread.id,\n                    thread\n                ])).values());\n            return threads;\n        }, [\n            room,\n            manager\n        ]);\n        const revalidateCache = useRevalidateCache(manager, fetcher);\n        const status = useSyncExternalStore3(room.events.status.subscribe, room.getStatus, room.getStatus);\n        const isOnline = useIsOnline();\n        const isDocumentVisible = useIsDocumentVisible();\n        const refreshInterval = getPollingInterval(isOnline, isDocumentVisible, status === \"connected\");\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            let revalidationTimerId;\n            function scheduleRevalidation() {\n                if (refreshInterval === 0) return;\n                revalidationTimerId = window.setTimeout(()=>{\n                    if (isOnline && isDocumentVisible && !manager.getError() && manager.getTotalReferenceCount() > 0) {\n                        void revalidateCache({\n                            shouldDedupe: true\n                        }).then(scheduleRevalidation);\n                        return;\n                    }\n                    scheduleRevalidation();\n                }, refreshInterval);\n            }\n            scheduleRevalidation();\n            return ()=>{\n                window.clearTimeout(revalidationTimerId);\n            };\n        }, [\n            revalidateCache,\n            refreshInterval,\n            isOnline,\n            isDocumentVisible,\n            manager\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            function handleIsOnline() {\n                if (isDocumentVisible) {\n                    void revalidateCache({\n                        shouldDedupe: true\n                    });\n                }\n            }\n            window.addEventListener(\"online\", handleIsOnline);\n            return ()=>{\n                window.removeEventListener(\"online\", handleIsOnline);\n            };\n        }, [\n            revalidateCache,\n            isDocumentVisible\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            function handleVisibilityChange() {\n                const isVisible = document.visibilityState === \"visible\";\n                if (isVisible && isOnline) {\n                    void revalidateCache({\n                        shouldDedupe: true\n                    });\n                }\n            }\n            document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n            return ()=>{\n                document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n            };\n        }, [\n            revalidateCache,\n            isOnline\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            const unsubscribe = room.events.comments.subscribe(()=>{\n                void revalidateCache({\n                    shouldDedupe: false\n                });\n            });\n            return ()=>{\n                unsubscribe();\n            };\n        }, [\n            room,\n            revalidateCache\n        ]);\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetcherContext.Provider, {\n            value: fetcher\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomManagerContext.Provider, {\n            value: manager\n        }, children));\n    }\n    function useRoomManager() {\n        const manager = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RoomManagerContext);\n        if (manager === null) {\n            throw new Error(\"CommentsRoomProvider is missing from the React tree.\");\n        }\n        return manager;\n    }\n    function getUseThreadsRevalidationManager(options, roomManager) {\n        const key = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(options);\n        const revalidationManager = roomManager.getRevalidationManager(key);\n        if (!revalidationManager) {\n            const useThreadsRevalidationManager = createUseThreadsRevalidationManager(options, roomManager);\n            roomManager.setRevalidationmanager(key, useThreadsRevalidationManager);\n            return useThreadsRevalidationManager;\n        }\n        return revalidationManager;\n    }\n    function useThreadsFetcher() {\n        const fetcher = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FetcherContext);\n        if (fetcher === null) {\n            throw new Error(\"CommentsRoomProvider is missing from the React tree.\");\n        }\n        return fetcher;\n    }\n    function useThreads(room, options = {\n        query: {\n            metadata: {}\n        }\n    }) {\n        const key = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(options), [\n            options\n        ]);\n        const manager = useRoomManager();\n        const useThreadsRevalidationManager = getUseThreadsRevalidationManager(options, manager);\n        const fetcher = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n            return room.getThreads(options);\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps -- The missing dependency is `options` but `key` and `normalized` are analogous, so we only include `key` as dependency. This helps minimize the number of re-renders as `options` can change on each render\n        [\n            key,\n            room\n        ]);\n        const revalidateCache = useRevalidateCache(useThreadsRevalidationManager, fetcher);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            void revalidateCache({\n                shouldDedupe: true\n            });\n        }, [\n            revalidateCache\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            manager.incrementReferenceCount(key);\n            return ()=>{\n                manager.decrementReferenceCount(key);\n            };\n        }, [\n            manager,\n            key\n        ]);\n        const cache = _useThreads(room, options);\n        return cache;\n    }\n    function useThreadsSuspense(room, options = {\n        query: {\n            metadata: {}\n        }\n    }) {\n        const key = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(options), [\n            options\n        ]);\n        const manager = useRoomManager();\n        const useThreadsRevalidationManager = getUseThreadsRevalidationManager(options, manager);\n        const fetcher = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n            return room.getThreads(options);\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps -- The missing dependency is `options` but `key` and `normalized` are analogous, so we only include `key` as dependency. This helps minimize the number of re-renders as `options` can change on each render\n        [\n            key,\n            room\n        ]);\n        const revalidateCache = useRevalidateCache(useThreadsRevalidationManager, fetcher);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            void revalidateCache({\n                shouldDedupe: true\n            });\n        }, [\n            revalidateCache\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            manager.incrementReferenceCount(key);\n            return ()=>{\n                manager.decrementReferenceCount(key);\n            };\n        }, [\n            manager,\n            key\n        ]);\n        const cache = _useThreads(room, options);\n        if (cache.error) {\n            throw cache.error;\n        }\n        if (cache.isLoading || !cache.threads) {\n            throw revalidateCache({\n                shouldDedupe: true\n            });\n        }\n        return {\n            isLoading: false,\n            threads: cache.threads,\n            error: cache.error\n        };\n    }\n    function _useThreads(room, options) {\n        const manager = useRoomManager();\n        const useThreadsRevalidationManager = getUseThreadsRevalidationManager(options, manager);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(store.subscribe, ()=>store.getThreads(), ()=>store.getThreads(), (state)=>{\n            const isLoading = useThreadsRevalidationManager.getIsLoading();\n            if (isLoading) {\n                return {\n                    isLoading: true\n                };\n            }\n            const options2 = useThreadsRevalidationManager.getOptions();\n            const error = useThreadsRevalidationManager.getError();\n            const filtered = state.filter((thread)=>{\n                if (thread.roomId !== room.id) return false;\n                const query = options2.query ?? {};\n                for(const key in query.metadata){\n                    if (thread.metadata[key] !== query.metadata[key]) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n            return {\n                isLoading: false,\n                threads: filtered,\n                error\n            };\n        });\n    }\n    function useEditThreadMetadata(room) {\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const editThreadMetadata = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((options)=>{\n            const threadId = options.threadId;\n            const metadata = \"metadata\" in options ? options.metadata : {};\n            const threads = getThreads(manager);\n            const optimisticData = threads.map((thread)=>thread.id === threadId ? {\n                    ...thread,\n                    metadata: {\n                        ...thread.metadata,\n                        ...metadata\n                    }\n                } : thread);\n            mutate(room.editThreadMetadata({\n                metadata,\n                threadId\n            }), {\n                optimisticData\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new EditThreadMetadataError(error, {\n                    roomId: room.id,\n                    threadId,\n                    metadata\n                }));\n            });\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return editThreadMetadata;\n    }\n    function useCreateThread(room) {\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const createThread = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((options)=>{\n            const body = options.body;\n            const metadata = \"metadata\" in options ? options.metadata : {};\n            const threads = getThreads(manager);\n            const threadId = createThreadId();\n            const commentId = createCommentId();\n            const now = /* @__PURE__ */ new Date();\n            const newComment = {\n                id: commentId,\n                threadId,\n                roomId: room.id,\n                createdAt: now,\n                type: \"comment\",\n                userId: getCurrentUserId(room),\n                body,\n                reactions: []\n            };\n            const newThread = {\n                id: threadId,\n                type: \"thread\",\n                createdAt: now,\n                roomId: room.id,\n                metadata,\n                comments: [\n                    newComment\n                ]\n            };\n            mutate(room.createThread({\n                threadId,\n                commentId,\n                body,\n                metadata\n            }), {\n                optimisticData: [\n                    ...threads,\n                    newThread\n                ]\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new CreateThreadError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    body,\n                    metadata\n                }));\n            });\n            return newThread;\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return createThread;\n    }\n    function useCreateComment(room) {\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const createComment = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ threadId, body })=>{\n            const threads = getThreads(manager);\n            const commentId = createCommentId();\n            const now = /* @__PURE__ */ new Date();\n            const comment = {\n                id: commentId,\n                threadId,\n                roomId: room.id,\n                type: \"comment\",\n                createdAt: now,\n                userId: getCurrentUserId(room),\n                body,\n                reactions: []\n            };\n            const optimisticData = threads.map((thread)=>thread.id === threadId ? {\n                    ...thread,\n                    comments: [\n                        ...thread.comments,\n                        comment\n                    ]\n                } : thread);\n            mutate(room.createComment({\n                threadId,\n                commentId,\n                body\n            }), {\n                optimisticData\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new CreateCommentError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    body\n                }));\n            });\n            return comment;\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return createComment;\n    }\n    function useEditComment(room) {\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const editComment = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ threadId, commentId, body })=>{\n            const threads = getThreads(manager);\n            const now = /* @__PURE__ */ new Date();\n            const optimisticData = threads.map((thread)=>thread.id === threadId ? {\n                    ...thread,\n                    comments: thread.comments.map((comment)=>comment.id === commentId ? {\n                            ...comment,\n                            editedAt: now,\n                            body\n                        } : comment)\n                } : thread);\n            mutate(room.editComment({\n                threadId,\n                commentId,\n                body\n            }), {\n                optimisticData\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new EditCommentError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    body\n                }));\n            });\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return editComment;\n    }\n    function useDeleteComment(room) {\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const deleteComment = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ threadId, commentId })=>{\n            const threads = getThreads(manager);\n            const now = /* @__PURE__ */ new Date();\n            const newThreads = [];\n            for (const thread of threads){\n                if (thread.id === threadId) {\n                    const newThread = {\n                        ...thread,\n                        comments: thread.comments.map((comment)=>comment.id === commentId ? {\n                                ...comment,\n                                deletedAt: now,\n                                body: void 0\n                            } : comment)\n                    };\n                    if (newThread.comments.some((comment)=>comment.deletedAt === void 0)) {\n                        newThreads.push(newThread);\n                    }\n                } else {\n                    newThreads.push(thread);\n                }\n            }\n            mutate(room.deleteComment({\n                threadId,\n                commentId\n            }), {\n                optimisticData: newThreads\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new DeleteCommentError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId\n                }));\n            });\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return deleteComment;\n    }\n    function useAddReaction(room) {\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const createComment = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ threadId, commentId, emoji })=>{\n            const threads = getThreads(manager);\n            const now = /* @__PURE__ */ new Date();\n            const userId = getCurrentUserId(room);\n            const optimisticData = threads.map((thread)=>thread.id === threadId ? {\n                    ...thread,\n                    comments: thread.comments.map((comment)=>{\n                        if (comment.id !== commentId) {\n                            return comment;\n                        }\n                        let reactions;\n                        if (comment.reactions.some((reaction)=>reaction.emoji === emoji)) {\n                            reactions = comment.reactions.map((reaction)=>reaction.emoji === emoji ? {\n                                    ...reaction,\n                                    users: [\n                                        ...reaction.users,\n                                        {\n                                            id: userId\n                                        }\n                                    ]\n                                } : reaction);\n                        } else {\n                            reactions = [\n                                ...comment.reactions,\n                                {\n                                    emoji,\n                                    createdAt: now,\n                                    users: [\n                                        {\n                                            id: userId\n                                        }\n                                    ]\n                                }\n                            ];\n                        }\n                        return {\n                            ...comment,\n                            reactions\n                        };\n                    })\n                } : thread);\n            mutate(room.addReaction({\n                threadId,\n                commentId,\n                emoji\n            }), {\n                optimisticData\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new AddReactionError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    emoji\n                }));\n            });\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return createComment;\n    }\n    function useRemoveReaction(room) {\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const createComment = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ threadId, commentId, emoji })=>{\n            const threads = getThreads(manager);\n            const userId = getCurrentUserId(room);\n            const optimisticData = threads.map((thread)=>thread.id === threadId ? {\n                    ...thread,\n                    comments: thread.comments.map((comment)=>{\n                        if (comment.id !== commentId) {\n                            return comment;\n                        }\n                        const reactionIndex = comment.reactions.findIndex((reaction)=>reaction.emoji === emoji);\n                        let reactions = comment.reactions;\n                        if (reactionIndex >= 0 && comment.reactions[reactionIndex].users.some((user)=>user.id === userId)) {\n                            if (comment.reactions[reactionIndex].users.length <= 1) {\n                                reactions = [\n                                    ...comment.reactions\n                                ];\n                                reactions.splice(reactionIndex, 1);\n                            } else {\n                                reactions[reactionIndex] = {\n                                    ...reactions[reactionIndex],\n                                    users: reactions[reactionIndex].users.filter((user)=>user.id !== userId)\n                                };\n                            }\n                        }\n                        return {\n                            ...comment,\n                            reactions\n                        };\n                    })\n                } : thread);\n            mutate(room.removeReaction({\n                threadId,\n                commentId,\n                emoji\n            }), {\n                optimisticData\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new RemoveReactionError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    emoji\n                }));\n            });\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return createComment;\n    }\n    return {\n        CommentsRoomProvider,\n        useThreads,\n        useThreadsSuspense,\n        useEditThreadMetadata,\n        useCreateThread,\n        useCreateComment,\n        useEditComment,\n        useDeleteComment,\n        useAddReaction,\n        useRemoveReaction\n    };\n}\nfunction createOptimisticId(prefix) {\n    return `${prefix}_${(0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)()}`;\n}\nfunction createThreadId() {\n    return createOptimisticId(THREAD_ID_PREFIX);\n}\nfunction createCommentId() {\n    return createOptimisticId(COMMENT_ID_PREFIX);\n}\nfunction getCurrentUserId(room) {\n    const self = room.getSelf();\n    if (self === null || self.id === void 0) {\n        return \"anonymous\";\n    } else {\n        return self.id;\n    }\n}\nfunction handleCommentsApiError(err) {\n    const message = `Request failed with status ${err.status}: ${err.message}`;\n    if (err.details?.error === \"FORBIDDEN\") {\n        const detailedMessage = [\n            message,\n            err.details.suggestion,\n            err.details.docs\n        ].filter(Boolean).join(\"\\n\");\n        console.error(detailedMessage);\n    }\n    return new Error(message);\n}\nfunction createRoomRevalidationManager(roomId, { getCache, setCache }) {\n    let request;\n    let error;\n    let mutation;\n    const revalidationManagerByOptions = /* @__PURE__ */ new Map();\n    const referenceCountByOptions = /* @__PURE__ */ new Map();\n    return {\n        // Cache\n        getCache () {\n            const threads = getCache();\n            const filtered = threads.filter((thread)=>thread.roomId === roomId);\n            return filtered;\n        },\n        setCache (value) {\n            for (const key of revalidationManagerByOptions.keys()){\n                if (referenceCountByOptions.get(key) === 0) {\n                    revalidationManagerByOptions.delete(key);\n                    referenceCountByOptions.delete(key);\n                }\n            }\n            const sorted = value.sort((a, b)=>new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n            const threads = getCache();\n            const newThreads = threads.filter((thread)=>thread.roomId !== roomId).concat(sorted);\n            setCache(newThreads);\n        },\n        // Request\n        getRequest () {\n            return request;\n        },\n        setRequest (value) {\n            request = value;\n        },\n        // Error\n        getError () {\n            return error;\n        },\n        setError (err) {\n            error = err;\n        },\n        // Mutation\n        getMutation () {\n            return mutation;\n        },\n        setMutation (info) {\n            mutation = info;\n        },\n        getRevalidationManagers () {\n            return Array.from(revalidationManagerByOptions.entries());\n        },\n        getRevalidationManager (key) {\n            return revalidationManagerByOptions.get(key);\n        },\n        setRevalidationmanager (key, manager) {\n            revalidationManagerByOptions.set(key, manager);\n        },\n        getTotalReferenceCount () {\n            return Array.from(referenceCountByOptions.values()).reduce((acc, count)=>acc + count, 0);\n        },\n        incrementReferenceCount (key) {\n            const count = referenceCountByOptions.get(key) ?? 0;\n            referenceCountByOptions.set(key, count + 1);\n        },\n        decrementReferenceCount (key) {\n            const count = referenceCountByOptions.get(key) ?? 0;\n            referenceCountByOptions.set(key, count - 1);\n        },\n        getReferenceCount (key) {\n            return referenceCountByOptions.get(key) ?? 0;\n        }\n    };\n}\nfunction createClientCacheStore() {\n    let threads = [];\n    const threadsEventSource = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makeEventSource)();\n    return {\n        getThreads () {\n            return threads;\n        },\n        setThreads (value) {\n            threads = value;\n            threadsEventSource.notify(threads);\n        },\n        subscribe (callback) {\n            return threadsEventSource.subscribe(callback);\n        }\n    };\n}\nfunction createUseThreadsRevalidationManager(options, manager) {\n    let isLoading = true;\n    let request;\n    let error;\n    return {\n        // Cache\n        getCache () {\n            return void 0;\n        },\n        setCache (value) {\n            const cache = new Map((manager.getCache() ?? []).map((thread)=>[\n                    thread.id,\n                    thread\n                ]));\n            for (const thread of value){\n                cache.set(thread.id, thread);\n            }\n            manager.setCache(Array.from(cache.values()));\n            isLoading = false;\n        },\n        // Request\n        getRequest () {\n            return request;\n        },\n        setRequest (value) {\n            request = value;\n        },\n        // Error\n        getError () {\n            return error;\n        },\n        setError (err) {\n            error = err;\n            isLoading = false;\n            const cache = manager.getCache();\n            manager.setCache(cache);\n        },\n        // Mutation\n        getMutation () {\n            return void 0;\n        },\n        setMutation (_) {\n            return;\n        },\n        getOptions () {\n            return options;\n        },\n        getIsLoading () {\n            return isLoading;\n        },\n        setIsLoading (value) {\n            isLoading = value;\n        }\n    };\n}\nfunction getPollingInterval(isBrowserOnline, isDocumentVisible, isRoomConnected) {\n    if (!isBrowserOnline || !isDocumentVisible) return;\n    if (isRoomConnected) return POLLING_INTERVAL_REALTIME;\n    return POLLING_INTERVAL;\n}\n// src/comments/lib/use-debounce.ts\n\nvar DEFAULT_DELAY = 500;\nfunction useDebounce(value, delay = DEFAULT_DELAY) {\n    const timeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const [debouncedValue, setDebouncedValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(value);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (delay === false) {\n            return;\n        }\n        if (timeout.current === void 0) {\n            setDebouncedValue(value);\n        }\n        timeout.current = window.setTimeout(()=>{\n            setDebouncedValue(value);\n            timeout.current = void 0;\n        }, delay);\n        return ()=>{\n            window.clearTimeout(timeout.current);\n        };\n    }, [\n        value,\n        delay\n    ]);\n    return debouncedValue;\n}\n// src/lib/use-async-cache.ts\n\n\n// src/lib/use-initial.ts\n\nfunction useInitial(value) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(value)[0];\n}\n// src/lib/use-async-cache.ts\nvar INITIAL_ASYNC_STATE = {\n    isLoading: false,\n    data: void 0,\n    error: void 0\n};\nvar noop = ()=>{};\nfunction useAsyncCache(cache, key, options) {\n    const frozenOptions = useInitial(options);\n    const cacheItem = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (key === null || !cache) {\n            return null;\n        }\n        const cacheItem2 = cache.create(key);\n        void cacheItem2.get();\n        return cacheItem2;\n    }, [\n        cache,\n        key\n    ]);\n    const subscribe2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback)=>cacheItem?.subscribe(callback) ?? noop, [\n        cacheItem\n    ]);\n    const getState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>cacheItem?.getState() ?? INITIAL_ASYNC_STATE, [\n        cacheItem\n    ]);\n    const revalidate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>cacheItem?.revalidate(), [\n        cacheItem\n    ]);\n    const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(subscribe2, getState, getState);\n    const previousData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    let data = state.data;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        previousData.current = {\n            key,\n            data: state.data\n        };\n    }, [\n        key,\n        state.data\n    ]);\n    if (!cacheItem) {\n        return {\n            isLoading: false,\n            data: void 0,\n            error: void 0,\n            getState,\n            revalidate\n        };\n    }\n    if (frozenOptions?.suspense) {\n        const error = getState().error;\n        if (error) {\n            throw error;\n        } else if (getState().isLoading) {\n            throw new Promise((resolve)=>{\n                cacheItem.subscribeOnce((state2)=>{\n                    if (!state2.isLoading) {\n                        resolve();\n                    }\n                });\n            });\n        }\n    }\n    if (state.isLoading && frozenOptions?.keepPreviousDataWhileLoading && typeof state.data === \"undefined\" && previousData.current?.key !== key && typeof previousData.current?.data !== \"undefined\") {\n        data = previousData.current.data;\n    }\n    return {\n        isLoading: state.isLoading,\n        data,\n        error: state.error,\n        getState,\n        revalidate\n    };\n}\n// src/lib/use-latest.ts\n\nfunction useLatest(value) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = value;\n    }, [\n        value\n    ]);\n    return ref;\n}\n// src/lib/use-rerender.ts\n\nfunction useRerender() {\n    const [, update] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(// This implementation works by incrementing a hidden counter value that is\n    // never consumed. Simply incrementing the counter changes the component's\n    // state and, thus, trigger a re-render.\n    (x)=>x + 1, 0);\n    return update;\n}\n// src/factory.tsx\nvar noop2 = ()=>{};\nvar identity = (x)=>x;\nvar missing_unstable_batchedUpdates = (reactVersion, roomId)=>`We noticed you\\u2019re using React ${reactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you\\u2019re ready to upgrade to React 18:\n\n    import { unstable_batchedUpdates } from \"react-dom\";  // or \"react-native\"\n\n    <RoomProvider id=${JSON.stringify(roomId)} ... unstable_batchedUpdates={unstable_batchedUpdates}>\n      ...\n    </RoomProvider>\n\nWhy? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information`;\nvar superfluous_unstable_batchedUpdates = \"You donâ€™t need to pass unstable_batchedUpdates to RoomProvider anymore, since youâ€™re on React 18+ already.\";\nfunction useSyncExternalStore3(s, gs, gss) {\n    return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(s, gs, gss, identity);\n}\nvar STABLE_EMPTY_LIST = Object.freeze([]);\nfunction alwaysEmptyList() {\n    return STABLE_EMPTY_LIST;\n}\nfunction alwaysNull() {\n    return null;\n}\nfunction makeMutationContext(room) {\n    const errmsg = \"This mutation cannot be used until connected to the Liveblocks room\";\n    return {\n        get storage () {\n            const mutableRoot = room.getStorageSnapshot();\n            if (mutableRoot === null) {\n                throw new Error(errmsg);\n            }\n            return mutableRoot;\n        },\n        get self () {\n            const self = room.getSelf();\n            if (self === null) {\n                throw new Error(errmsg);\n            }\n            return self;\n        },\n        get others () {\n            const others = room.getOthers();\n            if (room.getSelf() === null) {\n                throw new Error(errmsg);\n            }\n            return others;\n        },\n        setMyPresence: room.updatePresence\n    };\n}\nvar hasWarnedIfNoResolveUsers = false;\nfunction warnIfNoResolveUsers(usersCache) {\n    if (!hasWarnedIfNoResolveUsers && !usersCache && \"development\" !== \"production\") {\n        console.warn(\"Set the resolveUsers option in createRoomContext to specify user info.\");\n        hasWarnedIfNoResolveUsers = true;\n    }\n}\nvar ContextBundle = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction useRoomContextBundle() {\n    const bundle = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ContextBundle);\n    if (bundle === null) {\n        throw new Error(\"RoomProvider is missing from the React tree.\");\n    }\n    return bundle;\n}\nfunction createRoomContext(client, options) {\n    const RoomContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n    const commentsErrorEventSource = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makeEventSource)();\n    const { CommentsRoomProvider, ...commentsRoom } = createCommentsRoom(commentsErrorEventSource);\n    function RoomProviderOuter(props) {\n        const [cache] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>/* @__PURE__ */ new Map());\n        const stableEnterRoom = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((roomId, options2)=>{\n            const cached = cache.get(roomId);\n            if (cached) return cached;\n            const rv = client.enterRoom(roomId, options2);\n            const origLeave = rv.leave;\n            rv.leave = ()=>{\n                origLeave();\n                cache.delete(roomId);\n            };\n            cache.set(roomId, rv);\n            return rv;\n        }, [\n            cache\n        ]);\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomProviderInner, {\n            ...props,\n            stableEnterRoom\n        });\n    }\n    function RoomProviderInner(props) {\n        const { id: roomId, stableEnterRoom } = props;\n        if (true) {\n            if (!roomId) {\n                throw new Error(\"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\");\n            }\n            if (typeof roomId !== \"string\") {\n                throw new Error(\"RoomProvider id property should be a string.\");\n            }\n            const majorReactVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version) || 1;\n            const oldReactVersion = majorReactVersion < 18;\n            (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.errorIf)(oldReactVersion && props.unstable_batchedUpdates === void 0, missing_unstable_batchedUpdates(majorReactVersion, roomId));\n            (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.deprecateIf)(!oldReactVersion && props.unstable_batchedUpdates !== void 0, superfluous_unstable_batchedUpdates);\n        }\n        const frozenProps = useInitial({\n            initialPresence: props.initialPresence,\n            initialStorage: props.initialStorage,\n            unstable_batchedUpdates: props.unstable_batchedUpdates,\n            autoConnect: props.autoConnect ?? props.shouldInitiallyConnect ?? \"undefined\" !== \"undefined\"\n        });\n        const [{ room }, setRoomLeavePair] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>stableEnterRoom(roomId, {\n                ...frozenProps,\n                autoConnect: false\n            }));\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            const pair = stableEnterRoom(roomId, frozenProps);\n            setRoomLeavePair(pair);\n            const { room: room2, leave } = pair;\n            if (frozenProps.autoConnect) {\n                room2.connect();\n            }\n            return ()=>{\n                leave();\n            };\n        }, [\n            roomId,\n            frozenProps,\n            stableEnterRoom\n        ]);\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomContext.Provider, {\n            value: room\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CommentsRoomProvider, {\n            room\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextBundle.Provider, {\n            value: internalBundle\n        }, props.children)));\n    }\n    function connectionIdSelector(others) {\n        return others.map((user)=>user.connectionId);\n    }\n    function useRoom() {\n        const room = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RoomContext);\n        if (room === null) {\n            throw new Error(\"RoomProvider is missing from the React tree.\");\n        }\n        return room;\n    }\n    function useStatus() {\n        const room = useRoom();\n        const subscribe2 = room.events.status.subscribe;\n        const getSnapshot2 = room.getStatus;\n        const getServerSnapshot = room.getStatus;\n        return useSyncExternalStore3(subscribe2, getSnapshot2, getServerSnapshot);\n    }\n    function useMyPresence() {\n        const room = useRoom();\n        const subscribe2 = room.events.myPresence.subscribe;\n        const getSnapshot2 = room.getPresence;\n        const presence = useSyncExternalStore3(subscribe2, getSnapshot2, getSnapshot2);\n        const setPresence = room.updatePresence;\n        return [\n            presence,\n            setPresence\n        ];\n    }\n    function useUpdateMyPresence() {\n        return useRoom().updatePresence;\n    }\n    function useOthers(selector, isEqual) {\n        const room = useRoom();\n        const subscribe2 = room.events.others.subscribe;\n        const getSnapshot2 = room.getOthers;\n        const getServerSnapshot = alwaysEmptyList;\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(subscribe2, getSnapshot2, getServerSnapshot, selector ?? identity, isEqual);\n    }\n    function useOthersConnectionIds() {\n        return useOthers(connectionIdSelector, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow);\n    }\n    function useOthersMapped(itemSelector, itemIsEqual) {\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((others)=>others.map((other)=>[\n                    other.connectionId,\n                    itemSelector(other)\n                ]), [\n            itemSelector\n        ]);\n        const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((a, b)=>{\n            const eq = itemIsEqual ?? Object.is;\n            return a.length === b.length && a.every((atuple, index)=>{\n                const btuple = b[index];\n                return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n            });\n        }, [\n            itemIsEqual\n        ]);\n        return useOthers(wrappedSelector, wrappedIsEqual);\n    }\n    const NOT_FOUND = Symbol();\n    function useOther(connectionId, selector, isEqual) {\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((others)=>{\n            const other2 = others.find((other3)=>other3.connectionId === connectionId);\n            return other2 !== void 0 ? selector(other2) : NOT_FOUND;\n        }, [\n            connectionId,\n            selector\n        ]);\n        const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((prev, curr)=>{\n            if (prev === NOT_FOUND || curr === NOT_FOUND) {\n                return prev === curr;\n            }\n            const eq = isEqual ?? Object.is;\n            return eq(prev, curr);\n        }, [\n            isEqual\n        ]);\n        const other = useOthers(wrappedSelector, wrappedIsEqual);\n        if (other === NOT_FOUND) {\n            throw new Error(`No such other user with connection id ${connectionId} exists`);\n        }\n        return other;\n    }\n    function useBroadcastEvent() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event, options2 = {\n            shouldQueueEventIfNotReady: false\n        })=>{\n            room.broadcastEvent(event, options2);\n        }, [\n            room\n        ]);\n    }\n    function useOthersListener(callback) {\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>room.events.others.subscribe((event)=>savedCallback.current(event)), [\n            room,\n            savedCallback\n        ]);\n    }\n    function useLostConnectionListener(callback) {\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>room.events.lostConnection.subscribe((event)=>savedCallback.current(event)), [\n            room,\n            savedCallback\n        ]);\n    }\n    function useErrorListener(callback) {\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>room.events.error.subscribe((e)=>savedCallback.current(e)), [\n            room,\n            savedCallback\n        ]);\n    }\n    function useEventListener(callback) {\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            const listener = (eventData)=>{\n                savedCallback.current(eventData);\n            };\n            return room.events.customEvent.subscribe(listener);\n        }, [\n            room,\n            savedCallback\n        ]);\n    }\n    function useSelf(maybeSelector, isEqual) {\n        const room = useRoom();\n        const subscribe2 = room.events.self.subscribe;\n        const getSnapshot2 = room.getSelf;\n        const selector = maybeSelector ?? identity;\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((me)=>me !== null ? selector(me) : null, [\n            selector\n        ]);\n        const getServerSnapshot = alwaysNull;\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(subscribe2, getSnapshot2, getServerSnapshot, wrappedSelector, isEqual);\n    }\n    function useMutableStorageRoot() {\n        const room = useRoom();\n        const subscribe2 = room.events.storageDidLoad.subscribeOnce;\n        const getSnapshot2 = room.getStorageSnapshot;\n        const getServerSnapshot = alwaysNull;\n        return useSyncExternalStore3(subscribe2, getSnapshot2, getServerSnapshot);\n    }\n    function useStorageRoot() {\n        return [\n            useMutableStorageRoot()\n        ];\n    }\n    function useHistory() {\n        return useRoom().history;\n    }\n    function useUndo() {\n        return useHistory().undo;\n    }\n    function useRedo() {\n        return useHistory().redo;\n    }\n    function useCanUndo() {\n        const room = useRoom();\n        const subscribe2 = room.events.history.subscribe;\n        const canUndo = room.history.canUndo;\n        return useSyncExternalStore3(subscribe2, canUndo, canUndo);\n    }\n    function useCanRedo() {\n        const room = useRoom();\n        const subscribe2 = room.events.history.subscribe;\n        const canRedo = room.history.canRedo;\n        return useSyncExternalStore3(subscribe2, canRedo, canRedo);\n    }\n    function useBatch() {\n        return useRoom().batch;\n    }\n    function useLegacyKey(key) {\n        const room = useRoom();\n        const rootOrNull = useMutableStorageRoot();\n        const rerender = useRerender();\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            if (rootOrNull === null) {\n                return;\n            }\n            const root = rootOrNull;\n            let unsubCurr;\n            let curr = root.get(key);\n            function subscribeToCurr() {\n                unsubCurr = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.isLiveNode)(curr) ? room.subscribe(curr, rerender) : void 0;\n            }\n            function onRootChange() {\n                const newValue = root.get(key);\n                if (newValue !== curr) {\n                    unsubCurr?.();\n                    curr = newValue;\n                    subscribeToCurr();\n                    rerender();\n                }\n            }\n            subscribeToCurr();\n            rerender();\n            const unsubscribeRoot = room.subscribe(root, onRootChange);\n            return ()=>{\n                unsubscribeRoot();\n                unsubCurr?.();\n            };\n        }, [\n            rootOrNull,\n            room,\n            key,\n            rerender\n        ]);\n        if (rootOrNull === null) {\n            return null;\n        } else {\n            return rootOrNull.get(key);\n        }\n    }\n    function useStorage(selector, isEqual) {\n        const room = useRoom();\n        const rootOrNull = useMutableStorageRoot();\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((rootOrNull2)=>rootOrNull2 !== null ? selector(rootOrNull2) : null, [\n            selector\n        ]);\n        const subscribe2 = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((onStoreChange)=>rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, {\n                isDeep: true\n            }) : noop2, [\n            room,\n            rootOrNull\n        ]);\n        const getSnapshot2 = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n            if (rootOrNull === null) {\n                return null;\n            } else {\n                const root = rootOrNull;\n                const imm = root.toImmutable();\n                return imm;\n            }\n        }, [\n            rootOrNull\n        ]);\n        const getServerSnapshot = alwaysNull;\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(subscribe2, getSnapshot2, getServerSnapshot, wrappedSelector, isEqual);\n    }\n    function ensureNotServerSide() {\n        if (true) {\n            throw new Error(\"You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr\");\n        }\n    }\n    function useSuspendUntilStorageLoaded() {\n        const room = useRoom();\n        if (room.getStorageSnapshot() !== null) {\n            return;\n        }\n        ensureNotServerSide();\n        throw new Promise((res)=>{\n            room.events.storageDidLoad.subscribeOnce(()=>res());\n        });\n    }\n    function useSuspendUntilPresenceLoaded() {\n        const room = useRoom();\n        if (room.getSelf() !== null) {\n            return;\n        }\n        ensureNotServerSide();\n        throw new Promise((res)=>{\n            room.events.self.subscribeOnce(()=>res());\n            room.events.status.subscribeOnce(()=>res());\n        });\n    }\n    function useMutation(callback, deps) {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n            return (...args)=>// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                room.batch(()=>// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    callback(makeMutationContext(room), ...args));\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            room,\n            ...deps\n        ]);\n    }\n    function useStorageSuspense(selector, isEqual) {\n        useSuspendUntilStorageLoaded();\n        return useStorage(selector, isEqual);\n    }\n    function useSelfSuspense(selector, isEqual) {\n        useSuspendUntilPresenceLoaded();\n        return useSelf(selector, isEqual);\n    }\n    function useOthersSuspense(selector, isEqual) {\n        useSuspendUntilPresenceLoaded();\n        return useOthers(selector, isEqual);\n    }\n    function useOthersConnectionIdsSuspense() {\n        useSuspendUntilPresenceLoaded();\n        return useOthersConnectionIds();\n    }\n    function useOthersMappedSuspense(itemSelector, itemIsEqual) {\n        useSuspendUntilPresenceLoaded();\n        return useOthersMapped(itemSelector, itemIsEqual);\n    }\n    function useOtherSuspense(connectionId, selector, isEqual) {\n        useSuspendUntilPresenceLoaded();\n        return useOther(connectionId, selector, isEqual);\n    }\n    function useLegacyKeySuspense(key) {\n        useSuspendUntilStorageLoaded();\n        return useLegacyKey(key);\n    }\n    function useThreads(options2) {\n        const room = useRoom();\n        return commentsRoom.useThreads(room, options2);\n    }\n    function useThreadsSuspense(options2) {\n        const room = useRoom();\n        return commentsRoom.useThreadsSuspense(room, options2);\n    }\n    function useCreateThread() {\n        const room = useRoom();\n        return commentsRoom.useCreateThread(room);\n    }\n    function useEditThreadMetadata() {\n        const room = useRoom();\n        return commentsRoom.useEditThreadMetadata(room);\n    }\n    function useAddReaction() {\n        const room = useRoom();\n        return commentsRoom.useAddReaction(room);\n    }\n    function useRemoveReaction() {\n        const room = useRoom();\n        return commentsRoom.useRemoveReaction(room);\n    }\n    function useCreateComment() {\n        const room = useRoom();\n        return commentsRoom.useCreateComment(room);\n    }\n    function useEditComment() {\n        const room = useRoom();\n        return commentsRoom.useEditComment(room);\n    }\n    function useDeleteComment() {\n        const room = useRoom();\n        return commentsRoom.useDeleteComment(room);\n    }\n    const { resolveUsers, resolveMentionSuggestions } = options ?? {};\n    const usersCache = resolveUsers ? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.createAsyncCache)(async (stringifiedOptions)=>{\n        const users = await resolveUsers(JSON.parse(stringifiedOptions));\n        return users?.[0];\n    }) : void 0;\n    function useUser(userId) {\n        const room = useRoom();\n        const resolverKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)({\n                userIds: [\n                    userId\n                ],\n                roomId: room.id\n            }), [\n            userId,\n            room.id\n        ]);\n        const state = useAsyncCache(usersCache, resolverKey);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>warnIfNoResolveUsers(usersCache), []);\n        if (state.isLoading) {\n            return {\n                isLoading: true\n            };\n        } else {\n            return {\n                user: state.data,\n                error: state.error,\n                isLoading: false\n            };\n        }\n    }\n    function useUserSuspense(userId) {\n        const room = useRoom();\n        const resolverKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)({\n                userIds: [\n                    userId\n                ],\n                roomId: room.id\n            }), [\n            userId,\n            room.id\n        ]);\n        const state = useAsyncCache(usersCache, resolverKey, {\n            suspense: true\n        });\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>warnIfNoResolveUsers(usersCache), []);\n        return {\n            user: state.data,\n            isLoading: false\n        };\n    }\n    const mentionSuggestionsCache = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.createAsyncCache)(resolveMentionSuggestions ? (stringifiedOptions)=>{\n        return resolveMentionSuggestions(JSON.parse(stringifiedOptions));\n    } : ()=>Promise.resolve([]));\n    function useMentionSuggestions(search) {\n        const room = useRoom();\n        const debouncedSearch = useDebounce(search, 500);\n        const resolverKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>debouncedSearch !== void 0 ? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)({\n                text: debouncedSearch,\n                roomId: room.id\n            }) : null, [\n            debouncedSearch,\n            room.id\n        ]);\n        const { data } = useAsyncCache(mentionSuggestionsCache, resolverKey, {\n            keepPreviousDataWhileLoading: true\n        });\n        return data;\n    }\n    const bundle = {\n        RoomContext,\n        RoomProvider: RoomProviderOuter,\n        useRoom,\n        useStatus,\n        useBatch,\n        useBroadcastEvent,\n        useOthersListener,\n        useLostConnectionListener,\n        useErrorListener,\n        useEventListener,\n        useHistory,\n        useUndo,\n        useRedo,\n        useCanRedo,\n        useCanUndo,\n        // These are just aliases. The passed-in key will define their return values.\n        useList: useLegacyKey,\n        useMap: useLegacyKey,\n        useObject: useLegacyKey,\n        useStorageRoot,\n        useStorage,\n        useSelf,\n        useMyPresence,\n        useUpdateMyPresence,\n        useOthers,\n        useOthersMapped,\n        useOthersConnectionIds,\n        useOther,\n        useMutation,\n        useThreads,\n        useUser,\n        useCreateThread,\n        useEditThreadMetadata,\n        useCreateComment,\n        useEditComment,\n        useDeleteComment,\n        useAddReaction,\n        useRemoveReaction,\n        suspense: {\n            RoomContext,\n            RoomProvider: RoomProviderOuter,\n            useRoom,\n            useStatus,\n            useBatch,\n            useBroadcastEvent,\n            useOthersListener,\n            useLostConnectionListener,\n            useErrorListener,\n            useEventListener,\n            useHistory,\n            useUndo,\n            useRedo,\n            useCanRedo,\n            useCanUndo,\n            // Legacy hooks\n            useList: useLegacyKeySuspense,\n            useMap: useLegacyKeySuspense,\n            useObject: useLegacyKeySuspense,\n            useStorageRoot,\n            useStorage: useStorageSuspense,\n            useSelf: useSelfSuspense,\n            useMyPresence,\n            useUpdateMyPresence,\n            useOthers: useOthersSuspense,\n            useOthersMapped: useOthersMappedSuspense,\n            useOthersConnectionIds: useOthersConnectionIdsSuspense,\n            useOther: useOtherSuspense,\n            useMutation,\n            useThreads: useThreadsSuspense,\n            useUser: useUserSuspense,\n            useCreateThread,\n            useEditThreadMetadata,\n            useCreateComment,\n            useEditComment,\n            useDeleteComment,\n            useAddReaction,\n            useRemoveReaction\n        }\n    };\n    const internalBundle = {\n        ...bundle,\n        hasResolveMentionSuggestions: resolveMentionSuggestions !== void 0,\n        useMentionSuggestions\n    };\n    return bundle;\n}\n// src/index.ts\n\n(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.detectDupes)(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O3VIQUVBLGVBQWU7QUFDZ0M7QUFFL0MsaUJBQWlCO0FBQ2pCLElBQUlDLFdBQVc7QUFDZixJQUFJQyxjQUFjO0FBQ2xCLElBQUlDLGFBQWE7QUFFakIsNkJBQTZCO0FBQ0U7QUFDL0IsU0FBU0UsbUJBQW1CQyxLQUFLO0lBQy9CLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHSiwyQ0FBYyxDQUFDO0lBQzdDQSw0Q0FBZSxDQUFDO1FBQ2RJLFdBQVc7SUFDYixHQUFHLEVBQUU7SUFDTCxPQUFPLGFBQWEsaUJBQUdKLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFO1FBQUVTLFVBQVVQLE1BQU1PLFFBQVE7SUFBQyxHQUFHTixVQUFVRCxNQUFNUSxRQUFRLEtBQUtSLE1BQU1PLFFBQVE7QUFDdEk7QUFFQSxrQkFBa0I7QUFDMkI7QUFRbkI7QUFDTTtBQUNzRztBQUV0SSxnQ0FBZ0M7QUFDZ0Q7QUFDaEQ7QUFPakI7QUFDa0Y7QUFFakcseUJBQXlCO0FBQ3pCLElBQUl1QixvQkFBb0IsY0FBY0M7SUFDcENDLFlBQVlDLEtBQUssRUFBRUMsT0FBTyxDQUFFO1FBQzFCLEtBQUssQ0FBQztRQUNOLElBQUksQ0FBQ0QsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUNBLElBQUlDLDBCQUEwQixjQUFjTDtJQUMxQ0MsWUFBWUMsS0FBSyxFQUFFQyxPQUFPLENBQUU7UUFDMUIsS0FBSyxDQUFDO1FBQ04sSUFBSSxDQUFDRCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBQ0EsSUFBSUUscUJBQXFCLGNBQWNOO0lBQ3JDQyxZQUFZQyxLQUFLLEVBQUVDLE9BQU8s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QkFBd0I2RTtZQUN4QjlELFVBQVVnRTtZQUNWUjtZQUNBclIsWUFBWU87WUFDWjRSLFNBQVNHO1lBQ1RqUjtZQUNBUDtZQUNBc0I7WUFDQUc7WUFDQUc7WUFDQU07WUFDQUs7UUFDRjtJQUNGO0lBQ0EsTUFBTTBJLGlCQUFpQjtRQUNyQixHQUFHNUIsTUFBTTtRQUNUNkksOEJBQThCaEIsOEJBQThCLEtBQUs7UUFDakVRO0lBQ0Y7SUFDQSxPQUFPckk7QUFDVDtBQUVBLGVBQWU7QUFDMEM7QUFDekRyViw2REFBV0EsQ0FBQ0MsVUFBVUMsYUFBYUM7QUFNakMsQ0FDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maWdtYS1jbG9uZS8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC9kaXN0L2luZGV4Lm1qcz9jZDM5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG4vLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IGRldGVjdER1cGVzIH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcblxuLy8gc3JjL3ZlcnNpb24udHNcbnZhciBQS0dfTkFNRSA9IFwiQGxpdmVibG9ja3MvcmVhY3RcIjtcbnZhciBQS0dfVkVSU0lPTiA9IFwiMS45LjdcIjtcbnZhciBQS0dfRk9STUFUID0gXCJlc21cIjtcblxuLy8gc3JjL0NsaWVudFNpZGVTdXNwZW5zZS50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gQ2xpZW50U2lkZVN1c3BlbnNlKHByb3BzKSB7XG4gIGNvbnN0IFttb3VudGVkLCBzZXRNb3VudGVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRNb3VudGVkKHRydWUpO1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5TdXNwZW5zZSwgeyBmYWxsYmFjazogcHJvcHMuZmFsbGJhY2sgfSwgbW91bnRlZCA/IHByb3BzLmNoaWxkcmVuKCkgOiBwcm9wcy5mYWxsYmFjayk7XG59XG5cbi8vIHNyYy9mYWN0b3J5LnRzeFxuaW1wb3J0IHsgc2hhbGxvdyB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jbGllbnRcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZUFzeW5jQ2FjaGUsXG4gIGRlcHJlY2F0ZUlmLFxuICBlcnJvcklmLFxuICBpc0xpdmVOb2RlLFxuICBtYWtlRXZlbnRTb3VyY2UgYXMgbWFrZUV2ZW50U291cmNlMixcbiAgc3RyaW5naWZ5IGFzIHN0cmluZ2lmeTJcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmltcG9ydCAqIGFzIFJlYWN0MyBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMiB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanNcIjtcblxuLy8gc3JjL2NvbW1lbnRzL0NvbW1lbnRzUm9vbS50c3hcbmltcG9ydCB7IENvbW1lbnRzQXBpRXJyb3IsIG1ha2VFdmVudFNvdXJjZSwgc3RyaW5naWZ5IH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmltcG9ydCB7IG5hbm9pZCB9IGZyb20gXCJuYW5vaWRcIjtcbmltcG9ydCBSZWFjdDIsIHtcbiAgY3JlYXRlQ29udGV4dCxcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2szLFxuICB1c2VDb250ZXh0LFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MyxcbiAgdXNlTWVtb1xufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIH0gZnJvbSBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vd2l0aC1zZWxlY3Rvci5qc1wiO1xuXG4vLyBzcmMvY29tbWVudHMvZXJyb3JzLnRzXG52YXIgQ3JlYXRlVGhyZWFkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIkNyZWF0ZSB0aHJlYWQgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIkNyZWF0ZVRocmVhZEVycm9yXCI7XG4gIH1cbn07XG52YXIgRWRpdFRocmVhZE1ldGFkYXRhRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIkVkaXQgdGhyZWFkIG1ldGFkYXRhIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJFZGl0VGhyZWFkTWV0YWRhdGFFcnJvclwiO1xuICB9XG59O1xudmFyIENyZWF0ZUNvbW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiQ3JlYXRlIGNvbW1lbnQgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIkNyZWF0ZUNvbW1lbnRFcnJvclwiO1xuICB9XG59O1xudmFyIEVkaXRDb21tZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIkVkaXQgY29tbWVudCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiRWRpdENvbW1lbnRFcnJvclwiO1xuICB9XG59O1xudmFyIERlbGV0ZUNvbW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiRGVsZXRlIGNvbW1lbnQgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIkRlbGV0ZUNvbW1lbnRFcnJvclwiO1xuICB9XG59O1xudmFyIEFkZFJlYWN0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIkFkZCByZWFjdGlvbiBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiQWRkUmVhY3Rpb25FcnJvclwiO1xuICB9XG59O1xudmFyIFJlbW92ZVJlYWN0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIlJlbW92ZSByZWFjdGlvbiBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiUmVtb3ZlUmVhY3Rpb25FcnJvclwiO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbWVudHMvbGliL3JldmFsaWRhdGlvbi50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2syLCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MiwgdXNlUmVmIGFzIHVzZVJlZjIgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2NvbW1lbnRzL2xpYi91c2UtaXMtZG9jdW1lbnQtdmlzaWJsZS50c1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS9pbmRleC5qc1wiO1xuZnVuY3Rpb24gdXNlSXNEb2N1bWVudFZpc2libGUoKSB7XG4gIGNvbnN0IGlzVmlzaWJsZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNuYXBzaG90KTtcbiAgcmV0dXJuIGlzVmlzaWJsZTtcbn1cbmZ1bmN0aW9uIHN1YnNjcmliZShvblN0b3JlQ2hhbmdlKSB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uU3RvcmVDaGFuZ2UpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uU3RvcmVDaGFuZ2UpO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0U25hcHNob3QoKSB7XG4gIGNvbnN0IGlzRG9jdW1lbnREZWZpbmVkID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuICByZXR1cm4gaXNEb2N1bWVudERlZmluZWQgPyBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiIDogdHJ1ZTtcbn1cblxuLy8gc3JjL2NvbW1lbnRzL2xpYi91c2UtaXMtb25saW5lLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS9pbmRleC5qc1wiO1xuZnVuY3Rpb24gdXNlSXNPbmxpbmUoKSB7XG4gIGNvbnN0IGlzT25saW5lUmVmID0gdXNlUmVmKHRydWUpO1xuICBjb25zdCBzdWJzY3JpYmUyID0gdXNlQ2FsbGJhY2soKG9uU3RvcmVDaGFuZ2UpID0+IHtcbiAgICBmdW5jdGlvbiBoYW5kbGVJc09ubGluZSgpIHtcbiAgICAgIGlzT25saW5lUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgb25TdG9yZUNoYW5nZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVJc09mZmxpbmUoKSB7XG4gICAgICBpc09ubGluZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBvblN0b3JlQ2hhbmdlKCk7XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIGhhbmRsZUlzT25saW5lKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgaGFuZGxlSXNPZmZsaW5lKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgaGFuZGxlSXNPbmxpbmUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIGhhbmRsZUlzT2ZmbGluZSk7XG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCBnZXRTbmFwc2hvdDIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgcmV0dXJuIGlzT25saW5lUmVmLmN1cnJlbnQ7XG4gIH0sIFtdKTtcbiAgY29uc3QgaXNPbmxpbmUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoc3Vic2NyaWJlMiwgZ2V0U25hcHNob3QyLCBnZXRTbmFwc2hvdDIpO1xuICByZXR1cm4gaXNPbmxpbmU7XG59XG5cbi8vIHNyYy9jb21tZW50cy9saWIvcmV2YWxpZGF0aW9uLnRzXG52YXIgREVGQVVMVF9FUlJPUl9SRVRSWV9JTlRFUlZBTCA9IDVlMztcbnZhciBERUZBVUxUX01BWF9FUlJPUl9SRVRSWV9DT1VOVCA9IDU7XG52YXIgREVGQVVMVF9ERURVUElOR19JTlRFUlZBTCA9IDJlMztcbnZhciB0aW1lc3RhbXAgPSAwO1xuZnVuY3Rpb24gdXNlUmV2YWxpZGF0ZUNhY2hlKG1hbmFnZXIsIGZldGNoZXIsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBpc09ubGluZVJlZiA9IHVzZVJlZjIodHJ1ZSk7XG4gIGNvbnN0IHtcbiAgICBkZWR1cGluZ0ludGVydmFsID0gREVGQVVMVF9ERURVUElOR19JTlRFUlZBTCxcbiAgICBlcnJvclJldHJ5SW50ZXJ2YWwgPSBERUZBVUxUX0VSUk9SX1JFVFJZX0lOVEVSVkFMLFxuICAgIGVycm9yUmV0cnlDb3VudCA9IERFRkFVTFRfTUFYX0VSUk9SX1JFVFJZX0NPVU5UXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBfcmV2YWxpZGF0ZUNhY2hlID0gdXNlQ2FsbGJhY2syKFxuICAgIGFzeW5jICh7XG4gICAgICBzaG91bGREZWR1cGUsXG4gICAgICByZXRyeUNvdW50ID0gMFxuICAgIH0pID0+IHtcbiAgICAgIGxldCBzdGFydEF0O1xuICAgICAgY29uc3Qgc2hvdWxkU3RhcnRSZXF1ZXN0ID0gIW1hbmFnZXIuZ2V0UmVxdWVzdCgpIHx8ICFzaG91bGREZWR1cGU7XG4gICAgICBmdW5jdGlvbiBkZWxldGVBY3RpdmVSZXF1ZXN0KCkge1xuICAgICAgICBjb25zdCBhY3RpdmVSZXF1ZXN0ID0gbWFuYWdlci5nZXRSZXF1ZXN0KCk7XG4gICAgICAgIGlmICghYWN0aXZlUmVxdWVzdClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChhY3RpdmVSZXF1ZXN0LnRpbWVzdGFtcCAhPT0gc3RhcnRBdClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIG1hbmFnZXIuc2V0UmVxdWVzdCh2b2lkIDApO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSB+figoTWF0aC5yYW5kb20oKSArIDAuNSkgKiAoMSA8PCAocmV0cnlDb3VudCA8IDggPyByZXRyeUNvdW50IDogOCkpKSAqIGVycm9yUmV0cnlJbnRlcnZhbDtcbiAgICAgICAgaWYgKHJldHJ5Q291bnQgPiBlcnJvclJldHJ5Q291bnQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB2b2lkIF9yZXZhbGlkYXRlQ2FjaGUoe1xuICAgICAgICAgICAgc2hvdWxkRGVkdXBlOiBmYWxzZSxcbiAgICAgICAgICAgIHJldHJ5Q291bnQ6IHJldHJ5Q291bnQgKyAxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFN0YXJ0UmVxdWVzdCkge1xuICAgICAgICBtYW5hZ2VyLnNldFJlcXVlc3Qoe1xuICAgICAgICAgIGZldGNoZXI6IGZldGNoZXIoKSxcbiAgICAgICAgICB0aW1lc3RhbXA6ICsrdGltZXN0YW1wXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGFjdGl2ZVJlcXVlc3QgPSBtYW5hZ2VyLmdldFJlcXVlc3QoKTtcbiAgICAgICAgaWYgKCFhY3RpdmVSZXF1ZXN0KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc3RhcnRBdCA9IGFjdGl2ZVJlcXVlc3QudGltZXN0YW1wO1xuICAgICAgICBjb25zdCBuZXdEYXRhID0gYXdhaXQgYWN0aXZlUmVxdWVzdC5mZXRjaGVyO1xuICAgICAgICBpZiAoc2hvdWxkU3RhcnRSZXF1ZXN0KSB7XG4gICAgICAgICAgc2V0VGltZW91dChkZWxldGVBY3RpdmVSZXF1ZXN0LCBkZWR1cGluZ0ludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVSZXF1ZXN0ID0gbWFuYWdlci5nZXRSZXF1ZXN0KCk7XG4gICAgICAgIGlmICghYWN0aXZlUmVxdWVzdCB8fCBhY3RpdmVSZXF1ZXN0LnRpbWVzdGFtcCAhPT0gc3RhcnRBdClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGFjdGl2ZU11dGF0aW9uID0gbWFuYWdlci5nZXRNdXRhdGlvbigpO1xuICAgICAgICBpZiAoYWN0aXZlTXV0YXRpb24gJiYgKGFjdGl2ZU11dGF0aW9uLnN0YXJ0VGltZSA+IHN0YXJ0QXQgfHwgYWN0aXZlTXV0YXRpb24uZW5kVGltZSA+IHN0YXJ0QXQgfHwgYWN0aXZlTXV0YXRpb24uZW5kVGltZSA9PT0gMCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWFuYWdlci5zZXRDYWNoZShuZXdEYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBkZWxldGVBY3RpdmVSZXF1ZXN0KCk7XG4gICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJ2aXNpYmxlXCI7XG4gICAgICAgIGNvbnN0IGlzT25saW5lID0gaXNPbmxpbmVSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKHNob3VsZFN0YXJ0UmVxdWVzdCAmJiBpc1Zpc2libGUgJiYgaXNPbmxpbmUpXG4gICAgICAgICAgaGFuZGxlRXJyb3IoKTtcbiAgICAgICAgbWFuYWdlci5zZXRFcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgW21hbmFnZXIsIGZldGNoZXIsIGRlZHVwaW5nSW50ZXJ2YWwsIGVycm9yUmV0cnlJbnRlcnZhbCwgZXJyb3JSZXRyeUNvdW50XVxuICApO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBmdW5jdGlvbiBoYW5kbGVJc09ubGluZSgpIHtcbiAgICAgIGlzT25saW5lUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVJc09mZmxpbmUoKSB7XG4gICAgICBpc09ubGluZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIGhhbmRsZUlzT25saW5lKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgaGFuZGxlSXNPZmZsaW5lKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgaGFuZGxlSXNPbmxpbmUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIGhhbmRsZUlzT2ZmbGluZSk7XG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCByZXZhbGlkYXRlQ2FjaGUgPSB1c2VDYWxsYmFjazIoXG4gICAgKHsgc2hvdWxkRGVkdXBlIH0pID0+IHtcbiAgICAgIHJldHVybiBfcmV2YWxpZGF0ZUNhY2hlKHsgc2hvdWxkRGVkdXBlLCByZXRyeUNvdW50OiAwIH0pO1xuICAgIH0sXG4gICAgW19yZXZhbGlkYXRlQ2FjaGVdXG4gICk7XG4gIHJldHVybiByZXZhbGlkYXRlQ2FjaGU7XG59XG5mdW5jdGlvbiB1c2VNdXRhdGUobWFuYWdlciwgcmV2YWxpZGF0ZUNhY2hlKSB7XG4gIGNvbnN0IG11dGF0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICBhc3luYyAoZGF0YSwgb3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgYmVmb3JlTXV0YXRpb25UaW1lc3RhbXAgPSArK3RpbWVzdGFtcDtcbiAgICAgIG1hbmFnZXIuc2V0TXV0YXRpb24oe1xuICAgICAgICBzdGFydFRpbWU6IGJlZm9yZU11dGF0aW9uVGltZXN0YW1wLFxuICAgICAgICBlbmRUaW1lOiAwXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGN1cnJlbnRDYWNoZSA9IG1hbmFnZXIuZ2V0Q2FjaGUoKTtcbiAgICAgIG1hbmFnZXIuc2V0Q2FjaGUob3B0aW9ucy5vcHRpbWlzdGljRGF0YSk7XG4gICAgICBsZXQgZXJyb3I7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBkYXRhO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0aXZlTXV0YXRpb24gPSBtYW5hZ2VyLmdldE11dGF0aW9uKCk7XG4gICAgICBpZiAoYWN0aXZlTXV0YXRpb24gJiYgYmVmb3JlTXV0YXRpb25UaW1lc3RhbXAgIT09IGFjdGl2ZU11dGF0aW9uLnN0YXJ0VGltZSkge1xuICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBtYW5hZ2VyLnNldENhY2hlKGN1cnJlbnRDYWNoZSk7XG4gICAgICB9XG4gICAgICBtYW5hZ2VyLnNldE11dGF0aW9uKHtcbiAgICAgICAgc3RhcnRUaW1lOiBiZWZvcmVNdXRhdGlvblRpbWVzdGFtcCxcbiAgICAgICAgZW5kVGltZTogKyt0aW1lc3RhbXBcbiAgICAgIH0pO1xuICAgICAgbWFuYWdlci5zZXRSZXF1ZXN0KHZvaWQgMCk7XG4gICAgICB2b2lkIHJldmFsaWRhdGVDYWNoZSh7IHNob3VsZERlZHVwZTogZmFsc2UgfSk7XG4gICAgICBpZiAoZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0sXG4gICAgW21hbmFnZXIsIHJldmFsaWRhdGVDYWNoZV1cbiAgKTtcbiAgcmV0dXJuIG11dGF0ZTtcbn1cblxuLy8gc3JjL2NvbW1lbnRzL0NvbW1lbnRzUm9vbS50c3hcbnZhciBUSFJFQURfSURfUFJFRklYID0gXCJ0aFwiO1xudmFyIENPTU1FTlRfSURfUFJFRklYID0gXCJjbVwiO1xudmFyIFBPTExJTkdfSU5URVJWQUxfUkVBTFRJTUUgPSAzZTQ7XG52YXIgUE9MTElOR19JTlRFUlZBTCA9IDVlMztcbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRzUm9vbShlcnJvckV2ZW50U291cmNlKSB7XG4gIGNvbnN0IHN0b3JlID0gY3JlYXRlQ2xpZW50Q2FjaGVTdG9yZSgpO1xuICBjb25zdCBGZXRjaGVyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG4gIGNvbnN0IFJvb21NYW5hZ2VyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG4gIGZ1bmN0aW9uIGdldFRocmVhZHMobWFuYWdlcikge1xuICAgIGNvbnN0IHRocmVhZHMgPSBtYW5hZ2VyLmdldENhY2hlKCk7XG4gICAgaWYgKCF0aHJlYWRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IHVwZGF0ZSB0aHJlYWRzIG9yIGNvbW1lbnRzIGJlZm9yZSB0aGV5IGFyZSBsb2FkZWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aHJlYWRzO1xuICB9XG4gIGZ1bmN0aW9uIENvbW1lbnRzUm9vbVByb3ZpZGVyKHtcbiAgICByb29tLFxuICAgIGNoaWxkcmVuXG4gIH0pIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICByZXR1cm4gY3JlYXRlUm9vbVJldmFsaWRhdGlvbk1hbmFnZXIocm9vbS5pZCwge1xuICAgICAgICBnZXRDYWNoZTogc3RvcmUuZ2V0VGhyZWFkcyxcbiAgICAgICAgc2V0Q2FjaGU6IHN0b3JlLnNldFRocmVhZHNcbiAgICAgIH0pO1xuICAgIH0sIFtyb29tLmlkXSk7XG4gICAgY29uc3QgZmV0Y2hlciA9IFJlYWN0Mi51c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zID0gbWFuYWdlci5nZXRSZXZhbGlkYXRpb25NYW5hZ2VycygpLmZpbHRlcigoW2tleV0pID0+IG1hbmFnZXIuZ2V0UmVmZXJlbmNlQ291bnQoa2V5KSA+IDApLm1hcCgoW18sIG1hbmFnZXIyXSkgPT4gbWFuYWdlcjIuZ2V0T3B0aW9ucygpKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBvcHRpb25zLm1hcChhc3luYyAob3B0aW9uKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHJvb20uZ2V0VGhyZWFkcyhvcHRpb24pO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRocmVhZHMgPSBBcnJheS5mcm9tKFxuICAgICAgICBuZXcgTWFwKHJlc3BvbnNlcy5mbGF0KCkubWFwKCh0aHJlYWQpID0+IFt0aHJlYWQuaWQsIHRocmVhZF0pKS52YWx1ZXMoKVxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aHJlYWRzO1xuICAgIH0sIFtyb29tLCBtYW5hZ2VyXSk7XG4gICAgY29uc3QgcmV2YWxpZGF0ZUNhY2hlID0gdXNlUmV2YWxpZGF0ZUNhY2hlKG1hbmFnZXIsIGZldGNoZXIpO1xuICAgIGNvbnN0IHN0YXR1cyA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhcbiAgICAgIHJvb20uZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmUsXG4gICAgICByb29tLmdldFN0YXR1cyxcbiAgICAgIHJvb20uZ2V0U3RhdHVzXG4gICAgKTtcbiAgICBjb25zdCBpc09ubGluZSA9IHVzZUlzT25saW5lKCk7XG4gICAgY29uc3QgaXNEb2N1bWVudFZpc2libGUgPSB1c2VJc0RvY3VtZW50VmlzaWJsZSgpO1xuICAgIGNvbnN0IHJlZnJlc2hJbnRlcnZhbCA9IGdldFBvbGxpbmdJbnRlcnZhbChcbiAgICAgIGlzT25saW5lLFxuICAgICAgaXNEb2N1bWVudFZpc2libGUsXG4gICAgICBzdGF0dXMgPT09IFwiY29ubmVjdGVkXCJcbiAgICApO1xuICAgIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgICAgbGV0IHJldmFsaWRhdGlvblRpbWVySWQ7XG4gICAgICBmdW5jdGlvbiBzY2hlZHVsZVJldmFsaWRhdGlvbigpIHtcbiAgICAgICAgaWYgKHJlZnJlc2hJbnRlcnZhbCA9PT0gMClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldmFsaWRhdGlvblRpbWVySWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKGlzT25saW5lICYmIGlzRG9jdW1lbnRWaXNpYmxlICYmICFtYW5hZ2VyLmdldEVycm9yKCkgJiYgbWFuYWdlci5nZXRUb3RhbFJlZmVyZW5jZUNvdW50KCkgPiAwKSB7XG4gICAgICAgICAgICB2b2lkIHJldmFsaWRhdGVDYWNoZSh7IHNob3VsZERlZHVwZTogdHJ1ZSB9KS50aGVuKFxuICAgICAgICAgICAgICBzY2hlZHVsZVJldmFsaWRhdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2NoZWR1bGVSZXZhbGlkYXRpb24oKTtcbiAgICAgICAgfSwgcmVmcmVzaEludGVydmFsKTtcbiAgICAgIH1cbiAgICAgIHNjaGVkdWxlUmV2YWxpZGF0aW9uKCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHJldmFsaWRhdGlvblRpbWVySWQpO1xuICAgICAgfTtcbiAgICB9LCBbXG4gICAgICByZXZhbGlkYXRlQ2FjaGUsXG4gICAgICByZWZyZXNoSW50ZXJ2YWwsXG4gICAgICBpc09ubGluZSxcbiAgICAgIGlzRG9jdW1lbnRWaXNpYmxlLFxuICAgICAgbWFuYWdlclxuICAgIF0pO1xuICAgIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgICAgZnVuY3Rpb24gaGFuZGxlSXNPbmxpbmUoKSB7XG4gICAgICAgIGlmIChpc0RvY3VtZW50VmlzaWJsZSkge1xuICAgICAgICAgIHZvaWQgcmV2YWxpZGF0ZUNhY2hlKHsgc2hvdWxkRGVkdXBlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBoYW5kbGVJc09ubGluZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBoYW5kbGVJc09ubGluZSk7XG4gICAgICB9O1xuICAgIH0sIFtyZXZhbGlkYXRlQ2FjaGUsIGlzRG9jdW1lbnRWaXNpYmxlXSk7XG4gICAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgICBmdW5jdGlvbiBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiO1xuICAgICAgICBpZiAoaXNWaXNpYmxlICYmIGlzT25saW5lKSB7XG4gICAgICAgICAgdm9pZCByZXZhbGlkYXRlQ2FjaGUoeyBzaG91bGREZWR1cGU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBcInZpc2liaWxpdHljaGFuZ2VcIixcbiAgICAgICAgICBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH0sIFtyZXZhbGlkYXRlQ2FjaGUsIGlzT25saW5lXSk7XG4gICAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHJvb20uZXZlbnRzLmNvbW1lbnRzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHZvaWQgcmV2YWxpZGF0ZUNhY2hlKHsgc2hvdWxkRGVkdXBlOiBmYWxzZSB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIH07XG4gICAgfSwgW3Jvb20sIHJldmFsaWRhdGVDYWNoZV0pO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoRmV0Y2hlckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGZldGNoZXIgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJvb21NYW5hZ2VyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogbWFuYWdlciB9LCBjaGlsZHJlbikpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVJvb21NYW5hZ2VyKCkge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VDb250ZXh0KFJvb21NYW5hZ2VyQ29udGV4dCk7XG4gICAgaWYgKG1hbmFnZXIgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbW1lbnRzUm9vbVByb3ZpZGVyIGlzIG1pc3NpbmcgZnJvbSB0aGUgUmVhY3QgdHJlZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBtYW5hZ2VyO1xuICB9XG4gIGZ1bmN0aW9uIGdldFVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyKG9wdGlvbnMsIHJvb21NYW5hZ2VyKSB7XG4gICAgY29uc3Qga2V5ID0gc3RyaW5naWZ5KG9wdGlvbnMpO1xuICAgIGNvbnN0IHJldmFsaWRhdGlvbk1hbmFnZXIgPSByb29tTWFuYWdlci5nZXRSZXZhbGlkYXRpb25NYW5hZ2VyKGtleSk7XG4gICAgaWYgKCFyZXZhbGlkYXRpb25NYW5hZ2VyKSB7XG4gICAgICBjb25zdCB1c2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlciA9IGNyZWF0ZVVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyKFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICByb29tTWFuYWdlclxuICAgICAgKTtcbiAgICAgIHJvb21NYW5hZ2VyLnNldFJldmFsaWRhdGlvbm1hbmFnZXIoa2V5LCB1c2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlcik7XG4gICAgICByZXR1cm4gdXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXI7XG4gICAgfVxuICAgIHJldHVybiByZXZhbGlkYXRpb25NYW5hZ2VyO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVRocmVhZHNGZXRjaGVyKCkge1xuICAgIGNvbnN0IGZldGNoZXIgPSB1c2VDb250ZXh0KEZldGNoZXJDb250ZXh0KTtcbiAgICBpZiAoZmV0Y2hlciA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tbWVudHNSb29tUHJvdmlkZXIgaXMgbWlzc2luZyBmcm9tIHRoZSBSZWFjdCB0cmVlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZldGNoZXI7XG4gIH1cbiAgZnVuY3Rpb24gdXNlVGhyZWFkcyhyb29tLCBvcHRpb25zID0geyBxdWVyeTogeyBtZXRhZGF0YToge30gfSB9KSB7XG4gICAgY29uc3Qga2V5ID0gdXNlTWVtbygoKSA9PiBzdHJpbmdpZnkob3B0aW9ucyksIFtvcHRpb25zXSk7XG4gICAgY29uc3QgbWFuYWdlciA9IHVzZVJvb21NYW5hZ2VyKCk7XG4gICAgY29uc3QgdXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIgPSBnZXRVc2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlcihcbiAgICAgIG9wdGlvbnMsXG4gICAgICBtYW5hZ2VyXG4gICAgKTtcbiAgICBjb25zdCBmZXRjaGVyID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKCkgPT4ge1xuICAgICAgICByZXR1cm4gcm9vbS5nZXRUaHJlYWRzKG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgLS0gVGhlIG1pc3NpbmcgZGVwZW5kZW5jeSBpcyBgb3B0aW9uc2AgYnV0IGBrZXlgIGFuZCBgbm9ybWFsaXplZGAgYXJlIGFuYWxvZ291cywgc28gd2Ugb25seSBpbmNsdWRlIGBrZXlgIGFzIGRlcGVuZGVuY3kuIFRoaXMgaGVscHMgbWluaW1pemUgdGhlIG51bWJlciBvZiByZS1yZW5kZXJzIGFzIGBvcHRpb25zYCBjYW4gY2hhbmdlIG9uIGVhY2ggcmVuZGVyXG4gICAgICBba2V5LCByb29tXVxuICAgICk7XG4gICAgY29uc3QgcmV2YWxpZGF0ZUNhY2hlID0gdXNlUmV2YWxpZGF0ZUNhY2hlKFxuICAgICAgdXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIsXG4gICAgICBmZXRjaGVyXG4gICAgKTtcbiAgICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICAgIHZvaWQgcmV2YWxpZGF0ZUNhY2hlKHsgc2hvdWxkRGVkdXBlOiB0cnVlIH0pO1xuICAgIH0sIFtyZXZhbGlkYXRlQ2FjaGVdKTtcbiAgICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICAgIG1hbmFnZXIuaW5jcmVtZW50UmVmZXJlbmNlQ291bnQoa2V5KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIG1hbmFnZXIuZGVjcmVtZW50UmVmZXJlbmNlQ291bnQoa2V5KTtcbiAgICAgIH07XG4gICAgfSwgW21hbmFnZXIsIGtleV0pO1xuICAgIGNvbnN0IGNhY2hlID0gX3VzZVRocmVhZHMocm9vbSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGNhY2hlO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVRocmVhZHNTdXNwZW5zZShyb29tLCBvcHRpb25zID0geyBxdWVyeTogeyBtZXRhZGF0YToge30gfSB9KSB7XG4gICAgY29uc3Qga2V5ID0gdXNlTWVtbygoKSA9PiBzdHJpbmdpZnkob3B0aW9ucyksIFtvcHRpb25zXSk7XG4gICAgY29uc3QgbWFuYWdlciA9IHVzZVJvb21NYW5hZ2VyKCk7XG4gICAgY29uc3QgdXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIgPSBnZXRVc2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlcihcbiAgICAgIG9wdGlvbnMsXG4gICAgICBtYW5hZ2VyXG4gICAgKTtcbiAgICBjb25zdCBmZXRjaGVyID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKCkgPT4ge1xuICAgICAgICByZXR1cm4gcm9vbS5nZXRUaHJlYWRzKG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgLS0gVGhlIG1pc3NpbmcgZGVwZW5kZW5jeSBpcyBgb3B0aW9uc2AgYnV0IGBrZXlgIGFuZCBgbm9ybWFsaXplZGAgYXJlIGFuYWxvZ291cywgc28gd2Ugb25seSBpbmNsdWRlIGBrZXlgIGFzIGRlcGVuZGVuY3kuIFRoaXMgaGVscHMgbWluaW1pemUgdGhlIG51bWJlciBvZiByZS1yZW5kZXJzIGFzIGBvcHRpb25zYCBjYW4gY2hhbmdlIG9uIGVhY2ggcmVuZGVyXG4gICAgICBba2V5LCByb29tXVxuICAgICk7XG4gICAgY29uc3QgcmV2YWxpZGF0ZUNhY2hlID0gdXNlUmV2YWxpZGF0ZUNhY2hlKFxuICAgICAgdXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIsXG4gICAgICBmZXRjaGVyXG4gICAgKTtcbiAgICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICAgIHZvaWQgcmV2YWxpZGF0ZUNhY2hlKHsgc2hvdWxkRGVkdXBlOiB0cnVlIH0pO1xuICAgIH0sIFtyZXZhbGlkYXRlQ2FjaGVdKTtcbiAgICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICAgIG1hbmFnZXIuaW5jcmVtZW50UmVmZXJlbmNlQ291bnQoa2V5KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIG1hbmFnZXIuZGVjcmVtZW50UmVmZXJlbmNlQ291bnQoa2V5KTtcbiAgICAgIH07XG4gICAgfSwgW21hbmFnZXIsIGtleV0pO1xuICAgIGNvbnN0IGNhY2hlID0gX3VzZVRocmVhZHMocm9vbSwgb3B0aW9ucyk7XG4gICAgaWYgKGNhY2hlLmVycm9yKSB7XG4gICAgICB0aHJvdyBjYWNoZS5lcnJvcjtcbiAgICB9XG4gICAgaWYgKGNhY2hlLmlzTG9hZGluZyB8fCAhY2FjaGUudGhyZWFkcykge1xuICAgICAgdGhyb3cgcmV2YWxpZGF0ZUNhY2hlKHtcbiAgICAgICAgc2hvdWxkRGVkdXBlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICB0aHJlYWRzOiBjYWNoZS50aHJlYWRzLFxuICAgICAgZXJyb3I6IGNhY2hlLmVycm9yXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBfdXNlVGhyZWFkcyhyb29tLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHVzZVJvb21NYW5hZ2VyKCk7XG4gICAgY29uc3QgdXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIgPSBnZXRVc2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlcihcbiAgICAgIG9wdGlvbnMsXG4gICAgICBtYW5hZ2VyXG4gICAgKTtcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgICAoKSA9PiBzdG9yZS5nZXRUaHJlYWRzKCksXG4gICAgICAoKSA9PiBzdG9yZS5nZXRUaHJlYWRzKCksXG4gICAgICAoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgaXNMb2FkaW5nID0gdXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIuZ2V0SXNMb2FkaW5nKCk7XG4gICAgICAgIGlmIChpc0xvYWRpbmcpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNMb2FkaW5nOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zMiA9IHVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyLmdldE9wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB1c2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlci5nZXRFcnJvcigpO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IHN0YXRlLmZpbHRlcigodGhyZWFkKSA9PiB7XG4gICAgICAgICAgaWYgKHRocmVhZC5yb29tSWQgIT09IHJvb20uaWQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgY29uc3QgcXVlcnkgPSBvcHRpb25zMi5xdWVyeSA/PyB7fTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBxdWVyeS5tZXRhZGF0YSkge1xuICAgICAgICAgICAgaWYgKHRocmVhZC5tZXRhZGF0YVtrZXldICE9PSBxdWVyeS5tZXRhZGF0YVtrZXldKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgdGhyZWFkczogZmlsdGVyZWQsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUVkaXRUaHJlYWRNZXRhZGF0YShyb29tKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHVzZVJvb21NYW5hZ2VyKCk7XG4gICAgY29uc3QgZmV0Y2hlciA9IHVzZVRocmVhZHNGZXRjaGVyKCk7XG4gICAgY29uc3QgcmV2YWxpZGF0ZSA9IHVzZVJldmFsaWRhdGVDYWNoZShtYW5hZ2VyLCBmZXRjaGVyKTtcbiAgICBjb25zdCBtdXRhdGUgPSB1c2VNdXRhdGUobWFuYWdlciwgcmV2YWxpZGF0ZSk7XG4gICAgY29uc3QgZWRpdFRocmVhZE1ldGFkYXRhID0gdXNlQ2FsbGJhY2szKFxuICAgICAgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgdGhyZWFkSWQgPSBvcHRpb25zLnRocmVhZElkO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IFwibWV0YWRhdGFcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5tZXRhZGF0YSA6IHt9O1xuICAgICAgICBjb25zdCB0aHJlYWRzID0gZ2V0VGhyZWFkcyhtYW5hZ2VyKTtcbiAgICAgICAgY29uc3Qgb3B0aW1pc3RpY0RhdGEgPSB0aHJlYWRzLm1hcChcbiAgICAgICAgICAodGhyZWFkKSA9PiB0aHJlYWQuaWQgPT09IHRocmVhZElkID8ge1xuICAgICAgICAgICAgLi4udGhyZWFkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgLi4udGhyZWFkLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAuLi5tZXRhZGF0YVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gOiB0aHJlYWRcbiAgICAgICAgKTtcbiAgICAgICAgbXV0YXRlKHJvb20uZWRpdFRocmVhZE1ldGFkYXRhKHsgbWV0YWRhdGEsIHRocmVhZElkIH0pLCB7XG4gICAgICAgICAgb3B0aW1pc3RpY0RhdGFcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIENvbW1lbnRzQXBpRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGVycm9yID0gaGFuZGxlQ29tbWVudHNBcGlFcnJvcihlcnIpO1xuICAgICAgICAgIGVycm9yRXZlbnRTb3VyY2Uubm90aWZ5KFxuICAgICAgICAgICAgbmV3IEVkaXRUaHJlYWRNZXRhZGF0YUVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFtyb29tLCBtdXRhdGUsIG1hbmFnZXJdXG4gICAgKTtcbiAgICByZXR1cm4gZWRpdFRocmVhZE1ldGFkYXRhO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUNyZWF0ZVRocmVhZChyb29tKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHVzZVJvb21NYW5hZ2VyKCk7XG4gICAgY29uc3QgZmV0Y2hlciA9IHVzZVRocmVhZHNGZXRjaGVyKCk7XG4gICAgY29uc3QgcmV2YWxpZGF0ZSA9IHVzZVJldmFsaWRhdGVDYWNoZShtYW5hZ2VyLCBmZXRjaGVyKTtcbiAgICBjb25zdCBtdXRhdGUgPSB1c2VNdXRhdGUobWFuYWdlciwgcmV2YWxpZGF0ZSk7XG4gICAgY29uc3QgY3JlYXRlVGhyZWFkID0gdXNlQ2FsbGJhY2szKFxuICAgICAgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBcIm1ldGFkYXRhXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMubWV0YWRhdGEgOiB7fTtcbiAgICAgICAgY29uc3QgdGhyZWFkcyA9IGdldFRocmVhZHMobWFuYWdlcik7XG4gICAgICAgIGNvbnN0IHRocmVhZElkID0gY3JlYXRlVGhyZWFkSWQoKTtcbiAgICAgICAgY29uc3QgY29tbWVudElkID0gY3JlYXRlQ29tbWVudElkKCk7XG4gICAgICAgIGNvbnN0IG5vdyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBuZXdDb21tZW50ID0ge1xuICAgICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgIGNyZWF0ZWRBdDogbm93LFxuICAgICAgICAgIHR5cGU6IFwiY29tbWVudFwiLFxuICAgICAgICAgIHVzZXJJZDogZ2V0Q3VycmVudFVzZXJJZChyb29tKSxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIHJlYWN0aW9uczogW11cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbmV3VGhyZWFkID0ge1xuICAgICAgICAgIGlkOiB0aHJlYWRJZCxcbiAgICAgICAgICB0eXBlOiBcInRocmVhZFwiLFxuICAgICAgICAgIGNyZWF0ZWRBdDogbm93LFxuICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICBjb21tZW50czogW25ld0NvbW1lbnRdXG4gICAgICAgIH07XG4gICAgICAgIG11dGF0ZShyb29tLmNyZWF0ZVRocmVhZCh7IHRocmVhZElkLCBjb21tZW50SWQsIGJvZHksIG1ldGFkYXRhIH0pLCB7XG4gICAgICAgICAgb3B0aW1pc3RpY0RhdGE6IFsuLi50aHJlYWRzLCBuZXdUaHJlYWRdXG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBDb21tZW50c0FwaUVycm9yKSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBlcnJvciA9IGhhbmRsZUNvbW1lbnRzQXBpRXJyb3IoZXJyKTtcbiAgICAgICAgICBlcnJvckV2ZW50U291cmNlLm5vdGlmeShcbiAgICAgICAgICAgIG5ldyBDcmVhdGVUaHJlYWRFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3VGhyZWFkO1xuICAgICAgfSxcbiAgICAgIFtyb29tLCBtdXRhdGUsIG1hbmFnZXJdXG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlVGhyZWFkO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUNyZWF0ZUNvbW1lbnQocm9vbSkge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VSb29tTWFuYWdlcigpO1xuICAgIGNvbnN0IGZldGNoZXIgPSB1c2VUaHJlYWRzRmV0Y2hlcigpO1xuICAgIGNvbnN0IHJldmFsaWRhdGUgPSB1c2VSZXZhbGlkYXRlQ2FjaGUobWFuYWdlciwgZmV0Y2hlcik7XG4gICAgY29uc3QgbXV0YXRlID0gdXNlTXV0YXRlKG1hbmFnZXIsIHJldmFsaWRhdGUpO1xuICAgIGNvbnN0IGNyZWF0ZUNvbW1lbnQgPSB1c2VDYWxsYmFjazMoXG4gICAgICAoeyB0aHJlYWRJZCwgYm9keSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHRocmVhZHMgPSBnZXRUaHJlYWRzKG1hbmFnZXIpO1xuICAgICAgICBjb25zdCBjb21tZW50SWQgPSBjcmVhdGVDb21tZW50SWQoKTtcbiAgICAgICAgY29uc3Qgbm93ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IGNvbW1lbnQgPSB7XG4gICAgICAgICAgaWQ6IGNvbW1lbnRJZCxcbiAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgdHlwZTogXCJjb21tZW50XCIsXG4gICAgICAgICAgY3JlYXRlZEF0OiBub3csXG4gICAgICAgICAgdXNlcklkOiBnZXRDdXJyZW50VXNlcklkKHJvb20pLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgcmVhY3Rpb25zOiBbXVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvcHRpbWlzdGljRGF0YSA9IHRocmVhZHMubWFwKFxuICAgICAgICAgICh0aHJlYWQpID0+IHRocmVhZC5pZCA9PT0gdGhyZWFkSWQgPyB7XG4gICAgICAgICAgICAuLi50aHJlYWQsXG4gICAgICAgICAgICBjb21tZW50czogWy4uLnRocmVhZC5jb21tZW50cywgY29tbWVudF1cbiAgICAgICAgICB9IDogdGhyZWFkXG4gICAgICAgICk7XG4gICAgICAgIG11dGF0ZShyb29tLmNyZWF0ZUNvbW1lbnQoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5IH0pLCB7XG4gICAgICAgICAgb3B0aW1pc3RpY0RhdGFcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIENvbW1lbnRzQXBpRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGVycm9yID0gaGFuZGxlQ29tbWVudHNBcGlFcnJvcihlcnIpO1xuICAgICAgICAgIGVycm9yRXZlbnRTb3VyY2Uubm90aWZ5KFxuICAgICAgICAgICAgbmV3IENyZWF0ZUNvbW1lbnRFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICAgIGJvZHlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb21tZW50O1xuICAgICAgfSxcbiAgICAgIFtyb29tLCBtdXRhdGUsIG1hbmFnZXJdXG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlQ29tbWVudDtcbiAgfVxuICBmdW5jdGlvbiB1c2VFZGl0Q29tbWVudChyb29tKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHVzZVJvb21NYW5hZ2VyKCk7XG4gICAgY29uc3QgZmV0Y2hlciA9IHVzZVRocmVhZHNGZXRjaGVyKCk7XG4gICAgY29uc3QgcmV2YWxpZGF0ZSA9IHVzZVJldmFsaWRhdGVDYWNoZShtYW5hZ2VyLCBmZXRjaGVyKTtcbiAgICBjb25zdCBtdXRhdGUgPSB1c2VNdXRhdGUobWFuYWdlciwgcmV2YWxpZGF0ZSk7XG4gICAgY29uc3QgZWRpdENvbW1lbnQgPSB1c2VDYWxsYmFjazMoXG4gICAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5IH0pID0+IHtcbiAgICAgICAgY29uc3QgdGhyZWFkcyA9IGdldFRocmVhZHMobWFuYWdlcik7XG4gICAgICAgIGNvbnN0IG5vdyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBvcHRpbWlzdGljRGF0YSA9IHRocmVhZHMubWFwKFxuICAgICAgICAgICh0aHJlYWQpID0+IHRocmVhZC5pZCA9PT0gdGhyZWFkSWQgPyB7XG4gICAgICAgICAgICAuLi50aHJlYWQsXG4gICAgICAgICAgICBjb21tZW50czogdGhyZWFkLmNvbW1lbnRzLm1hcChcbiAgICAgICAgICAgICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZCA/IHtcbiAgICAgICAgICAgICAgICAuLi5jb21tZW50LFxuICAgICAgICAgICAgICAgIGVkaXRlZEF0OiBub3csXG4gICAgICAgICAgICAgICAgYm9keVxuICAgICAgICAgICAgICB9IDogY29tbWVudFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0gOiB0aHJlYWRcbiAgICAgICAgKTtcbiAgICAgICAgbXV0YXRlKHJvb20uZWRpdENvbW1lbnQoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5IH0pLCB7XG4gICAgICAgICAgb3B0aW1pc3RpY0RhdGFcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIENvbW1lbnRzQXBpRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGVycm9yID0gaGFuZGxlQ29tbWVudHNBcGlFcnJvcihlcnIpO1xuICAgICAgICAgIGVycm9yRXZlbnRTb3VyY2Uubm90aWZ5KFxuICAgICAgICAgICAgbmV3IEVkaXRDb21tZW50RXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgICBib2R5XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFtyb29tLCBtdXRhdGUsIG1hbmFnZXJdXG4gICAgKTtcbiAgICByZXR1cm4gZWRpdENvbW1lbnQ7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRGVsZXRlQ29tbWVudChyb29tKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHVzZVJvb21NYW5hZ2VyKCk7XG4gICAgY29uc3QgZmV0Y2hlciA9IHVzZVRocmVhZHNGZXRjaGVyKCk7XG4gICAgY29uc3QgcmV2YWxpZGF0ZSA9IHVzZVJldmFsaWRhdGVDYWNoZShtYW5hZ2VyLCBmZXRjaGVyKTtcbiAgICBjb25zdCBtdXRhdGUgPSB1c2VNdXRhdGUobWFuYWdlciwgcmV2YWxpZGF0ZSk7XG4gICAgY29uc3QgZGVsZXRlQ29tbWVudCA9IHVzZUNhbGxiYWNrMyhcbiAgICAgICh7IHRocmVhZElkLCBjb21tZW50SWQgfSkgPT4ge1xuICAgICAgICBjb25zdCB0aHJlYWRzID0gZ2V0VGhyZWFkcyhtYW5hZ2VyKTtcbiAgICAgICAgY29uc3Qgbm93ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IG5ld1RocmVhZHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0aHJlYWQgb2YgdGhyZWFkcykge1xuICAgICAgICAgIGlmICh0aHJlYWQuaWQgPT09IHRocmVhZElkKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdUaHJlYWQgPSB7XG4gICAgICAgICAgICAgIC4uLnRocmVhZCxcbiAgICAgICAgICAgICAgY29tbWVudHM6IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgICAgICAgICAgICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZCA/IHtcbiAgICAgICAgICAgICAgICAgIC4uLmNvbW1lbnQsXG4gICAgICAgICAgICAgICAgICBkZWxldGVkQXQ6IG5vdyxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHZvaWQgMFxuICAgICAgICAgICAgICAgIH0gOiBjb21tZW50XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobmV3VGhyZWFkLmNvbW1lbnRzLnNvbWUoXG4gICAgICAgICAgICAgIChjb21tZW50KSA9PiBjb21tZW50LmRlbGV0ZWRBdCA9PT0gdm9pZCAwXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgIG5ld1RocmVhZHMucHVzaChuZXdUaHJlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdUaHJlYWRzLnB1c2godGhyZWFkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbXV0YXRlKHJvb20uZGVsZXRlQ29tbWVudCh7IHRocmVhZElkLCBjb21tZW50SWQgfSksIHtcbiAgICAgICAgICBvcHRpbWlzdGljRGF0YTogbmV3VGhyZWFkc1xuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgQ29tbWVudHNBcGlFcnJvcikpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBoYW5kbGVDb21tZW50c0FwaUVycm9yKGVycik7XG4gICAgICAgICAgZXJyb3JFdmVudFNvdXJjZS5ub3RpZnkoXG4gICAgICAgICAgICBuZXcgRGVsZXRlQ29tbWVudEVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICAgIGNvbW1lbnRJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBbcm9vbSwgbXV0YXRlLCBtYW5hZ2VyXVxuICAgICk7XG4gICAgcmV0dXJuIGRlbGV0ZUNvbW1lbnQ7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQWRkUmVhY3Rpb24ocm9vbSkge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VSb29tTWFuYWdlcigpO1xuICAgIGNvbnN0IGZldGNoZXIgPSB1c2VUaHJlYWRzRmV0Y2hlcigpO1xuICAgIGNvbnN0IHJldmFsaWRhdGUgPSB1c2VSZXZhbGlkYXRlQ2FjaGUobWFuYWdlciwgZmV0Y2hlcik7XG4gICAgY29uc3QgbXV0YXRlID0gdXNlTXV0YXRlKG1hbmFnZXIsIHJldmFsaWRhdGUpO1xuICAgIGNvbnN0IGNyZWF0ZUNvbW1lbnQgPSB1c2VDYWxsYmFjazMoXG4gICAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHRocmVhZHMgPSBnZXRUaHJlYWRzKG1hbmFnZXIpO1xuICAgICAgICBjb25zdCBub3cgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgdXNlcklkID0gZ2V0Q3VycmVudFVzZXJJZChyb29tKTtcbiAgICAgICAgY29uc3Qgb3B0aW1pc3RpY0RhdGEgPSB0aHJlYWRzLm1hcChcbiAgICAgICAgICAodGhyZWFkKSA9PiB0aHJlYWQuaWQgPT09IHRocmVhZElkID8ge1xuICAgICAgICAgICAgLi4udGhyZWFkLFxuICAgICAgICAgICAgY29tbWVudHM6IHRocmVhZC5jb21tZW50cy5tYXAoKGNvbW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGNvbW1lbnQuaWQgIT09IGNvbW1lbnRJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCByZWFjdGlvbnM7XG4gICAgICAgICAgICAgIGlmIChjb21tZW50LnJlYWN0aW9ucy5zb21lKFxuICAgICAgICAgICAgICAgIChyZWFjdGlvbikgPT4gcmVhY3Rpb24uZW1vamkgPT09IGVtb2ppXG4gICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICByZWFjdGlvbnMgPSBjb21tZW50LnJlYWN0aW9ucy5tYXAoXG4gICAgICAgICAgICAgICAgICAocmVhY3Rpb24pID0+IHJlYWN0aW9uLmVtb2ppID09PSBlbW9qaSA/IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIHVzZXJzOiBbLi4ucmVhY3Rpb24udXNlcnMsIHsgaWQ6IHVzZXJJZCB9XVxuICAgICAgICAgICAgICAgICAgfSA6IHJlYWN0aW9uXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWFjdGlvbnMgPSBbXG4gICAgICAgICAgICAgICAgICAuLi5jb21tZW50LnJlYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZW1vamksXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogbm93LFxuICAgICAgICAgICAgICAgICAgICB1c2VyczogW3sgaWQ6IHVzZXJJZCB9XVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jb21tZW50LFxuICAgICAgICAgICAgICAgIHJlYWN0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IDogdGhyZWFkXG4gICAgICAgICk7XG4gICAgICAgIG11dGF0ZShyb29tLmFkZFJlYWN0aW9uKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSksIHtcbiAgICAgICAgICBvcHRpbWlzdGljRGF0YVxuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgQ29tbWVudHNBcGlFcnJvcikpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBoYW5kbGVDb21tZW50c0FwaUVycm9yKGVycik7XG4gICAgICAgICAgZXJyb3JFdmVudFNvdXJjZS5ub3RpZnkoXG4gICAgICAgICAgICBuZXcgQWRkUmVhY3Rpb25FcnJvcihlcnJvciwge1xuICAgICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICAgIGVtb2ppXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFtyb29tLCBtdXRhdGUsIG1hbmFnZXJdXG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlQ29tbWVudDtcbiAgfVxuICBmdW5jdGlvbiB1c2VSZW1vdmVSZWFjdGlvbihyb29tKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHVzZVJvb21NYW5hZ2VyKCk7XG4gICAgY29uc3QgZmV0Y2hlciA9IHVzZVRocmVhZHNGZXRjaGVyKCk7XG4gICAgY29uc3QgcmV2YWxpZGF0ZSA9IHVzZVJldmFsaWRhdGVDYWNoZShtYW5hZ2VyLCBmZXRjaGVyKTtcbiAgICBjb25zdCBtdXRhdGUgPSB1c2VNdXRhdGUobWFuYWdlciwgcmV2YWxpZGF0ZSk7XG4gICAgY29uc3QgY3JlYXRlQ29tbWVudCA9IHVzZUNhbGxiYWNrMyhcbiAgICAgICh7IHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pID0+IHtcbiAgICAgICAgY29uc3QgdGhyZWFkcyA9IGdldFRocmVhZHMobWFuYWdlcik7XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IGdldEN1cnJlbnRVc2VySWQocm9vbSk7XG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWNEYXRhID0gdGhyZWFkcy5tYXAoXG4gICAgICAgICAgKHRocmVhZCkgPT4gdGhyZWFkLmlkID09PSB0aHJlYWRJZCA/IHtcbiAgICAgICAgICAgIC4uLnRocmVhZCxcbiAgICAgICAgICAgIGNvbW1lbnRzOiB0aHJlYWQuY29tbWVudHMubWFwKChjb21tZW50KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjb21tZW50LmlkICE9PSBjb21tZW50SWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWVudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCByZWFjdGlvbkluZGV4ID0gY29tbWVudC5yZWFjdGlvbnMuZmluZEluZGV4KFxuICAgICAgICAgICAgICAgIChyZWFjdGlvbikgPT4gcmVhY3Rpb24uZW1vamkgPT09IGVtb2ppXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGxldCByZWFjdGlvbnMgPSBjb21tZW50LnJlYWN0aW9ucztcbiAgICAgICAgICAgICAgaWYgKHJlYWN0aW9uSW5kZXggPj0gMCAmJiBjb21tZW50LnJlYWN0aW9uc1tyZWFjdGlvbkluZGV4XS51c2Vycy5zb21lKFxuICAgICAgICAgICAgICAgICh1c2VyKSA9PiB1c2VyLmlkID09PSB1c2VySWRcbiAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb21tZW50LnJlYWN0aW9uc1tyZWFjdGlvbkluZGV4XS51c2Vycy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgcmVhY3Rpb25zID0gWy4uLmNvbW1lbnQucmVhY3Rpb25zXTtcbiAgICAgICAgICAgICAgICAgIHJlYWN0aW9ucy5zcGxpY2UocmVhY3Rpb25JbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlYWN0aW9uc1tyZWFjdGlvbkluZGV4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVhY3Rpb25zW3JlYWN0aW9uSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICB1c2VyczogcmVhY3Rpb25zW3JlYWN0aW9uSW5kZXhdLnVzZXJzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAodXNlcikgPT4gdXNlci5pZCAhPT0gdXNlcklkXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY29tbWVudCxcbiAgICAgICAgICAgICAgICByZWFjdGlvbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSA6IHRocmVhZFxuICAgICAgICApO1xuICAgICAgICBtdXRhdGUocm9vbS5yZW1vdmVSZWFjdGlvbih7IHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pLCB7XG4gICAgICAgICAgb3B0aW1pc3RpY0RhdGFcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIENvbW1lbnRzQXBpRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGVycm9yID0gaGFuZGxlQ29tbWVudHNBcGlFcnJvcihlcnIpO1xuICAgICAgICAgIGVycm9yRXZlbnRTb3VyY2Uubm90aWZ5KFxuICAgICAgICAgICAgbmV3IFJlbW92ZVJlYWN0aW9uRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgICBlbW9qaVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBbcm9vbSwgbXV0YXRlLCBtYW5hZ2VyXVxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbW1lbnQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBDb21tZW50c1Jvb21Qcm92aWRlcixcbiAgICB1c2VUaHJlYWRzLFxuICAgIHVzZVRocmVhZHNTdXNwZW5zZSxcbiAgICB1c2VFZGl0VGhyZWFkTWV0YWRhdGEsXG4gICAgdXNlQ3JlYXRlVGhyZWFkLFxuICAgIHVzZUNyZWF0ZUNvbW1lbnQsXG4gICAgdXNlRWRpdENvbW1lbnQsXG4gICAgdXNlRGVsZXRlQ29tbWVudCxcbiAgICB1c2VBZGRSZWFjdGlvbixcbiAgICB1c2VSZW1vdmVSZWFjdGlvblxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlT3B0aW1pc3RpY0lkKHByZWZpeCkge1xuICByZXR1cm4gYCR7cHJlZml4fV8ke25hbm9pZCgpfWA7XG59XG5mdW5jdGlvbiBjcmVhdGVUaHJlYWRJZCgpIHtcbiAgcmV0dXJuIGNyZWF0ZU9wdGltaXN0aWNJZChUSFJFQURfSURfUFJFRklYKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRJZCgpIHtcbiAgcmV0dXJuIGNyZWF0ZU9wdGltaXN0aWNJZChDT01NRU5UX0lEX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50VXNlcklkKHJvb20pIHtcbiAgY29uc3Qgc2VsZiA9IHJvb20uZ2V0U2VsZigpO1xuICBpZiAoc2VsZiA9PT0gbnVsbCB8fCBzZWxmLmlkID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gXCJhbm9ueW1vdXNcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2VsZi5pZDtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlQ29tbWVudHNBcGlFcnJvcihlcnIpIHtcbiAgY29uc3QgbWVzc2FnZSA9IGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyAke2Vyci5zdGF0dXN9OiAke2Vyci5tZXNzYWdlfWA7XG4gIGlmIChlcnIuZGV0YWlscz8uZXJyb3IgPT09IFwiRk9SQklEREVOXCIpIHtcbiAgICBjb25zdCBkZXRhaWxlZE1lc3NhZ2UgPSBbbWVzc2FnZSwgZXJyLmRldGFpbHMuc3VnZ2VzdGlvbiwgZXJyLmRldGFpbHMuZG9jc10uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcXG5cIik7XG4gICAgY29uc29sZS5lcnJvcihkZXRhaWxlZE1lc3NhZ2UpO1xuICB9XG4gIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSb29tUmV2YWxpZGF0aW9uTWFuYWdlcihyb29tSWQsIHtcbiAgZ2V0Q2FjaGUsXG4gIHNldENhY2hlXG59KSB7XG4gIGxldCByZXF1ZXN0O1xuICBsZXQgZXJyb3I7XG4gIGxldCBtdXRhdGlvbjtcbiAgY29uc3QgcmV2YWxpZGF0aW9uTWFuYWdlckJ5T3B0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHJlZmVyZW5jZUNvdW50QnlPcHRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBDYWNoZVxuICAgIGdldENhY2hlKCkge1xuICAgICAgY29uc3QgdGhyZWFkcyA9IGdldENhY2hlKCk7XG4gICAgICBjb25zdCBmaWx0ZXJlZCA9IHRocmVhZHMuZmlsdGVyKCh0aHJlYWQpID0+IHRocmVhZC5yb29tSWQgPT09IHJvb21JZCk7XG4gICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgfSxcbiAgICBzZXRDYWNoZSh2YWx1ZSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgcmV2YWxpZGF0aW9uTWFuYWdlckJ5T3B0aW9ucy5rZXlzKCkpIHtcbiAgICAgICAgaWYgKHJlZmVyZW5jZUNvdW50QnlPcHRpb25zLmdldChrZXkpID09PSAwKSB7XG4gICAgICAgICAgcmV2YWxpZGF0aW9uTWFuYWdlckJ5T3B0aW9ucy5kZWxldGUoa2V5KTtcbiAgICAgICAgICByZWZlcmVuY2VDb3VudEJ5T3B0aW9ucy5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc29ydGVkID0gdmFsdWUuc29ydChcbiAgICAgICAgKGEsIGIpID0+IG5ldyBEYXRlKGEuY3JlYXRlZEF0KS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShiLmNyZWF0ZWRBdCkuZ2V0VGltZSgpXG4gICAgICApO1xuICAgICAgY29uc3QgdGhyZWFkcyA9IGdldENhY2hlKCk7XG4gICAgICBjb25zdCBuZXdUaHJlYWRzID0gdGhyZWFkcy5maWx0ZXIoKHRocmVhZCkgPT4gdGhyZWFkLnJvb21JZCAhPT0gcm9vbUlkKS5jb25jYXQoc29ydGVkKTtcbiAgICAgIHNldENhY2hlKG5ld1RocmVhZHMpO1xuICAgIH0sXG4gICAgLy8gUmVxdWVzdFxuICAgIGdldFJlcXVlc3QoKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9LFxuICAgIHNldFJlcXVlc3QodmFsdWUpIHtcbiAgICAgIHJlcXVlc3QgPSB2YWx1ZTtcbiAgICB9LFxuICAgIC8vIEVycm9yXG4gICAgZ2V0RXJyb3IoKSB7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSxcbiAgICBzZXRFcnJvcihlcnIpIHtcbiAgICAgIGVycm9yID0gZXJyO1xuICAgIH0sXG4gICAgLy8gTXV0YXRpb25cbiAgICBnZXRNdXRhdGlvbigpIHtcbiAgICAgIHJldHVybiBtdXRhdGlvbjtcbiAgICB9LFxuICAgIHNldE11dGF0aW9uKGluZm8pIHtcbiAgICAgIG11dGF0aW9uID0gaW5mbztcbiAgICB9LFxuICAgIGdldFJldmFsaWRhdGlvbk1hbmFnZXJzKCkge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20ocmV2YWxpZGF0aW9uTWFuYWdlckJ5T3B0aW9ucy5lbnRyaWVzKCkpO1xuICAgIH0sXG4gICAgZ2V0UmV2YWxpZGF0aW9uTWFuYWdlcihrZXkpIHtcbiAgICAgIHJldHVybiByZXZhbGlkYXRpb25NYW5hZ2VyQnlPcHRpb25zLmdldChrZXkpO1xuICAgIH0sXG4gICAgc2V0UmV2YWxpZGF0aW9ubWFuYWdlcihrZXksIG1hbmFnZXIpIHtcbiAgICAgIHJldmFsaWRhdGlvbk1hbmFnZXJCeU9wdGlvbnMuc2V0KGtleSwgbWFuYWdlcik7XG4gICAgfSxcbiAgICBnZXRUb3RhbFJlZmVyZW5jZUNvdW50KCkge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20ocmVmZXJlbmNlQ291bnRCeU9wdGlvbnMudmFsdWVzKCkpLnJlZHVjZShcbiAgICAgICAgKGFjYywgY291bnQpID0+IGFjYyArIGNvdW50LFxuICAgICAgICAwXG4gICAgICApO1xuICAgIH0sXG4gICAgaW5jcmVtZW50UmVmZXJlbmNlQ291bnQoa2V5KSB7XG4gICAgICBjb25zdCBjb3VudCA9IHJlZmVyZW5jZUNvdW50QnlPcHRpb25zLmdldChrZXkpID8/IDA7XG4gICAgICByZWZlcmVuY2VDb3VudEJ5T3B0aW9ucy5zZXQoa2V5LCBjb3VudCArIDEpO1xuICAgIH0sXG4gICAgZGVjcmVtZW50UmVmZXJlbmNlQ291bnQoa2V5KSB7XG4gICAgICBjb25zdCBjb3VudCA9IHJlZmVyZW5jZUNvdW50QnlPcHRpb25zLmdldChrZXkpID8/IDA7XG4gICAgICByZWZlcmVuY2VDb3VudEJ5T3B0aW9ucy5zZXQoa2V5LCBjb3VudCAtIDEpO1xuICAgIH0sXG4gICAgZ2V0UmVmZXJlbmNlQ291bnQoa2V5KSB7XG4gICAgICByZXR1cm4gcmVmZXJlbmNlQ291bnRCeU9wdGlvbnMuZ2V0KGtleSkgPz8gMDtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnRDYWNoZVN0b3JlKCkge1xuICBsZXQgdGhyZWFkcyA9IFtdO1xuICBjb25zdCB0aHJlYWRzRXZlbnRTb3VyY2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgcmV0dXJuIHtcbiAgICBnZXRUaHJlYWRzKCkge1xuICAgICAgcmV0dXJuIHRocmVhZHM7XG4gICAgfSxcbiAgICBzZXRUaHJlYWRzKHZhbHVlKSB7XG4gICAgICB0aHJlYWRzID0gdmFsdWU7XG4gICAgICB0aHJlYWRzRXZlbnRTb3VyY2Uubm90aWZ5KHRocmVhZHMpO1xuICAgIH0sXG4gICAgc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhyZWFkc0V2ZW50U291cmNlLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIob3B0aW9ucywgbWFuYWdlcikge1xuICBsZXQgaXNMb2FkaW5nID0gdHJ1ZTtcbiAgbGV0IHJlcXVlc3Q7XG4gIGxldCBlcnJvcjtcbiAgcmV0dXJuIHtcbiAgICAvLyBDYWNoZVxuICAgIGdldENhY2hlKCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9LFxuICAgIHNldENhY2hlKHZhbHVlKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoXG4gICAgICAgIChtYW5hZ2VyLmdldENhY2hlKCkgPz8gW10pLm1hcCgodGhyZWFkKSA9PiBbdGhyZWFkLmlkLCB0aHJlYWRdKVxuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3QgdGhyZWFkIG9mIHZhbHVlKSB7XG4gICAgICAgIGNhY2hlLnNldCh0aHJlYWQuaWQsIHRocmVhZCk7XG4gICAgICB9XG4gICAgICBtYW5hZ2VyLnNldENhY2hlKEFycmF5LmZyb20oY2FjaGUudmFsdWVzKCkpKTtcbiAgICAgIGlzTG9hZGluZyA9IGZhbHNlO1xuICAgIH0sXG4gICAgLy8gUmVxdWVzdFxuICAgIGdldFJlcXVlc3QoKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9LFxuICAgIHNldFJlcXVlc3QodmFsdWUpIHtcbiAgICAgIHJlcXVlc3QgPSB2YWx1ZTtcbiAgICB9LFxuICAgIC8vIEVycm9yXG4gICAgZ2V0RXJyb3IoKSB7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSxcbiAgICBzZXRFcnJvcihlcnIpIHtcbiAgICAgIGVycm9yID0gZXJyO1xuICAgICAgaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICBjb25zdCBjYWNoZSA9IG1hbmFnZXIuZ2V0Q2FjaGUoKTtcbiAgICAgIG1hbmFnZXIuc2V0Q2FjaGUoY2FjaGUpO1xuICAgIH0sXG4gICAgLy8gTXV0YXRpb25cbiAgICBnZXRNdXRhdGlvbigpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfSxcbiAgICBzZXRNdXRhdGlvbihfKSB7XG4gICAgICByZXR1cm47XG4gICAgfSxcbiAgICBnZXRPcHRpb25zKCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfSxcbiAgICBnZXRJc0xvYWRpbmcoKSB7XG4gICAgICByZXR1cm4gaXNMb2FkaW5nO1xuICAgIH0sXG4gICAgc2V0SXNMb2FkaW5nKHZhbHVlKSB7XG4gICAgICBpc0xvYWRpbmcgPSB2YWx1ZTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXRQb2xsaW5nSW50ZXJ2YWwoaXNCcm93c2VyT25saW5lLCBpc0RvY3VtZW50VmlzaWJsZSwgaXNSb29tQ29ubmVjdGVkKSB7XG4gIGlmICghaXNCcm93c2VyT25saW5lIHx8ICFpc0RvY3VtZW50VmlzaWJsZSlcbiAgICByZXR1cm47XG4gIGlmIChpc1Jvb21Db25uZWN0ZWQpXG4gICAgcmV0dXJuIFBPTExJTkdfSU5URVJWQUxfUkVBTFRJTUU7XG4gIHJldHVybiBQT0xMSU5HX0lOVEVSVkFMO1xufVxuXG4vLyBzcmMvY29tbWVudHMvbGliL3VzZS1kZWJvdW5jZS50c1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDQsIHVzZVJlZiBhcyB1c2VSZWYzLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBERUZBVUxUX0RFTEFZID0gNTAwO1xuZnVuY3Rpb24gdXNlRGVib3VuY2UodmFsdWUsIGRlbGF5ID0gREVGQVVMVF9ERUxBWSkge1xuICBjb25zdCB0aW1lb3V0ID0gdXNlUmVmMygpO1xuICBjb25zdCBbZGVib3VuY2VkVmFsdWUsIHNldERlYm91bmNlZFZhbHVlXSA9IHVzZVN0YXRlMih2YWx1ZSk7XG4gIHVzZUVmZmVjdDQoKCkgPT4ge1xuICAgIGlmIChkZWxheSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRpbWVvdXQuY3VycmVudCA9PT0gdm9pZCAwKSB7XG4gICAgICBzZXREZWJvdW5jZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHRpbWVvdXQuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldERlYm91bmNlZFZhbHVlKHZhbHVlKTtcbiAgICAgIHRpbWVvdXQuY3VycmVudCA9IHZvaWQgMDtcbiAgICB9LCBkZWxheSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dC5jdXJyZW50KTtcbiAgICB9O1xuICB9LCBbdmFsdWUsIGRlbGF5XSk7XG4gIHJldHVybiBkZWJvdW5jZWRWYWx1ZTtcbn1cblxuLy8gc3JjL2xpYi91c2UtYXN5bmMtY2FjaGUudHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrNCwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDUsIHVzZU1lbW8gYXMgdXNlTWVtbzIsIHVzZVJlZiBhcyB1c2VSZWY0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZTQgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS9pbmRleC5qc1wiO1xuXG4vLyBzcmMvbGliL3VzZS1pbml0aWFsLnRzXG5pbXBvcnQgeyB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTMgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZUluaXRpYWwodmFsdWUpIHtcbiAgcmV0dXJuIHVzZVN0YXRlMyh2YWx1ZSlbMF07XG59XG5cbi8vIHNyYy9saWIvdXNlLWFzeW5jLWNhY2hlLnRzXG52YXIgSU5JVElBTF9BU1lOQ19TVEFURSA9IHtcbiAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgZGF0YTogdm9pZCAwLFxuICBlcnJvcjogdm9pZCAwXG59O1xudmFyIG5vb3AgPSAoKSA9PiB7XG59O1xuZnVuY3Rpb24gdXNlQXN5bmNDYWNoZShjYWNoZSwga2V5LCBvcHRpb25zKSB7XG4gIGNvbnN0IGZyb3plbk9wdGlvbnMgPSB1c2VJbml0aWFsKG9wdGlvbnMpO1xuICBjb25zdCBjYWNoZUl0ZW0gPSB1c2VNZW1vMigoKSA9PiB7XG4gICAgaWYgKGtleSA9PT0gbnVsbCB8fCAhY2FjaGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZUl0ZW0yID0gY2FjaGUuY3JlYXRlKGtleSk7XG4gICAgdm9pZCBjYWNoZUl0ZW0yLmdldCgpO1xuICAgIHJldHVybiBjYWNoZUl0ZW0yO1xuICB9LCBbY2FjaGUsIGtleV0pO1xuICBjb25zdCBzdWJzY3JpYmUyID0gdXNlQ2FsbGJhY2s0KFxuICAgIChjYWxsYmFjaykgPT4gY2FjaGVJdGVtPy5zdWJzY3JpYmUoY2FsbGJhY2spID8/IG5vb3AsXG4gICAgW2NhY2hlSXRlbV1cbiAgKTtcbiAgY29uc3QgZ2V0U3RhdGUgPSB1c2VDYWxsYmFjazQoXG4gICAgKCkgPT4gY2FjaGVJdGVtPy5nZXRTdGF0ZSgpID8/IElOSVRJQUxfQVNZTkNfU1RBVEUsXG4gICAgW2NhY2hlSXRlbV1cbiAgKTtcbiAgY29uc3QgcmV2YWxpZGF0ZSA9IHVzZUNhbGxiYWNrNCgoKSA9PiBjYWNoZUl0ZW0/LnJldmFsaWRhdGUoKSwgW2NhY2hlSXRlbV0pO1xuICBjb25zdCBzdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlNChzdWJzY3JpYmUyLCBnZXRTdGF0ZSwgZ2V0U3RhdGUpO1xuICBjb25zdCBwcmV2aW91c0RhdGEgPSB1c2VSZWY0KCk7XG4gIGxldCBkYXRhID0gc3RhdGUuZGF0YTtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgcHJldmlvdXNEYXRhLmN1cnJlbnQgPSB7IGtleSwgZGF0YTogc3RhdGUuZGF0YSB9O1xuICB9LCBba2V5LCBzdGF0ZS5kYXRhXSk7XG4gIGlmICghY2FjaGVJdGVtKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBkYXRhOiB2b2lkIDAsXG4gICAgICBlcnJvcjogdm9pZCAwLFxuICAgICAgZ2V0U3RhdGUsXG4gICAgICByZXZhbGlkYXRlXG4gICAgfTtcbiAgfVxuICBpZiAoZnJvemVuT3B0aW9ucz8uc3VzcGVuc2UpIHtcbiAgICBjb25zdCBlcnJvciA9IGdldFN0YXRlKCkuZXJyb3I7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGVsc2UgaWYgKGdldFN0YXRlKCkuaXNMb2FkaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjYWNoZUl0ZW0uc3Vic2NyaWJlT25jZSgoc3RhdGUyKSA9PiB7XG4gICAgICAgICAgaWYgKCFzdGF0ZTIuaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGUuaXNMb2FkaW5nICYmIGZyb3plbk9wdGlvbnM/LmtlZXBQcmV2aW91c0RhdGFXaGlsZUxvYWRpbmcgJiYgdHlwZW9mIHN0YXRlLmRhdGEgPT09IFwidW5kZWZpbmVkXCIgJiYgcHJldmlvdXNEYXRhLmN1cnJlbnQ/LmtleSAhPT0ga2V5ICYmIHR5cGVvZiBwcmV2aW91c0RhdGEuY3VycmVudD8uZGF0YSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGRhdGEgPSBwcmV2aW91c0RhdGEuY3VycmVudC5kYXRhO1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNMb2FkaW5nOiBzdGF0ZS5pc0xvYWRpbmcsXG4gICAgZGF0YSxcbiAgICBlcnJvcjogc3RhdGUuZXJyb3IsXG4gICAgZ2V0U3RhdGUsXG4gICAgcmV2YWxpZGF0ZVxuICB9O1xufVxuXG4vLyBzcmMvbGliL3VzZS1sYXRlc3QudHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q2LCB1c2VSZWYgYXMgdXNlUmVmNSB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlTGF0ZXN0KHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZjUodmFsdWUpO1xuICB1c2VFZmZlY3Q2KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuLy8gc3JjL2xpYi91c2UtcmVyZW5kZXIudHNcbmltcG9ydCB7IHVzZVJlZHVjZXIgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZVJlcmVuZGVyKCkge1xuICBjb25zdCBbLCB1cGRhdGVdID0gdXNlUmVkdWNlcihcbiAgICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIHdvcmtzIGJ5IGluY3JlbWVudGluZyBhIGhpZGRlbiBjb3VudGVyIHZhbHVlIHRoYXQgaXNcbiAgICAvLyBuZXZlciBjb25zdW1lZC4gU2ltcGx5IGluY3JlbWVudGluZyB0aGUgY291bnRlciBjaGFuZ2VzIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHN0YXRlIGFuZCwgdGh1cywgdHJpZ2dlciBhIHJlLXJlbmRlci5cbiAgICAoeCkgPT4geCArIDEsXG4gICAgMFxuICApO1xuICByZXR1cm4gdXBkYXRlO1xufVxuXG4vLyBzcmMvZmFjdG9yeS50c3hcbnZhciBub29wMiA9ICgpID0+IHtcbn07XG52YXIgaWRlbnRpdHkgPSAoeCkgPT4geDtcbnZhciBtaXNzaW5nX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gKHJlYWN0VmVyc2lvbiwgcm9vbUlkKSA9PiBgV2Ugbm90aWNlZCB5b3VcXHUyMDE5cmUgdXNpbmcgUmVhY3QgJHtyZWFjdFZlcnNpb259LiBQbGVhc2UgcGFzcyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyBhdCB0aGUgUm9vbVByb3ZpZGVyIGxldmVsIHVudGlsIHlvdVxcdTIwMTlyZSByZWFkeSB0byB1cGdyYWRlIHRvIFJlYWN0IDE4OlxuXG4gICAgaW1wb3J0IHsgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgfSBmcm9tIFwicmVhY3QtZG9tXCI7ICAvLyBvciBcInJlYWN0LW5hdGl2ZVwiXG5cbiAgICA8Um9vbVByb3ZpZGVyIGlkPSR7SlNPTi5zdHJpbmdpZnkoXG4gIHJvb21JZFxuKX0gLi4uIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzPXt1bnN0YWJsZV9iYXRjaGVkVXBkYXRlc30+XG4gICAgICAuLi5cbiAgICA8L1Jvb21Qcm92aWRlcj5cblxuV2h5PyBQbGVhc2Ugc2VlIGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL3BsYXRmb3JtL3Ryb3VibGVzaG9vdGluZyNzdGFsZS1wcm9wcy16b21iaWUtY2hpbGQgZm9yIG1vcmUgaW5mb3JtYXRpb25gO1xudmFyIHN1cGVyZmx1b3VzX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gXCJZb3UgZG9uXFx1MjAxOXQgbmVlZCB0byBwYXNzIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIHRvIFJvb21Qcm92aWRlciBhbnltb3JlLCBzaW5jZSB5b3VcXHUyMDE5cmUgb24gUmVhY3QgMTgrIGFscmVhZHkuXCI7XG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTMocywgZ3MsIGdzcykge1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKHMsIGdzLCBnc3MsIGlkZW50aXR5KTtcbn1cbnZhciBTVEFCTEVfRU1QVFlfTElTVCA9IE9iamVjdC5mcmVlemUoW10pO1xuZnVuY3Rpb24gYWx3YXlzRW1wdHlMaXN0KCkge1xuICByZXR1cm4gU1RBQkxFX0VNUFRZX0xJU1Q7XG59XG5mdW5jdGlvbiBhbHdheXNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG1ha2VNdXRhdGlvbkNvbnRleHQocm9vbSkge1xuICBjb25zdCBlcnJtc2cgPSBcIlRoaXMgbXV0YXRpb24gY2Fubm90IGJlIHVzZWQgdW50aWwgY29ubmVjdGVkIHRvIHRoZSBMaXZlYmxvY2tzIHJvb21cIjtcbiAgcmV0dXJuIHtcbiAgICBnZXQgc3RvcmFnZSgpIHtcbiAgICAgIGNvbnN0IG11dGFibGVSb290ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKTtcbiAgICAgIGlmIChtdXRhYmxlUm9vdCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJybXNnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtdXRhYmxlUm9vdDtcbiAgICB9LFxuICAgIGdldCBzZWxmKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHJvb20uZ2V0U2VsZigpO1xuICAgICAgaWYgKHNlbGYgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm1zZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuICAgIGdldCBvdGhlcnMoKSB7XG4gICAgICBjb25zdCBvdGhlcnMgPSByb29tLmdldE90aGVycygpO1xuICAgICAgaWYgKHJvb20uZ2V0U2VsZigpID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJtc2cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG90aGVycztcbiAgICB9LFxuICAgIHNldE15UHJlc2VuY2U6IHJvb20udXBkYXRlUHJlc2VuY2VcbiAgfTtcbn1cbnZhciBoYXNXYXJuZWRJZk5vUmVzb2x2ZVVzZXJzID0gZmFsc2U7XG5mdW5jdGlvbiB3YXJuSWZOb1Jlc29sdmVVc2Vycyh1c2Vyc0NhY2hlKSB7XG4gIGlmICghaGFzV2FybmVkSWZOb1Jlc29sdmVVc2VycyAmJiAhdXNlcnNDYWNoZSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIlNldCB0aGUgcmVzb2x2ZVVzZXJzIG9wdGlvbiBpbiBjcmVhdGVSb29tQ29udGV4dCB0byBzcGVjaWZ5IHVzZXIgaW5mby5cIlxuICAgICk7XG4gICAgaGFzV2FybmVkSWZOb1Jlc29sdmVVc2VycyA9IHRydWU7XG4gIH1cbn1cbnZhciBDb250ZXh0QnVuZGxlID0gUmVhY3QzLmNyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiB1c2VSb29tQ29udGV4dEJ1bmRsZSgpIHtcbiAgY29uc3QgYnVuZGxlID0gUmVhY3QzLnVzZUNvbnRleHQoQ29udGV4dEJ1bmRsZSk7XG4gIGlmIChidW5kbGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb29tUHJvdmlkZXIgaXMgbWlzc2luZyBmcm9tIHRoZSBSZWFjdCB0cmVlLlwiKTtcbiAgfVxuICByZXR1cm4gYnVuZGxlO1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vbUNvbnRleHQoY2xpZW50LCBvcHRpb25zKSB7XG4gIGNvbnN0IFJvb21Db250ZXh0ID0gUmVhY3QzLmNyZWF0ZUNvbnRleHQobnVsbCk7XG4gIGNvbnN0IGNvbW1lbnRzRXJyb3JFdmVudFNvdXJjZSA9IG1ha2VFdmVudFNvdXJjZTIoKTtcbiAgY29uc3QgeyBDb21tZW50c1Jvb21Qcm92aWRlciwgLi4uY29tbWVudHNSb29tIH0gPSBjcmVhdGVDb21tZW50c1Jvb20oY29tbWVudHNFcnJvckV2ZW50U291cmNlKTtcbiAgZnVuY3Rpb24gUm9vbVByb3ZpZGVyT3V0ZXIocHJvcHMpIHtcbiAgICBjb25zdCBbY2FjaGVdID0gUmVhY3QzLnVzZVN0YXRlKFxuICAgICAgKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICAgICk7XG4gICAgY29uc3Qgc3RhYmxlRW50ZXJSb29tID0gUmVhY3QzLnVzZUNhbGxiYWNrKFxuICAgICAgKHJvb21JZCwgb3B0aW9uczIpID0+IHtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KHJvb21JZCk7XG4gICAgICAgIGlmIChjYWNoZWQpXG4gICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgY29uc3QgcnYgPSBjbGllbnQuZW50ZXJSb29tKFxuICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICBvcHRpb25zMlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBvcmlnTGVhdmUgPSBydi5sZWF2ZTtcbiAgICAgICAgcnYubGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgb3JpZ0xlYXZlKCk7XG4gICAgICAgICAgY2FjaGUuZGVsZXRlKHJvb21JZCk7XG4gICAgICAgIH07XG4gICAgICAgIGNhY2hlLnNldChyb29tSWQsIHJ2KTtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSxcbiAgICAgIFtjYWNoZV1cbiAgICApO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoUm9vbVByb3ZpZGVySW5uZXIsIHsgLi4ucHJvcHMsIHN0YWJsZUVudGVyUm9vbSB9KTtcbiAgfVxuICBmdW5jdGlvbiBSb29tUHJvdmlkZXJJbm5lcihwcm9wcykge1xuICAgIGNvbnN0IHsgaWQ6IHJvb21JZCwgc3RhYmxlRW50ZXJSb29tIH0gPSBwcm9wcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoIXJvb21JZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJSb29tUHJvdmlkZXIgaWQgcHJvcGVydHkgaXMgcmVxdWlyZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvbGl2ZWJsb2Nrcy1yZWFjdC9Sb29tUHJvdmlkZXItaWQtcHJvcGVydHktaXMtcmVxdWlyZWRcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiByb29tSWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vbVByb3ZpZGVyIGlkIHByb3BlcnR5IHNob3VsZCBiZSBhIHN0cmluZy5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtYWpvclJlYWN0VmVyc2lvbiA9IHBhcnNlSW50KFJlYWN0My52ZXJzaW9uKSB8fCAxO1xuICAgICAgY29uc3Qgb2xkUmVhY3RWZXJzaW9uID0gbWFqb3JSZWFjdFZlcnNpb24gPCAxODtcbiAgICAgIGVycm9ySWYoXG4gICAgICAgIG9sZFJlYWN0VmVyc2lvbiAmJiBwcm9wcy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA9PT0gdm9pZCAwLFxuICAgICAgICBtaXNzaW5nX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKG1ham9yUmVhY3RWZXJzaW9uLCByb29tSWQpXG4gICAgICApO1xuICAgICAgZGVwcmVjYXRlSWYoXG4gICAgICAgICFvbGRSZWFjdFZlcnNpb24gJiYgcHJvcHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgIT09IHZvaWQgMCxcbiAgICAgICAgc3VwZXJmbHVvdXNfdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGZyb3plblByb3BzID0gdXNlSW5pdGlhbCh7XG4gICAgICBpbml0aWFsUHJlc2VuY2U6IHByb3BzLmluaXRpYWxQcmVzZW5jZSxcbiAgICAgIGluaXRpYWxTdG9yYWdlOiBwcm9wcy5pbml0aWFsU3RvcmFnZSxcbiAgICAgIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBwcm9wcy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyxcbiAgICAgIGF1dG9Db25uZWN0OiBwcm9wcy5hdXRvQ29ubmVjdCA/PyBwcm9wcy5zaG91bGRJbml0aWFsbHlDb25uZWN0ID8/IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCJcbiAgICB9KTtcbiAgICBjb25zdCBbeyByb29tIH0sIHNldFJvb21MZWF2ZVBhaXJdID0gUmVhY3QzLnVzZVN0YXRlKFxuICAgICAgKCkgPT4gc3RhYmxlRW50ZXJSb29tKHJvb21JZCwge1xuICAgICAgICAuLi5mcm96ZW5Qcm9wcyxcbiAgICAgICAgYXV0b0Nvbm5lY3Q6IGZhbHNlXG4gICAgICAgIC8vIERlbGliZXJhdGVseSB1c2luZyBmYWxzZSBoZXJlIG9uIHRoZSBmaXJzdCByZW5kZXIsIHNlZSBiZWxvd1xuICAgICAgfSlcbiAgICApO1xuICAgIFJlYWN0My51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgcGFpciA9IHN0YWJsZUVudGVyUm9vbShyb29tSWQsIGZyb3plblByb3BzKTtcbiAgICAgIHNldFJvb21MZWF2ZVBhaXIocGFpcik7XG4gICAgICBjb25zdCB7IHJvb206IHJvb20yLCBsZWF2ZSB9ID0gcGFpcjtcbiAgICAgIGlmIChmcm96ZW5Qcm9wcy5hdXRvQ29ubmVjdCkge1xuICAgICAgICByb29tMi5jb25uZWN0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBsZWF2ZSgpO1xuICAgICAgfTtcbiAgICB9LCBbcm9vbUlkLCBmcm96ZW5Qcm9wcywgc3RhYmxlRW50ZXJSb29tXSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChSb29tQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcm9vbSB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoQ29tbWVudHNSb29tUHJvdmlkZXIsIHsgcm9vbSB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBDb250ZXh0QnVuZGxlLlByb3ZpZGVyLFxuICAgICAge1xuICAgICAgICB2YWx1ZTogaW50ZXJuYWxCdW5kbGVcbiAgICAgIH0sXG4gICAgICBwcm9wcy5jaGlsZHJlblxuICAgICkpKTtcbiAgfVxuICBmdW5jdGlvbiBjb25uZWN0aW9uSWRTZWxlY3RvcihvdGhlcnMpIHtcbiAgICByZXR1cm4gb3RoZXJzLm1hcCgodXNlcikgPT4gdXNlci5jb25uZWN0aW9uSWQpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVJvb20oKSB7XG4gICAgY29uc3Qgcm9vbSA9IFJlYWN0My51c2VDb250ZXh0KFJvb21Db250ZXh0KTtcbiAgICBpZiAocm9vbSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vbVByb3ZpZGVyIGlzIG1pc3NpbmcgZnJvbSB0aGUgUmVhY3QgdHJlZS5cIik7XG4gICAgfVxuICAgIHJldHVybiByb29tO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVN0YXR1cygpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHN1YnNjcmliZTIgPSByb29tLmV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlO1xuICAgIGNvbnN0IGdldFNuYXBzaG90MiA9IHJvb20uZ2V0U3RhdHVzO1xuICAgIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gcm9vbS5nZXRTdGF0dXM7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhzdWJzY3JpYmUyLCBnZXRTbmFwc2hvdDIsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgfVxuICBmdW5jdGlvbiB1c2VNeVByZXNlbmNlKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc3Vic2NyaWJlMiA9IHJvb20uZXZlbnRzLm15UHJlc2VuY2Uuc3Vic2NyaWJlO1xuICAgIGNvbnN0IGdldFNuYXBzaG90MiA9IHJvb20uZ2V0UHJlc2VuY2U7XG4gICAgY29uc3QgcHJlc2VuY2UgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTMoc3Vic2NyaWJlMiwgZ2V0U25hcHNob3QyLCBnZXRTbmFwc2hvdDIpO1xuICAgIGNvbnN0IHNldFByZXNlbmNlID0gcm9vbS51cGRhdGVQcmVzZW5jZTtcbiAgICByZXR1cm4gW3ByZXNlbmNlLCBzZXRQcmVzZW5jZV07XG4gIH1cbiAgZnVuY3Rpb24gdXNlVXBkYXRlTXlQcmVzZW5jZSgpIHtcbiAgICByZXR1cm4gdXNlUm9vbSgpLnVwZGF0ZVByZXNlbmNlO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU90aGVycyhzZWxlY3RvciwgaXNFcXVhbCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc3Vic2NyaWJlMiA9IHJvb20uZXZlbnRzLm90aGVycy5zdWJzY3JpYmU7XG4gICAgY29uc3QgZ2V0U25hcHNob3QyID0gcm9vbS5nZXRPdGhlcnM7XG4gICAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSBhbHdheXNFbXB0eUxpc3Q7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICAgIHN1YnNjcmliZTIsXG4gICAgICBnZXRTbmFwc2hvdDIsXG4gICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICAgIHNlbGVjdG9yID8/IGlkZW50aXR5LFxuICAgICAgaXNFcXVhbFxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlT3RoZXJzQ29ubmVjdGlvbklkcygpIHtcbiAgICByZXR1cm4gdXNlT3RoZXJzKGNvbm5lY3Rpb25JZFNlbGVjdG9yLCBzaGFsbG93KTtcbiAgfVxuICBmdW5jdGlvbiB1c2VPdGhlcnNNYXBwZWQoaXRlbVNlbGVjdG9yLCBpdGVtSXNFcXVhbCkge1xuICAgIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9IFJlYWN0My51c2VDYWxsYmFjayhcbiAgICAgIChvdGhlcnMpID0+IG90aGVycy5tYXAoXG4gICAgICAgIChvdGhlcikgPT4gW290aGVyLmNvbm5lY3Rpb25JZCwgaXRlbVNlbGVjdG9yKG90aGVyKV1cbiAgICAgICksXG4gICAgICBbaXRlbVNlbGVjdG9yXVxuICAgICk7XG4gICAgY29uc3Qgd3JhcHBlZElzRXF1YWwgPSBSZWFjdDMudXNlQ2FsbGJhY2soXG4gICAgICAoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCBlcSA9IGl0ZW1Jc0VxdWFsID8/IE9iamVjdC5pcztcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KChhdHVwbGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgYnR1cGxlID0gYltpbmRleF07XG4gICAgICAgICAgcmV0dXJuIGF0dXBsZVswXSA9PT0gYnR1cGxlWzBdICYmIGVxKGF0dXBsZVsxXSwgYnR1cGxlWzFdKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgW2l0ZW1Jc0VxdWFsXVxuICAgICk7XG4gICAgcmV0dXJuIHVzZU90aGVycyh3cmFwcGVkU2VsZWN0b3IsIHdyYXBwZWRJc0VxdWFsKTtcbiAgfVxuICBjb25zdCBOT1RfRk9VTkQgPSBTeW1ib2woKTtcbiAgZnVuY3Rpb24gdXNlT3RoZXIoY29ubmVjdGlvbklkLCBzZWxlY3RvciwgaXNFcXVhbCkge1xuICAgIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9IFJlYWN0My51c2VDYWxsYmFjayhcbiAgICAgIChvdGhlcnMpID0+IHtcbiAgICAgICAgY29uc3Qgb3RoZXIyID0gb3RoZXJzLmZpbmQoXG4gICAgICAgICAgKG90aGVyMykgPT4gb3RoZXIzLmNvbm5lY3Rpb25JZCA9PT0gY29ubmVjdGlvbklkXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBvdGhlcjIgIT09IHZvaWQgMCA/IHNlbGVjdG9yKG90aGVyMikgOiBOT1RfRk9VTkQ7XG4gICAgICB9LFxuICAgICAgW2Nvbm5lY3Rpb25JZCwgc2VsZWN0b3JdXG4gICAgKTtcbiAgICBjb25zdCB3cmFwcGVkSXNFcXVhbCA9IFJlYWN0My51c2VDYWxsYmFjayhcbiAgICAgIChwcmV2LCBjdXJyKSA9PiB7XG4gICAgICAgIGlmIChwcmV2ID09PSBOT1RfRk9VTkQgfHwgY3VyciA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXYgPT09IGN1cnI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXEgPSBpc0VxdWFsID8/IE9iamVjdC5pcztcbiAgICAgICAgcmV0dXJuIGVxKHByZXYsIGN1cnIpO1xuICAgICAgfSxcbiAgICAgIFtpc0VxdWFsXVxuICAgICk7XG4gICAgY29uc3Qgb3RoZXIgPSB1c2VPdGhlcnMod3JhcHBlZFNlbGVjdG9yLCB3cmFwcGVkSXNFcXVhbCk7XG4gICAgaWYgKG90aGVyID09PSBOT1RfRk9VTkQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE5vIHN1Y2ggb3RoZXIgdXNlciB3aXRoIGNvbm5lY3Rpb24gaWQgJHtjb25uZWN0aW9uSWR9IGV4aXN0c2BcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBvdGhlcjtcbiAgfVxuICBmdW5jdGlvbiB1c2VCcm9hZGNhc3RFdmVudCgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBSZWFjdDMudXNlQ2FsbGJhY2soXG4gICAgICAoZXZlbnQsIG9wdGlvbnMyID0geyBzaG91bGRRdWV1ZUV2ZW50SWZOb3RSZWFkeTogZmFsc2UgfSkgPT4ge1xuICAgICAgICByb29tLmJyb2FkY2FzdEV2ZW50KGV2ZW50LCBvcHRpb25zMik7XG4gICAgICB9LFxuICAgICAgW3Jvb21dXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VPdGhlcnNMaXN0ZW5lcihjYWxsYmFjaykge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc2F2ZWRDYWxsYmFjayA9IHVzZUxhdGVzdChjYWxsYmFjayk7XG4gICAgUmVhY3QzLnVzZUVmZmVjdChcbiAgICAgICgpID0+IHJvb20uZXZlbnRzLm90aGVycy5zdWJzY3JpYmUoKGV2ZW50KSA9PiBzYXZlZENhbGxiYWNrLmN1cnJlbnQoZXZlbnQpKSxcbiAgICAgIFtyb29tLCBzYXZlZENhbGxiYWNrXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlTG9zdENvbm5lY3Rpb25MaXN0ZW5lcihjYWxsYmFjaykge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc2F2ZWRDYWxsYmFjayA9IHVzZUxhdGVzdChjYWxsYmFjayk7XG4gICAgUmVhY3QzLnVzZUVmZmVjdChcbiAgICAgICgpID0+IHJvb20uZXZlbnRzLmxvc3RDb25uZWN0aW9uLnN1YnNjcmliZShcbiAgICAgICAgKGV2ZW50KSA9PiBzYXZlZENhbGxiYWNrLmN1cnJlbnQoZXZlbnQpXG4gICAgICApLFxuICAgICAgW3Jvb20sIHNhdmVkQ2FsbGJhY2tdXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VFcnJvckxpc3RlbmVyKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlTGF0ZXN0KGNhbGxiYWNrKTtcbiAgICBSZWFjdDMudXNlRWZmZWN0KFxuICAgICAgKCkgPT4gcm9vbS5ldmVudHMuZXJyb3Iuc3Vic2NyaWJlKChlKSA9PiBzYXZlZENhbGxiYWNrLmN1cnJlbnQoZSkpLFxuICAgICAgW3Jvb20sIHNhdmVkQ2FsbGJhY2tdXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VFdmVudExpc3RlbmVyKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlTGF0ZXN0KGNhbGxiYWNrKTtcbiAgICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gKGV2ZW50RGF0YSkgPT4ge1xuICAgICAgICBzYXZlZENhbGxiYWNrLmN1cnJlbnQoZXZlbnREYXRhKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcm9vbS5ldmVudHMuY3VzdG9tRXZlbnQuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgICB9LCBbcm9vbSwgc2F2ZWRDYWxsYmFja10pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVNlbGYobWF5YmVTZWxlY3RvciwgaXNFcXVhbCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc3Vic2NyaWJlMiA9IHJvb20uZXZlbnRzLnNlbGYuc3Vic2NyaWJlO1xuICAgIGNvbnN0IGdldFNuYXBzaG90MiA9IHJvb20uZ2V0U2VsZjtcbiAgICBjb25zdCBzZWxlY3RvciA9IG1heWJlU2VsZWN0b3IgPz8gaWRlbnRpdHk7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3QzLnVzZUNhbGxiYWNrKFxuICAgICAgKG1lKSA9PiBtZSAhPT0gbnVsbCA/IHNlbGVjdG9yKG1lKSA6IG51bGwsXG4gICAgICBbc2VsZWN0b3JdXG4gICAgKTtcbiAgICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGFsd2F5c051bGw7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICAgIHN1YnNjcmliZTIsXG4gICAgICBnZXRTbmFwc2hvdDIsXG4gICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICAgIHdyYXBwZWRTZWxlY3RvcixcbiAgICAgIGlzRXF1YWxcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU11dGFibGVTdG9yYWdlUm9vdCgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHN1YnNjcmliZTIgPSByb29tLmV2ZW50cy5zdG9yYWdlRGlkTG9hZC5zdWJzY3JpYmVPbmNlO1xuICAgIGNvbnN0IGdldFNuYXBzaG90MiA9IHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90O1xuICAgIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzTnVsbDtcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUzKHN1YnNjcmliZTIsIGdldFNuYXBzaG90MiwgZ2V0U2VydmVyU25hcHNob3QpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVN0b3JhZ2VSb290KCkge1xuICAgIHJldHVybiBbdXNlTXV0YWJsZVN0b3JhZ2VSb290KCldO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUhpc3RvcnkoKSB7XG4gICAgcmV0dXJuIHVzZVJvb20oKS5oaXN0b3J5O1xuICB9XG4gIGZ1bmN0aW9uIHVzZVVuZG8oKSB7XG4gICAgcmV0dXJuIHVzZUhpc3RvcnkoKS51bmRvO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVJlZG8oKSB7XG4gICAgcmV0dXJuIHVzZUhpc3RvcnkoKS5yZWRvO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUNhblVuZG8oKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBzdWJzY3JpYmUyID0gcm9vbS5ldmVudHMuaGlzdG9yeS5zdWJzY3JpYmU7XG4gICAgY29uc3QgY2FuVW5kbyA9IHJvb20uaGlzdG9yeS5jYW5VbmRvO1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTMoc3Vic2NyaWJlMiwgY2FuVW5kbywgY2FuVW5kbyk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQ2FuUmVkbygpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHN1YnNjcmliZTIgPSByb29tLmV2ZW50cy5oaXN0b3J5LnN1YnNjcmliZTtcbiAgICBjb25zdCBjYW5SZWRvID0gcm9vbS5oaXN0b3J5LmNhblJlZG87XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhzdWJzY3JpYmUyLCBjYW5SZWRvLCBjYW5SZWRvKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VCYXRjaCgpIHtcbiAgICByZXR1cm4gdXNlUm9vbSgpLmJhdGNoO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUxlZ2FjeUtleShrZXkpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHJvb3RPck51bGwgPSB1c2VNdXRhYmxlU3RvcmFnZVJvb3QoKTtcbiAgICBjb25zdCByZXJlbmRlciA9IHVzZVJlcmVuZGVyKCk7XG4gICAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAocm9vdE9yTnVsbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByb290ID0gcm9vdE9yTnVsbDtcbiAgICAgIGxldCB1bnN1YkN1cnI7XG4gICAgICBsZXQgY3VyciA9IHJvb3QuZ2V0KGtleSk7XG4gICAgICBmdW5jdGlvbiBzdWJzY3JpYmVUb0N1cnIoKSB7XG4gICAgICAgIHVuc3ViQ3VyciA9IGlzTGl2ZU5vZGUoY3VycikgPyByb29tLnN1YnNjcmliZShjdXJyLCByZXJlbmRlcikgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvblJvb3RDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcm9vdC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBjdXJyKSB7XG4gICAgICAgICAgdW5zdWJDdXJyPy4oKTtcbiAgICAgICAgICBjdXJyID0gbmV3VmFsdWU7XG4gICAgICAgICAgc3Vic2NyaWJlVG9DdXJyKCk7XG4gICAgICAgICAgcmVyZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3Vic2NyaWJlVG9DdXJyKCk7XG4gICAgICByZXJlbmRlcigpO1xuICAgICAgY29uc3QgdW5zdWJzY3JpYmVSb290ID0gcm9vbS5zdWJzY3JpYmUocm9vdCwgb25Sb290Q2hhbmdlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVuc3Vic2NyaWJlUm9vdCgpO1xuICAgICAgICB1bnN1YkN1cnI/LigpO1xuICAgICAgfTtcbiAgICB9LCBbcm9vdE9yTnVsbCwgcm9vbSwga2V5LCByZXJlbmRlcl0pO1xuICAgIGlmIChyb290T3JOdWxsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJvb3RPck51bGwuZ2V0KGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVzZVN0b3JhZ2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHJvb3RPck51bGwgPSB1c2VNdXRhYmxlU3RvcmFnZVJvb3QoKTtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdDMudXNlQ2FsbGJhY2soXG4gICAgICAocm9vdE9yTnVsbDIpID0+IHJvb3RPck51bGwyICE9PSBudWxsID8gc2VsZWN0b3Iocm9vdE9yTnVsbDIpIDogbnVsbCxcbiAgICAgIFtzZWxlY3Rvcl1cbiAgICApO1xuICAgIGNvbnN0IHN1YnNjcmliZTIgPSBSZWFjdDMudXNlQ2FsbGJhY2soXG4gICAgICAob25TdG9yZUNoYW5nZSkgPT4gcm9vdE9yTnVsbCAhPT0gbnVsbCA/IHJvb20uc3Vic2NyaWJlKHJvb3RPck51bGwsIG9uU3RvcmVDaGFuZ2UsIHsgaXNEZWVwOiB0cnVlIH0pIDogbm9vcDIsXG4gICAgICBbcm9vbSwgcm9vdE9yTnVsbF1cbiAgICApO1xuICAgIGNvbnN0IGdldFNuYXBzaG90MiA9IFJlYWN0My51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICBpZiAocm9vdE9yTnVsbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSByb290T3JOdWxsO1xuICAgICAgICBjb25zdCBpbW0gPSByb290LnRvSW1tdXRhYmxlKCk7XG4gICAgICAgIHJldHVybiBpbW07XG4gICAgICB9XG4gICAgfSwgW3Jvb3RPck51bGxdKTtcbiAgICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGFsd2F5c051bGw7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICAgIHN1YnNjcmliZTIsXG4gICAgICBnZXRTbmFwc2hvdDIsXG4gICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICAgIHdyYXBwZWRTZWxlY3RvcixcbiAgICAgIGlzRXF1YWxcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGVuc3VyZU5vdFNlcnZlclNpZGUoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJZb3UgY2Fubm90IHVzZSB0aGUgU3VzcGVuc2UgdmVyc2lvbiBvZiB0aGlzIGhvb2sgb24gdGhlIHNlcnZlciBzaWRlLiBNYWtlIHN1cmUgdG8gb25seSBjYWxsIHRoZW0gb24gdGhlIGNsaWVudCBzaWRlLlxcbkZvciB0aXBzLCBzZWUgaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLXJlYWN0I3N1c3BlbnNlLWF2b2lkLXNzclwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1c2VTdXNwZW5kVW50aWxTdG9yYWdlTG9hZGVkKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgaWYgKHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90KCkgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5zdXJlTm90U2VydmVyU2lkZSgpO1xuICAgIHRocm93IG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgIHJvb20uZXZlbnRzLnN0b3JhZ2VEaWRMb2FkLnN1YnNjcmliZU9uY2UoKCkgPT4gcmVzKCkpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlTG9hZGVkKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgaWYgKHJvb20uZ2V0U2VsZigpICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVuc3VyZU5vdFNlcnZlclNpZGUoKTtcbiAgICB0aHJvdyBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICByb29tLmV2ZW50cy5zZWxmLnN1YnNjcmliZU9uY2UoKCkgPT4gcmVzKCkpO1xuICAgICAgcm9vbS5ldmVudHMuc3RhdHVzLnN1YnNjcmliZU9uY2UoKCkgPT4gcmVzKCkpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU11dGF0aW9uKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gUmVhY3QzLnVzZU1lbW8oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4gKFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgIHJvb20uYmF0Y2goXG4gICAgICAgICAgICAoKSA9PiAoXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgICAgICBtYWtlTXV0YXRpb25Db250ZXh0KHJvb20pLFxuICAgICAgICAgICAgICAgIC4uLmFyZ3NcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICBbcm9vbSwgLi4uZGVwc11cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVN0b3JhZ2VTdXNwZW5zZShzZWxlY3RvciwgaXNFcXVhbCkge1xuICAgIHVzZVN1c3BlbmRVbnRpbFN0b3JhZ2VMb2FkZWQoKTtcbiAgICByZXR1cm4gdXNlU3RvcmFnZShcbiAgICAgIHNlbGVjdG9yLFxuICAgICAgaXNFcXVhbFxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlU2VsZlN1c3BlbnNlKHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gICAgdXNlU3VzcGVuZFVudGlsUHJlc2VuY2VMb2FkZWQoKTtcbiAgICByZXR1cm4gdXNlU2VsZihcbiAgICAgIHNlbGVjdG9yLFxuICAgICAgaXNFcXVhbFxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlT3RoZXJzU3VzcGVuc2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZUxvYWRlZCgpO1xuICAgIHJldHVybiB1c2VPdGhlcnMoXG4gICAgICBzZWxlY3RvcixcbiAgICAgIGlzRXF1YWxcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHNTdXNwZW5zZSgpIHtcbiAgICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZUxvYWRlZCgpO1xuICAgIHJldHVybiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzKCk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlT3RoZXJzTWFwcGVkU3VzcGVuc2UoaXRlbVNlbGVjdG9yLCBpdGVtSXNFcXVhbCkge1xuICAgIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlTG9hZGVkKCk7XG4gICAgcmV0dXJuIHVzZU90aGVyc01hcHBlZChpdGVtU2VsZWN0b3IsIGl0ZW1Jc0VxdWFsKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VPdGhlclN1c3BlbnNlKGNvbm5lY3Rpb25JZCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZUxvYWRlZCgpO1xuICAgIHJldHVybiB1c2VPdGhlcihjb25uZWN0aW9uSWQsIHNlbGVjdG9yLCBpc0VxdWFsKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VMZWdhY3lLZXlTdXNwZW5zZShrZXkpIHtcbiAgICB1c2VTdXNwZW5kVW50aWxTdG9yYWdlTG9hZGVkKCk7XG4gICAgcmV0dXJuIHVzZUxlZ2FjeUtleShrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVRocmVhZHMob3B0aW9uczIpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBjb21tZW50c1Jvb20udXNlVGhyZWFkcyhyb29tLCBvcHRpb25zMik7XG4gIH1cbiAgZnVuY3Rpb24gdXNlVGhyZWFkc1N1c3BlbnNlKG9wdGlvbnMyKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gY29tbWVudHNSb29tLnVzZVRocmVhZHNTdXNwZW5zZShyb29tLCBvcHRpb25zMik7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQ3JlYXRlVGhyZWFkKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIGNvbW1lbnRzUm9vbS51c2VDcmVhdGVUaHJlYWQocm9vbSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRWRpdFRocmVhZE1ldGFkYXRhKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIGNvbW1lbnRzUm9vbS51c2VFZGl0VGhyZWFkTWV0YWRhdGEocm9vbSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQWRkUmVhY3Rpb24oKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gY29tbWVudHNSb29tLnVzZUFkZFJlYWN0aW9uKHJvb20pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVJlbW92ZVJlYWN0aW9uKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIGNvbW1lbnRzUm9vbS51c2VSZW1vdmVSZWFjdGlvbihyb29tKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VDcmVhdGVDb21tZW50KCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIGNvbW1lbnRzUm9vbS51c2VDcmVhdGVDb21tZW50KHJvb20pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUVkaXRDb21tZW50KCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIGNvbW1lbnRzUm9vbS51c2VFZGl0Q29tbWVudChyb29tKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VEZWxldGVDb21tZW50KCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIGNvbW1lbnRzUm9vbS51c2VEZWxldGVDb21tZW50KHJvb20pO1xuICB9XG4gIGNvbnN0IHsgcmVzb2x2ZVVzZXJzLCByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zIH0gPSBvcHRpb25zID8/IHt9O1xuICBjb25zdCB1c2Vyc0NhY2hlID0gcmVzb2x2ZVVzZXJzID8gY3JlYXRlQXN5bmNDYWNoZShhc3luYyAoc3RyaW5naWZpZWRPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgdXNlcnMgPSBhd2FpdCByZXNvbHZlVXNlcnMoXG4gICAgICBKU09OLnBhcnNlKHN0cmluZ2lmaWVkT3B0aW9ucylcbiAgICApO1xuICAgIHJldHVybiB1c2Vycz8uWzBdO1xuICB9KSA6IHZvaWQgMDtcbiAgZnVuY3Rpb24gdXNlVXNlcih1c2VySWQpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHJlc29sdmVyS2V5ID0gUmVhY3QzLnVzZU1lbW8oXG4gICAgICAoKSA9PiBzdHJpbmdpZnkyKHsgdXNlcklkczogW3VzZXJJZF0sIHJvb21JZDogcm9vbS5pZCB9KSxcbiAgICAgIFt1c2VySWQsIHJvb20uaWRdXG4gICAgKTtcbiAgICBjb25zdCBzdGF0ZSA9IHVzZUFzeW5jQ2FjaGUodXNlcnNDYWNoZSwgcmVzb2x2ZXJLZXkpO1xuICAgIFJlYWN0My51c2VFZmZlY3QoKCkgPT4gd2FybklmTm9SZXNvbHZlVXNlcnModXNlcnNDYWNoZSksIFtdKTtcbiAgICBpZiAoc3RhdGUuaXNMb2FkaW5nKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0xvYWRpbmc6IHRydWVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVzZXI6IHN0YXRlLmRhdGEsXG4gICAgICAgIGVycm9yOiBzdGF0ZS5lcnJvcixcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXNlVXNlclN1c3BlbnNlKHVzZXJJZCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3QgcmVzb2x2ZXJLZXkgPSBSZWFjdDMudXNlTWVtbyhcbiAgICAgICgpID0+IHN0cmluZ2lmeTIoeyB1c2VySWRzOiBbdXNlcklkXSwgcm9vbUlkOiByb29tLmlkIH0pLFxuICAgICAgW3VzZXJJZCwgcm9vbS5pZF1cbiAgICApO1xuICAgIGNvbnN0IHN0YXRlID0gdXNlQXN5bmNDYWNoZSh1c2Vyc0NhY2hlLCByZXNvbHZlcktleSwge1xuICAgICAgc3VzcGVuc2U6IHRydWVcbiAgICB9KTtcbiAgICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHdhcm5JZk5vUmVzb2x2ZVVzZXJzKHVzZXJzQ2FjaGUpLCBbXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXI6IHN0YXRlLmRhdGEsXG4gICAgICBpc0xvYWRpbmc6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjb25zdCBtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZSA9IGNyZWF0ZUFzeW5jQ2FjaGUoXG4gICAgcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyA/IChzdHJpbmdpZmllZE9wdGlvbnMpID0+IHtcbiAgICAgIHJldHVybiByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zKFxuICAgICAgICBKU09OLnBhcnNlKHN0cmluZ2lmaWVkT3B0aW9ucylcbiAgICAgICk7XG4gICAgfSA6ICgpID0+IFByb21pc2UucmVzb2x2ZShbXSlcbiAgKTtcbiAgZnVuY3Rpb24gdXNlTWVudGlvblN1Z2dlc3Rpb25zKHNlYXJjaCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3QgZGVib3VuY2VkU2VhcmNoID0gdXNlRGVib3VuY2Uoc2VhcmNoLCA1MDApO1xuICAgIGNvbnN0IHJlc29sdmVyS2V5ID0gUmVhY3QzLnVzZU1lbW8oXG4gICAgICAoKSA9PiBkZWJvdW5jZWRTZWFyY2ggIT09IHZvaWQgMCA/IHN0cmluZ2lmeTIoeyB0ZXh0OiBkZWJvdW5jZWRTZWFyY2gsIHJvb21JZDogcm9vbS5pZCB9KSA6IG51bGwsXG4gICAgICBbZGVib3VuY2VkU2VhcmNoLCByb29tLmlkXVxuICAgICk7XG4gICAgY29uc3QgeyBkYXRhIH0gPSB1c2VBc3luY0NhY2hlKG1lbnRpb25TdWdnZXN0aW9uc0NhY2hlLCByZXNvbHZlcktleSwge1xuICAgICAga2VlcFByZXZpb3VzRGF0YVdoaWxlTG9hZGluZzogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGNvbnN0IGJ1bmRsZSA9IHtcbiAgICBSb29tQ29udGV4dCxcbiAgICBSb29tUHJvdmlkZXI6IFJvb21Qcm92aWRlck91dGVyLFxuICAgIHVzZVJvb20sXG4gICAgdXNlU3RhdHVzLFxuICAgIHVzZUJhdGNoLFxuICAgIHVzZUJyb2FkY2FzdEV2ZW50LFxuICAgIHVzZU90aGVyc0xpc3RlbmVyLFxuICAgIHVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIsXG4gICAgdXNlRXJyb3JMaXN0ZW5lcixcbiAgICB1c2VFdmVudExpc3RlbmVyLFxuICAgIHVzZUhpc3RvcnksXG4gICAgdXNlVW5kbyxcbiAgICB1c2VSZWRvLFxuICAgIHVzZUNhblJlZG8sXG4gICAgdXNlQ2FuVW5kbyxcbiAgICAvLyBUaGVzZSBhcmUganVzdCBhbGlhc2VzLiBUaGUgcGFzc2VkLWluIGtleSB3aWxsIGRlZmluZSB0aGVpciByZXR1cm4gdmFsdWVzLlxuICAgIHVzZUxpc3Q6IHVzZUxlZ2FjeUtleSxcbiAgICB1c2VNYXA6IHVzZUxlZ2FjeUtleSxcbiAgICB1c2VPYmplY3Q6IHVzZUxlZ2FjeUtleSxcbiAgICB1c2VTdG9yYWdlUm9vdCxcbiAgICB1c2VTdG9yYWdlLFxuICAgIHVzZVNlbGYsXG4gICAgdXNlTXlQcmVzZW5jZSxcbiAgICB1c2VVcGRhdGVNeVByZXNlbmNlLFxuICAgIHVzZU90aGVycyxcbiAgICB1c2VPdGhlcnNNYXBwZWQsXG4gICAgdXNlT3RoZXJzQ29ubmVjdGlvbklkcyxcbiAgICB1c2VPdGhlcixcbiAgICB1c2VNdXRhdGlvbixcbiAgICB1c2VUaHJlYWRzLFxuICAgIHVzZVVzZXIsXG4gICAgdXNlQ3JlYXRlVGhyZWFkLFxuICAgIHVzZUVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgICB1c2VDcmVhdGVDb21tZW50LFxuICAgIHVzZUVkaXRDb21tZW50LFxuICAgIHVzZURlbGV0ZUNvbW1lbnQsXG4gICAgdXNlQWRkUmVhY3Rpb24sXG4gICAgdXNlUmVtb3ZlUmVhY3Rpb24sXG4gICAgc3VzcGVuc2U6IHtcbiAgICAgIFJvb21Db250ZXh0LFxuICAgICAgUm9vbVByb3ZpZGVyOiBSb29tUHJvdmlkZXJPdXRlcixcbiAgICAgIHVzZVJvb20sXG4gICAgICB1c2VTdGF0dXMsXG4gICAgICB1c2VCYXRjaCxcbiAgICAgIHVzZUJyb2FkY2FzdEV2ZW50LFxuICAgICAgdXNlT3RoZXJzTGlzdGVuZXIsXG4gICAgICB1c2VMb3N0Q29ubmVjdGlvbkxpc3RlbmVyLFxuICAgICAgdXNlRXJyb3JMaXN0ZW5lcixcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIsXG4gICAgICB1c2VIaXN0b3J5LFxuICAgICAgdXNlVW5kbyxcbiAgICAgIHVzZVJlZG8sXG4gICAgICB1c2VDYW5SZWRvLFxuICAgICAgdXNlQ2FuVW5kbyxcbiAgICAgIC8vIExlZ2FjeSBob29rc1xuICAgICAgdXNlTGlzdDogdXNlTGVnYWN5S2V5U3VzcGVuc2UsXG4gICAgICB1c2VNYXA6IHVzZUxlZ2FjeUtleVN1c3BlbnNlLFxuICAgICAgdXNlT2JqZWN0OiB1c2VMZWdhY3lLZXlTdXNwZW5zZSxcbiAgICAgIHVzZVN0b3JhZ2VSb290LFxuICAgICAgdXNlU3RvcmFnZTogdXNlU3RvcmFnZVN1c3BlbnNlLFxuICAgICAgdXNlU2VsZjogdXNlU2VsZlN1c3BlbnNlLFxuICAgICAgdXNlTXlQcmVzZW5jZSxcbiAgICAgIHVzZVVwZGF0ZU15UHJlc2VuY2UsXG4gICAgICB1c2VPdGhlcnM6IHVzZU90aGVyc1N1c3BlbnNlLFxuICAgICAgdXNlT3RoZXJzTWFwcGVkOiB1c2VPdGhlcnNNYXBwZWRTdXNwZW5zZSxcbiAgICAgIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHM6IHVzZU90aGVyc0Nvbm5lY3Rpb25JZHNTdXNwZW5zZSxcbiAgICAgIHVzZU90aGVyOiB1c2VPdGhlclN1c3BlbnNlLFxuICAgICAgdXNlTXV0YXRpb24sXG4gICAgICB1c2VUaHJlYWRzOiB1c2VUaHJlYWRzU3VzcGVuc2UsXG4gICAgICB1c2VVc2VyOiB1c2VVc2VyU3VzcGVuc2UsXG4gICAgICB1c2VDcmVhdGVUaHJlYWQsXG4gICAgICB1c2VFZGl0VGhyZWFkTWV0YWRhdGEsXG4gICAgICB1c2VDcmVhdGVDb21tZW50LFxuICAgICAgdXNlRWRpdENvbW1lbnQsXG4gICAgICB1c2VEZWxldGVDb21tZW50LFxuICAgICAgdXNlQWRkUmVhY3Rpb24sXG4gICAgICB1c2VSZW1vdmVSZWFjdGlvblxuICAgIH1cbiAgfTtcbiAgY29uc3QgaW50ZXJuYWxCdW5kbGUgPSB7XG4gICAgLi4uYnVuZGxlLFxuICAgIGhhc1Jlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnM6IHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMgIT09IHZvaWQgMCxcbiAgICB1c2VNZW50aW9uU3VnZ2VzdGlvbnNcbiAgfTtcbiAgcmV0dXJuIGJ1bmRsZTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBzaGFsbG93IGFzIHNoYWxsb3cyIH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NsaWVudFwiO1xuZGV0ZWN0RHVwZXMoUEtHX05BTUUsIFBLR19WRVJTSU9OLCBQS0dfRk9STUFUKTtcbmV4cG9ydCB7XG4gIENsaWVudFNpZGVTdXNwZW5zZSxcbiAgY3JlYXRlUm9vbUNvbnRleHQsXG4gIHNoYWxsb3cyIGFzIHNoYWxsb3csXG4gIHVzZVJvb21Db250ZXh0QnVuZGxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJkZXRlY3REdXBlcyIsIlBLR19OQU1FIiwiUEtHX1ZFUlNJT04iLCJQS0dfRk9STUFUIiwiUmVhY3QiLCJDbGllbnRTaWRlU3VzcGVuc2UiLCJwcm9wcyIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJjcmVhdGVFbGVtZW50IiwiU3VzcGVuc2UiLCJmYWxsYmFjayIsImNoaWxkcmVuIiwic2hhbGxvdyIsImNyZWF0ZUFzeW5jQ2FjaGUiLCJkZXByZWNhdGVJZiIsImVycm9ySWYiLCJpc0xpdmVOb2RlIiwibWFrZUV2ZW50U291cmNlIiwibWFrZUV2ZW50U291cmNlMiIsInN0cmluZ2lmeSIsInN0cmluZ2lmeTIiLCJSZWFjdDMiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciIsInVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMiIsIkNvbW1lbnRzQXBpRXJyb3IiLCJuYW5vaWQiLCJSZWFjdDIiLCJjcmVhdGVDb250ZXh0IiwidXNlQ2FsbGJhY2siLCJ1c2VDYWxsYmFjazMiLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0MyIsInVzZU1lbW8iLCJDcmVhdGVUaHJlYWRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjYXVzZSIsImNvbnRleHQiLCJuYW1lIiwiRWRpdFRocmVhZE1ldGFkYXRhRXJyb3IiLCJDcmVhdGVDb21tZW50RXJyb3IiLCJFZGl0Q29tbWVudEVycm9yIiwiRGVsZXRlQ29tbWVudEVycm9yIiwiQWRkUmVhY3Rpb25FcnJvciIsIlJlbW92ZVJlYWN0aW9uRXJyb3IiLCJ1c2VDYWxsYmFjazIiLCJ1c2VFZmZlY3QyIiwidXNlUmVmIiwidXNlUmVmMiIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwidXNlSXNEb2N1bWVudFZpc2libGUiLCJpc1Zpc2libGUiLCJzdWJzY3JpYmUiLCJnZXRTbmFwc2hvdCIsIm9uU3RvcmVDaGFuZ2UiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaXNEb2N1bWVudERlZmluZWQiLCJ2aXNpYmlsaXR5U3RhdGUiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZTIiLCJ1c2VJc09ubGluZSIsImlzT25saW5lUmVmIiwic3Vic2NyaWJlMiIsImhhbmRsZUlzT25saW5lIiwiY3VycmVudCIsImhhbmRsZUlzT2ZmbGluZSIsIndpbmRvdyIsImdldFNuYXBzaG90MiIsImlzT25saW5lIiwiREVGQVVMVF9FUlJPUl9SRVRSWV9JTlRFUlZBTCIsIkRFRkFVTFRfTUFYX0VSUk9SX1JFVFJZX0NPVU5UIiwiREVGQVVMVF9ERURVUElOR19JTlRFUlZBTCIsInRpbWVzdGFtcCIsInVzZVJldmFsaWRhdGVDYWNoZSIsIm1hbmFnZXIiLCJmZXRjaGVyIiwib3B0aW9ucyIsImRlZHVwaW5nSW50ZXJ2YWwiLCJlcnJvclJldHJ5SW50ZXJ2YWwiLCJlcnJvclJldHJ5Q291bnQiLCJfcmV2YWxpZGF0ZUNhY2hlIiwic2hvdWxkRGVkdXBlIiwicmV0cnlDb3VudCIsInN0YXJ0QXQiLCJzaG91bGRTdGFydFJlcXVlc3QiLCJnZXRSZXF1ZXN0IiwiZGVsZXRlQWN0aXZlUmVxdWVzdCIsImFjdGl2ZVJlcXVlc3QiLCJzZXRSZXF1ZXN0IiwiaGFuZGxlRXJyb3IiLCJ0aW1lb3V0IiwiTWF0aCIsInJhbmRvbSIsInNldFRpbWVvdXQiLCJuZXdEYXRhIiwiYWN0aXZlTXV0YXRpb24iLCJnZXRNdXRhdGlvbiIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJzZXRDYWNoZSIsImVyciIsInNldEVycm9yIiwicmV2YWxpZGF0ZUNhY2hlIiwidXNlTXV0YXRlIiwibXV0YXRlIiwiZGF0YSIsImJlZm9yZU11dGF0aW9uVGltZXN0YW1wIiwic2V0TXV0YXRpb24iLCJjdXJyZW50Q2FjaGUiLCJnZXRDYWNoZSIsIm9wdGltaXN0aWNEYXRhIiwiZXJyb3IiLCJUSFJFQURfSURfUFJFRklYIiwiQ09NTUVOVF9JRF9QUkVGSVgiLCJQT0xMSU5HX0lOVEVSVkFMX1JFQUxUSU1FIiwiUE9MTElOR19JTlRFUlZBTCIsImNyZWF0ZUNvbW1lbnRzUm9vbSIsImVycm9yRXZlbnRTb3VyY2UiLCJzdG9yZSIsImNyZWF0ZUNsaWVudENhY2hlU3RvcmUiLCJGZXRjaGVyQ29udGV4dCIsIlJvb21NYW5hZ2VyQ29udGV4dCIsImdldFRocmVhZHMiLCJ0aHJlYWRzIiwiQ29tbWVudHNSb29tUHJvdmlkZXIiLCJyb29tIiwiY3JlYXRlUm9vbVJldmFsaWRhdGlvbk1hbmFnZXIiLCJpZCIsInNldFRocmVhZHMiLCJnZXRSZXZhbGlkYXRpb25NYW5hZ2VycyIsImZpbHRlciIsImtleSIsImdldFJlZmVyZW5jZUNvdW50IiwibWFwIiwiXyIsIm1hbmFnZXIyIiwiZ2V0T3B0aW9ucyIsInJlc3BvbnNlcyIsIlByb21pc2UiLCJhbGwiLCJvcHRpb24iLCJBcnJheSIsImZyb20iLCJNYXAiLCJmbGF0IiwidGhyZWFkIiwidmFsdWVzIiwic3RhdHVzIiwidXNlU3luY0V4dGVybmFsU3RvcmUzIiwiZXZlbnRzIiwiZ2V0U3RhdHVzIiwiaXNEb2N1bWVudFZpc2libGUiLCJyZWZyZXNoSW50ZXJ2YWwiLCJnZXRQb2xsaW5nSW50ZXJ2YWwiLCJyZXZhbGlkYXRpb25UaW1lcklkIiwic2NoZWR1bGVSZXZhbGlkYXRpb24iLCJnZXRFcnJvciIsImdldFRvdGFsUmVmZXJlbmNlQ291bnQiLCJ0aGVuIiwiY2xlYXJUaW1lb3V0IiwiaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSIsInVuc3Vic2NyaWJlIiwiY29tbWVudHMiLCJQcm92aWRlciIsInZhbHVlIiwidXNlUm9vbU1hbmFnZXIiLCJnZXRVc2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlciIsInJvb21NYW5hZ2VyIiwicmV2YWxpZGF0aW9uTWFuYWdlciIsImdldFJldmFsaWRhdGlvbk1hbmFnZXIiLCJ1c2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlciIsImNyZWF0ZVVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyIiwic2V0UmV2YWxpZGF0aW9ubWFuYWdlciIsInVzZVRocmVhZHNGZXRjaGVyIiwidXNlVGhyZWFkcyIsInF1ZXJ5IiwibWV0YWRhdGEiLCJpbmNyZW1lbnRSZWZlcmVuY2VDb3VudCIsImRlY3JlbWVudFJlZmVyZW5jZUNvdW50IiwiY2FjaGUiLCJfdXNlVGhyZWFkcyIsInVzZVRocmVhZHNTdXNwZW5zZSIsImlzTG9hZGluZyIsInN0YXRlIiwiZ2V0SXNMb2FkaW5nIiwib3B0aW9uczIiLCJmaWx0ZXJlZCIsInJvb21JZCIsInVzZUVkaXRUaHJlYWRNZXRhZGF0YSIsInJldmFsaWRhdGUiLCJlZGl0VGhyZWFkTWV0YWRhdGEiLCJ0aHJlYWRJZCIsImNhdGNoIiwiaGFuZGxlQ29tbWVudHNBcGlFcnJvciIsIm5vdGlmeSIsInVzZUNyZWF0ZVRocmVhZCIsImNyZWF0ZVRocmVhZCIsImJvZHkiLCJjcmVhdGVUaHJlYWRJZCIsImNvbW1lbnRJZCIsImNyZWF0ZUNvbW1lbnRJZCIsIm5vdyIsIkRhdGUiLCJuZXdDb21tZW50IiwiY3JlYXRlZEF0IiwidHlwZSIsInVzZXJJZCIsImdldEN1cnJlbnRVc2VySWQiLCJyZWFjdGlvbnMiLCJuZXdUaHJlYWQiLCJ1c2VDcmVhdGVDb21tZW50IiwiY3JlYXRlQ29tbWVudCIsImNvbW1lbnQiLCJ1c2VFZGl0Q29tbWVudCIsImVkaXRDb21tZW50IiwiZWRpdGVkQXQiLCJ1c2VEZWxldGVDb21tZW50IiwiZGVsZXRlQ29tbWVudCIsIm5ld1RocmVhZHMiLCJkZWxldGVkQXQiLCJzb21lIiwicHVzaCIsInVzZUFkZFJlYWN0aW9uIiwiZW1vamkiLCJyZWFjdGlvbiIsInVzZXJzIiwiYWRkUmVhY3Rpb24iLCJ1c2VSZW1vdmVSZWFjdGlvbiIsInJlYWN0aW9uSW5kZXgiLCJmaW5kSW5kZXgiLCJ1c2VyIiwibGVuZ3RoIiwic3BsaWNlIiwicmVtb3ZlUmVhY3Rpb24iLCJjcmVhdGVPcHRpbWlzdGljSWQiLCJwcmVmaXgiLCJzZWxmIiwiZ2V0U2VsZiIsIm1lc3NhZ2UiLCJkZXRhaWxzIiwiZGV0YWlsZWRNZXNzYWdlIiwic3VnZ2VzdGlvbiIsImRvY3MiLCJCb29sZWFuIiwiam9pbiIsImNvbnNvbGUiLCJyZXF1ZXN0IiwibXV0YXRpb24iLCJyZXZhbGlkYXRpb25NYW5hZ2VyQnlPcHRpb25zIiwicmVmZXJlbmNlQ291bnRCeU9wdGlvbnMiLCJrZXlzIiwiZ2V0IiwiZGVsZXRlIiwic29ydGVkIiwic29ydCIsImEiLCJiIiwiZ2V0VGltZSIsImNvbmNhdCIsImluZm8iLCJlbnRyaWVzIiwic2V0IiwicmVkdWNlIiwiYWNjIiwiY291bnQiLCJ0aHJlYWRzRXZlbnRTb3VyY2UiLCJjYWxsYmFjayIsInNldElzTG9hZGluZyIsImlzQnJvd3Nlck9ubGluZSIsImlzUm9vbUNvbm5lY3RlZCIsInVzZUVmZmVjdDQiLCJ1c2VSZWYzIiwidXNlU3RhdGUyIiwiREVGQVVMVF9ERUxBWSIsInVzZURlYm91bmNlIiwiZGVsYXkiLCJkZWJvdW5jZWRWYWx1ZSIsInNldERlYm91bmNlZFZhbHVlIiwidXNlQ2FsbGJhY2s0IiwidXNlRWZmZWN0NSIsInVzZU1lbW8yIiwidXNlUmVmNCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlNCIsInVzZVN0YXRlMyIsInVzZUluaXRpYWwiLCJJTklUSUFMX0FTWU5DX1NUQVRFIiwibm9vcCIsInVzZUFzeW5jQ2FjaGUiLCJmcm96ZW5PcHRpb25zIiwiY2FjaGVJdGVtIiwiY2FjaGVJdGVtMiIsImNyZWF0ZSIsImdldFN0YXRlIiwicHJldmlvdXNEYXRhIiwic3VzcGVuc2UiLCJyZXNvbHZlIiwic3Vic2NyaWJlT25jZSIsInN0YXRlMiIsImtlZXBQcmV2aW91c0RhdGFXaGlsZUxvYWRpbmciLCJ1c2VFZmZlY3Q2IiwidXNlUmVmNSIsInVzZUxhdGVzdCIsInJlZiIsInVzZVJlZHVjZXIiLCJ1c2VSZXJlbmRlciIsInVwZGF0ZSIsIngiLCJub29wMiIsImlkZW50aXR5IiwibWlzc2luZ191bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsInJlYWN0VmVyc2lvbiIsIkpTT04iLCJzdXBlcmZsdW91c191bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsInMiLCJncyIsImdzcyIsIlNUQUJMRV9FTVBUWV9MSVNUIiwiT2JqZWN0IiwiZnJlZXplIiwiYWx3YXlzRW1wdHlMaXN0IiwiYWx3YXlzTnVsbCIsIm1ha2VNdXRhdGlvbkNvbnRleHQiLCJlcnJtc2ciLCJzdG9yYWdlIiwibXV0YWJsZVJvb3QiLCJnZXRTdG9yYWdlU25hcHNob3QiLCJvdGhlcnMiLCJnZXRPdGhlcnMiLCJzZXRNeVByZXNlbmNlIiwidXBkYXRlUHJlc2VuY2UiLCJoYXNXYXJuZWRJZk5vUmVzb2x2ZVVzZXJzIiwid2FybklmTm9SZXNvbHZlVXNlcnMiLCJ1c2Vyc0NhY2hlIiwicHJvY2VzcyIsIndhcm4iLCJDb250ZXh0QnVuZGxlIiwidXNlUm9vbUNvbnRleHRCdW5kbGUiLCJidW5kbGUiLCJjcmVhdGVSb29tQ29udGV4dCIsImNsaWVudCIsIlJvb21Db250ZXh0IiwiY29tbWVudHNFcnJvckV2ZW50U291cmNlIiwiY29tbWVudHNSb29tIiwiUm9vbVByb3ZpZGVyT3V0ZXIiLCJzdGFibGVFbnRlclJvb20iLCJjYWNoZWQiLCJydiIsImVudGVyUm9vbSIsIm9yaWdMZWF2ZSIsImxlYXZlIiwiUm9vbVByb3ZpZGVySW5uZXIiLCJtYWpvclJlYWN0VmVyc2lvbiIsInBhcnNlSW50IiwidmVyc2lvbiIsIm9sZFJlYWN0VmVyc2lvbiIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwiZnJvemVuUHJvcHMiLCJpbml0aWFsUHJlc2VuY2UiLCJpbml0aWFsU3RvcmFnZSIsImF1dG9Db25uZWN0Iiwic2hvdWxkSW5pdGlhbGx5Q29ubmVjdCIsInNldFJvb21MZWF2ZVBhaXIiLCJwYWlyIiwicm9vbTIiLCJjb25uZWN0IiwiaW50ZXJuYWxCdW5kbGUiLCJjb25uZWN0aW9uSWRTZWxlY3RvciIsImNvbm5lY3Rpb25JZCIsInVzZVJvb20iLCJ1c2VTdGF0dXMiLCJnZXRTZXJ2ZXJTbmFwc2hvdCIsInVzZU15UHJlc2VuY2UiLCJteVByZXNlbmNlIiwiZ2V0UHJlc2VuY2UiLCJwcmVzZW5jZSIsInNldFByZXNlbmNlIiwidXNlVXBkYXRlTXlQcmVzZW5jZSIsInVzZU90aGVycyIsInNlbGVjdG9yIiwiaXNFcXVhbCIsInVzZU90aGVyc0Nvbm5lY3Rpb25JZHMiLCJ1c2VPdGhlcnNNYXBwZWQiLCJpdGVtU2VsZWN0b3IiLCJpdGVtSXNFcXVhbCIsIndyYXBwZWRTZWxlY3RvciIsIm90aGVyIiwid3JhcHBlZElzRXF1YWwiLCJlcSIsImlzIiwiZXZlcnkiLCJhdHVwbGUiLCJpbmRleCIsImJ0dXBsZSIsIk5PVF9GT1VORCIsIlN5bWJvbCIsInVzZU90aGVyIiwib3RoZXIyIiwiZmluZCIsIm90aGVyMyIsInByZXYiLCJjdXJyIiwidXNlQnJvYWRjYXN0RXZlbnQiLCJldmVudCIsInNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5IiwiYnJvYWRjYXN0RXZlbnQiLCJ1c2VPdGhlcnNMaXN0ZW5lciIsInNhdmVkQ2FsbGJhY2siLCJ1c2VMb3N0Q29ubmVjdGlvbkxpc3RlbmVyIiwibG9zdENvbm5lY3Rpb24iLCJ1c2VFcnJvckxpc3RlbmVyIiwiZSIsInVzZUV2ZW50TGlzdGVuZXIiLCJsaXN0ZW5lciIsImV2ZW50RGF0YSIsImN1c3RvbUV2ZW50IiwidXNlU2VsZiIsIm1heWJlU2VsZWN0b3IiLCJtZSIsInVzZU11dGFibGVTdG9yYWdlUm9vdCIsInN0b3JhZ2VEaWRMb2FkIiwidXNlU3RvcmFnZVJvb3QiLCJ1c2VIaXN0b3J5IiwiaGlzdG9yeSIsInVzZVVuZG8iLCJ1bmRvIiwidXNlUmVkbyIsInJlZG8iLCJ1c2VDYW5VbmRvIiwiY2FuVW5kbyIsInVzZUNhblJlZG8iLCJjYW5SZWRvIiwidXNlQmF0Y2giLCJiYXRjaCIsInVzZUxlZ2FjeUtleSIsInJvb3RPck51bGwiLCJyZXJlbmRlciIsInJvb3QiLCJ1bnN1YkN1cnIiLCJzdWJzY3JpYmVUb0N1cnIiLCJvblJvb3RDaGFuZ2UiLCJuZXdWYWx1ZSIsInVuc3Vic2NyaWJlUm9vdCIsInVzZVN0b3JhZ2UiLCJyb290T3JOdWxsMiIsImlzRGVlcCIsImltbSIsInRvSW1tdXRhYmxlIiwiZW5zdXJlTm90U2VydmVyU2lkZSIsInVzZVN1c3BlbmRVbnRpbFN0b3JhZ2VMb2FkZWQiLCJyZXMiLCJ1c2VTdXNwZW5kVW50aWxQcmVzZW5jZUxvYWRlZCIsInVzZU11dGF0aW9uIiwiZGVwcyIsImFyZ3MiLCJ1c2VTdG9yYWdlU3VzcGVuc2UiLCJ1c2VTZWxmU3VzcGVuc2UiLCJ1c2VPdGhlcnNTdXNwZW5zZSIsInVzZU90aGVyc0Nvbm5lY3Rpb25JZHNTdXNwZW5zZSIsInVzZU90aGVyc01hcHBlZFN1c3BlbnNlIiwidXNlT3RoZXJTdXNwZW5zZSIsInVzZUxlZ2FjeUtleVN1c3BlbnNlIiwicmVzb2x2ZVVzZXJzIiwicmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyIsInN0cmluZ2lmaWVkT3B0aW9ucyIsInBhcnNlIiwidXNlVXNlciIsInJlc29sdmVyS2V5IiwidXNlcklkcyIsInVzZVVzZXJTdXNwZW5zZSIsIm1lbnRpb25TdWdnZXN0aW9uc0NhY2hlIiwidXNlTWVudGlvblN1Z2dlc3Rpb25zIiwic2VhcmNoIiwiZGVib3VuY2VkU2VhcmNoIiwidGV4dCIsIlJvb21Qcm92aWRlciIsInVzZUxpc3QiLCJ1c2VNYXAiLCJ1c2VPYmplY3QiLCJoYXNSZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zIiwic2hhbGxvdzIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react/dist/index.mjs\n");

/***/ })

};
;