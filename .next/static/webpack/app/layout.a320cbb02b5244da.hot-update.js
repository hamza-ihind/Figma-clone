/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2Fhome%2Fe11even%2FDesktop%2FFigma-clone%2Fapp%2Fglobals.css&modules=%2Fhome%2Fe11even%2FDesktop%2FFigma-clone%2Fapp%2FRoom.tsx&modules=%2Fhome%2Fe11even%2FDesktop%2FFigma-clone%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%22path%22%3A%22app%2Flayout.tsx%22%2C%22import%22%3A%22Work_Sans%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-work-sans%22%2C%22weight%22%3A%5B%22400%22%2C%22600%22%2C%22700%22%5D%7D%5D%2C%22variableName%22%3A%22workSans%22%7D&server=false!":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2Fhome%2Fe11even%2FDesktop%2FFigma-clone%2Fapp%2Fglobals.css&modules=%2Fhome%2Fe11even%2FDesktop%2FFigma-clone%2Fapp%2FRoom.tsx&modules=%2Fhome%2Fe11even%2FDesktop%2FFigma-clone%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%22path%22%3A%22app%2Flayout.tsx%22%2C%22import%22%3A%22Work_Sans%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-work-sans%22%2C%22weight%22%3A%5B%22400%22%2C%22600%22%2C%22700%22%5D%7D%5D%2C%22variableName%22%3A%22workSans%22%7D&server=false! ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/globals.css */ \"(app-pages-browser)/./app/globals.css\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/Room.tsx */ \"(app-pages-browser)/./app/Room.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"app/layout.tsx\",\"import\":\"Work_Sans\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-work-sans\",\"weight\":[\"400\",\"600\",\"700\"]}],\"variableName\":\"workSans\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app/layout.tsx\\\",\\\"import\\\":\\\"Work_Sans\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"],\\\"variable\\\":\\\"--font-work-sans\\\",\\\"weight\\\":[\\\"400\\\",\\\"600\\\",\\\"700\\\"]}],\\\"variableName\\\":\\\"workSans\\\"}\", 23))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZob21lJTJGZTExZXZlbiUyRkRlc2t0b3AlMkZGaWdtYS1jbG9uZSUyRmFwcCUyRmdsb2JhbHMuY3NzJm1vZHVsZXM9JTJGaG9tZSUyRmUxMWV2ZW4lMkZEZXNrdG9wJTJGRmlnbWEtY2xvbmUlMkZhcHAlMkZSb29tLnRzeCZtb2R1bGVzPSUyRmhvbWUlMkZlMTFldmVuJTJGRGVza3RvcCUyRkZpZ21hLWNsb25lJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmZvbnQlMkZnb29nbGUlMkZ0YXJnZXQuY3NzJTNGJTdCJTIycGF0aCUyMiUzQSUyMmFwcCUyRmxheW91dC50c3glMjIlMkMlMjJpbXBvcnQlMjIlM0ElMjJXb3JrX1NhbnMlMjIlMkMlMjJhcmd1bWVudHMlMjIlM0ElNUIlN0IlMjJzdWJzZXRzJTIyJTNBJTVCJTIybGF0aW4lMjIlNUQlMkMlMjJ2YXJpYWJsZSUyMiUzQSUyMi0tZm9udC13b3JrLXNhbnMlMjIlMkMlMjJ3ZWlnaHQlMjIlM0ElNUIlMjI0MDAlMjIlMkMlMjI2MDAlMjIlMkMlMjI3MDAlMjIlNUQlN0QlNUQlMkMlMjJ2YXJpYWJsZU5hbWUlMjIlM0ElMjJ3b3JrU2FucyUyMiU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLDRKQUFzRjtBQUN0RixzSkFBbUY7QUFDbkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz8xZGNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL2hvbWUvZTExZXZlbi9EZXNrdG9wL0ZpZ21hLWNsb25lL2FwcC9nbG9iYWxzLmNzc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL2hvbWUvZTExZXZlbi9EZXNrdG9wL0ZpZ21hLWNsb25lL2FwcC9Sb29tLnRzeFwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL2hvbWUvZTExZXZlbi9EZXNrdG9wL0ZpZ21hLWNsb25lL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1xcXCJwYXRoXFxcIjpcXFwiYXBwL2xheW91dC50c3hcXFwiLFxcXCJpbXBvcnRcXFwiOlxcXCJXb3JrX1NhbnNcXFwiLFxcXCJhcmd1bWVudHNcXFwiOlt7XFxcInN1YnNldHNcXFwiOltcXFwibGF0aW5cXFwiXSxcXFwidmFyaWFibGVcXFwiOlxcXCItLWZvbnQtd29yay1zYW5zXFxcIixcXFwid2VpZ2h0XFxcIjpbXFxcIjQwMFxcXCIsXFxcIjYwMFxcXCIsXFxcIjcwMFxcXCJdfV0sXFxcInZhcmlhYmxlTmFtZVxcXCI6XFxcIndvcmtTYW5zXFxcIn1cIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2Fhome%2Fe11even%2FDesktop%2FFigma-clone%2Fapp%2Fglobals.css&modules=%2Fhome%2Fe11even%2FDesktop%2FFigma-clone%2Fapp%2FRoom.tsx&modules=%2Fhome%2Fe11even%2FDesktop%2FFigma-clone%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%22path%22%3A%22app%2Flayout.tsx%22%2C%22import%22%3A%22Work_Sans%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-work-sans%22%2C%22weight%22%3A%5B%22400%22%2C%22600%22%2C%22700%22%5D%7D%5D%2C%22variableName%22%3A%22workSans%22%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        var _s = $RefreshSig$();\n        \"use strict\";\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        // dispatch for CommonJS interop named imports.\n        var useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue;\n        var didWarnOld18Alpha = false;\n        var didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n        // because of a very particular set of implementation details and assumptions\n        // -- change any one of them and it will break. The most important assumption\n        // is that updates are always synchronous, because concurrent rendering is\n        // only available in versions of React that also have a built-in\n        // useSyncExternalStore API. And we only use this shim when the built-in API\n        // does not exist.\n        //\n        // Do not assume that the clever hacks used by this hook also work in general.\n        // The point of this shim is to replace the need for hacks by other libraries.\n        function useSyncExternalStore(subscribe, getSnapshot, // React do not expose a way to check if we're hydrating. So users of the shim\n        // will need to track that themselves and return the correct value\n        // from `getSnapshot`.\n        getServerSnapshot) {\n            _s();\n            {\n                if (!didWarnOld18Alpha) {\n                    if (React.startTransition !== undefined) {\n                        didWarnOld18Alpha = true;\n                        error(\"You are using an outdated, pre-release alpha of React 18 that \" + \"does not support useSyncExternalStore. The \" + \"use-sync-external-store shim will not work correctly. Upgrade \" + \"to a newer pre-release.\");\n                    }\n                }\n            }\n            // breaks the rules of React, and only works here because of specific\n            // implementation details, most importantly that updates are\n            // always synchronous.\n            var value = getSnapshot();\n            {\n                if (!didWarnUncachedGetSnapshot) {\n                    var cachedValue = getSnapshot();\n                    if (!objectIs(value, cachedValue)) {\n                        error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                        didWarnUncachedGetSnapshot = true;\n                    }\n                }\n            }\n            // re-render whenever the subscribed state changes by updating an some\n            // arbitrary useState hook. Then, during render, we call getSnapshot to read\n            // the current value.\n            //\n            // Because we don't actually use the state returned by the useState hook, we\n            // can save a bit of memory by storing other stuff in that slot.\n            //\n            // To implement the early bailout, we need to track some things on a mutable\n            // object. Usually, we would put that in a useRef hook, but we can stash it in\n            // our useState hook instead.\n            //\n            // To force a re-render, we call forceUpdate({inst}). That works because the\n            // new object always fails an equality check.\n            var _useState = useState({\n                inst: {\n                    value: value,\n                    getSnapshot: getSnapshot\n                }\n            }), inst = _useState[0].inst, forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n            // in the layout phase so we can access it during the tearing check that\n            // happens on subscribe.\n            useLayoutEffect(function() {\n                inst.value = value;\n                inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n                // commit phase if there was an interleaved mutation. In concurrent mode\n                // this can happen all the time, but even in synchronous mode, an earlier\n                // effect may have mutated the store.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceUpdate({\n                        inst: inst\n                    });\n                }\n            }, [\n                subscribe,\n                value,\n                getSnapshot\n            ]);\n            useEffect(function() {\n                // Check for changes right before subscribing. Subsequent changes will be\n                // detected in the subscription handler.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceUpdate({\n                        inst: inst\n                    });\n                }\n                var handleStoreChange = function() {\n                    // TODO: Because there is no cross-renderer API for batching updates, it's\n                    // up to the consumer of this library to wrap their subscription event\n                    // with unstable_batchedUpdates. Should we try to detect when this isn't\n                    // the case and print a warning in development?\n                    // The store changed. Check if the snapshot changed since the last time we\n                    // read from the store.\n                    if (checkIfSnapshotChanged(inst)) {\n                        // Force a re-render.\n                        forceUpdate({\n                            inst: inst\n                        });\n                    }\n                }; // Subscribe to the store and return a clean-up function.\n                return subscribe(handleStoreChange);\n            }, [\n                subscribe\n            ]);\n            useDebugValue(value);\n            return value;\n        }\n        _s(useSyncExternalStore, \"HNxGYQ39TeXJ0jUaPc6qLOsv73k=\");\n        function checkIfSnapshotChanged(inst) {\n            var latestGetSnapshot = inst.getSnapshot;\n            var prevValue = inst.value;\n            try {\n                var nextValue = latestGetSnapshot();\n                return !objectIs(prevValue, nextValue);\n            } catch (error) {\n                return true;\n            }\n        }\n        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n            // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n            // React do not expose a way to check if we're hydrating. So users of the shim\n            // will need to track that themselves and return the correct value\n            // from `getSnapshot`.\n            return getSnapshot();\n        }\n        var canUseDOM = !!( true && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\n        var isServerEnvironment = !canUseDOM;\n        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\n        var useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\n        exports.useSyncExternalStore = useSyncExternalStore$2;\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4Qzs7UUFFTztRQUVWLHlDQUF5QyxHQUN6QyxJQUNFLE9BQU9DLG1DQUFtQyxlQUMxQyxPQUFPQSwrQkFBK0JDLDJCQUEyQixLQUMvRCxZQUNGO1lBQ0FELCtCQUErQkMsMkJBQTJCLENBQUMsSUFBSUM7UUFDakU7UUFDVSxJQUFJQyxRQUFRQyxtQkFBT0EsQ0FBQztRQUU5QixJQUFJQyx1QkFBdUJGLE1BQU1HLGtEQUFrRDtRQUVuRixTQUFTQyxNQUFNQyxNQUFNO1lBQ25CO2dCQUNFO29CQUNFLElBQUssSUFBSUMsUUFBUUMsVUFBVUMsTUFBTSxFQUFFQyxPQUFPLElBQUlDLE1BQU1KLFFBQVEsSUFBSUEsUUFBUSxJQUFJLElBQUlLLFFBQVEsR0FBR0EsUUFBUUwsT0FBT0ssUUFBUzt3QkFDakhGLElBQUksQ0FBQ0UsUUFBUSxFQUFFLEdBQUdKLFNBQVMsQ0FBQ0ksTUFBTTtvQkFDcEM7b0JBRUFDLGFBQWEsU0FBU1AsUUFBUUk7Z0JBQ2hDO1lBQ0Y7UUFDRjtRQUVBLFNBQVNHLGFBQWFDLEtBQUssRUFBRVIsTUFBTSxFQUFFSSxJQUFJO1lBQ3ZDLG1EQUFtRDtZQUNuRCw2Q0FBNkM7WUFDN0M7Z0JBQ0UsSUFBSUsseUJBQXlCWixxQkFBcUJZLHNCQUFzQjtnQkFDeEUsSUFBSUMsUUFBUUQsdUJBQXVCRSxnQkFBZ0I7Z0JBRW5ELElBQUlELFVBQVUsSUFBSTtvQkFDaEJWLFVBQVU7b0JBQ1ZJLE9BQU9BLEtBQUtRLE1BQU0sQ0FBQzt3QkFBQ0Y7cUJBQU07Z0JBQzVCLEVBQUUsK0RBQStEO2dCQUdqRSxJQUFJRyxpQkFBaUJULEtBQUtVLEdBQUcsQ0FBQyxTQUFV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LEtBQzlELFlBQ0Y7WUFDQW5FLCtCQUErQm1FLDBCQUEwQixDQUFDLElBQUlqRTtRQUNoRTtJQUVFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzPzNlOWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbi8vIGRpc3BhdGNoIGZvciBDb21tb25KUyBpbnRlcm9wIG5hbWVkIGltcG9ydHMuXG5cbnZhciB1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlLFxuICAgIHVzZUVmZmVjdCA9IFJlYWN0LnVzZUVmZmVjdCxcbiAgICB1c2VMYXlvdXRFZmZlY3QgPSBSZWFjdC51c2VMYXlvdXRFZmZlY3QsXG4gICAgdXNlRGVidWdWYWx1ZSA9IFJlYWN0LnVzZURlYnVnVmFsdWU7XG52YXIgZGlkV2Fybk9sZDE4QWxwaGEgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IGZhbHNlOyAvLyBEaXNjbGFpbWVyOiBUaGlzIHNoaW0gYnJlYWtzIG1hbnkgb2YgdGhlIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3Jrc1xuLy8gYmVjYXVzZSBvZiBhIHZlcnkgcGFydGljdWxhciBzZXQgb2YgaW1wbGVtZW50YXRpb24gZGV0YWlscyBhbmQgYXNzdW1wdGlvbnNcbi8vIC0tIGNoYW5nZSBhbnkgb25lIG9mIHRoZW0gYW5kIGl0IHdpbGwgYnJlYWsuIFRoZSBtb3N0IGltcG9ydGFudCBhc3N1bXB0aW9uXG4vLyBpcyB0aGF0IHVwZGF0ZXMgYXJlIGFsd2F5cyBzeW5jaHJvbm91cywgYmVjYXVzZSBjb25jdXJyZW50IHJlbmRlcmluZyBpc1xuLy8gb25seSBhdmFpbGFibGUgaW4gdmVyc2lvbnMgb2YgUmVhY3QgdGhhdCBhbHNvIGhhdmUgYSBidWlsdC1pblxuLy8gdXNlU3luY0V4dGVybmFsU3RvcmUgQVBJLiBBbmQgd2Ugb25seSB1c2UgdGhpcyBzaGltIHdoZW4gdGhlIGJ1aWx0LWluIEFQSVxuLy8gZG9lcyBub3QgZXhpc3QuXG4vL1xuLy8gRG8gbm90IGFzc3VtZSB0aGF0IHRoZSBjbGV2ZXIgaGFja3MgdXNlZCBieSB0aGlzIGhvb2sgYWxzbyB3b3JrIGluIGdlbmVyYWwuXG4vLyBUaGUgcG9pbnQgb2YgdGhpcyBzaGltIGlzIHRvIHJlcGxhY2UgdGhlIG5lZWQgZm9yIGhhY2tzIGJ5IG90aGVyIGxpYnJhcmllcy5cblxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgLy8gTm90ZTogVGhlIHNoaW0gZG9lcyBub3QgdXNlIGdldFNlcnZlclNuYXBzaG90LCBiZWNhdXNlIHByZS0xOCB2ZXJzaW9ucyBvZlxuLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG4vLyB3aWxsIG5lZWQgdG8gdHJhY2sgdGhhdCB0aGVtc2VsdmVzIGFuZCByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWVcbi8vIGZyb20gYGdldFNuYXBzaG90YC5cbmdldFNlcnZlclNuYXBzaG90KSB7XG4gIHtcbiAgICBpZiAoIWRpZFdhcm5PbGQxOEFscGhhKSB7XG4gICAgICBpZiAoUmVhY3Quc3RhcnRUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlkV2Fybk9sZDE4QWxwaGEgPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdZb3UgYXJlIHVzaW5nIGFuIG91dGRhdGVkLCBwcmUtcmVsZWFzZSBhbHBoYSBvZiBSZWFjdCAxOCB0aGF0ICcgKyAnZG9lcyBub3Qgc3VwcG9ydCB1c2VTeW5jRXh0ZXJuYWxTdG9yZS4gVGhlICcgKyAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUgc2hpbSB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseS4gVXBncmFkZSAnICsgJ3RvIGEgbmV3ZXIgcHJlLXJlbGVhc2UuJyk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBBZ2FpbiwgdGhpc1xuICAvLyBicmVha3MgdGhlIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBoZXJlIGJlY2F1c2Ugb2Ygc3BlY2lmaWNcbiAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscywgbW9zdCBpbXBvcnRhbnRseSB0aGF0IHVwZGF0ZXMgYXJlXG4gIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cblxuXG4gIHZhciB2YWx1ZSA9IGdldFNuYXBzaG90KCk7XG5cbiAge1xuICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcbiAgICAgIHZhciBjYWNoZWRWYWx1ZSA9IGdldFNuYXBzaG90KCk7XG5cbiAgICAgIGlmICghb2JqZWN0SXModmFsdWUsIGNhY2hlZFZhbHVlKSkge1xuICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEJlY2F1c2UgdXBkYXRlcyBhcmUgc3luY2hyb25vdXMsIHdlIGRvbid0IHF1ZXVlIHRoZW0uIEluc3RlYWQgd2UgZm9yY2UgYVxuICAvLyByZS1yZW5kZXIgd2hlbmV2ZXIgdGhlIHN1YnNjcmliZWQgc3RhdGUgY2hhbmdlcyBieSB1cGRhdGluZyBhbiBzb21lXG4gIC8vIGFyYml0cmFyeSB1c2VTdGF0ZSBob29rLiBUaGVuLCBkdXJpbmcgcmVuZGVyLCB3ZSBjYWxsIGdldFNuYXBzaG90IHRvIHJlYWRcbiAgLy8gdGhlIGN1cnJlbnQgdmFsdWUuXG4gIC8vXG4gIC8vIEJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgdXNlIHRoZSBzdGF0ZSByZXR1cm5lZCBieSB0aGUgdXNlU3RhdGUgaG9vaywgd2VcbiAgLy8gY2FuIHNhdmUgYSBiaXQgb2YgbWVtb3J5IGJ5IHN0b3Jpbmcgb3RoZXIgc3R1ZmYgaW4gdGhhdCBzbG90LlxuICAvL1xuICAvLyBUbyBpbXBsZW1lbnQgdGhlIGVhcmx5IGJhaWxvdXQsIHdlIG5lZWQgdG8gdHJhY2sgc29tZSB0aGluZ3Mgb24gYSBtdXRhYmxlXG4gIC8vIG9iamVjdC4gVXN1YWxseSwgd2Ugd291bGQgcHV0IHRoYXQgaW4gYSB1c2VSZWYgaG9vaywgYnV0IHdlIGNhbiBzdGFzaCBpdCBpblxuICAvLyBvdXIgdXNlU3RhdGUgaG9vayBpbnN0ZWFkLlxuICAvL1xuICAvLyBUbyBmb3JjZSBhIHJlLXJlbmRlciwgd2UgY2FsbCBmb3JjZVVwZGF0ZSh7aW5zdH0pLiBUaGF0IHdvcmtzIGJlY2F1c2UgdGhlXG4gIC8vIG5ldyBvYmplY3QgYWx3YXlzIGZhaWxzIGFuIGVxdWFsaXR5IGNoZWNrLlxuXG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKHtcbiAgICBpbnN0OiB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3RcbiAgICB9XG4gIH0pLFxuICAgICAgaW5zdCA9IF91c2VTdGF0ZVswXS5pbnN0LFxuICAgICAgZm9yY2VVcGRhdGUgPSBfdXNlU3RhdGVbMV07IC8vIFRyYWNrIHRoZSBsYXRlc3QgZ2V0U25hcHNob3QgZnVuY3Rpb24gd2l0aCBhIHJlZi4gVGhpcyBuZWVkcyB0byBiZSB1cGRhdGVkXG4gIC8vIGluIHRoZSBsYXlvdXQgcGhhc2Ugc28gd2UgY2FuIGFjY2VzcyBpdCBkdXJpbmcgdGhlIHRlYXJpbmcgY2hlY2sgdGhhdFxuICAvLyBoYXBwZW5zIG9uIHN1YnNjcmliZS5cblxuXG4gIHVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaW5zdC52YWx1ZSA9IHZhbHVlO1xuICAgIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDsgLy8gV2hlbmV2ZXIgZ2V0U25hcHNob3Qgb3Igc3Vic2NyaWJlIGNoYW5nZXMsIHdlIG5lZWQgdG8gY2hlY2sgaW4gdGhlXG4gICAgLy8gY29tbWl0IHBoYXNlIGlmIHRoZXJlIHdhcyBhbiBpbnRlcmxlYXZlZCBtdXRhdGlvbi4gSW4gY29uY3VycmVudCBtb2RlXG4gICAgLy8gdGhpcyBjYW4gaGFwcGVuIGFsbCB0aGUgdGltZSwgYnV0IGV2ZW4gaW4gc3luY2hyb25vdXMgbW9kZSwgYW4gZWFybGllclxuICAgIC8vIGVmZmVjdCBtYXkgaGF2ZSBtdXRhdGVkIHRoZSBzdG9yZS5cblxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgaW5zdDogaW5zdFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbc3Vic2NyaWJlLCB2YWx1ZSwgZ2V0U25hcHNob3RdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDaGVjayBmb3IgY2hhbmdlcyByaWdodCBiZWZvcmUgc3Vic2NyaWJpbmcuIFN1YnNlcXVlbnQgY2hhbmdlcyB3aWxsIGJlXG4gICAgLy8gZGV0ZWN0ZWQgaW4gdGhlIHN1YnNjcmlwdGlvbiBoYW5kbGVyLlxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgaW5zdDogaW5zdFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZVN0b3JlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ETzogQmVjYXVzZSB0aGVyZSBpcyBubyBjcm9zcy1yZW5kZXJlciBBUEkgZm9yIGJhdGNoaW5nIHVwZGF0ZXMsIGl0J3NcbiAgICAgIC8vIHVwIHRvIHRoZSBjb25zdW1lciBvZiB0aGlzIGxpYnJhcnkgdG8gd3JhcCB0aGVpciBzdWJzY3JpcHRpb24gZXZlbnRcbiAgICAgIC8vIHdpdGggdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMuIFNob3VsZCB3ZSB0cnkgdG8gZGV0ZWN0IHdoZW4gdGhpcyBpc24ndFxuICAgICAgLy8gdGhlIGNhc2UgYW5kIHByaW50IGEgd2FybmluZyBpbiBkZXZlbG9wbWVudD9cbiAgICAgIC8vIFRoZSBzdG9yZSBjaGFuZ2VkLiBDaGVjayBpZiB0aGUgc25hcHNob3QgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlXG4gICAgICAvLyByZWFkIGZyb20gdGhlIHN0b3JlLlxuICAgICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgICBpbnN0OiBpbnN0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07IC8vIFN1YnNjcmliZSB0byB0aGUgc3RvcmUgYW5kIHJldHVybiBhIGNsZWFuLXVwIGZ1bmN0aW9uLlxuXG5cbiAgICByZXR1cm4gc3Vic2NyaWJlKGhhbmRsZVN0b3JlQ2hhbmdlKTtcbiAgfSwgW3N1YnNjcmliZV0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gaW5zdC5nZXRTbmFwc2hvdDtcbiAgdmFyIHByZXZWYWx1ZSA9IGluc3QudmFsdWU7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcbiAgICByZXR1cm4gIW9iamVjdElzKHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIC8vIE5vdGU6IFRoZSBzaGltIGRvZXMgbm90IHVzZSBnZXRTZXJ2ZXJTbmFwc2hvdCwgYmVjYXVzZSBwcmUtMTggdmVyc2lvbnMgb2ZcbiAgLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG4gIC8vIHdpbGwgbmVlZCB0byB0cmFjayB0aGF0IHRoZW1zZWx2ZXMgYW5kIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZVxuICAvLyBmcm9tIGBnZXRTbmFwc2hvdGAuXG4gIHJldHVybiBnZXRTbmFwc2hvdCgpO1xufVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG5cbnZhciBpc1NlcnZlckVudmlyb25tZW50ID0gIWNhblVzZURPTTtcblxudmFyIHNoaW0gPSBpc1NlcnZlckVudmlyb25tZW50ID8gdXNlU3luY0V4dGVybmFsU3RvcmUkMSA6IHVzZVN5bmNFeHRlcm5hbFN0b3JlO1xudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDIgPSBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZSAhPT0gdW5kZWZpbmVkID8gUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUgOiBzaGltO1xuXG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gdXNlU3luY0V4dGVybmFsU3RvcmUkMjtcbiAgICAgICAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgIFxuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJyZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQiLCJFcnJvciIsIlJlYWN0IiwicmVxdWlyZSIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJlcnJvciIsImZvcm1hdCIsIl9sZW4yIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleTIiLCJwcmludFdhcm5pbmciLCJsZXZlbCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJzdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJTdHJpbmciLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwiaXMiLCJ4IiwieSIsIm9iamVjdElzIiwiT2JqZWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VEZWJ1Z1ZhbHVlIiwiZGlkV2Fybk9sZDE4QWxwaGEiLCJkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwic3Vic2NyaWJlIiwiZ2V0U25hcHNob3QiLCJnZXRTZXJ2ZXJTbmFwc2hvdCIsInN0YXJ0VHJhbnNpdGlvbiIsInVuZGVmaW5lZCIsInZhbHVlIiwiY2FjaGVkVmFsdWUiLCJfdXNlU3RhdGUiLCJpbnN0IiwiZm9yY2VVcGRhdGUiLCJjaGVja0lmU25hcHNob3RDaGFuZ2VkIiwiaGFuZGxlU3RvcmVDaGFuZ2UiLCJsYXRlc3RHZXRTbmFwc2hvdCIsInByZXZWYWx1ZSIsIm5leHRWYWx1ZSIsInVzZVN5bmNFeHRlcm5hbFN0b3JlJDEiLCJjYW5Vc2VET00iLCJ3aW5kb3ciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpc1NlcnZlckVudmlyb25tZW50Iiwic2hpbSIsInVzZVN5bmNFeHRlcm5hbFN0b3JlJDIiLCJleHBvcnRzIiwicmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        var _s = $RefreshSig$();\n        \"use strict\";\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        var shim = __webpack_require__(/*! use-sync-external-store/shim */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\");\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        var useSyncExternalStore = shim.useSyncExternalStore;\n        // for CommonJS interop.\n        var useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\n        function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n            _s();\n            // Use this to track the rendered snapshot.\n            var instRef = useRef(null);\n            var inst;\n            if (instRef.current === null) {\n                inst = {\n                    hasValue: false,\n                    value: null\n                };\n                instRef.current = inst;\n            } else {\n                inst = instRef.current;\n            }\n            var _useMemo = useMemo(function() {\n                // Track the memoized state using closure variables that are local to this\n                // memoized instance of a getSnapshot function. Intentionally not using a\n                // useRef hook, because that state would be shared across all concurrent\n                // copies of the hook/component.\n                var hasMemo = false;\n                var memoizedSnapshot;\n                var memoizedSelection;\n                var memoizedSelector = function(nextSnapshot) {\n                    if (!hasMemo) {\n                        // The first time the hook is called, there is no memoized result.\n                        hasMemo = true;\n                        memoizedSnapshot = nextSnapshot;\n                        var _nextSelection = selector(nextSnapshot);\n                        if (isEqual !== undefined) {\n                            // Even if the selector has changed, the currently rendered selection\n                            // may be equal to the new selection. We should attempt to reuse the\n                            // current value if possible, to preserve downstream memoizations.\n                            if (inst.hasValue) {\n                                var currentSelection = inst.value;\n                                if (isEqual(currentSelection, _nextSelection)) {\n                                    memoizedSelection = currentSelection;\n                                    return currentSelection;\n                                }\n                            }\n                        }\n                        memoizedSelection = _nextSelection;\n                        return _nextSelection;\n                    } // We may be able to reuse the previous invocation's result.\n                    // We may be able to reuse the previous invocation's result.\n                    var prevSnapshot = memoizedSnapshot;\n                    var prevSelection = memoizedSelection;\n                    if (objectIs(prevSnapshot, nextSnapshot)) {\n                        // The snapshot is the same as last time. Reuse the previous selection.\n                        return prevSelection;\n                    } // The snapshot has changed, so we need to compute a new selection.\n                    // The snapshot has changed, so we need to compute a new selection.\n                    var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\n                    // has changed. If it hasn't, return the previous selection. That signals\n                    // to React that the selections are conceptually equal, and we can bail\n                    // out of rendering.\n                    // If a custom isEqual function is provided, use that to check if the data\n                    // has changed. If it hasn't, return the previous selection. That signals\n                    // to React that the selections are conceptually equal, and we can bail\n                    // out of rendering.\n                    if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n                        return prevSelection;\n                    }\n                    memoizedSnapshot = nextSnapshot;\n                    memoizedSelection = nextSelection;\n                    return nextSelection;\n                }; // Assigning this to a constant so that Flow knows it can't change.\n                // Assigning this to a constant so that Flow knows it can't change.\n                var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\n                var getSnapshotWithSelector = function() {\n                    return memoizedSelector(getSnapshot());\n                };\n                var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function() {\n                    return memoizedSelector(maybeGetServerSnapshot());\n                };\n                return [\n                    getSnapshotWithSelector,\n                    getServerSnapshotWithSelector\n                ];\n            }, [\n                getSnapshot,\n                getServerSnapshot,\n                selector,\n                isEqual\n            ]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];\n            var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n            useEffect(function() {\n                inst.hasValue = true;\n                inst.value = value;\n            }, [\n                value\n            ]);\n            useDebugValue(value);\n            return value;\n        }\n        _s(useSyncExternalStoreWithSelector, \"mZhzs7ShZXU5RBraOlzBOQ4BK68=\", false, function() {\n            return [\n                useSyncExternalStore\n            ];\n        });\n        exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDLEdBRUQ7QUFFQSxJQUFJQSxJQUFxQyxFQUFFO0lBQ3hDOztRQUVPO1FBRVYseUNBQXlDLEdBQ3pDLElBQ0UsT0FBT0MsbUNBQW1DLGVBQzFDLE9BQU9BLCtCQUErQkMsMkJBQTJCLEtBQy9ELFlBQ0Y7WUFDQUQsK0JBQStCQywyQkFBMkIsQ0FBQyxJQUFJQztRQUNqRTtRQUNVLElBQUlDLFFBQVFDLG1CQUFPQSxDQUFDO1FBQzlCLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDO1FBRW5COzs7Q0FHQyxHQUNELFNBQVNFLEdBQUdDLENBQUMsRUFBRUMsQ0FBQztZQUNkLE9BQU9ELE1BQU1DLEtBQU1ELENBQUFBLE1BQU0sS0FBSyxJQUFJQSxNQUFNLElBQUlDLENBQUFBLEtBQU1ELE1BQU1BLEtBQUtDLE1BQU1BLEVBQUUsc0NBQXNDOztRQUU3RztRQUVBLElBQUlDLFdBQVcsT0FBT0MsT0FBT0osRUFBRSxLQUFLLGFBQWFJLE9BQU9KLEVBQUUsR0FBR0E7UUFFN0QsSUFBSUssdUJBQXVCTixLQUFLTSxvQkFBb0I7UUFFcEQsd0JBQXdCO1FBRXhCLElBQUlDLFNBQVNULE1BQU1TLE1BQU0sRUFDckJDLFlBQVlWLE1BQU1VLFNBQVMsRUFDM0JDLFVBQVVYLE1BQU1XLE9BQU8sRUFDdkJDLGdCQUFnQlosTUFBTVksYUFBYSxFQUFFLDZFQUE2RTtRQUV0SCxTQUFTQyxpQ0FBaUNDLFNBQVMsRUFBRUMsV0FBVyxFQUFFQyxpQkFBaUIsRUFBRUMsUUFBUSxFQUFFQyxPQUFPOztZQUNwRywyQ0FBMkM7WUFDM0MsSUFBSUMsVUFBVVYsT0FBTztZQUNyQixJQUFJVztZQUVKLElBQUlELFFBQVFFLE9BQU8sS0FBSyxNQUFNO2dCQUM1QkQsT0FBTztvQkFDTEUsVUFBVTtvQkFDVkMsT0FBTztnQkFDVDtnQkFDQUosUUFBUUUsT0FBTyxHQUFHRDtZQUNwQixPQUFPO2dCQUNMQSxPQUFPRCxRQUFRRSxPQUFPO1lBQ3hCO1lBRUEsSUFBSUcsV0FBV2IsUUFBUTtnQkFDckIsMEVBQTBFO2dCQUMxRSx5RUFBeUU7Z0JBQ3pFLHdFQUF3RTtnQkFDeEUsZ0NBQWdDO2dCQUNoQyxJQUFJYyxVQUFVO2dCQUNkLElBQUlDO2dCQUNKLElBQUlDO2dCQUVKLElBQUlDLG1CQUFtQixTQUFVQyxZQUFZO29CQUMzQyxJQUFJLENBQUNKLFNBQVM7d0JBQ1osa0VBQWtFO3dCQUNsRUEsVUFBVTt3QkFDVkMsbUJBQW1CRzt3QkFFbkIsSUFBSUMsaUJBQWlCYixTQUFTWTt3QkFFOUIsSUFBSVgsWUFBWWEsV0FBVzs0QkFDekIscUVBQXFFOzRCQUNyRSxvRUFBb0U7NEJBQ3BFLGtFQUFrRTs0QkFDbEUsSUFBSVgsS0FBS0UsUUFBUSxFQUFFO2dDQUNqQixJQUFJVSxtQkFBbUJaLEtBQUtHLEtBQUs7Z0NBRWpDLElBQUlMLFFBQVFjLGtCQUFrQkYsaUJBQWlCO29DQUM3Q0gsb0JBQW9CSztvQ0FDcEIsT0FBT0E7Z0NBQ1Q7NEJBQ0Y7d0JBQ0Y7d0JBRUFMLG9CQUFvQkc7d0JBQ3BCLE9BQU9BO29CQUNULEVBQUUsNERBQTREO29CQUc5RCw0REFBNEQ7b0JBQzVELElBQUlHLGVBQWVQO29CQUNuQixJQUFJUSxnQkFBZ0JQO29CQUVwQixJQUFJckIsU0FBUzJCLGNBQWNKLGVBQWU7d0JBQ3hDLHVFQUF1RTt3QkFDdkUsT0FBT0s7b0JBQ1QsRUFBRSxtRUFBbUU7b0JBR3JFLG1FQUFtRTtvQkFDbkUsSUFBSUMsZ0JBQWdCbEIsU0FBU1ksZUFBZSwwRUFBMEU7b0JBQ3RILHlFQUF5RTtvQkFDekUsdUVBQXVFO29CQUN2RSxvQkFBb0I7b0JBRXBCLDBFQUEwRTtvQkFDMUUseUVBQXlFO29CQUN6RSx1RUFBdUU7b0JBQ3ZFLG9CQUFvQjtvQkFDcEIsSUFBSVgsWUFBWWEsYUFBYWIsUUFBUWdCLGVBQWVDLGdCQUFnQjt3QkFDbEUsT0FBT0Q7b0JBQ1Q7b0JBRUFSLG1CQUFtQkc7b0JBQ25CRixvQkFBb0JRO29CQUNwQixPQUFPQTtnQkFDVCxHQUFHLG1FQUFtRTtnQkFHdEUsbUVBQW1FO2dCQUNuRSxJQUFJQyx5QkFBeUJwQixzQkFBc0JlLFlBQVksT0FBT2Y7Z0JBRXRFLElBQUlxQiwwQkFBMEI7b0JBQzVCLE9BQU9ULGlCQUFpQmI7Z0JBQzFCO2dCQUVBLElBQUl1QixnQ0FBZ0NGLDJCQUEyQixPQUFPTCxZQUFZO29CQUNoRixPQUFPSCxpQkFBaUJRO2dCQUMxQjtnQkFDQSxPQUFPO29CQUFDQztvQkFBeUJDO2lCQUE4QjtZQUNqRSxHQUFHO2dCQUFDdkI7Z0JBQWFDO2dCQUFtQkM7Z0JBQVVDO2FBQVEsR0FDbERxQixlQUFlZixRQUFRLENBQUMsRUFBRSxFQUMxQmdCLHFCQUFxQmhCLFFBQVEsQ0FBQyxFQUFFO1lBRXBDLElBQUlELFFBQVFmLHFCQUFxQk0sV0FBV3lCLGNBQWNDO1lBQzFEOUIsVUFBVTtnQkFDUlUsS0FBS0UsUUFBUSxHQUFHO2dCQUNoQkYsS0FBS0csS0FBSyxHQUFHQTtZQUNmLEdBQUc7Z0JBQUNBO2FBQU07WUFDVlgsY0FBY1c7WUFDZCxPQUFPQTtRQUNUO1dBdkdTVjs7Z0JBZ0dLTDs7O1FBU2RpQyx3Q0FBd0MsR0FBRzVCO1FBQ2pDLHlDQUF5QyxHQUNuRCxJQUNFLE9BQU9oQixtQ0FBbUMsZUFDMUMsT0FBT0EsK0JBQStCNkMsMEJBQTBCLEtBQzlELFlBQ0Y7WUFDQTdDLCtCQUErQjZDLDBCQUEwQixDQUFDLElBQUkzQztRQUNoRTtJQUVFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3dpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanM/NzVhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3dpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgICB2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHNoaW0gPSByZXF1aXJlKCd1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltJyk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbnZhciB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IHNoaW0udXNlU3luY0V4dGVybmFsU3RvcmU7XG5cbi8vIGZvciBDb21tb25KUyBpbnRlcm9wLlxuXG52YXIgdXNlUmVmID0gUmVhY3QudXNlUmVmLFxuICAgIHVzZUVmZmVjdCA9IFJlYWN0LnVzZUVmZmVjdCxcbiAgICB1c2VNZW1vID0gUmVhY3QudXNlTWVtbyxcbiAgICB1c2VEZWJ1Z1ZhbHVlID0gUmVhY3QudXNlRGVidWdWYWx1ZTsgLy8gU2FtZSBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSwgYnV0IHN1cHBvcnRzIHNlbGVjdG9yIGFuZCBpc0VxdWFsIGFyZ3VtZW50cy5cblxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3Ioc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIC8vIFVzZSB0aGlzIHRvIHRyYWNrIHRoZSByZW5kZXJlZCBzbmFwc2hvdC5cbiAgdmFyIGluc3RSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBpbnN0O1xuXG4gIGlmIChpbnN0UmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICBpbnN0ID0ge1xuICAgICAgaGFzVmFsdWU6IGZhbHNlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9O1xuICAgIGluc3RSZWYuY3VycmVudCA9IGluc3Q7XG4gIH0gZWxzZSB7XG4gICAgaW5zdCA9IGluc3RSZWYuY3VycmVudDtcbiAgfVxuXG4gIHZhciBfdXNlTWVtbyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIC8vIFRyYWNrIHRoZSBtZW1vaXplZCBzdGF0ZSB1c2luZyBjbG9zdXJlIHZhcmlhYmxlcyB0aGF0IGFyZSBsb2NhbCB0byB0aGlzXG4gICAgLy8gbWVtb2l6ZWQgaW5zdGFuY2Ugb2YgYSBnZXRTbmFwc2hvdCBmdW5jdGlvbi4gSW50ZW50aW9uYWxseSBub3QgdXNpbmcgYVxuICAgIC8vIHVzZVJlZiBob29rLCBiZWNhdXNlIHRoYXQgc3RhdGUgd291bGQgYmUgc2hhcmVkIGFjcm9zcyBhbGwgY29uY3VycmVudFxuICAgIC8vIGNvcGllcyBvZiB0aGUgaG9vay9jb21wb25lbnQuXG4gICAgdmFyIGhhc01lbW8gPSBmYWxzZTtcbiAgICB2YXIgbWVtb2l6ZWRTbmFwc2hvdDtcbiAgICB2YXIgbWVtb2l6ZWRTZWxlY3Rpb247XG5cbiAgICB2YXIgbWVtb2l6ZWRTZWxlY3RvciA9IGZ1bmN0aW9uIChuZXh0U25hcHNob3QpIHtcbiAgICAgIGlmICghaGFzTWVtbykge1xuICAgICAgICAvLyBUaGUgZmlyc3QgdGltZSB0aGUgaG9vayBpcyBjYWxsZWQsIHRoZXJlIGlzIG5vIG1lbW9pemVkIHJlc3VsdC5cbiAgICAgICAgaGFzTWVtbyA9IHRydWU7XG4gICAgICAgIG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3Q7XG5cbiAgICAgICAgdmFyIF9uZXh0U2VsZWN0aW9uID0gc2VsZWN0b3IobmV4dFNuYXBzaG90KTtcblxuICAgICAgICBpZiAoaXNFcXVhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gRXZlbiBpZiB0aGUgc2VsZWN0b3IgaGFzIGNoYW5nZWQsIHRoZSBjdXJyZW50bHkgcmVuZGVyZWQgc2VsZWN0aW9uXG4gICAgICAgICAgLy8gbWF5IGJlIGVxdWFsIHRvIHRoZSBuZXcgc2VsZWN0aW9uLiBXZSBzaG91bGQgYXR0ZW1wdCB0byByZXVzZSB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IHZhbHVlIGlmIHBvc3NpYmxlLCB0byBwcmVzZXJ2ZSBkb3duc3RyZWFtIG1lbW9pemF0aW9ucy5cbiAgICAgICAgICBpZiAoaW5zdC5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBpbnN0LnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoaXNFcXVhbChjdXJyZW50U2VsZWN0aW9uLCBfbmV4dFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IF9uZXh0U2VsZWN0aW9uO1xuICAgICAgICByZXR1cm4gX25leHRTZWxlY3Rpb247XG4gICAgICB9IC8vIFdlIG1heSBiZSBhYmxlIHRvIHJldXNlIHRoZSBwcmV2aW91cyBpbnZvY2F0aW9uJ3MgcmVzdWx0LlxuXG5cbiAgICAgIC8vIFdlIG1heSBiZSBhYmxlIHRvIHJldXNlIHRoZSBwcmV2aW91cyBpbnZvY2F0aW9uJ3MgcmVzdWx0LlxuICAgICAgdmFyIHByZXZTbmFwc2hvdCA9IG1lbW9pemVkU25hcHNob3Q7XG4gICAgICB2YXIgcHJldlNlbGVjdGlvbiA9IG1lbW9pemVkU2VsZWN0aW9uO1xuXG4gICAgICBpZiAob2JqZWN0SXMocHJldlNuYXBzaG90LCBuZXh0U25hcHNob3QpKSB7XG4gICAgICAgIC8vIFRoZSBzbmFwc2hvdCBpcyB0aGUgc2FtZSBhcyBsYXN0IHRpbWUuIFJldXNlIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24uXG4gICAgICAgIHJldHVybiBwcmV2U2VsZWN0aW9uO1xuICAgICAgfSAvLyBUaGUgc25hcHNob3QgaGFzIGNoYW5nZWQsIHNvIHdlIG5lZWQgdG8gY29tcHV0ZSBhIG5ldyBzZWxlY3Rpb24uXG5cblxuICAgICAgLy8gVGhlIHNuYXBzaG90IGhhcyBjaGFuZ2VkLCBzbyB3ZSBuZWVkIHRvIGNvbXB1dGUgYSBuZXcgc2VsZWN0aW9uLlxuICAgICAgdmFyIG5leHRTZWxlY3Rpb24gPSBzZWxlY3RvcihuZXh0U25hcHNob3QpOyAvLyBJZiBhIGN1c3RvbSBpc0VxdWFsIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB1c2UgdGhhdCB0byBjaGVjayBpZiB0aGUgZGF0YVxuICAgICAgLy8gaGFzIGNoYW5nZWQuIElmIGl0IGhhc24ndCwgcmV0dXJuIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24uIFRoYXQgc2lnbmFsc1xuICAgICAgLy8gdG8gUmVhY3QgdGhhdCB0aGUgc2VsZWN0aW9ucyBhcmUgY29uY2VwdHVhbGx5IGVxdWFsLCBhbmQgd2UgY2FuIGJhaWxcbiAgICAgIC8vIG91dCBvZiByZW5kZXJpbmcuXG5cbiAgICAgIC8vIElmIGEgY3VzdG9tIGlzRXF1YWwgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHVzZSB0aGF0IHRvIGNoZWNrIGlmIHRoZSBkYXRhXG4gICAgICAvLyBoYXMgY2hhbmdlZC4gSWYgaXQgaGFzbid0LCByZXR1cm4gdGhlIHByZXZpb3VzIHNlbGVjdGlvbi4gVGhhdCBzaWduYWxzXG4gICAgICAvLyB0byBSZWFjdCB0aGF0IHRoZSBzZWxlY3Rpb25zIGFyZSBjb25jZXB0dWFsbHkgZXF1YWwsIGFuZCB3ZSBjYW4gYmFpbFxuICAgICAgLy8gb3V0IG9mIHJlbmRlcmluZy5cbiAgICAgIGlmIChpc0VxdWFsICE9PSB1bmRlZmluZWQgJiYgaXNFcXVhbChwcmV2U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gcHJldlNlbGVjdGlvbjtcbiAgICAgIH1cblxuICAgICAgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcbiAgICAgIG1lbW9pemVkU2VsZWN0aW9uID0gbmV4dFNlbGVjdGlvbjtcbiAgICAgIHJldHVybiBuZXh0U2VsZWN0aW9uO1xuICAgIH07IC8vIEFzc2lnbmluZyB0aGlzIHRvIGEgY29uc3RhbnQgc28gdGhhdCBGbG93IGtub3dzIGl0IGNhbid0IGNoYW5nZS5cblxuXG4gICAgLy8gQXNzaWduaW5nIHRoaXMgdG8gYSBjb25zdGFudCBzbyB0aGF0IEZsb3cga25vd3MgaXQgY2FuJ3QgY2hhbmdlLlxuICAgIHZhciBtYXliZUdldFNlcnZlclNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBnZXRTZXJ2ZXJTbmFwc2hvdDtcblxuICAgIHZhciBnZXRTbmFwc2hvdFdpdGhTZWxlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBtZW1vaXplZFNlbGVjdG9yKGdldFNuYXBzaG90KCkpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0U2VydmVyU25hcHNob3RXaXRoU2VsZWN0b3IgPSBtYXliZUdldFNlcnZlclNuYXBzaG90ID09PSBudWxsID8gdW5kZWZpbmVkIDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0b3IobWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCgpKTtcbiAgICB9O1xuICAgIHJldHVybiBbZ2V0U25hcHNob3RXaXRoU2VsZWN0b3IsIGdldFNlcnZlclNuYXBzaG90V2l0aFNlbGVjdG9yXTtcbiAgfSwgW2dldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc2VsZWN0b3IsIGlzRXF1YWxdKSxcbiAgICAgIGdldFNlbGVjdGlvbiA9IF91c2VNZW1vWzBdLFxuICAgICAgZ2V0U2VydmVyU2VsZWN0aW9uID0gX3VzZU1lbW9bMV07XG5cbiAgdmFyIHZhbHVlID0gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTZWxlY3Rpb24sIGdldFNlcnZlclNlbGVjdGlvbik7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaW5zdC5oYXNWYWx1ZSA9IHRydWU7XG4gICAgaW5zdC52YWx1ZSA9IHZhbHVlO1xuICB9LCBbdmFsdWVdKTtcbiAgdXNlRGVidWdWYWx1ZSh2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yO1xuICAgICAgICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgXG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsInJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCIsIkVycm9yIiwiUmVhY3QiLCJyZXF1aXJlIiwic2hpbSIsImlzIiwieCIsInkiLCJvYmplY3RJcyIsIk9iamVjdCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwidXNlUmVmIiwidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZURlYnVnVmFsdWUiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciIsInN1YnNjcmliZSIsImdldFNuYXBzaG90IiwiZ2V0U2VydmVyU25hcHNob3QiLCJzZWxlY3RvciIsImlzRXF1YWwiLCJpbnN0UmVmIiwiaW5zdCIsImN1cnJlbnQiLCJoYXNWYWx1ZSIsInZhbHVlIiwiX3VzZU1lbW8iLCJoYXNNZW1vIiwibWVtb2l6ZWRTbmFwc2hvdCIsIm1lbW9pemVkU2VsZWN0aW9uIiwibWVtb2l6ZWRTZWxlY3RvciIsIm5leHRTbmFwc2hvdCIsIl9uZXh0U2VsZWN0aW9uIiwidW5kZWZpbmVkIiwiY3VycmVudFNlbGVjdGlvbiIsInByZXZTbmFwc2hvdCIsInByZXZTZWxlY3Rpb24iLCJuZXh0U2VsZWN0aW9uIiwibWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCIsImdldFNuYXBzaG90V2l0aFNlbGVjdG9yIiwiZ2V0U2VydmVyU25hcHNob3RXaXRoU2VsZWN0b3IiLCJnZXRTZWxlY3Rpb24iLCJnZXRTZXJ2ZXJTZWxlY3Rpb24iLCJleHBvcnRzIiwicmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js":
/*!************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/index.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDRNQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS9pbmRleC5qcz8yZTg3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js":
/*!********************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/with-selector.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim/with-selector.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxLQUF5QixFQUFjLEVBRTFDLE1BQU07SUFDTEMsd09BQXlCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanM/ZTMzYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"ab4f101d5d33\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2dsb2JhbHMuY3NzP2MyY2QiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJhYjRmMTAxZDVkMzNcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/Room.tsx":
/*!**********************!*\
  !*** ./app/Room.tsx ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Room: function() { return /* binding */ Room; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _liveblocks_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../liveblocks.config */ \"(app-pages-browser)/./liveblocks.config.ts\");\n/* harmony import */ var _liveblocks_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liveblocks/react */ \"(app-pages-browser)/./node_modules/@liveblocks/react/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ Room auto */ \n\n\nfunction Room(param) {\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_liveblocks_config__WEBPACK_IMPORTED_MODULE_1__.RoomProvider, {\n        id: \"my-room\",\n        initialPresence: {},\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_liveblocks_react__WEBPACK_IMPORTED_MODULE_2__.ClientSideSuspense, {\n            fallback: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: \"Loading\"\n            }, void 0, false, {\n                fileName: \"/home/e11even/Desktop/Figma-clone/app/Room.tsx\",\n                lineNumber: 10,\n                columnNumber: 37\n            }, void 0),\n            children: ()=>children\n        }, void 0, false, {\n            fileName: \"/home/e11even/Desktop/Figma-clone/app/Room.tsx\",\n            lineNumber: 10,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/home/e11even/Desktop/Figma-clone/app/Room.tsx\",\n        lineNumber: 9,\n        columnNumber: 5\n    }, this);\n}\n_c = Room;\nvar _c;\n$RefreshReg$(_c, \"Room\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9Sb29tLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUdvRDtBQUNHO0FBRWhELFNBQVNFLEtBQUssS0FBcUM7UUFBckMsRUFBRUMsUUFBUSxFQUEyQixHQUFyQztJQUNuQixxQkFDRSw4REFBQ0gsNERBQVlBO1FBQUNJLElBQUc7UUFBVUMsaUJBQWlCLENBQUM7a0JBQzNDLDRFQUFDSixpRUFBa0JBO1lBQUNLLHdCQUFVLDhEQUFDQzswQkFBSTs7Ozs7O3NCQUNoQyxJQUFNSjs7Ozs7Ozs7Ozs7QUFJZjtLQVJnQkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL1Jvb20udHN4Pzk4Y2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IFJlYWN0Tm9kZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgUm9vbVByb3ZpZGVyIH0gZnJvbSBcIi4uL2xpdmVibG9ja3MuY29uZmlnXCI7XG5pbXBvcnQgeyBDbGllbnRTaWRlU3VzcGVuc2UgfSBmcm9tIFwiQGxpdmVibG9ja3MvcmVhY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIFJvb20oeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdE5vZGUgfSkge1xuICByZXR1cm4gKFxuICAgIDxSb29tUHJvdmlkZXIgaWQ9XCJteS1yb29tXCIgaW5pdGlhbFByZXNlbmNlPXt7fX0+XG4gICAgICA8Q2xpZW50U2lkZVN1c3BlbnNlIGZhbGxiYWNrPXs8ZGl2PkxvYWRpbmfigKY8L2Rpdj59PlxuICAgICAgICB7KCkgPT4gY2hpbGRyZW59XG4gICAgICA8L0NsaWVudFNpZGVTdXNwZW5zZT5cbiAgICA8L1Jvb21Qcm92aWRlcj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJSb29tUHJvdmlkZXIiLCJDbGllbnRTaWRlU3VzcGVuc2UiLCJSb29tIiwiY2hpbGRyZW4iLCJpZCIsImluaXRpYWxQcmVzZW5jZSIsImZhbGxiYWNrIiwiZGl2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/Room.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./liveblocks.config.ts":
/*!******************************!*\
  !*** ./liveblocks.config.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RoomProvider: function() { return /* binding */ RoomProvider; },\n/* harmony export */   useAddReaction: function() { return /* binding */ useAddReaction; },\n/* harmony export */   useBatch: function() { return /* binding */ useBatch; },\n/* harmony export */   useBroadcastEvent: function() { return /* binding */ useBroadcastEvent; },\n/* harmony export */   useCanRedo: function() { return /* binding */ useCanRedo; },\n/* harmony export */   useCanUndo: function() { return /* binding */ useCanUndo; },\n/* harmony export */   useCreateComment: function() { return /* binding */ useCreateComment; },\n/* harmony export */   useCreateThread: function() { return /* binding */ useCreateThread; },\n/* harmony export */   useDeleteComment: function() { return /* binding */ useDeleteComment; },\n/* harmony export */   useEditComment: function() { return /* binding */ useEditComment; },\n/* harmony export */   useEditThreadMetadata: function() { return /* binding */ useEditThreadMetadata; },\n/* harmony export */   useErrorListener: function() { return /* binding */ useErrorListener; },\n/* harmony export */   useEventListener: function() { return /* binding */ useEventListener; },\n/* harmony export */   useHistory: function() { return /* binding */ useHistory; },\n/* harmony export */   useList: function() { return /* binding */ useList; },\n/* harmony export */   useLostConnectionListener: function() { return /* binding */ useLostConnectionListener; },\n/* harmony export */   useMap: function() { return /* binding */ useMap; },\n/* harmony export */   useMutation: function() { return /* binding */ useMutation; },\n/* harmony export */   useMyPresence: function() { return /* binding */ useMyPresence; },\n/* harmony export */   useObject: function() { return /* binding */ useObject; },\n/* harmony export */   useOther: function() { return /* binding */ useOther; },\n/* harmony export */   useOthers: function() { return /* binding */ useOthers; },\n/* harmony export */   useOthersConnectionIds: function() { return /* binding */ useOthersConnectionIds; },\n/* harmony export */   useOthersMapped: function() { return /* binding */ useOthersMapped; },\n/* harmony export */   useRedo: function() { return /* binding */ useRedo; },\n/* harmony export */   useRemoveReaction: function() { return /* binding */ useRemoveReaction; },\n/* harmony export */   useRoom: function() { return /* binding */ useRoom; },\n/* harmony export */   useSelf: function() { return /* binding */ useSelf; },\n/* harmony export */   useStatus: function() { return /* binding */ useStatus; },\n/* harmony export */   useStorage: function() { return /* binding */ useStorage; },\n/* harmony export */   useThreads: function() { return /* binding */ useThreads; },\n/* harmony export */   useUndo: function() { return /* binding */ useUndo; },\n/* harmony export */   useUpdateMyPresence: function() { return /* binding */ useUpdateMyPresence; },\n/* harmony export */   useUser: function() { return /* binding */ useUser; }\n/* harmony export */ });\n/* harmony import */ var _liveblocks_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @liveblocks/client */ \"(app-pages-browser)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var _liveblocks_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liveblocks/react */ \"(app-pages-browser)/./node_modules/@liveblocks/react/dist/index.mjs\");\n\n\nconst client = (0,_liveblocks_client__WEBPACK_IMPORTED_MODULE_0__.createClient)({\n    publicApiKey: \"pk_dev_YlBh_xd9gnot_yD0X_h8hNMR2KY0IxEI87l3K9zcgcmWaD09_4cqxk12fFCS7AKA\"\n});\nconst { suspense: { RoomProvider, useRoom, useMyPresence, useUpdateMyPresence, useSelf, useOthers, useOthersMapped, useOthersConnectionIds, useOther, useBroadcastEvent, useEventListener, useErrorListener, useStorage, useObject, useMap, useList, useBatch, useHistory, useUndo, useRedo, useCanUndo, useCanRedo, useMutation, useStatus, useLostConnectionListener, useThreads, useUser, useCreateThread, useEditThreadMetadata, useCreateComment, useEditComment, useDeleteComment, useAddReaction, useRemoveReaction } } = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_1__.createRoomContext)(client, {\n    async resolveUsers (param) {\n        let { userIds } = param;\n        // Used only for Comments. Return a list of user information retrieved\n        // from `userIds`. This info is used in comments, mentions etc.\n        // const usersData = await __fetchUsersFromDB__(userIds);\n        //\n        // return usersData.map((userData) => ({\n        //   name: userData.name,\n        //   avatar: userData.avatar.src,\n        // }));\n        return [];\n    },\n    async resolveMentionSuggestions (param) {\n        let { text, roomId } = param;\n        // Used only for Comments. Return a list of userIds that match `text`.\n        // These userIds are used to create a mention list when typing in the\n        // composer.\n        //\n        // For example when you type \"@jo\", `text` will be `\"jo\"`, and\n        // you should to return an array with John and Joanna's userIds:\n        // [\"john@example.com\", \"joanna@example.com\"]\n        // const userIds = await __fetchAllUserIdsFromDB__(roomId);\n        //\n        // Return all userIds if no `text`\n        // if (!text) {\n        //   return userIds;\n        // }\n        //\n        // Otherwise, filter userIds for the search `text` and return\n        // return userIds.filter((userId) =>\n        //   userId.toLowerCase().includes(text.toLowerCase())\n        // );\n        return [];\n    }\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpdmVibG9ja3MuY29uZmlnLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrRDtBQUNJO0FBRXRELE1BQU1FLFNBQVNGLGdFQUFZQSxDQUFDO0lBQzFCRyxjQUFjQyx5RUFBNkM7QUFDN0Q7QUEwQ08sTUFBTSxFQUNYRyxVQUFVLEVBQ1JDLFlBQVksRUFDWkMsT0FBTyxFQUNQQyxhQUFhLEVBQ2JDLG1CQUFtQixFQUNuQkMsT0FBTyxFQUNQQyxTQUFTLEVBQ1RDLGVBQWUsRUFDZkMsc0JBQXNCLEVBQ3RCQyxRQUFRLEVBQ1JDLGlCQUFpQixFQUNqQkMsZ0JBQWdCLEVBQ2hCQyxnQkFBZ0IsRUFDaEJDLFVBQVUsRUFDVkMsU0FBUyxFQUNUQyxNQUFNLEVBQ05DLE9BQU8sRUFDUEMsUUFBUSxFQUNSQyxVQUFVLEVBQ1ZDLE9BQU8sRUFDUEMsT0FBTyxFQUNQQyxVQUFVLEVBQ1ZDLFVBQVUsRUFDVkMsV0FBVyxFQUNYQyxTQUFTLEVBQ1RDLHlCQUF5QixFQUN6QkMsVUFBVSxFQUNWQyxPQUFPLEVBQ1BDLGVBQWUsRUFDZkMscUJBQXFCLEVBQ3JCQyxnQkFBZ0IsRUFDaEJDLGNBQWMsRUFDZEMsZ0JBQWdCLEVBQ2hCQyxjQUFjLEVBQ2RDLGlCQUFpQixFQUNsQixFQUNGLEdBQUd4QyxvRUFBaUJBLENBQ25CQyxRQUNBO0lBQ0UsTUFBTXdDLGNBQWEsS0FBVztZQUFYLEVBQUVDLE9BQU8sRUFBRSxHQUFYO1FBQ2pCLHNFQUFzRTtRQUN0RSwrREFBK0Q7UUFFL0QseURBQXlEO1FBQ3pELEVBQUU7UUFDRix3Q0FBd0M7UUFDeEMseUJBQXlCO1FBQ3pCLGlDQUFpQztRQUNqQyxPQUFPO1FBRVAsT0FBTyxFQUFFO0lBQ1g7SUFDQSxNQUFNQywyQkFBMEIsS0FBZ0I7WUFBaEIsRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUUsR0FBaEI7UUFDOUIsc0VBQXNFO1FBQ3RFLHFFQUFxRTtRQUNyRSxZQUFZO1FBQ1osRUFBRTtRQUNGLDhEQUE4RDtRQUM5RCxnRUFBZ0U7UUFDaEUsNkNBQTZDO1FBRTdDLDJEQUEyRDtRQUMzRCxFQUFFO1FBQ0Ysa0NBQWtDO1FBQ2xDLGVBQWU7UUFDZixvQkFBb0I7UUFDcEIsSUFBSTtRQUNKLEVBQUU7UUFDRiw2REFBNkQ7UUFDN0Qsb0NBQW9DO1FBQ3BDLHNEQUFzRDtRQUN0RCxLQUFLO1FBRUwsT0FBTyxFQUFFO0lBQ1g7QUFDRixHQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpdmVibG9ja3MuY29uZmlnLnRzP2JjMDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NsaWVudFwiO1xuaW1wb3J0IHsgY3JlYXRlUm9vbUNvbnRleHQgfSBmcm9tIFwiQGxpdmVibG9ja3MvcmVhY3RcIjtcblxuY29uc3QgY2xpZW50ID0gY3JlYXRlQ2xpZW50KHtcbiAgcHVibGljQXBpS2V5OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19MSVZFQkxPQ0tTX1BVQkxJQ19LRVkhLFxufSk7XG5cbi8vIFByZXNlbmNlIHJlcHJlc2VudHMgdGhlIHByb3BlcnRpZXMgdGhhdCBleGlzdCBvbiBldmVyeSB1c2VyIGluIHRoZSBSb29tXG4vLyBhbmQgdGhhdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUga2VwdCBpbiBzeW5jLiBBY2Nlc3NpYmxlIHRocm91Z2ggdGhlXG4vLyBgdXNlci5wcmVzZW5jZWAgcHJvcGVydHkuIE11c3QgYmUgSlNPTi1zZXJpYWxpemFibGUuXG50eXBlIFByZXNlbmNlID0ge1xuICAvLyBjdXJzb3I6IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfSB8IG51bGwsXG4gIC8vIC4uLlxufTtcblxuLy8gT3B0aW9uYWxseSwgU3RvcmFnZSByZXByZXNlbnRzIHRoZSBzaGFyZWQgZG9jdW1lbnQgdGhhdCBwZXJzaXN0cyBpbiB0aGVcbi8vIFJvb20sIGV2ZW4gYWZ0ZXIgYWxsIHVzZXJzIGxlYXZlLiBGaWVsZHMgdW5kZXIgU3RvcmFnZSB0eXBpY2FsbHkgYXJlXG4vLyBMaXZlTGlzdCwgTGl2ZU1hcCwgTGl2ZU9iamVjdCBpbnN0YW5jZXMsIGZvciB3aGljaCB1cGRhdGVzIGFyZVxuLy8gYXV0b21hdGljYWxseSBwZXJzaXN0ZWQgYW5kIHN5bmNlZCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMuXG50eXBlIFN0b3JhZ2UgPSB7XG4gIC8vIGF1dGhvcjogTGl2ZU9iamVjdDx7IGZpcnN0TmFtZTogc3RyaW5nLCBsYXN0TmFtZTogc3RyaW5nIH0+LFxuICAvLyAuLi5cbn07XG5cbi8vIE9wdGlvbmFsbHksIFVzZXJNZXRhIHJlcHJlc2VudHMgc3RhdGljL3JlYWRvbmx5IG1ldGFkYXRhIG9uIGVhY2ggdXNlciwgYXNcbi8vIHByb3ZpZGVkIGJ5IHlvdXIgb3duIGN1c3RvbSBhdXRoIGJhY2sgZW5kIChpZiB1c2VkKS4gVXNlZnVsIGZvciBkYXRhIHRoYXRcbi8vIHdpbGwgbm90IGNoYW5nZSBkdXJpbmcgYSBzZXNzaW9uLCBsaWtlIGEgdXNlcidzIG5hbWUgb3IgYXZhdGFyLlxudHlwZSBVc2VyTWV0YSA9IHtcbiAgLy8gaWQ/OiBzdHJpbmcsICAvLyBBY2Nlc3NpYmxlIHRocm91Z2ggYHVzZXIuaWRgXG4gIC8vIGluZm8/OiBKc29uLCAgLy8gQWNjZXNzaWJsZSB0aHJvdWdoIGB1c2VyLmluZm9gXG59O1xuXG4vLyBPcHRpb25hbGx5LCB0aGUgdHlwZSBvZiBjdXN0b20gZXZlbnRzIGJyb2FkY2FzdCBhbmQgbGlzdGVuZWQgdG8gaW4gdGhpc1xuLy8gcm9vbS4gVXNlIGEgdW5pb24gZm9yIG11bHRpcGxlIGV2ZW50cy4gTXVzdCBiZSBKU09OLXNlcmlhbGl6YWJsZS5cbnR5cGUgUm9vbUV2ZW50ID0ge1xuICAvLyB0eXBlOiBcIk5PVElGSUNBVElPTlwiLFxuICAvLyAuLi5cbn07XG5cbi8vIE9wdGlvbmFsbHksIHdoZW4gdXNpbmcgQ29tbWVudHMsIFRocmVhZE1ldGFkYXRhIHJlcHJlc2VudHMgbWV0YWRhdGEgb25cbi8vIGVhY2ggdGhyZWFkLiBDYW4gb25seSBjb250YWluIGJvb2xlYW5zLCBzdHJpbmdzLCBhbmQgbnVtYmVycy5cbmV4cG9ydCB0eXBlIFRocmVhZE1ldGFkYXRhID0ge1xuICAvLyByZXNvbHZlZDogYm9vbGVhbjtcbiAgLy8gcXVvdGU6IHN0cmluZztcbiAgLy8gdGltZTogbnVtYmVyO1xufTtcblxuZXhwb3J0IGNvbnN0IHtcbiAgc3VzcGVuc2U6IHtcbiAgICBSb29tUHJvdmlkZXIsXG4gICAgdXNlUm9vbSxcbiAgICB1c2VNeVByZXNlbmNlLFxuICAgIHVzZVVwZGF0ZU15UHJlc2VuY2UsXG4gICAgdXNlU2VsZixcbiAgICB1c2VPdGhlcnMsXG4gICAgdXNlT3RoZXJzTWFwcGVkLFxuICAgIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHMsXG4gICAgdXNlT3RoZXIsXG4gICAgdXNlQnJvYWRjYXN0RXZlbnQsXG4gICAgdXNlRXZlbnRMaXN0ZW5lcixcbiAgICB1c2VFcnJvckxpc3RlbmVyLFxuICAgIHVzZVN0b3JhZ2UsXG4gICAgdXNlT2JqZWN0LFxuICAgIHVzZU1hcCxcbiAgICB1c2VMaXN0LFxuICAgIHVzZUJhdGNoLFxuICAgIHVzZUhpc3RvcnksXG4gICAgdXNlVW5kbyxcbiAgICB1c2VSZWRvLFxuICAgIHVzZUNhblVuZG8sXG4gICAgdXNlQ2FuUmVkbyxcbiAgICB1c2VNdXRhdGlvbixcbiAgICB1c2VTdGF0dXMsXG4gICAgdXNlTG9zdENvbm5lY3Rpb25MaXN0ZW5lcixcbiAgICB1c2VUaHJlYWRzLFxuICAgIHVzZVVzZXIsXG4gICAgdXNlQ3JlYXRlVGhyZWFkLFxuICAgIHVzZUVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgICB1c2VDcmVhdGVDb21tZW50LFxuICAgIHVzZUVkaXRDb21tZW50LFxuICAgIHVzZURlbGV0ZUNvbW1lbnQsXG4gICAgdXNlQWRkUmVhY3Rpb24sXG4gICAgdXNlUmVtb3ZlUmVhY3Rpb24sXG4gIH0sXG59ID0gY3JlYXRlUm9vbUNvbnRleHQ8UHJlc2VuY2UsIFN0b3JhZ2UsIFVzZXJNZXRhLCBSb29tRXZlbnQsIFRocmVhZE1ldGFkYXRhPihcbiAgY2xpZW50LFxuICB7XG4gICAgYXN5bmMgcmVzb2x2ZVVzZXJzKHsgdXNlcklkcyB9KSB7XG4gICAgICAvLyBVc2VkIG9ubHkgZm9yIENvbW1lbnRzLiBSZXR1cm4gYSBsaXN0IG9mIHVzZXIgaW5mb3JtYXRpb24gcmV0cmlldmVkXG4gICAgICAvLyBmcm9tIGB1c2VySWRzYC4gVGhpcyBpbmZvIGlzIHVzZWQgaW4gY29tbWVudHMsIG1lbnRpb25zIGV0Yy5cblxuICAgICAgLy8gY29uc3QgdXNlcnNEYXRhID0gYXdhaXQgX19mZXRjaFVzZXJzRnJvbURCX18odXNlcklkcyk7XG4gICAgICAvL1xuICAgICAgLy8gcmV0dXJuIHVzZXJzRGF0YS5tYXAoKHVzZXJEYXRhKSA9PiAoe1xuICAgICAgLy8gICBuYW1lOiB1c2VyRGF0YS5uYW1lLFxuICAgICAgLy8gICBhdmF0YXI6IHVzZXJEYXRhLmF2YXRhci5zcmMsXG4gICAgICAvLyB9KSk7XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIGFzeW5jIHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMoeyB0ZXh0LCByb29tSWQgfSkge1xuICAgICAgLy8gVXNlZCBvbmx5IGZvciBDb21tZW50cy4gUmV0dXJuIGEgbGlzdCBvZiB1c2VySWRzIHRoYXQgbWF0Y2ggYHRleHRgLlxuICAgICAgLy8gVGhlc2UgdXNlcklkcyBhcmUgdXNlZCB0byBjcmVhdGUgYSBtZW50aW9uIGxpc3Qgd2hlbiB0eXBpbmcgaW4gdGhlXG4gICAgICAvLyBjb21wb3Nlci5cbiAgICAgIC8vXG4gICAgICAvLyBGb3IgZXhhbXBsZSB3aGVuIHlvdSB0eXBlIFwiQGpvXCIsIGB0ZXh0YCB3aWxsIGJlIGBcImpvXCJgLCBhbmRcbiAgICAgIC8vIHlvdSBzaG91bGQgdG8gcmV0dXJuIGFuIGFycmF5IHdpdGggSm9obiBhbmQgSm9hbm5hJ3MgdXNlcklkczpcbiAgICAgIC8vIFtcImpvaG5AZXhhbXBsZS5jb21cIiwgXCJqb2FubmFAZXhhbXBsZS5jb21cIl1cblxuICAgICAgLy8gY29uc3QgdXNlcklkcyA9IGF3YWl0IF9fZmV0Y2hBbGxVc2VySWRzRnJvbURCX18ocm9vbUlkKTtcbiAgICAgIC8vXG4gICAgICAvLyBSZXR1cm4gYWxsIHVzZXJJZHMgaWYgbm8gYHRleHRgXG4gICAgICAvLyBpZiAoIXRleHQpIHtcbiAgICAgIC8vICAgcmV0dXJuIHVzZXJJZHM7XG4gICAgICAvLyB9XG4gICAgICAvL1xuICAgICAgLy8gT3RoZXJ3aXNlLCBmaWx0ZXIgdXNlcklkcyBmb3IgdGhlIHNlYXJjaCBgdGV4dGAgYW5kIHJldHVyblxuICAgICAgLy8gcmV0dXJuIHVzZXJJZHMuZmlsdGVyKCh1c2VySWQpID0+XG4gICAgICAvLyAgIHVzZXJJZC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHRleHQudG9Mb3dlckNhc2UoKSlcbiAgICAgIC8vICk7XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICB9XG4pO1xuIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsImNyZWF0ZVJvb21Db250ZXh0IiwiY2xpZW50IiwicHVibGljQXBpS2V5IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0xJVkVCTE9DS1NfUFVCTElDX0tFWSIsInN1c3BlbnNlIiwiUm9vbVByb3ZpZGVyIiwidXNlUm9vbSIsInVzZU15UHJlc2VuY2UiLCJ1c2VVcGRhdGVNeVByZXNlbmNlIiwidXNlU2VsZiIsInVzZU90aGVycyIsInVzZU90aGVyc01hcHBlZCIsInVzZU90aGVyc0Nvbm5lY3Rpb25JZHMiLCJ1c2VPdGhlciIsInVzZUJyb2FkY2FzdEV2ZW50IiwidXNlRXZlbnRMaXN0ZW5lciIsInVzZUVycm9yTGlzdGVuZXIiLCJ1c2VTdG9yYWdlIiwidXNlT2JqZWN0IiwidXNlTWFwIiwidXNlTGlzdCIsInVzZUJhdGNoIiwidXNlSGlzdG9yeSIsInVzZVVuZG8iLCJ1c2VSZWRvIiwidXNlQ2FuVW5kbyIsInVzZUNhblJlZG8iLCJ1c2VNdXRhdGlvbiIsInVzZVN0YXR1cyIsInVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIiLCJ1c2VUaHJlYWRzIiwidXNlVXNlciIsInVzZUNyZWF0ZVRocmVhZCIsInVzZUVkaXRUaHJlYWRNZXRhZGF0YSIsInVzZUNyZWF0ZUNvbW1lbnQiLCJ1c2VFZGl0Q29tbWVudCIsInVzZURlbGV0ZUNvbW1lbnQiLCJ1c2VBZGRSZWFjdGlvbiIsInVzZVJlbW92ZVJlYWN0aW9uIiwicmVzb2x2ZVVzZXJzIiwidXNlcklkcyIsInJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMiLCJ0ZXh0Iiwicm9vbUlkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./liveblocks.config.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@liveblocks/core/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@liveblocks/core/dist/index.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientMsgCode: function() { return /* binding */ ClientMsgCode; },\n/* harmony export */   CommentsApiError: function() { return /* binding */ CommentsApiError; },\n/* harmony export */   CrdtType: function() { return /* binding */ CrdtType; },\n/* harmony export */   LiveList: function() { return /* binding */ LiveList; },\n/* harmony export */   LiveMap: function() { return /* binding */ LiveMap; },\n/* harmony export */   LiveObject: function() { return /* binding */ LiveObject; },\n/* harmony export */   OpCode: function() { return /* binding */ OpCode; },\n/* harmony export */   ServerMsgCode: function() { return /* binding */ ServerMsgCode; },\n/* harmony export */   WebsocketCloseCodes: function() { return /* binding */ WebsocketCloseCodes; },\n/* harmony export */   ackOp: function() { return /* binding */ ackOp; },\n/* harmony export */   asPos: function() { return /* binding */ asPos; },\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   assertNever: function() { return /* binding */ assertNever; },\n/* harmony export */   b64decode: function() { return /* binding */ b64decode; },\n/* harmony export */   cloneLson: function() { return /* binding */ cloneLson; },\n/* harmony export */   console: function() { return /* binding */ fancy_console_exports; },\n/* harmony export */   convertToCommentData: function() { return /* binding */ convertToCommentData; },\n/* harmony export */   convertToCommentUserReaction: function() { return /* binding */ convertToCommentUserReaction; },\n/* harmony export */   convertToThreadData: function() { return /* binding */ convertToThreadData; },\n/* harmony export */   createAsyncCache: function() { return /* binding */ createAsyncCache; },\n/* harmony export */   createClient: function() { return /* binding */ createClient; },\n/* harmony export */   createCommentsApi: function() { return /* binding */ createCommentsApi; },\n/* harmony export */   deprecate: function() { return /* binding */ deprecate; },\n/* harmony export */   deprecateIf: function() { return /* binding */ deprecateIf; },\n/* harmony export */   detectDupes: function() { return /* binding */ detectDupes; },\n/* harmony export */   errorIf: function() { return /* binding */ errorIf; },\n/* harmony export */   freeze: function() { return /* binding */ freeze; },\n/* harmony export */   getMentionedIdsFromCommentBody: function() { return /* binding */ getMentionedIdsFromCommentBody; },\n/* harmony export */   isChildCrdt: function() { return /* binding */ isChildCrdt; },\n/* harmony export */   isJsonArray: function() { return /* binding */ isJsonArray; },\n/* harmony export */   isJsonObject: function() { return /* binding */ isJsonObject; },\n/* harmony export */   isJsonScalar: function() { return /* binding */ isJsonScalar; },\n/* harmony export */   isLiveNode: function() { return /* binding */ isLiveNode; },\n/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; },\n/* harmony export */   isRootCrdt: function() { return /* binding */ isRootCrdt; },\n/* harmony export */   legacy_patchImmutableObject: function() { return /* binding */ legacy_patchImmutableObject; },\n/* harmony export */   lsonToJson: function() { return /* binding */ lsonToJson; },\n/* harmony export */   makeEventSource: function() { return /* binding */ makeEventSource; },\n/* harmony export */   makePoller: function() { return /* binding */ makePoller; },\n/* harmony export */   makePosition: function() { return /* binding */ makePosition; },\n/* harmony export */   nn: function() { return /* binding */ nn; },\n/* harmony export */   patchLiveObjectKey: function() { return /* binding */ patchLiveObjectKey; },\n/* harmony export */   raise: function() { return /* binding */ raise; },\n/* harmony export */   shallow: function() { return /* binding */ shallow; },\n/* harmony export */   stringify: function() { return /* binding */ stringify; },\n/* harmony export */   stringifyCommentBody: function() { return /* binding */ stringifyCommentBody; },\n/* harmony export */   throwUsageError: function() { return /* binding */ throwUsageError; },\n/* harmony export */   toPlainLson: function() { return /* binding */ toPlainLson; },\n/* harmony export */   tryParseJson: function() { return /* binding */ tryParseJson; },\n/* harmony export */   withTimeout: function() { return /* binding */ withTimeout; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_tagged_template_literal */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_tagged_template_literal.js\");\n\nfunction _templateObject() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"<p>\",\n        \"</p>\"\n    ]);\n    _templateObject = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject1() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"<strong>\",\n        \"</strong>\"\n    ]);\n    _templateObject1 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject2() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"<em>\",\n        \"</em>\"\n    ]);\n    _templateObject2 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject3() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"<s>\",\n        \"</s>\"\n    ]);\n    _templateObject3 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject4() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"<code>\",\n        \"</code>\"\n    ]);\n    _templateObject4 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject5() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        '<a href=\"',\n        '\" target=\"_blank\" rel=\"noopener noreferrer\">',\n        \"</a>\"\n    ]);\n    _templateObject5 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject6() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"<span data-mention>@\",\n        \"</span>\"\n    ]);\n    _templateObject6 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject7() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"**\",\n        \"**\"\n    ]);\n    _templateObject7 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject8() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"_\",\n        \"_\"\n    ]);\n    _templateObject8 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject9() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"~~\",\n        \"~~\"\n    ]);\n    _templateObject9 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject10() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"`\",\n        \"`\"\n    ], [\n        \"\\\\`\",\n        \"\\\\`\"\n    ]);\n    _templateObject10 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject11() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"[\",\n        \"](\",\n        \")\"\n    ]);\n    _templateObject11 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject12() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"@\",\n        \"\"\n    ]);\n    _templateObject12 = function() {\n        return data;\n    };\n    return data;\n}\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"1.9.7\";\nvar PKG_FORMAT = \"esm\";\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis :  true ? window : 0;\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n    if (false) {} else {\n        throw new Error(msg);\n    }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n    const pkgId = Symbol.for(pkgName);\n    const pkgBuildInfo = pkgFormat ? \"\".concat(pkgVersion || \"dev\", \" (\").concat(pkgFormat, \")\") : pkgVersion || \"dev\";\n    if (!g[pkgId]) {\n        g[pkgId] = pkgBuildInfo;\n    } else if (g[pkgId] === pkgBuildInfo) {} else {\n        const msg = [\n            \"Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See \".concat(dupesDocs + SPACE),\n            \"\",\n            \"Conflicts:\",\n            \"- \".concat(pkgName, \" \").concat(g[pkgId], \" (already loaded)\"),\n            \"- \".concat(pkgName, \" \").concat(pkgBuildInfo, \" (trying to load this now)\")\n        ].join(\"\\n\");\n        error(msg);\n    }\n    if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n        error([\n            \"Cross-linked versions of Liveblocks found, which will cause issues! See \".concat(crossLinkedDocs + SPACE),\n            \"\",\n            \"Conflicts:\",\n            \"- \".concat(PKG_NAME, \" is at \").concat(PKG_VERSION),\n            \"- \".concat(pkgName, \" is at \").concat(pkgVersion),\n            \"\",\n            \"Always upgrade all Liveblocks packages to the same version number.\"\n        ].join(\"\\n\"));\n    }\n}\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n    throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n    if (true) {\n        if (!condition) {\n            const err = new Error(errmsg);\n            err.name = \"Assertion failure\";\n            throw err;\n        }\n    }\n}\nfunction nn(value) {\n    let errmsg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"Expected value to be non-nullable\";\n    assert(value !== null && value !== void 0, errmsg);\n    return value;\n}\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n    let flagger;\n    const promise = new Promise((res)=>{\n        flagger = res;\n    });\n    if (!flagger) {\n        throw new Error(\"Should never happen\");\n    }\n    return [\n        promise,\n        flagger\n    ];\n}\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n    const _onetimeObservers = /* @__PURE__ */ new Set();\n    const _observers = /* @__PURE__ */ new Set();\n    let _buffer = null;\n    function pause() {\n        _buffer = [];\n    }\n    function unpause() {\n        if (_buffer === null) {\n            return;\n        }\n        for (const event of _buffer){\n            notify(event);\n        }\n        _buffer = null;\n    }\n    function subscribe(callback) {\n        _observers.add(callback);\n        return ()=>_observers.delete(callback);\n    }\n    function subscribeOnce(callback) {\n        _onetimeObservers.add(callback);\n        return ()=>_onetimeObservers.delete(callback);\n    }\n    async function waitUntil(predicate) {\n        let unsub;\n        return new Promise((res)=>{\n            unsub = subscribe((event)=>{\n                if (predicate === void 0 || predicate(event)) {\n                    res(event);\n                }\n            });\n        }).finally(()=>unsub === null || unsub === void 0 ? void 0 : unsub());\n    }\n    function notifyOrBuffer(event) {\n        if (_buffer !== null) {\n            _buffer.push(event);\n        } else {\n            notify(event);\n        }\n    }\n    function notify(event) {\n        _onetimeObservers.forEach((callback)=>callback(event));\n        _onetimeObservers.clear();\n        _observers.forEach((callback)=>callback(event));\n    }\n    function clear() {\n        _onetimeObservers.clear();\n        _observers.clear();\n    }\n    function count() {\n        return _onetimeObservers.size + _observers.size;\n    }\n    return {\n        // Private/internal control over event emission\n        notify: notifyOrBuffer,\n        subscribe,\n        subscribeOnce,\n        clear,\n        count,\n        waitUntil,\n        pause,\n        unpause,\n        // Publicly exposable subscription API\n        observable: {\n            subscribe,\n            subscribeOnce,\n            waitUntil\n        }\n    };\n}\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n    error: ()=>error2,\n    errorWithTitle: ()=>errorWithTitle,\n    warn: ()=>warn,\n    warnWithTitle: ()=>warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n    return  false ? 0 : /* istanbul ignore next */ function(message) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        return console[method](\"%cLiveblocks\", badge, message, ...args);\n    };\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n    return  false ? 0 : /* istanbul ignore next */ function(title, message) {\n        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n            args[_key - 2] = arguments[_key];\n        }\n        return console[method](\"%cLiveblocks%c \".concat(title), badge, bold, message, ...args);\n    };\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n    if (state1 === state2) {\n        return [\n            0,\n            0\n        ];\n    }\n    const chunks1 = state1.split(\".\");\n    const chunks2 = state2.split(\".\");\n    const minLen = Math.min(chunks1.length, chunks2.length);\n    let shared = 0;\n    for(; shared < minLen; shared++){\n        if (chunks1[shared] !== chunks2[shared]) {\n            break;\n        }\n    }\n    const up = chunks1.length - shared;\n    const down = chunks2.length - shared;\n    return [\n        up,\n        down\n    ];\n}\nfunction patterns(targetState, levels) {\n    const parts = targetState.split(\".\");\n    if (levels < 1 || levels > parts.length + 1) {\n        throw new Error(\"Invalid number of levels\");\n    }\n    const result = [];\n    if (levels > parts.length) {\n        result.push(\"*\");\n    }\n    for(let i = parts.length - levels + 1; i < parts.length; i++){\n        const slice = parts.slice(0, i);\n        if (slice.length > 0) {\n            result.push(slice.join(\".\") + \".*\");\n        }\n    }\n    result.push(targetState);\n    return result;\n}\nvar SafeContext = class {\n    get current() {\n        return this.curr;\n    }\n    /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */ allowPatching(callback) {\n        const self = this;\n        let allowed = true;\n        const patchableContext = {\n            ...this.curr,\n            patch (patch) {\n                if (allowed) {\n                    self.curr = Object.assign({}, self.curr, patch);\n                    for (const pair of Object.entries(patch)){\n                        const [key, value] = pair;\n                        if (key !== \"patch\") {\n                            this[key] = value;\n                        }\n                    }\n                } else {\n                    throw new Error(\"Can no longer patch stale context\");\n                }\n            }\n        };\n        callback(patchableContext);\n        allowed = false;\n        return;\n    }\n    constructor(initialContext){\n        this.curr = initialContext;\n    }\n};\nvar nextId = 1;\nvar FSM = class {\n    /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */ get initialState() {\n        const result = this.states.values()[Symbol.iterator]().next();\n        if (result.done) {\n            throw new Error(\"No states defined yet\");\n        } else {\n            return result.value;\n        }\n    }\n    get currentState() {\n        if (this.currentStateOrNull === null) {\n            if (this.runningState === 0 /* NOT_STARTED_YET */ ) {\n                throw new Error(\"Not started yet\");\n            } else {\n                throw new Error(\"Already stopped\");\n            }\n        }\n        return this.currentStateOrNull;\n    }\n    /**\n   * Starts the machine by entering the initial state.\n   */ start() {\n        if (this.runningState !== 0 /* NOT_STARTED_YET */ ) {\n            throw new Error(\"State machine has already started\");\n        }\n        this.runningState = 1 /* STARTED */ ;\n        this.currentStateOrNull = this.initialState;\n        this.enter(null);\n        return this;\n    }\n    /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */ stop() {\n        if (this.runningState !== 1 /* STARTED */ ) {\n            throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n        }\n        this.exit(null);\n        this.runningState = 2 /* STOPPED */ ;\n        this.currentStateOrNull = null;\n    }\n    get context() {\n        return this.currentContext.current;\n    }\n    /**\n   * Define an explicit finite state in the state machine.\n   */ addState(state) {\n        if (this.runningState !== 0 /* NOT_STARTED_YET */ ) {\n            throw new Error(\"Already started\");\n        }\n        this.states.add(state);\n        return this;\n    }\n    onEnter(nameOrPattern, enterFn) {\n        if (this.runningState !== 0 /* NOT_STARTED_YET */ ) {\n            throw new Error(\"Already started\");\n        } else if (this.enterFns.has(nameOrPattern)) {\n            throw new Error(// TODO We _currently_ don't support multiple .onEnters() for the same\n            // state, but this is not a fundamental limitation. Just not\n            // implemented yet. If we wanted to, we could make this an array.\n            \"enter/exit function for \".concat(nameOrPattern, \" already exists\"));\n        }\n        this.enterFns.set(nameOrPattern, enterFn);\n        return this;\n    }\n    onEnterAsync(nameOrPattern, promiseFn, onOK, onError) {\n        return this.onEnter(nameOrPattern, ()=>{\n            let cancelled = false;\n            void promiseFn(this.currentContext.current).then(// On OK\n            (data)=>{\n                if (!cancelled) {\n                    this.transition({\n                        type: \"ASYNC_OK\",\n                        data\n                    }, onOK);\n                }\n            }, // On Error\n            (reason)=>{\n                if (!cancelled) {\n                    this.transition({\n                        type: \"ASYNC_ERROR\",\n                        reason\n                    }, onError);\n                }\n            });\n            return ()=>{\n                cancelled = true;\n            };\n        });\n    }\n    getStatesMatching(nameOrPattern) {\n        const matches = [];\n        if (nameOrPattern === \"*\") {\n            for (const state of this.states){\n                matches.push(state);\n            }\n        } else if (nameOrPattern.endsWith(\".*\")) {\n            const prefix = nameOrPattern.slice(0, -1);\n            for (const state of this.states){\n                if (state.startsWith(prefix)) {\n                    matches.push(state);\n                }\n            }\n        } else {\n            const name = nameOrPattern;\n            if (this.states.has(name)) {\n                matches.push(name);\n            }\n        }\n        if (matches.length === 0) {\n            throw new Error(\"No states match \".concat(JSON.stringify(nameOrPattern)));\n        }\n        return matches;\n    }\n    /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */ addTransitions(nameOrPattern, mapping) {\n        if (this.runningState !== 0 /* NOT_STARTED_YET */ ) {\n            throw new Error(\"Already started\");\n        }\n        for (const srcState of this.getStatesMatching(nameOrPattern)){\n            let map = this.allowedTransitions.get(srcState);\n            if (map === void 0) {\n                map = /* @__PURE__ */ new Map();\n                this.allowedTransitions.set(srcState, map);\n            }\n            for (const [type, target_] of Object.entries(mapping)){\n                if (map.has(type)) {\n                    throw new Error('Trying to set transition \"'.concat(type, '\" on \"').concat(srcState, '\" (via \"').concat(nameOrPattern, '\"), but a transition already exists there.'));\n                }\n                const target = target_;\n                this.knownEventTypes.add(type);\n                if (target !== void 0) {\n                    const targetFn = typeof target === \"function\" ? target : ()=>target;\n                    map.set(type, targetFn);\n                }\n            }\n        }\n        return this;\n    }\n    /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern The state name, or state group pattern name.\n   * @param after          Number of milliseconds after which to take the\n   *                       transition. If in the mean time, another transition\n   *                       is taken, the timer will get cancelled.\n   * @param target     The target state to go to.\n   */ addTimedTransition(stateOrPattern, after2, target) {\n        return this.onEnter(stateOrPattern, ()=>{\n            const ms = typeof after2 === \"function\" ? after2(this.currentContext.current) : after2;\n            const timeoutID = setTimeout(()=>{\n                this.transition({\n                    type: \"TIMER\"\n                }, target);\n            }, ms);\n            return ()=>{\n                clearTimeout(timeoutID);\n            };\n        });\n    }\n    getTargetFn(eventName) {\n        var _this_allowedTransitions_get;\n        return (_this_allowedTransitions_get = this.allowedTransitions.get(this.currentState)) === null || _this_allowedTransitions_get === void 0 ? void 0 : _this_allowedTransitions_get.get(eventName);\n    }\n    /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */ exit(levels) {\n        this.eventHub.willExitState.notify(this.currentState);\n        this.currentContext.allowPatching((patchableContext)=>{\n            levels = levels !== null && levels !== void 0 ? levels : this.cleanupStack.length;\n            for(let i = 0; i < levels; i++){\n                var _this_cleanupStack_pop;\n                (_this_cleanupStack_pop = this.cleanupStack.pop()) === null || _this_cleanupStack_pop === void 0 ? void 0 : _this_cleanupStack_pop(patchableContext);\n            }\n        });\n    }\n    /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */ enter(levels) {\n        const enterPatterns = patterns(this.currentState, levels !== null && levels !== void 0 ? levels : this.currentState.split(\".\").length + 1);\n        this.currentContext.allowPatching((patchableContext)=>{\n            for (const pattern of enterPatterns){\n                const enterFn = this.enterFns.get(pattern);\n                const cleanupFn = enterFn === null || enterFn === void 0 ? void 0 : enterFn(patchableContext);\n                if (typeof cleanupFn === \"function\") {\n                    this.cleanupStack.push(cleanupFn);\n                } else {\n                    this.cleanupStack.push(null);\n                }\n            }\n        });\n        this.eventHub.didEnterState.notify(this.currentState);\n    }\n    /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */ send(event) {\n        if (!this.knownEventTypes.has(event.type)) {\n            throw new Error(\"Invalid event \".concat(JSON.stringify(event.type)));\n        }\n        if (this.runningState === 2 /* STOPPED */ ) {\n            return;\n        }\n        const targetFn = this.getTargetFn(event.type);\n        if (targetFn !== void 0) {\n            return this.transition(event, targetFn);\n        } else {\n            this.eventHub.didIgnoreEvent.notify(event);\n        }\n    }\n    transition(event, target) {\n        this.eventHub.didReceiveEvent.notify(event);\n        const oldState = this.currentState;\n        const targetFn = typeof target === \"function\" ? target : ()=>target;\n        const nextTarget = targetFn(event, this.currentContext.current);\n        let nextState;\n        let effects = void 0;\n        if (nextTarget === null) {\n            this.eventHub.didIgnoreEvent.notify(event);\n            return;\n        }\n        if (typeof nextTarget === \"string\") {\n            nextState = nextTarget;\n        } else {\n            nextState = nextTarget.target;\n            effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [\n                nextTarget.effect\n            ];\n        }\n        if (!this.states.has(nextState)) {\n            throw new Error(\"Invalid next state name: \".concat(JSON.stringify(nextState)));\n        }\n        this.eventHub.willTransition.notify({\n            from: oldState,\n            to: nextState\n        });\n        const [up, down] = distance(this.currentState, nextState);\n        if (up > 0) {\n            this.exit(up);\n        }\n        this.currentStateOrNull = nextState;\n        if (effects !== void 0) {\n            const effectsToRun = effects;\n            this.currentContext.allowPatching((patchableContext)=>{\n                for (const effect of effectsToRun){\n                    if (typeof effect === \"function\") {\n                        effect(patchableContext, event);\n                    } else {\n                        patchableContext.patch(effect);\n                    }\n                }\n            });\n        }\n        if (down > 0) {\n            this.enter(down);\n        }\n    }\n    constructor(initialContext){\n        this.id = nextId++;\n        this.runningState = 0 /* NOT_STARTED_YET */ ;\n        this.currentStateOrNull = null;\n        this.states = /* @__PURE__ */ new Set();\n        this.enterFns = /* @__PURE__ */ new Map();\n        this.cleanupStack = [];\n        this.knownEventTypes = /* @__PURE__ */ new Set();\n        this.allowedTransitions = /* @__PURE__ */ new Map();\n        this.currentContext = new SafeContext(initialContext);\n        this.eventHub = {\n            didReceiveEvent: makeEventSource(),\n            willTransition: makeEventSource(),\n            didIgnoreEvent: makeEventSource(),\n            willExitState: makeEventSource(),\n            didEnterState: makeEventSource()\n        };\n        this.events = {\n            didReceiveEvent: this.eventHub.didReceiveEvent.observable,\n            willTransition: this.eventHub.willTransition.observable,\n            didIgnoreEvent: this.eventHub.didIgnoreEvent.observable,\n            willExitState: this.eventHub.willExitState.observable,\n            didEnterState: this.eventHub.didEnterState.observable\n        };\n    }\n};\n// src/lib/utils.ts\nfunction raise(msg) {\n    throw new Error(msg);\n}\nfunction isPlainObject(blob) {\n    return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction entries(obj) {\n    return Object.entries(obj);\n}\nfunction tryParseJson(rawMessage) {\n    try {\n        return JSON.parse(rawMessage);\n    } catch (e) {\n        return void 0;\n    }\n}\nfunction deepClone(value) {\n    return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n    try {\n        const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n        const decodedValue = decodeURIComponent(atob(formattedValue).split(\"\").map(function(c) {\n            return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n        }).join(\"\"));\n        return decodedValue;\n    } catch (err) {\n        return atob(b64value);\n    }\n}\nfunction compact(items) {\n    return items.filter((item)=>item !== null && item !== void 0);\n}\nfunction compactObject(obj) {\n    const newObj = {\n        ...obj\n    };\n    Object.keys(obj).forEach((k)=>{\n        const key = k;\n        if (newObj[key] === void 0) {\n            delete newObj[key];\n        }\n    });\n    return newObj;\n}\nasync function withTimeout(promise, millis, errmsg) {\n    let timerID;\n    const timer$ = new Promise((_, reject)=>{\n        timerID = setTimeout(()=>{\n            reject(new Error(errmsg));\n        }, millis);\n    });\n    return Promise.race([\n        promise,\n        timer$\n    ]).finally(()=>clearTimeout(timerID));\n}\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2)=>{\n    ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n    ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n    ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n    ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n    ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n    ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n    ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n    ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n    ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n    ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n    ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n    ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n    ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n    ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n    ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n    ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n    return ServerMsgCode2;\n})(ServerMsgCode || {});\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2)=>{\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n    return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n    return code === 4999 /* CLOSE_WITHOUT_RETRY */  || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n    return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n    return code === 1013 /* TRY_AGAIN_LATER */  || code >= 4200 && code < 4300;\n}\n// src/connection.ts\nfunction isIdle(status) {\n    return status === \"initial\" || status === \"disconnected\";\n}\nfunction newToLegacyStatus(status) {\n    switch(status){\n        case \"connecting\":\n            return \"connecting\";\n        case \"connected\":\n            return \"open\";\n        case \"reconnecting\":\n            return \"unavailable\";\n        case \"disconnected\":\n            return \"failed\";\n        case \"initial\":\n            return \"closed\";\n        default:\n            return \"closed\";\n    }\n}\nfunction toNewConnectionStatus(machine) {\n    const state = machine.currentState;\n    switch(state){\n        case \"@ok.connected\":\n        case \"@ok.awaiting-pong\":\n            return \"connected\";\n        case \"@idle.initial\":\n            return \"initial\";\n        case \"@auth.busy\":\n        case \"@auth.backoff\":\n        case \"@connecting.busy\":\n        case \"@connecting.backoff\":\n        case \"@idle.zombie\":\n            return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n        case \"@idle.failed\":\n            return \"disconnected\";\n        default:\n            return assertNever(state, \"Unknown state\");\n    }\n}\nvar BACKOFF_DELAYS = [\n    250,\n    500,\n    1e3,\n    2e3,\n    4e3,\n    8e3,\n    1e4\n];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [\n    2e3,\n    3e4,\n    6e4,\n    3e5\n];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n    constructor(reason){\n        super(reason);\n    }\n};\nvar LiveblocksError = class extends Error {\n    constructor(message, code){\n        super(message);\n        this.code = code;\n    }\n};\nfunction nextBackoffDelay(currentDelay) {\n    let delays = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : BACKOFF_DELAYS;\n    var _delays_find;\n    return (_delays_find = delays.find((delay)=>delay > currentDelay)) !== null && _delays_find !== void 0 ? _delays_find : delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n    context.patch({\n        backoffDelay: nextBackoffDelay(context.backoffDelay)\n    });\n}\nfunction increaseBackoffDelayAggressively(context) {\n    context.patch({\n        backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n    });\n}\nfunction resetSuccessCount(context) {\n    context.patch({\n        successCount: 0\n    });\n}\nfunction log(level, message) {\n    const logger = level === 2 /* ERROR */  ? error2 : level === 1 /* WARN */  ? warn : /* black hole */ ()=>{};\n    return ()=>{\n        logger(message);\n    };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n    const conn = \"Connection to Liveblocks websocket server\";\n    return (ctx)=>{\n        if (e instanceof Error) {\n            warn(\"\".concat(conn, \" could not be established. \").concat(String(e)));\n        } else {\n            warn(isCloseEvent(e) ? \"\".concat(conn, \" closed prematurely (code: \").concat(e.code, \"). Retrying in \").concat(ctx.backoffDelay, \"ms.\") : \"\".concat(conn, \" could not be established.\"));\n        }\n    };\n}\nfunction logCloseEvent(event) {\n    return (ctx)=>{\n        warn(\"Connection to Liveblocks websocket server closed (code: \".concat(event.code, \"). Retrying in \").concat(ctx.backoffDelay, \"ms.\"));\n    };\n}\nvar logPermanentClose = log(1 /* WARN */ , \"Connection to WebSocket closed permanently. Won't retry.\");\nfunction isCloseEvent(error3) {\n    return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n    const start = /* @__PURE__ */ new Date().getTime();\n    function log2() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        warn(\"\".concat(((/* @__PURE__ */ new Date().getTime() - start) / 1e3).toFixed(2), \" [FSM #\").concat(machine.id, \"]\"), ...args);\n    }\n    const unsubs = [\n        machine.events.didReceiveEvent.subscribe((e)=>log2(\"Event \".concat(e.type))),\n        machine.events.willTransition.subscribe((param)=>{\n            let { from, to } = param;\n            return log2(\"Transitioning\", from, \"\", to);\n        }),\n        machine.events.didIgnoreEvent.subscribe((e)=>log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\"))\n    ];\n    return ()=>{\n        for (const unsub of unsubs){\n            unsub();\n        }\n    };\n}\nfunction defineConnectivityEvents(machine) {\n    const statusDidChange = makeEventSource();\n    const didConnect = makeEventSource();\n    const didDisconnect = makeEventSource();\n    let lastStatus = null;\n    const unsubscribe = machine.events.didEnterState.subscribe(()=>{\n        const currStatus = toNewConnectionStatus(machine);\n        if (currStatus !== lastStatus) {\n            statusDidChange.notify(currStatus);\n        }\n        if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n            didDisconnect.notify();\n        } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n            didConnect.notify();\n        }\n        lastStatus = currStatus;\n    });\n    return {\n        statusDidChange: statusDidChange.observable,\n        didConnect: didConnect.observable,\n        didDisconnect: didDisconnect.observable,\n        unsubscribe\n    };\n}\nvar assign = (patch)=>(ctx)=>ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n    const onMessage = makeEventSource();\n    onMessage.pause();\n    const onLiveblocksError = makeEventSource();\n    function fireErrorEvent(errmsg, errcode) {\n        return ()=>{\n            const err = new LiveblocksError(errmsg, errcode);\n            onLiveblocksError.notify(err);\n        };\n    }\n    const initialContext = {\n        successCount: 0,\n        authValue: null,\n        socket: null,\n        backoffDelay: RESET_DELAY\n    };\n    const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n    machine.addTransitions(\"*\", {\n        RECONNECT: {\n            target: \"@auth.backoff\",\n            effect: [\n                increaseBackoffDelay,\n                resetSuccessCount\n            ]\n        },\n        DISCONNECT: \"@idle.initial\"\n    });\n    machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n        CONNECT: (_, ctx)=>// If we still have a known authValue, try to reconnect to the socket directly,\n            // otherwise, try to obtain a new authValue\n            ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    });\n    machine.addTransitions(\"@auth.backoff\", {\n        NAVIGATOR_ONLINE: {\n            target: \"@auth.busy\",\n            effect: assign({\n                backoffDelay: RESET_DELAY\n            })\n        }\n    }).addTimedTransition(\"@auth.backoff\", (ctx)=>ctx.backoffDelay, \"@auth.busy\").onEnterAsync(\"@auth.busy\", ()=>withTimeout(delegates.authenticate(), AUTH_TIMEOUT, \"Timed out during auth\"), // On successful authentication\n    (okEvent)=>({\n            target: \"@connecting.busy\",\n            effect: assign({\n                authValue: okEvent.data,\n                backoffDelay: RESET_DELAY\n            })\n        }), // Auth failed\n    (failedEvent)=>{\n        if (failedEvent.reason instanceof StopRetrying) {\n            return {\n                target: \"@idle.failed\",\n                effect: [\n                    log(2 /* ERROR */ , failedEvent.reason.message),\n                    fireErrorEvent(failedEvent.reason.message, -1)\n                ]\n            };\n        }\n        return {\n            target: \"@auth.backoff\",\n            effect: [\n                increaseBackoffDelay,\n                log(2 /* ERROR */ , \"Authentication failed: \".concat(failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)))\n            ]\n        };\n    });\n    const onSocketError = (event)=>machine.send({\n            type: \"EXPLICIT_SOCKET_ERROR\",\n            event\n        });\n    const onSocketClose = (event)=>machine.send({\n            type: \"EXPLICIT_SOCKET_CLOSE\",\n            event\n        });\n    const onSocketMessage = (event)=>event.data === \"pong\" ? machine.send({\n            type: \"PONG\"\n        }) : onMessage.notify(event);\n    function teardownSocket(socket) {\n        if (socket) {\n            socket.removeEventListener(\"error\", onSocketError);\n            socket.removeEventListener(\"close\", onSocketClose);\n            socket.removeEventListener(\"message\", onSocketMessage);\n            socket.close();\n        }\n    }\n    machine.addTransitions(\"@connecting.backoff\", {\n        NAVIGATOR_ONLINE: {\n            target: \"@connecting.busy\",\n            effect: assign({\n                backoffDelay: RESET_DELAY\n            })\n        }\n    }).addTimedTransition(\"@connecting.backoff\", (ctx)=>ctx.backoffDelay, \"@connecting.busy\").onEnterAsync(\"@connecting.busy\", //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx)=>{\n        let capturedPrematureEvent = null;\n        const connect$ = new Promise((resolve, rej)=>{\n            if (ctx.authValue === null) {\n                throw new Error(\"No auth authValue\");\n            }\n            const socket = delegates.createSocket(ctx.authValue);\n            function reject(event) {\n                capturedPrematureEvent = event;\n                socket.removeEventListener(\"message\", onSocketMessage);\n                rej(event);\n            }\n            const [actor$, didReceiveActor] = controlledPromise();\n            if (!options.waitForActorId) {\n                didReceiveActor();\n            }\n            function waitForActorId(event) {\n                const serverMsg = tryParseJson(event.data);\n                if ((serverMsg === null || serverMsg === void 0 ? void 0 : serverMsg.type) === 104 /* ROOM_STATE */ ) {\n                    didReceiveActor();\n                }\n            }\n            socket.addEventListener(\"message\", onSocketMessage);\n            if (options.waitForActorId) {\n                socket.addEventListener(\"message\", waitForActorId);\n            }\n            socket.addEventListener(\"error\", reject);\n            socket.addEventListener(\"close\", reject);\n            socket.addEventListener(\"open\", ()=>{\n                socket.addEventListener(\"error\", onSocketError);\n                socket.addEventListener(\"close\", onSocketClose);\n                const unsub = ()=>{\n                    socket.removeEventListener(\"error\", reject);\n                    socket.removeEventListener(\"close\", reject);\n                    socket.removeEventListener(\"message\", waitForActorId);\n                };\n                void actor$.then(()=>{\n                    resolve([\n                        socket,\n                        unsub\n                    ]);\n                });\n            });\n        });\n        return withTimeout(connect$, SOCKET_CONNECT_TIMEOUT, \"Timed out during websocket connection\").then(//\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        (param)=>{\n            let [socket, unsub] = param;\n            unsub();\n            if (capturedPrematureEvent) {\n                throw capturedPrematureEvent;\n            }\n            return socket;\n        });\n    }, // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent)=>({\n            target: \"@ok.connected\",\n            effect: assign({\n                socket: okEvent.data,\n                backoffDelay: RESET_DELAY\n            })\n        }), // If the WebSocket connection cannot be established\n    (failure)=>{\n        const err = failure.reason;\n        if (err instanceof StopRetrying) {\n            return {\n                target: \"@idle.failed\",\n                effect: [\n                    log(2 /* ERROR */ , err.message),\n                    fireErrorEvent(err.message, -1)\n                ]\n            };\n        }\n        if (isCloseEvent(err)) {\n            if (err.code === 4109 /* TOKEN_EXPIRED */ ) {\n                return \"@auth.busy\";\n            }\n            if (shouldRetryWithoutReauth(err.code)) {\n                return {\n                    target: \"@connecting.backoff\",\n                    effect: [\n                        increaseBackoffDelayAggressively,\n                        logPrematureErrorOrCloseEvent(err)\n                    ]\n                };\n            }\n            if (shouldDisconnect(err.code)) {\n                return {\n                    target: \"@idle.failed\",\n                    effect: [\n                        log(2 /* ERROR */ , err.reason),\n                        fireErrorEvent(err.reason, err.code)\n                    ]\n                };\n            }\n        }\n        return {\n            target: \"@auth.backoff\",\n            effect: [\n                increaseBackoffDelay,\n                logPrematureErrorOrCloseEvent(err)\n            ]\n        };\n    });\n    const sendHeartbeat = {\n        target: \"@ok.awaiting-pong\",\n        effect: (ctx)=>{\n            var _ctx_socket;\n            (_ctx_socket = ctx.socket) === null || _ctx_socket === void 0 ? void 0 : _ctx_socket.send(\"ping\");\n        }\n    };\n    const maybeHeartbeat = ()=>{\n        const doc = typeof document !== \"undefined\" ? document : void 0;\n        const canZombie = (doc === null || doc === void 0 ? void 0 : doc.visibilityState) === \"hidden\" && delegates.canZombie();\n        return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n    };\n    machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n        NAVIGATOR_OFFLINE: maybeHeartbeat,\n        // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n        WINDOW_GOT_FOCUS: sendHeartbeat\n    });\n    machine.addTransitions(\"@idle.zombie\", {\n        WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    });\n    machine.onEnter(\"@ok.*\", (ctx)=>{\n        ctx.patch({\n            successCount: ctx.successCount + 1\n        });\n        const timerID = setTimeout(// On the next tick, start delivering all messages that have already\n        // been received, and continue synchronous delivery of all future\n        // incoming messages.\n        onMessage.unpause, 0);\n        return (ctx2)=>{\n            teardownSocket(ctx2.socket);\n            ctx2.patch({\n                socket: null\n            });\n            clearTimeout(timerID);\n            onMessage.pause();\n        };\n    }).addTransitions(\"@ok.awaiting-pong\", {\n        PONG: \"@ok.connected\"\n    }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n        target: \"@connecting.busy\",\n        // Log implicit connection loss and drop the current open socket\n        effect: log(1 /* WARN */ , \"Received no pong from server, assume implicit connection loss.\")\n    }).addTransitions(\"@ok.*\", {\n        // When a socket receives an error, this can cause the closing of the\n        // socket, or not. So always check to see if the socket is still OPEN or\n        // not. When still OPEN, don't transition.\n        EXPLICIT_SOCKET_ERROR: (_, context)=>{\n            var _context_socket;\n            if (((_context_socket = context.socket) === null || _context_socket === void 0 ? void 0 : _context_socket.readyState) === 1) {\n                return null;\n            }\n            return {\n                target: \"@connecting.backoff\",\n                effect: increaseBackoffDelay\n            };\n        },\n        EXPLICIT_SOCKET_CLOSE: (e)=>{\n            if (shouldDisconnect(e.event.code)) {\n                return {\n                    target: \"@idle.failed\",\n                    effect: [\n                        logPermanentClose,\n                        fireErrorEvent(e.event.reason, e.event.code)\n                    ]\n                };\n            }\n            if (shouldReauth(e.event.code)) {\n                if (e.event.code === 4109 /* TOKEN_EXPIRED */ ) {\n                    return \"@auth.busy\";\n                } else {\n                    return {\n                        target: \"@auth.backoff\",\n                        effect: [\n                            increaseBackoffDelay,\n                            logCloseEvent(e.event)\n                        ]\n                    };\n                }\n            }\n            if (shouldRetryWithoutReauth(e.event.code)) {\n                return {\n                    target: \"@connecting.backoff\",\n                    effect: [\n                        increaseBackoffDelayAggressively,\n                        logCloseEvent(e.event)\n                    ]\n                };\n            }\n            return {\n                target: \"@connecting.backoff\",\n                effect: [\n                    increaseBackoffDelay,\n                    logCloseEvent(e.event)\n                ]\n            };\n        }\n    });\n    if (typeof document !== \"undefined\") {\n        const doc = typeof document !== \"undefined\" ? document : void 0;\n        const win =  true ? window : 0;\n        const root = win !== null && win !== void 0 ? win : doc;\n        machine.onEnter(\"*\", (ctx)=>{\n            function onNetworkOffline() {\n                machine.send({\n                    type: \"NAVIGATOR_OFFLINE\"\n                });\n            }\n            function onNetworkBackOnline() {\n                machine.send({\n                    type: \"NAVIGATOR_ONLINE\"\n                });\n            }\n            function onVisibilityChange() {\n                if ((doc === null || doc === void 0 ? void 0 : doc.visibilityState) === \"visible\") {\n                    machine.send({\n                        type: \"WINDOW_GOT_FOCUS\"\n                    });\n                }\n            }\n            win === null || win === void 0 ? void 0 : win.addEventListener(\"online\", onNetworkBackOnline);\n            win === null || win === void 0 ? void 0 : win.addEventListener(\"offline\", onNetworkOffline);\n            root === null || root === void 0 ? void 0 : root.addEventListener(\"visibilitychange\", onVisibilityChange);\n            return ()=>{\n                root === null || root === void 0 ? void 0 : root.removeEventListener(\"visibilitychange\", onVisibilityChange);\n                win === null || win === void 0 ? void 0 : win.removeEventListener(\"online\", onNetworkBackOnline);\n                win === null || win === void 0 ? void 0 : win.removeEventListener(\"offline\", onNetworkOffline);\n                teardownSocket(ctx.socket);\n            };\n        });\n    }\n    const cleanups = [];\n    const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n    cleanups.push(unsubscribe);\n    if (options.enableDebugLogging) {\n        cleanups.push(enableTracing(machine));\n    }\n    machine.start();\n    return {\n        machine,\n        cleanups,\n        // Observable events that will be emitted by this machine\n        events: {\n            statusDidChange,\n            didConnect,\n            didDisconnect,\n            onMessage: onMessage.observable,\n            onLiveblocksError: onLiveblocksError.observable\n        }\n    };\n}\nvar ManagedSocket = class {\n    getLegacyStatus() {\n        return newToLegacyStatus(this.getStatus());\n    }\n    getStatus() {\n        try {\n            return toNewConnectionStatus(this.machine);\n        } catch (e) {\n            return \"initial\";\n        }\n    }\n    /**\n   * Returns the current auth authValue.\n   */ get authValue() {\n        return this.machine.context.authValue;\n    }\n    /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */ connect() {\n        this.machine.send({\n            type: \"CONNECT\"\n        });\n    }\n    /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */ reconnect() {\n        this.machine.send({\n            type: \"RECONNECT\"\n        });\n    }\n    /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */ disconnect() {\n        this.machine.send({\n            type: \"DISCONNECT\"\n        });\n    }\n    /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */ destroy() {\n        this.machine.stop();\n        let cleanup;\n        while(cleanup = this.cleanups.pop()){\n            cleanup();\n        }\n    }\n    /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */ send(data) {\n        var _this_machine_context;\n        const socket = (_this_machine_context = this.machine.context) === null || _this_machine_context === void 0 ? void 0 : _this_machine_context.socket;\n        if (socket === null) {\n            warn(\"Cannot send: not connected yet\", data);\n        } else if (socket.readyState !== 1) {\n            warn(\"Cannot send: WebSocket no longer open\", data);\n        } else {\n            socket.send(data);\n        }\n    }\n    /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */ _privateSendMachineEvent(event) {\n        this.machine.send(event);\n    }\n    constructor(delegates, enableDebugLogging = false, waitForActorId = true){\n        const { machine, events, cleanups } = createConnectionStateMachine(delegates, {\n            waitForActorId,\n            enableDebugLogging\n        });\n        this.machine = machine;\n        this.events = events;\n        this.cleanups = cleanups;\n    }\n};\n// src/protocol/AuthToken.ts\nfunction canWriteStorage(scopes) {\n    return scopes.includes(\"room:write\" /* Write */ );\n}\nfunction canComment(scopes) {\n    return scopes.includes(\"comments:write\" /* CommentsWrite */ ) || scopes.includes(\"room:write\" /* Write */ );\n}\nfunction isValidAuthTokenPayload(data) {\n    return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */  || data.k === \"id\" /* ID_TOKEN */  || data.k === \"sec-legacy\" /* SECRET_LEGACY */ );\n}\nfunction parseAuthToken(rawTokenString) {\n    const tokenParts = rawTokenString.split(\".\");\n    if (tokenParts.length !== 3) {\n        throw new Error(\"Authentication error: invalid JWT token\");\n    }\n    const payload = tryParseJson(b64decode(tokenParts[1]));\n    if (!(payload && isValidAuthTokenPayload(payload))) {\n        throw new Error(\"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\");\n    }\n    return {\n        raw: rawTokenString,\n        parsed: payload\n    };\n}\n// src/auth-manager.ts\nfunction createAuthManager(authOptions) {\n    const authentication = prepareAuthentication(authOptions);\n    const seenTokens = /* @__PURE__ */ new Set();\n    const tokens = [];\n    const expiryTimes = [];\n    const requestPromises = /* @__PURE__ */ new Map();\n    function reset() {\n        seenTokens.clear();\n        tokens.length = 0;\n        expiryTimes.length = 0;\n        requestPromises.clear();\n    }\n    function hasCorrespondingScopes(requestedScope, scopes) {\n        if (requestedScope === \"comments:read\") {\n            return scopes.includes(\"comments:read\" /* CommentsRead */ ) || scopes.includes(\"comments:write\" /* CommentsWrite */ ) || scopes.includes(\"room:read\" /* Read */ ) || scopes.includes(\"room:write\" /* Write */ );\n        } else if (requestedScope === \"room:read\") {\n            return scopes.includes(\"room:read\" /* Read */ ) || scopes.includes(\"room:write\" /* Write */ );\n        }\n        return false;\n    }\n    function getCachedToken(requestedScope, roomId) {\n        const now = Math.ceil(Date.now() / 1e3);\n        for(let i = tokens.length - 1; i >= 0; i--){\n            const token = tokens[i];\n            const expiresAt = expiryTimes[i];\n            if (expiresAt <= now) {\n                tokens.splice(i, 1);\n                expiryTimes.splice(i, 1);\n                continue;\n            }\n            if (token.parsed.k === \"id\" /* ID_TOKEN */ ) {\n                return token;\n            } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */ ) {\n                for (const [resource, scopes] of Object.entries(token.parsed.perms)){\n                    if (resource.includes(\"*\") && roomId.startsWith(resource.replace(\"*\", \"\")) || roomId === resource && hasCorrespondingScopes(requestedScope, scopes)) {\n                        return token;\n                    }\n                }\n            }\n        }\n        return void 0;\n    }\n    async function makeAuthRequest(roomId) {\n        var _authOptions_polyfills;\n        var _authOptions_polyfills_fetch;\n        const fetcher = (_authOptions_polyfills_fetch = (_authOptions_polyfills = authOptions.polyfills) === null || _authOptions_polyfills === void 0 ? void 0 : _authOptions_polyfills.fetch) !== null && _authOptions_polyfills_fetch !== void 0 ? _authOptions_polyfills_fetch :  false ? 0 : window.fetch;\n        if (authentication.type === \"private\") {\n            if (fetcher === void 0) {\n                throw new StopRetrying(\"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\");\n            }\n            const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n                room: roomId\n            });\n            const parsed = parseAuthToken(response.token);\n            if (seenTokens.has(parsed.raw)) {\n                throw new StopRetrying(\"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\");\n            }\n            return parsed;\n        }\n        if (authentication.type === \"custom\") {\n            const response = await authentication.callback(roomId);\n            if (response && typeof response === \"object\") {\n                if (typeof response.token === \"string\") {\n                    return parseAuthToken(response.token);\n                } else if (typeof response.error === \"string\") {\n                    const reason = \"Authentication failed: \".concat(\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\");\n                    if (response.error === \"forbidden\") {\n                        throw new StopRetrying(reason);\n                    } else {\n                        throw new Error(reason);\n                    }\n                }\n            }\n            throw new Error('Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }');\n        }\n        throw new Error(\"Unexpected authentication type. Must be private or custom.\");\n    }\n    async function getAuthValue(requestedScope, roomId) {\n        if (authentication.type === \"public\") {\n            return {\n                type: \"public\",\n                publicApiKey: authentication.publicApiKey\n            };\n        }\n        const cachedToken = getCachedToken(requestedScope, roomId);\n        if (cachedToken !== void 0) {\n            return {\n                type: \"secret\",\n                token: cachedToken\n            };\n        }\n        let currentPromise = requestPromises.get(roomId);\n        if (currentPromise === void 0) {\n            currentPromise = makeAuthRequest(roomId);\n            requestPromises.set(roomId, currentPromise);\n        }\n        try {\n            const token = await currentPromise;\n            const BUFFER = 30;\n            const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n            seenTokens.add(token.raw);\n            if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */ ) {\n                tokens.push(token);\n                expiryTimes.push(expiresAt);\n            }\n            return {\n                type: \"secret\",\n                token\n            };\n        } finally{\n            requestPromises.delete(roomId);\n        }\n    }\n    return {\n        reset,\n        getAuthValue\n    };\n}\nfunction prepareAuthentication(authOptions) {\n    const { publicApiKey, authEndpoint } = authOptions;\n    if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n        throw new Error(\"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\");\n    }\n    if (typeof publicApiKey === \"string\") {\n        if (publicApiKey.startsWith(\"sk_\")) {\n            throw new Error(\"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\");\n        } else if (!publicApiKey.startsWith(\"pk_\")) {\n            throw new Error(\"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\");\n        }\n        return {\n            type: \"public\",\n            publicApiKey\n        };\n    }\n    if (typeof authEndpoint === \"string\") {\n        return {\n            type: \"private\",\n            url: authEndpoint\n        };\n    } else if (typeof authEndpoint === \"function\") {\n        return {\n            type: \"custom\",\n            callback: authEndpoint\n        };\n    } else if (authEndpoint !== void 0) {\n        throw new Error(\"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\");\n    }\n    throw new Error(\"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\");\n}\nasync function fetchAuthEndpoint(fetch2, endpoint, body) {\n    const res = await fetch2(endpoint, {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(body)\n    });\n    if (!res.ok) {\n        const reason = \"\".concat((await res.text()).trim() || \"reason not provided in auth response\", \" (\").concat(res.status, \" returned by POST \").concat(endpoint, \")\");\n        if (res.status === 401 || res.status === 403) {\n            throw new StopRetrying(\"Unauthorized: \".concat(reason));\n        } else {\n            throw new Error(\"Failed to authenticate: \".concat(reason));\n        }\n    }\n    let data;\n    try {\n        data = await res.json();\n    } catch (er) {\n        throw new Error('Expected a JSON response when doing a POST request on \"'.concat(endpoint, '\". ').concat(String(er)));\n    }\n    if (!isPlainObject(data) || typeof data.token !== \"string\") {\n        throw new Error('Expected a JSON response of the form `{ token: \"...\" }` when doing a POST request on \"'.concat(endpoint, '\", but got ').concat(JSON.stringify(data)));\n    }\n    const { token } = data;\n    return {\n        token\n    };\n}\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n    _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n    if (false) {}\n    const fullMsg = {\n        ...message,\n        source: \"liveblocks-devtools-client\"\n    };\n    if (!((options === null || options === void 0 ? void 0 : options.force) || _bridgeActive)) {\n        return;\n    }\n    window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif (true) {\n    window.addEventListener(\"message\", (event)=>{\n        var _event_data;\n        if (event.source === window && ((_event_data = event.data) === null || _event_data === void 0 ? void 0 : _event_data.source) === \"liveblocks-devtools-panel\") {\n            eventSource.notify(event.data);\n        } else {}\n    });\n}\nvar onMessageFromPanel = eventSource.observable;\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n    if (false) {}\n    if (_devtoolsSetupHasRun) {\n        return;\n    }\n    _devtoolsSetupHasRun = true;\n    onMessageFromPanel.subscribe((msg)=>{\n        switch(msg.msg){\n            case \"connect\":\n                {\n                    activateBridge(true);\n                    for (const roomId of getAllRooms()){\n                        sendToPanel({\n                            msg: \"room::available\",\n                            roomId,\n                            clientVersion: VERSION\n                        });\n                    }\n                    break;\n                }\n        }\n    });\n    sendToPanel({\n        msg: \"wake-up-devtools\"\n    }, {\n        force: true\n    });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n    var _unsubsByRoomId_get;\n    const unsubs = (_unsubsByRoomId_get = unsubsByRoomId.get(roomId)) !== null && _unsubsByRoomId_get !== void 0 ? _unsubsByRoomId_get : [];\n    unsubsByRoomId.delete(roomId);\n    for (const unsub of unsubs){\n        unsub();\n    }\n}\nfunction startSyncStream(room) {\n    stopSyncStream(room.id);\n    fullSync(room);\n    unsubsByRoomId.set(room.id, [\n        // When the connection status changes\n        room.events.status.subscribe(()=>partialSyncConnection(room)),\n        // When storage initializes, send the update\n        room.events.storageDidLoad.subscribeOnce(()=>partialSyncStorage(room)),\n        // Any time storage updates, send the new storage root\n        room.events.storage.subscribe(()=>partialSyncStorage(room)),\n        // Any time \"me\" or \"others\" updates, send the new values accordingly\n        room.events.self.subscribe(()=>partialSyncMe(room)),\n        room.events.others.subscribe(()=>partialSyncOthers(room)),\n        // Any time ydoc is updated, forward the update\n        room.events.ydoc.subscribe((update)=>syncYdocUpdate(room, update)),\n        // Any time a custom room event is received, forward it\n        room.events.customEvent.subscribe((eventData)=>forwardEvent(room, eventData))\n    ]);\n}\nfunction syncYdocUpdate(room, update) {\n    sendToPanel({\n        msg: \"room::sync::ydoc\",\n        roomId: room.id,\n        update\n    });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n    return \"event-\".concat(loadedAt, \"-\").concat(eventCounter++);\n}\nfunction forwardEvent(room, eventData) {\n    sendToPanel({\n        msg: \"room::events::custom-event\",\n        roomId: room.id,\n        event: {\n            type: \"CustomEvent\",\n            id: nextEventId(),\n            key: \"Event\",\n            connectionId: eventData.connectionId,\n            payload: eventData.event\n        }\n    });\n}\nfunction partialSyncConnection(room) {\n    sendToPanel({\n        msg: \"room::sync::partial\",\n        roomId: room.id,\n        status: room.getStatus()\n    });\n}\nfunction partialSyncStorage(room) {\n    const root = room.getStorageSnapshot();\n    if (root) {\n        sendToPanel({\n            msg: \"room::sync::partial\",\n            roomId: room.id,\n            storage: root.toTreeNode(\"root\").payload\n        });\n    }\n}\nfunction partialSyncMe(room) {\n    const me = room.__internal.getSelf_forDevTools();\n    if (me) {\n        sendToPanel({\n            msg: \"room::sync::partial\",\n            roomId: room.id,\n            me\n        });\n    }\n}\nfunction partialSyncOthers(room) {\n    const others = room.__internal.getOthers_forDevTools();\n    if (others) {\n        sendToPanel({\n            msg: \"room::sync::partial\",\n            roomId: room.id,\n            others\n        });\n    }\n}\nfunction fullSync(room) {\n    const root = room.getStorageSnapshot();\n    const me = room.__internal.getSelf_forDevTools();\n    const others = room.__internal.getOthers_forDevTools();\n    room.fetchYDoc(\"\");\n    var _root_toTreeNode_payload;\n    sendToPanel({\n        msg: \"room::sync::full\",\n        roomId: room.id,\n        status: room.getStatus(),\n        storage: (_root_toTreeNode_payload = root === null || root === void 0 ? void 0 : root.toTreeNode(\"root\").payload) !== null && _root_toTreeNode_payload !== void 0 ? _root_toTreeNode_payload : null,\n        me,\n        others\n    });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n    const listener = roomChannelListeners.get(roomId);\n    roomChannelListeners.delete(roomId);\n    if (listener) {\n        listener();\n    }\n}\nfunction linkDevTools(roomId, room) {\n    if (false) {}\n    sendToPanel({\n        msg: \"room::available\",\n        roomId,\n        clientVersion: VERSION\n    });\n    stopRoomChannelListener(roomId);\n    roomChannelListeners.set(roomId, // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg)=>{\n        switch(msg.msg){\n            case \"room::subscribe\":\n                {\n                    if (msg.roomId === roomId) {\n                        startSyncStream(room);\n                    }\n                    break;\n                }\n            case \"room::unsubscribe\":\n                {\n                    if (msg.roomId === roomId) {\n                        stopSyncStream(roomId);\n                    }\n                    break;\n                }\n        }\n    }));\n}\nfunction unlinkDevTools(roomId) {\n    if (false) {}\n    stopSyncStream(roomId);\n    stopRoomChannelListener(roomId);\n    sendToPanel({\n        msg: \"room::unavailable\",\n        roomId\n    });\n}\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message) {\n    let key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : message;\n    if (true) {\n        if (!_emittedDeprecationWarnings.has(key)) {\n            _emittedDeprecationWarnings.add(key);\n            errorWithTitle(\"Deprecation warning\", message);\n        }\n    }\n}\nfunction deprecateIf(condition, message) {\n    let key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : message;\n    if (true) {\n        if (condition) {\n            deprecate(message, key);\n        }\n    }\n}\nfunction throwUsageError(message) {\n    if (true) {\n        const usageError = new Error(message);\n        usageError.name = \"Usage error\";\n        errorWithTitle(\"Usage error\", message);\n        throw usageError;\n    }\n}\nfunction errorIf(condition, message) {\n    if (true) {\n        if (condition) {\n            throwUsageError(message);\n        }\n    }\n}\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n    return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyText(element) {\n    return \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n    return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n    return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n    paragraph: isCommentBodyParagraph,\n    text: isCommentBodyText,\n    link: isCommentBodyLink,\n    mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n    paragraph: \"block\",\n    text: \"inline\",\n    link: \"inline\",\n    mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n    if (!body || !(body === null || body === void 0 ? void 0 : body.content)) {\n        return;\n    }\n    const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n    const type = element ? commentBodyElementsTypes[element] : \"all\";\n    const guard = element ? commentBodyElementsGuards[element] : ()=>true;\n    const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n    for (const block of body.content){\n        if (type === \"all\" || type === \"block\") {\n            if (guard(block)) {\n                visitor === null || visitor === void 0 ? void 0 : visitor(block);\n            }\n        }\n        if (type === \"all\" || type === \"inline\") {\n            for (const inline of block.children){\n                if (guard(inline)) {\n                    visitor === null || visitor === void 0 ? void 0 : visitor(inline);\n                }\n            }\n        }\n    }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n    const mentionedIds = /* @__PURE__ */ new Set();\n    traverseCommentBody(body, \"mention\", (mention)=>mentionedIds.add(mention.id));\n    return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n    const resolvedUsers = /* @__PURE__ */ new Map();\n    if (!resolveUsers) {\n        return resolvedUsers;\n    }\n    const userIds = getMentionedIdsFromCommentBody(body);\n    const users = await resolveUsers({\n        userIds\n    });\n    for (const [index, userId] of userIds.entries()){\n        const user = users === null || users === void 0 ? void 0 : users[index];\n        if (user) {\n            resolvedUsers.set(userId, user);\n        }\n    }\n    return resolvedUsers;\n}\nvar htmlEscapables = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(Object.keys(htmlEscapables).map((entity)=>\"\\\\\".concat(entity)).join(\"|\"), \"g\");\nfunction htmlSafe(value) {\n    return new HtmlSafeString([\n        String(value)\n    ], []);\n}\nfunction joinHtml(strings) {\n    if (strings.length <= 0) {\n        return new HtmlSafeString([\n            \"\"\n        ], []);\n    }\n    return new HtmlSafeString([\n        \"\",\n        ...Array(strings.length - 1).fill(\"\"),\n        \"\"\n    ], strings);\n}\nfunction escapeHtml(value) {\n    if (value instanceof HtmlSafeString) {\n        return value.toString();\n    }\n    if (Array.isArray(value)) {\n        return joinHtml(value).toString();\n    }\n    return String(value).replace(htmlEscapablesRegex, (character)=>htmlEscapables[character]);\n}\nvar HtmlSafeString = class {\n    toString() {\n        return this._strings.reduce((result, str, i)=>{\n            return result + escapeHtml(nn(this._values[i - 1])) + str;\n        });\n    }\n    constructor(strings, values){\n        this._strings = strings;\n        this._values = values;\n    }\n};\nfunction html(strings) {\n    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        values[_key - 1] = arguments[_key];\n    }\n    return new HtmlSafeString(strings, values);\n}\nvar markdownEscapables = {\n    _: \"\\\\_\",\n    \"*\": \"\\\\*\",\n    \"#\": \"\\\\#\",\n    \"`\": \"\\\\`\",\n    \"~\": \"\\\\~\",\n    \"!\": \"\\\\!\",\n    \"|\": \"\\\\|\",\n    \"(\": \"\\\\(\",\n    \")\": \"\\\\)\",\n    \"{\": \"\\\\{\",\n    \"}\": \"\\\\}\",\n    \"[\": \"\\\\[\",\n    \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(Object.keys(markdownEscapables).map((entity)=>\"\\\\\".concat(entity)).join(\"|\"), \"g\");\nfunction joinMarkdown(strings) {\n    if (strings.length <= 0) {\n        return new MarkdownSafeString([\n            \"\"\n        ], []);\n    }\n    return new MarkdownSafeString([\n        \"\",\n        ...Array(strings.length - 1).fill(\"\"),\n        \"\"\n    ], strings);\n}\nfunction escapeMarkdown(value) {\n    if (value instanceof MarkdownSafeString) {\n        return value.toString();\n    }\n    if (Array.isArray(value)) {\n        return joinMarkdown(value).toString();\n    }\n    return String(value).replace(markdownEscapablesRegex, (character)=>markdownEscapables[character]);\n}\nvar MarkdownSafeString = class {\n    toString() {\n        return this._strings.reduce((result, str, i)=>{\n            return result + escapeMarkdown(nn(this._values[i - 1])) + str;\n        });\n    }\n    constructor(strings, values){\n        this._strings = strings;\n        this._values = values;\n    }\n};\nfunction markdown(strings) {\n    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        values[_key - 1] = arguments[_key];\n    }\n    return new MarkdownSafeString(strings, values);\n}\nfunction toAbsoluteUrl(url) {\n    if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n        return url;\n    } else if (url.startsWith(\"www.\")) {\n        return \"https://\" + url;\n    }\n    return;\n}\nvar stringifyCommentBodyPlainElements = {\n    paragraph: (param)=>{\n        let { children } = param;\n        return children;\n    },\n    text: (param)=>{\n        let { element } = param;\n        return element.text;\n    },\n    link: (param)=>{\n        let { element } = param;\n        return element.url;\n    },\n    mention: (param)=>{\n        let { element, user } = param;\n        var _user_name;\n        return \"@\".concat((_user_name = user === null || user === void 0 ? void 0 : user.name) !== null && _user_name !== void 0 ? _user_name : element.id);\n    }\n};\nvar stringifyCommentBodyHtmlElements = {\n    paragraph: (param)=>{\n        let { children } = param;\n        return children ? html(_templateObject(), htmlSafe(children)) : children;\n    },\n    text: (param)=>{\n        let { element } = param;\n        let children = element.text;\n        if (!children) {\n            return children;\n        }\n        if (element.bold) {\n            children = html(_templateObject1(), children);\n        }\n        if (element.italic) {\n            children = html(_templateObject2(), children);\n        }\n        if (element.strikethrough) {\n            children = html(_templateObject3(), children);\n        }\n        if (element.code) {\n            children = html(_templateObject4(), children);\n        }\n        return children;\n    },\n    link: (param)=>{\n        let { element, href } = param;\n        return html(_templateObject5(), href, element.url);\n    },\n    mention: (param)=>{\n        let { element, user } = param;\n        var _user_name;\n        return html(_templateObject6(), (_user_name = user === null || user === void 0 ? void 0 : user.name) !== null && _user_name !== void 0 ? _user_name : element.id);\n    }\n};\nvar stringifyCommentBodyMarkdownElements = {\n    paragraph: (param)=>{\n        let { children } = param;\n        return children;\n    },\n    text: (param)=>{\n        let { element } = param;\n        let children = element.text;\n        if (!children) {\n            return children;\n        }\n        if (element.bold) {\n            children = markdown(_templateObject7(), children);\n        }\n        if (element.italic) {\n            children = markdown(_templateObject8(), children);\n        }\n        if (element.strikethrough) {\n            children = markdown(_templateObject9(), children);\n        }\n        if (element.code) {\n            children = markdown(_templateObject10(), children);\n        }\n        return children;\n    },\n    link: (param)=>{\n        let { element, href } = param;\n        return markdown(_templateObject11(), element.url, href);\n    },\n    mention: (param)=>{\n        let { element, user } = param;\n        var _user_name;\n        return markdown(_templateObject12(), (_user_name = user === null || user === void 0 ? void 0 : user.name) !== null && _user_name !== void 0 ? _user_name : element.id);\n    }\n};\nasync function stringifyCommentBody(body, options) {\n    var _options_format;\n    const format = (_options_format = options === null || options === void 0 ? void 0 : options.format) !== null && _options_format !== void 0 ? _options_format : \"plain\";\n    var _options_separator;\n    const separator = (_options_separator = options === null || options === void 0 ? void 0 : options.separator) !== null && _options_separator !== void 0 ? _options_separator : format === \"markdown\" ? \"\\n\\n\" : \"\\n\";\n    const elements = {\n        ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n        ...options === null || options === void 0 ? void 0 : options.elements\n    };\n    const resolvedUsers = await resolveUsersInCommentBody(body, options === null || options === void 0 ? void 0 : options.resolveUsers);\n    const blocks = body.content.flatMap((block, blockIndex)=>{\n        switch(block.type){\n            case \"paragraph\":\n                {\n                    const inlines = block.children.flatMap((inline, inlineIndex)=>{\n                        if (isCommentBodyMention(inline)) {\n                            return inline.id ? [\n                                elements.mention({\n                                    element: inline,\n                                    user: resolvedUsers.get(inline.id)\n                                }, inlineIndex)\n                            ] : [];\n                        }\n                        if (isCommentBodyLink(inline)) {\n                            var _toAbsoluteUrl;\n                            return [\n                                elements.link({\n                                    element: inline,\n                                    href: (_toAbsoluteUrl = toAbsoluteUrl(inline.url)) !== null && _toAbsoluteUrl !== void 0 ? _toAbsoluteUrl : inline.url\n                                }, inlineIndex)\n                            ];\n                        }\n                        if (isCommentBodyText(inline)) {\n                            return [\n                                elements.text({\n                                    element: inline\n                                }, inlineIndex)\n                            ];\n                        }\n                        return [];\n                    });\n                    return [\n                        elements.paragraph({\n                            element: block,\n                            children: inlines.join(\"\")\n                        }, blockIndex)\n                    ];\n                }\n            default:\n                return [];\n        }\n    });\n    return blocks.join(separator);\n}\nfunction convertToCommentData(data) {\n    const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    const reactions = data.reactions.map((reaction)=>({\n            ...reaction,\n            createdAt: new Date(reaction.createdAt)\n        }));\n    if (data.body) {\n        return {\n            ...data,\n            reactions,\n            createdAt,\n            editedAt\n        };\n    } else {\n        const deletedAt = new Date(data.deletedAt);\n        return {\n            ...data,\n            reactions,\n            createdAt,\n            editedAt,\n            deletedAt\n        };\n    }\n}\nfunction convertToThreadData(data) {\n    const updatedAt = data.updatedAt ? new Date(data.updatedAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    const comments = data.comments.map((comment)=>convertToCommentData(comment));\n    return {\n        ...data,\n        createdAt,\n        updatedAt,\n        comments\n    };\n}\nfunction convertToCommentUserReaction(data) {\n    return {\n        ...data,\n        createdAt: new Date(data.createdAt)\n    };\n}\n// src/comments/index.ts\nfunction getAuthBearerHeaderFromAuthValue(authValue) {\n    if (authValue.type === \"public\") {\n        return authValue.publicApiKey;\n    } else {\n        return authValue.token.raw;\n    }\n}\nvar CommentsApiError = class extends Error {\n    constructor(message, status, details){\n        super(message);\n        this.message = message;\n        this.status = status;\n        this.details = details;\n    }\n};\nfunction createCommentsApi(roomId, getAuthValue, config) {\n    async function fetchJson(endpoint, options) {\n        const response = await fetchApi(roomId, endpoint, options);\n        if (!response.ok) {\n            if (response.status >= 400 && response.status < 600) {\n                let error3;\n                try {\n                    const errorBody = await response.json();\n                    error3 = new CommentsApiError(errorBody.message, response.status, errorBody);\n                } catch (e) {\n                    error3 = new CommentsApiError(response.statusText, response.status);\n                }\n                throw error3;\n            }\n        }\n        let body;\n        try {\n            body = await response.json();\n        } catch (e) {\n            body = {};\n        }\n        return body;\n    }\n    async function fetchApi(roomId2, endpoint, options) {\n        const authValue = await getAuthValue();\n        const url = new URL(\"/v2/c/rooms/\".concat(encodeURIComponent(roomId2)).concat(endpoint), config.baseUrl);\n        return await fetch(url.toString(), {\n            ...options,\n            headers: {\n                ...options === null || options === void 0 ? void 0 : options.headers,\n                Authorization: \"Bearer \".concat(getAuthBearerHeaderFromAuthValue(authValue))\n            }\n        });\n    }\n    async function getThreads(options) {\n        var _options_query;\n        const response = await fetchApi(roomId, \"/threads/search\", {\n            body: JSON.stringify({\n                ...(options === null || options === void 0 ? void 0 : (_options_query = options.query) === null || _options_query === void 0 ? void 0 : _options_query.metadata) && {\n                    metadata: options.query.metadata\n                }\n            }),\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\"\n        });\n        if (response.ok) {\n            const json = await response.json();\n            return json.data.map((thread)=>convertToThreadData(thread));\n        } else if (response.status === 404) {\n            return [];\n        } else {\n            throw new Error(\"There was an error while getting threads.\");\n        }\n    }\n    async function createThread(param) {\n        let { metadata, body, commentId, threadId } = param;\n        const thread = await fetchJson(\"/threads\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                id: threadId,\n                comment: {\n                    id: commentId,\n                    body\n                },\n                metadata\n            })\n        });\n        return convertToThreadData(thread);\n    }\n    async function editThreadMetadata(param) {\n        let { metadata, threadId } = param;\n        return await fetchJson(\"/threads/\".concat(encodeURIComponent(threadId), \"/metadata\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(metadata)\n        });\n    }\n    async function createComment(param) {\n        let { threadId, commentId, body } = param;\n        const comment = await fetchJson(\"/threads/\".concat(encodeURIComponent(threadId), \"/comments\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                id: commentId,\n                body\n            })\n        });\n        return convertToCommentData(comment);\n    }\n    async function editComment(param) {\n        let { threadId, commentId, body } = param;\n        const comment = await fetchJson(\"/threads/\".concat(encodeURIComponent(threadId), \"/comments/\").concat(encodeURIComponent(commentId)), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                body\n            })\n        });\n        return convertToCommentData(comment);\n    }\n    async function deleteComment(param) {\n        let { threadId, commentId } = param;\n        await fetchJson(\"/threads/\".concat(encodeURIComponent(threadId), \"/comments/\").concat(encodeURIComponent(commentId)), {\n            method: \"DELETE\"\n        });\n    }\n    async function addReaction(param) {\n        let { threadId, commentId, emoji } = param;\n        const reaction = await fetchJson(\"/threads/\".concat(encodeURIComponent(threadId), \"/comments/\").concat(encodeURIComponent(commentId), \"/reactions\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                emoji\n            })\n        });\n        return convertToCommentUserReaction(reaction);\n    }\n    async function removeReaction(param) {\n        let { threadId, commentId, emoji } = param;\n        await fetchJson(\"/threads/\".concat(encodeURIComponent(threadId), \"/comments/\").concat(encodeURIComponent(commentId), \"/reactions/\").concat(encodeURIComponent(emoji)), {\n            method: \"DELETE\"\n        });\n    }\n    return {\n        getThreads,\n        createThread,\n        editThreadMetadata,\n        createComment,\n        editComment,\n        deleteComment,\n        addReaction,\n        removeReaction\n    };\n}\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n    const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n    if (code < MIN_CODE || code > MAX_CODE) {\n        throw new Error(\"Invalid n value: \".concat(n));\n    }\n    return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n    if (x !== void 0 && y !== void 0) {\n        return between(x, y);\n    } else if (x !== void 0) {\n        return after(x);\n    } else if (y !== void 0) {\n        return before(y);\n    } else {\n        return ONE;\n    }\n}\nfunction before(pos) {\n    const lastIndex = pos.length - 1;\n    for(let i = 0; i <= lastIndex; i++){\n        const code = pos.charCodeAt(i);\n        if (code <= MIN_CODE) {\n            continue;\n        }\n        if (i === lastIndex) {\n            if (code === MIN_CODE + 1) {\n                return pos.substring(0, i) + ZERO_NINE;\n            } else {\n                return pos.substring(0, i) + String.fromCharCode(code - 1);\n            }\n        } else {\n            return pos.substring(0, i + 1);\n        }\n    }\n    return ONE;\n}\nfunction after(pos) {\n    for(let i = 0; i <= pos.length - 1; i++){\n        const code = pos.charCodeAt(i);\n        if (code >= MAX_CODE) {\n            continue;\n        }\n        return pos.substring(0, i) + String.fromCharCode(code + 1);\n    }\n    return pos + ONE;\n}\nfunction between(lo, hi) {\n    if (lo < hi) {\n        return _between(lo, hi);\n    } else if (lo > hi) {\n        return _between(hi, lo);\n    } else {\n        throw new Error(\"Cannot compute value between two equal positions\");\n    }\n}\nfunction _between(lo, hi) {\n    let index = 0;\n    const loLen = lo.length;\n    const hiLen = hi.length;\n    while(true){\n        const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n        const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n        if (loCode === hiCode) {\n            index++;\n            continue;\n        }\n        if (hiCode - loCode === 1) {\n            const size = index + 1;\n            let prefix = lo.substring(0, size);\n            if (prefix.length < size) {\n                prefix += ZERO.repeat(size - prefix.length);\n            }\n            const suffix = lo.substring(size);\n            const nines = \"\";\n            return prefix + _between(suffix, nines);\n        } else {\n            return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n        }\n    }\n}\nfunction takeN(pos, n) {\n    return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n    if (str === \"\") {\n        return false;\n    }\n    const lastIdx = str.length - 1;\n    const last = str.charCodeAt(lastIdx);\n    if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n        return false;\n    }\n    for(let i = 0; i < lastIdx; i++){\n        const code = str.charCodeAt(i);\n        if (code < MIN_CODE || code > MAX_CODE) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction convertToPos(str) {\n    const codes = [];\n    for(let i = 0; i < str.length; i++){\n        const code = str.charCodeAt(i);\n        codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n    }\n    while(codes.length > 0 && codes[codes.length - 1] === MIN_CODE){\n        codes.length--;\n    }\n    return codes.length > 0 ? String.fromCharCode(...codes) : // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE;\n}\nfunction asPos(str) {\n    return isPos(str) ? str : convertToPos(str);\n}\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2)=>{\n    OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n    OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n    OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n    OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n    OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n    OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n    OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n    OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n    OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n    return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n    return {\n        type: 5 /* DELETE_CRDT */ ,\n        id: \"ACK\",\n        // (H)ACK\n        opId\n    };\n}\nfunction isAckOp(op) {\n    return op.type === 5 /* DELETE_CRDT */  && op.id === \"ACK\";\n}\n// src/crdts/AbstractCrdt.ts\nfunction crdtAsLiveNode(value) {\n    return value;\n}\nfunction HasParent(node, key) {\n    let pos = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : asPos(key);\n    return Object.freeze({\n        type: \"HasParent\",\n        node,\n        key,\n        pos\n    });\n}\n_c = HasParent;\nvar NoParent = Object.freeze({\n    type: \"NoParent\"\n});\nfunction Orphaned(oldKey) {\n    let oldPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : asPos(oldKey);\n    return Object.freeze({\n        type: \"Orphaned\",\n        oldKey,\n        oldPos\n    });\n}\n_c1 = Orphaned;\nvar AbstractCrdt = class {\n    /** @internal */ _getParentKeyOrThrow() {\n        switch(this.parent.type){\n            case \"HasParent\":\n                return this.parent.key;\n            case \"NoParent\":\n                throw new Error(\"Parent key is missing\");\n            case \"Orphaned\":\n                return this.parent.oldKey;\n            default:\n                return assertNever(this.parent, \"Unknown state\");\n        }\n    }\n    /** @internal */ get _parentPos() {\n        switch(this.parent.type){\n            case \"HasParent\":\n                return this.parent.pos;\n            case \"NoParent\":\n                throw new Error(\"Parent key is missing\");\n            case \"Orphaned\":\n                return this.parent.oldPos;\n            default:\n                return assertNever(this.parent, \"Unknown state\");\n        }\n    }\n    /** @internal */ get _pool() {\n        return this.__pool;\n    }\n    get roomId() {\n        return this.__pool ? this.__pool.roomId : null;\n    }\n    /** @internal */ get _id() {\n        return this.__id;\n    }\n    /** @internal */ get parent() {\n        return this._parent;\n    }\n    /** @internal */ get _parentKey() {\n        switch(this.parent.type){\n            case \"HasParent\":\n                return this.parent.key;\n            case \"NoParent\":\n                return null;\n            case \"Orphaned\":\n                return this.parent.oldKey;\n            default:\n                return assertNever(this.parent, \"Unknown state\");\n        }\n    }\n    /** @internal */ _apply(op, _isLocal) {\n        switch(op.type){\n            case 5 /* DELETE_CRDT */ :\n                {\n                    if (this.parent.type === \"HasParent\") {\n                        return this.parent.node._detachChild(crdtAsLiveNode(this));\n                    }\n                    return {\n                        modified: false\n                    };\n                }\n        }\n        return {\n            modified: false\n        };\n    }\n    /** @internal */ _setParentLink(newParentNode, newParentKey) {\n        switch(this.parent.type){\n            case \"HasParent\":\n                if (this.parent.node !== newParentNode) {\n                    throw new Error(\"Cannot set parent: node already has a parent\");\n                } else {\n                    this._parent = HasParent(newParentNode, newParentKey);\n                    return;\n                }\n            case \"Orphaned\":\n            case \"NoParent\":\n                {\n                    this._parent = HasParent(newParentNode, newParentKey);\n                    return;\n                }\n            default:\n                return assertNever(this.parent, \"Unknown state\");\n        }\n    }\n    /** @internal */ _attach(id, pool) {\n        if (this.__id || this.__pool) {\n            throw new Error(\"Cannot attach node: already attached\");\n        }\n        pool.addNode(id, crdtAsLiveNode(this));\n        this.__id = id;\n        this.__pool = pool;\n    }\n    /** @internal */ _detach() {\n        if (this.__pool && this.__id) {\n            this.__pool.deleteNode(this.__id);\n        }\n        switch(this.parent.type){\n            case \"HasParent\":\n                {\n                    this._parent = Orphaned(this.parent.key, this.parent.pos);\n                    break;\n                }\n            case \"NoParent\":\n                {\n                    this._parent = NoParent;\n                    break;\n                }\n            case \"Orphaned\":\n                {\n                    break;\n                }\n            default:\n                assertNever(this.parent, \"Unknown state\");\n        }\n        this.__pool = void 0;\n    }\n    /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */ invalidate() {\n        if (this._cachedImmutable !== void 0 || this._cachedTreeNode !== void 0) {\n            this._cachedImmutable = void 0;\n            this._cachedTreeNode = void 0;\n            if (this.parent.type === \"HasParent\") {\n                this.parent.node.invalidate();\n            }\n        }\n    }\n    /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */ toTreeNode(key) {\n        if (this._cachedTreeNode === void 0 || this._cachedTreeNodeKey !== key) {\n            this._cachedTreeNodeKey = key;\n            this._cachedTreeNode = this._toTreeNode(key);\n        }\n        return this._cachedTreeNode;\n    }\n    /**\n   * Return an immutable snapshot of this Live node and its children.\n   */ toImmutable() {\n        if (this._cachedImmutable === void 0) {\n            this._cachedImmutable = this._toImmutable();\n        }\n        return this._cachedImmutable;\n    }\n    constructor(){\n        /** @internal */ this._parent = NoParent;\n    }\n};\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2)=>{\n    CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n    CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n    CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n    CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n    return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n    return crdt.type === 0 /* OBJECT */  && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n    return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n// src/lib/nanoid.ts\nfunction nanoid() {\n    let length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 7;\n    const alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,./;[]~!@#$%&*()_+=-\";\n    const len = alphabet.length;\n    return Array.from({\n        length\n    }, ()=>alphabet.charAt(Math.floor(Math.random() * len))).join(\"\");\n}\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n    get data() {\n        return this._data;\n    }\n    /** @internal */ static _deserialize(param, _parentToChildren, pool) {\n        let [id, item] = param;\n        const register = new _LiveRegister(item.data);\n        register._attach(id, pool);\n        return register;\n    }\n    /** @internal */ _toOps(parentId, parentKey, pool) {\n        if (this._id === void 0) {\n            throw new Error(\"Cannot serialize register if parentId or parentKey is undefined\");\n        }\n        return [\n            {\n                type: 8 /* CREATE_REGISTER */ ,\n                opId: pool === null || pool === void 0 ? void 0 : pool.generateOpId(),\n                id: this._id,\n                parentId,\n                parentKey,\n                data: this.data\n            }\n        ];\n    }\n    /** @internal */ _serialize() {\n        if (this.parent.type !== \"HasParent\") {\n            throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n        }\n        return {\n            type: 3 /* REGISTER */ ,\n            parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n            parentKey: this.parent.key,\n            data: this.data\n        };\n    }\n    /** @internal */ _attachChild(_op) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @internal */ _detachChild(_crdt) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @internal */ _apply(op, isLocal) {\n        return super._apply(op, isLocal);\n    }\n    /** @internal */ _toTreeNode(key) {\n        var _this__id;\n        return {\n            type: \"Json\",\n            id: (_this__id = this._id) !== null && _this__id !== void 0 ? _this__id : nanoid(),\n            key,\n            payload: this._data\n        };\n    }\n    /** @internal */ _toImmutable() {\n        return this._data;\n    }\n    clone() {\n        return deepClone(this.data);\n    }\n    constructor(data){\n        super();\n        this._data = data;\n    }\n};\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n    const posA = itemA._parentPos;\n    const posB = itemB._parentPos;\n    return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n    /** @internal */ static _deserialize(param, parentToChildren, pool) {\n        let [id] = param;\n        const list = new _LiveList();\n        list._attach(id, pool);\n        const children = parentToChildren.get(id);\n        if (children === void 0) {\n            return list;\n        }\n        for (const [id2, crdt] of children){\n            const child = deserialize([\n                id2,\n                crdt\n            ], parentToChildren, pool);\n            child._setParentLink(list, crdt.parentKey);\n            list._insertAndSort(child);\n        }\n        return list;\n    }\n    /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */ _toOps(parentId, parentKey, pool) {\n        if (this._id === void 0) {\n            throw new Error(\"Cannot serialize item is not attached\");\n        }\n        const ops = [];\n        const op = {\n            id: this._id,\n            opId: pool === null || pool === void 0 ? void 0 : pool.generateOpId(),\n            type: 2 /* CREATE_LIST */ ,\n            parentId,\n            parentKey\n        };\n        ops.push(op);\n        for (const item of this._items){\n            const parentKey2 = item._getParentKeyOrThrow();\n            const childOps = HACK_addIntentAndDeletedIdToOperation(item._toOps(this._id, parentKey2, pool), void 0);\n            const childOpId = childOps[0].opId;\n            if (childOpId !== void 0) {\n                this._unacknowledgedSets.set(parentKey2, childOpId);\n            }\n            ops.push(...childOps);\n        }\n        return ops;\n    }\n    /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */ _insertAndSort(item) {\n        this._items.push(item);\n        this._sortItems();\n    }\n    /** @internal */ _sortItems() {\n        this._items.sort(compareNodePosition);\n        this.invalidate();\n    }\n    /** @internal */ _indexOfPosition(position) {\n        return this._items.findIndex((item)=>item._getParentKeyOrThrow() === position);\n    }\n    /** @internal */ _attach(id, pool) {\n        super._attach(id, pool);\n        for (const item of this._items){\n            item._attach(pool.generateId(), pool);\n        }\n    }\n    /** @internal */ _detach() {\n        super._detach();\n        for (const item of this._items){\n            item._detach();\n        }\n    }\n    /** @internal */ _applySetRemote(op) {\n        if (this._pool === void 0) {\n            throw new Error(\"Can't attach child if managed pool is not present\");\n        }\n        const { id, parentKey: key } = op;\n        const child = creationOpToLiveNode(op);\n        child._attach(id, this._pool);\n        child._setParentLink(this, key);\n        const deletedId = op.deletedId;\n        const indexOfItemWithSamePosition = this._indexOfPosition(key);\n        if (indexOfItemWithSamePosition !== -1) {\n            const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n            if (itemWithSamePosition._id === deletedId) {\n                itemWithSamePosition._detach();\n                this._items[indexOfItemWithSamePosition] = child;\n                return {\n                    modified: makeUpdate(this, [\n                        setDelta(indexOfItemWithSamePosition, child)\n                    ]),\n                    reverse: []\n                };\n            } else {\n                this._implicitlyDeletedItems.add(itemWithSamePosition);\n                this._items[indexOfItemWithSamePosition] = child;\n                const delta = [\n                    setDelta(indexOfItemWithSamePosition, child)\n                ];\n                const deleteDelta2 = this._detachItemAssociatedToSetOperation(op.deletedId);\n                if (deleteDelta2) {\n                    delta.push(deleteDelta2);\n                }\n                return {\n                    modified: makeUpdate(this, delta),\n                    reverse: []\n                };\n            }\n        } else {\n            const updates = [];\n            const deleteDelta2 = this._detachItemAssociatedToSetOperation(op.deletedId);\n            if (deleteDelta2) {\n                updates.push(deleteDelta2);\n            }\n            this._insertAndSort(child);\n            updates.push(insertDelta(this._indexOfPosition(key), child));\n            return {\n                reverse: [],\n                modified: makeUpdate(this, updates)\n            };\n        }\n    }\n    /** @internal */ _applySetAck(op) {\n        if (this._pool === void 0) {\n            throw new Error(\"Can't attach child if managed pool is not present\");\n        }\n        const delta = [];\n        const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n        if (deletedDelta) {\n            delta.push(deletedDelta);\n        }\n        const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n        if (unacknowledgedOpId !== void 0) {\n            if (unacknowledgedOpId !== op.opId) {\n                return delta.length === 0 ? {\n                    modified: false\n                } : {\n                    modified: makeUpdate(this, delta),\n                    reverse: []\n                };\n            } else {\n                this._unacknowledgedSets.delete(op.parentKey);\n            }\n        }\n        const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n        const existingItem = this._items.find((item)=>item._id === op.id);\n        if (existingItem !== void 0) {\n            if (existingItem._parentKey === op.parentKey) {\n                return {\n                    modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n                    reverse: []\n                };\n            }\n            if (indexOfItemWithSamePosition !== -1) {\n                this._implicitlyDeletedItems.add(this._items[indexOfItemWithSamePosition]);\n                this._items.splice(indexOfItemWithSamePosition, 1);\n                delta.push(deleteDelta(indexOfItemWithSamePosition));\n            }\n            const previousIndex = this._items.indexOf(existingItem);\n            existingItem._setParentLink(this, op.parentKey);\n            this._sortItems();\n            const newIndex = this._items.indexOf(existingItem);\n            if (newIndex !== previousIndex) {\n                delta.push(moveDelta(previousIndex, newIndex, existingItem));\n            }\n            return {\n                modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n                reverse: []\n            };\n        } else {\n            const orphan = this._pool.getNode(op.id);\n            if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n                orphan._setParentLink(this, op.parentKey);\n                this._implicitlyDeletedItems.delete(orphan);\n                this._insertAndSort(orphan);\n                const recreatedItemIndex = this._items.indexOf(orphan);\n                return {\n                    modified: makeUpdate(this, [\n                        // If there is an item at this position, update is a set, else it's an insert\n                        indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n                        ...delta\n                    ]),\n                    reverse: []\n                };\n            } else {\n                if (indexOfItemWithSamePosition !== -1) {\n                    this._items.splice(indexOfItemWithSamePosition, 1);\n                }\n                const { newItem, newIndex } = this._createAttachItemAndSort(op, op.parentKey);\n                return {\n                    modified: makeUpdate(this, [\n                        // If there is an item at this position, update is a set, else it's an insert\n                        indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n                        ...delta\n                    ]),\n                    reverse: []\n                };\n            }\n        }\n    }\n    /**\n   * Returns the update delta of the deletion or null\n   * @internal\n   */ _detachItemAssociatedToSetOperation(deletedId) {\n        if (deletedId === void 0 || this._pool === void 0) {\n            return null;\n        }\n        const deletedItem = this._pool.getNode(deletedId);\n        if (deletedItem === void 0) {\n            return null;\n        }\n        const result = this._detachChild(deletedItem);\n        if (result.modified === false) {\n            return null;\n        }\n        return result.modified.updates[0];\n    }\n    /** @internal */ _applyRemoteInsert(op) {\n        if (this._pool === void 0) {\n            throw new Error(\"Can't attach child if managed pool is not present\");\n        }\n        const key = asPos(op.parentKey);\n        const existingItemIndex = this._indexOfPosition(key);\n        if (existingItemIndex !== -1) {\n            this._shiftItemPosition(existingItemIndex, key);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n        return {\n            modified: makeUpdate(this, [\n                insertDelta(newIndex, newItem)\n            ]),\n            reverse: []\n        };\n    }\n    /** @internal */ _applyInsertAck(op) {\n        const existingItem = this._items.find((item)=>item._id === op.id);\n        const key = asPos(op.parentKey);\n        const itemIndexAtPosition = this._indexOfPosition(key);\n        if (existingItem) {\n            if (existingItem._parentKey === key) {\n                return {\n                    modified: false\n                };\n            } else {\n                const oldPositionIndex = this._items.indexOf(existingItem);\n                if (itemIndexAtPosition !== -1) {\n                    this._shiftItemPosition(itemIndexAtPosition, key);\n                }\n                existingItem._setParentLink(this, key);\n                this._sortItems();\n                const newIndex = this._indexOfPosition(key);\n                if (newIndex === oldPositionIndex) {\n                    return {\n                        modified: false\n                    };\n                }\n                return {\n                    modified: makeUpdate(this, [\n                        moveDelta(oldPositionIndex, newIndex, existingItem)\n                    ]),\n                    reverse: []\n                };\n            }\n        } else {\n            const orphan = nn(this._pool).getNode(op.id);\n            if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n                orphan._setParentLink(this, key);\n                this._implicitlyDeletedItems.delete(orphan);\n                this._insertAndSort(orphan);\n                const newIndex = this._indexOfPosition(key);\n                return {\n                    modified: makeUpdate(this, [\n                        insertDelta(newIndex, orphan)\n                    ]),\n                    reverse: []\n                };\n            } else {\n                if (itemIndexAtPosition !== -1) {\n                    this._shiftItemPosition(itemIndexAtPosition, key);\n                }\n                const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n                return {\n                    modified: makeUpdate(this, [\n                        insertDelta(newIndex, newItem)\n                    ]),\n                    reverse: []\n                };\n            }\n        }\n    }\n    /** @internal */ _applyInsertUndoRedo(op) {\n        var _this__pool;\n        const { id, parentKey: key } = op;\n        const child = creationOpToLiveNode(op);\n        if (((_this__pool = this._pool) === null || _this__pool === void 0 ? void 0 : _this__pool.getNode(id)) !== void 0) {\n            return {\n                modified: false\n            };\n        }\n        child._attach(id, nn(this._pool));\n        child._setParentLink(this, key);\n        const existingItemIndex = this._indexOfPosition(key);\n        let newKey = key;\n        if (existingItemIndex !== -1) {\n            var _this__items_existingItemIndex, _this__items_;\n            const before2 = (_this__items_existingItemIndex = this._items[existingItemIndex]) === null || _this__items_existingItemIndex === void 0 ? void 0 : _this__items_existingItemIndex._parentPos;\n            const after2 = (_this__items_ = this._items[existingItemIndex + 1]) === null || _this__items_ === void 0 ? void 0 : _this__items_._parentPos;\n            newKey = makePosition(before2, after2);\n            child._setParentLink(this, newKey);\n        }\n        this._insertAndSort(child);\n        const newIndex = this._indexOfPosition(newKey);\n        return {\n            modified: makeUpdate(this, [\n                insertDelta(newIndex, child)\n            ]),\n            reverse: [\n                {\n                    type: 5 /* DELETE_CRDT */ ,\n                    id\n                }\n            ]\n        };\n    }\n    /** @internal */ _applySetUndoRedo(op) {\n        var _this__pool;\n        const { id, parentKey: key } = op;\n        const child = creationOpToLiveNode(op);\n        if (((_this__pool = this._pool) === null || _this__pool === void 0 ? void 0 : _this__pool.getNode(id)) !== void 0) {\n            return {\n                modified: false\n            };\n        }\n        this._unacknowledgedSets.set(key, nn(op.opId));\n        const indexOfItemWithSameKey = this._indexOfPosition(key);\n        child._attach(id, nn(this._pool));\n        child._setParentLink(this, key);\n        const newKey = key;\n        if (indexOfItemWithSameKey !== -1) {\n            const existingItem = this._items[indexOfItemWithSameKey];\n            existingItem._detach();\n            this._items[indexOfItemWithSameKey] = child;\n            const reverse = HACK_addIntentAndDeletedIdToOperation(existingItem._toOps(nn(this._id), key, this._pool), op.id);\n            const delta = [\n                setDelta(indexOfItemWithSameKey, child)\n            ];\n            const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n            if (deletedDelta) {\n                delta.push(deletedDelta);\n            }\n            return {\n                modified: makeUpdate(this, delta),\n                reverse\n            };\n        } else {\n            this._insertAndSort(child);\n            this._detachItemAssociatedToSetOperation(op.deletedId);\n            const newIndex = this._indexOfPosition(newKey);\n            return {\n                reverse: [\n                    {\n                        type: 5 /* DELETE_CRDT */ ,\n                        id\n                    }\n                ],\n                modified: makeUpdate(this, [\n                    insertDelta(newIndex, child)\n                ])\n            };\n        }\n    }\n    /** @internal */ _attachChild(op, source) {\n        if (this._pool === void 0) {\n            throw new Error(\"Can't attach child if managed pool is not present\");\n        }\n        let result;\n        if (op.intent === \"set\") {\n            if (source === 1 /* REMOTE */ ) {\n                result = this._applySetRemote(op);\n            } else if (source === 2 /* ACK */ ) {\n                result = this._applySetAck(op);\n            } else {\n                result = this._applySetUndoRedo(op);\n            }\n        } else {\n            if (source === 1 /* REMOTE */ ) {\n                result = this._applyRemoteInsert(op);\n            } else if (source === 2 /* ACK */ ) {\n                result = this._applyInsertAck(op);\n            } else {\n                result = this._applyInsertUndoRedo(op);\n            }\n        }\n        if (result.modified !== false) {\n            this.invalidate();\n        }\n        return result;\n    }\n    /** @internal */ _detachChild(child) {\n        if (child) {\n            const parentKey = nn(child._parentKey);\n            const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n            const indexToDelete = this._items.indexOf(child);\n            if (indexToDelete === -1) {\n                return {\n                    modified: false\n                };\n            }\n            this._items.splice(indexToDelete, 1);\n            this.invalidate();\n            child._detach();\n            return {\n                modified: makeUpdate(this, [\n                    deleteDelta(indexToDelete)\n                ]),\n                reverse\n            };\n        }\n        return {\n            modified: false\n        };\n    }\n    /** @internal */ _applySetChildKeyRemote(newKey, child) {\n        if (this._implicitlyDeletedItems.has(child)) {\n            this._implicitlyDeletedItems.delete(child);\n            child._setParentLink(this, newKey);\n            this._insertAndSort(child);\n            const newIndex = this._items.indexOf(child);\n            return {\n                modified: makeUpdate(this, [\n                    insertDelta(newIndex, child)\n                ]),\n                reverse: []\n            };\n        }\n        const previousKey = child._parentKey;\n        if (newKey === previousKey) {\n            return {\n                modified: false\n            };\n        }\n        const existingItemIndex = this._indexOfPosition(newKey);\n        if (existingItemIndex === -1) {\n            const previousIndex = this._items.indexOf(child);\n            child._setParentLink(this, newKey);\n            this._sortItems();\n            const newIndex = this._items.indexOf(child);\n            if (newIndex === previousIndex) {\n                return {\n                    modified: false\n                };\n            }\n            return {\n                modified: makeUpdate(this, [\n                    moveDelta(previousIndex, newIndex, child)\n                ]),\n                reverse: []\n            };\n        } else {\n            var _this__items_;\n            this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, (_this__items_ = this._items[existingItemIndex + 1]) === null || _this__items_ === void 0 ? void 0 : _this__items_._parentPos));\n            const previousIndex = this._items.indexOf(child);\n            child._setParentLink(this, newKey);\n            this._sortItems();\n            const newIndex = this._items.indexOf(child);\n            if (newIndex === previousIndex) {\n                return {\n                    modified: false\n                };\n            }\n            return {\n                modified: makeUpdate(this, [\n                    moveDelta(previousIndex, newIndex, child)\n                ]),\n                reverse: []\n            };\n        }\n    }\n    /** @internal */ _applySetChildKeyAck(newKey, child) {\n        const previousKey = nn(child._parentKey);\n        if (this._implicitlyDeletedItems.has(child)) {\n            const existingItemIndex = this._indexOfPosition(newKey);\n            this._implicitlyDeletedItems.delete(child);\n            if (existingItemIndex !== -1) {\n                var _this__items_;\n                this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, (_this__items_ = this._items[existingItemIndex + 1]) === null || _this__items_ === void 0 ? void 0 : _this__items_._parentPos));\n            }\n            child._setParentLink(this, newKey);\n            this._insertAndSort(child);\n            return {\n                modified: false\n            };\n        } else {\n            if (newKey === previousKey) {\n                return {\n                    modified: false\n                };\n            }\n            const previousIndex = this._items.indexOf(child);\n            const existingItemIndex = this._indexOfPosition(newKey);\n            if (existingItemIndex !== -1) {\n                var _this__items_1;\n                this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, (_this__items_1 = this._items[existingItemIndex + 1]) === null || _this__items_1 === void 0 ? void 0 : _this__items_1._parentPos));\n            }\n            child._setParentLink(this, newKey);\n            this._sortItems();\n            const newIndex = this._items.indexOf(child);\n            if (previousIndex === newIndex) {\n                return {\n                    modified: false\n                };\n            } else {\n                return {\n                    modified: makeUpdate(this, [\n                        moveDelta(previousIndex, newIndex, child)\n                    ]),\n                    reverse: []\n                };\n            }\n        }\n    }\n    /** @internal */ _applySetChildKeyUndoRedo(newKey, child) {\n        const previousKey = nn(child._parentKey);\n        const previousIndex = this._items.indexOf(child);\n        const existingItemIndex = this._indexOfPosition(newKey);\n        if (existingItemIndex !== -1) {\n            var _this__items_;\n            this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, (_this__items_ = this._items[existingItemIndex + 1]) === null || _this__items_ === void 0 ? void 0 : _this__items_._parentPos));\n        }\n        child._setParentLink(this, newKey);\n        this._sortItems();\n        const newIndex = this._items.indexOf(child);\n        if (previousIndex === newIndex) {\n            return {\n                modified: false\n            };\n        }\n        return {\n            modified: makeUpdate(this, [\n                moveDelta(previousIndex, newIndex, child)\n            ]),\n            reverse: [\n                {\n                    type: 1 /* SET_PARENT_KEY */ ,\n                    id: nn(child._id),\n                    parentKey: previousKey\n                }\n            ]\n        };\n    }\n    /** @internal */ _setChildKey(newKey, child, source) {\n        if (source === 1 /* REMOTE */ ) {\n            return this._applySetChildKeyRemote(newKey, child);\n        } else if (source === 2 /* ACK */ ) {\n            return this._applySetChildKeyAck(newKey, child);\n        } else {\n            return this._applySetChildKeyUndoRedo(newKey, child);\n        }\n    }\n    /** @internal */ _apply(op, isLocal) {\n        return super._apply(op, isLocal);\n    }\n    /** @internal */ _serialize() {\n        if (this.parent.type !== \"HasParent\") {\n            throw new Error(\"Cannot serialize LiveList if parent is missing\");\n        }\n        return {\n            type: 1 /* LIST */ ,\n            parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n            parentKey: this.parent.key\n        };\n    }\n    /**\n   * Returns the number of elements.\n   */ get length() {\n        return this._items.length;\n    }\n    /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */ push(element) {\n        var _this__pool;\n        (_this__pool = this._pool) === null || _this__pool === void 0 ? void 0 : _this__pool.assertStorageIsWritable();\n        return this.insert(element, this.length);\n    }\n    /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */ insert(element, index) {\n        var _this__pool;\n        (_this__pool = this._pool) === null || _this__pool === void 0 ? void 0 : _this__pool.assertStorageIsWritable();\n        if (index < 0 || index > this._items.length) {\n            throw new Error('Cannot insert list item at index \"\\x1d'.concat(index, '\". index should be between 0 and ').concat(this._items.length));\n        }\n        const before2 = this._items[index - 1] ? this._items[index - 1]._parentPos : void 0;\n        const after2 = this._items[index] ? this._items[index]._parentPos : void 0;\n        const position = makePosition(before2, after2);\n        const value = lsonToLiveNode(element);\n        value._setParentLink(this, position);\n        this._insertAndSort(value);\n        if (this._pool && this._id) {\n            const id = this._pool.generateId();\n            value._attach(id, this._pool);\n            this._pool.dispatch(value._toOps(this._id, position, this._pool), [\n                {\n                    type: 5 /* DELETE_CRDT */ ,\n                    id\n                }\n            ], /* @__PURE__ */ new Map([\n                [\n                    this._id,\n                    makeUpdate(this, [\n                        insertDelta(index, value)\n                    ])\n                ]\n            ]));\n        }\n    }\n    /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */ move(index, targetIndex) {\n        var _this__pool;\n        (_this__pool = this._pool) === null || _this__pool === void 0 ? void 0 : _this__pool.assertStorageIsWritable();\n        if (targetIndex < 0) {\n            throw new Error(\"targetIndex cannot be less than 0\");\n        }\n        if (targetIndex >= this._items.length) {\n            throw new Error(\"targetIndex cannot be greater or equal than the list length\");\n        }\n        if (index < 0) {\n            throw new Error(\"index cannot be less than 0\");\n        }\n        if (index >= this._items.length) {\n            throw new Error(\"index cannot be greater or equal than the list length\");\n        }\n        let beforePosition = null;\n        let afterPosition = null;\n        if (index < targetIndex) {\n            afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos;\n            beforePosition = this._items[targetIndex]._parentPos;\n        } else {\n            afterPosition = this._items[targetIndex]._parentPos;\n            beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._parentPos;\n        }\n        const position = makePosition(beforePosition, afterPosition);\n        const item = this._items[index];\n        const previousPosition = item._getParentKeyOrThrow();\n        item._setParentLink(this, position);\n        this._sortItems();\n        if (this._pool && this._id) {\n            const storageUpdates = /* @__PURE__ */ new Map([\n                [\n                    this._id,\n                    makeUpdate(this, [\n                        moveDelta(index, targetIndex, item)\n                    ])\n                ]\n            ]);\n            this._pool.dispatch([\n                {\n                    type: 1 /* SET_PARENT_KEY */ ,\n                    id: nn(item._id),\n                    opId: this._pool.generateOpId(),\n                    parentKey: position\n                }\n            ], [\n                {\n                    type: 1 /* SET_PARENT_KEY */ ,\n                    id: nn(item._id),\n                    parentKey: previousPosition\n                }\n            ], storageUpdates);\n        }\n    }\n    /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */ delete(index) {\n        var _this__pool;\n        (_this__pool = this._pool) === null || _this__pool === void 0 ? void 0 : _this__pool.assertStorageIsWritable();\n        if (index < 0 || index >= this._items.length) {\n            throw new Error('Cannot delete list item at index \"'.concat(index, '\". index should be between 0 and ').concat(this._items.length - 1));\n        }\n        const item = this._items[index];\n        item._detach();\n        this._items.splice(index, 1);\n        this.invalidate();\n        if (this._pool) {\n            const childRecordId = item._id;\n            if (childRecordId) {\n                const storageUpdates = /* @__PURE__ */ new Map();\n                storageUpdates.set(nn(this._id), makeUpdate(this, [\n                    deleteDelta(index)\n                ]));\n                this._pool.dispatch([\n                    {\n                        id: childRecordId,\n                        opId: this._pool.generateOpId(),\n                        type: 5 /* DELETE_CRDT */ \n                    }\n                ], item._toOps(nn(this._id), item._getParentKeyOrThrow()), storageUpdates);\n            }\n        }\n    }\n    clear() {\n        var _this__pool;\n        (_this__pool = this._pool) === null || _this__pool === void 0 ? void 0 : _this__pool.assertStorageIsWritable();\n        if (this._pool) {\n            const ops = [];\n            const reverseOps = [];\n            const updateDelta = [];\n            for (const item of this._items){\n                item._detach();\n                const childId = item._id;\n                if (childId) {\n                    ops.push({\n                        type: 5 /* DELETE_CRDT */ ,\n                        id: childId,\n                        opId: this._pool.generateOpId()\n                    });\n                    reverseOps.push(...item._toOps(nn(this._id), item._getParentKeyOrThrow()));\n                    updateDelta.push(deleteDelta(0));\n                }\n            }\n            this._items = [];\n            this.invalidate();\n            const storageUpdates = /* @__PURE__ */ new Map();\n            storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n            this._pool.dispatch(ops, reverseOps, storageUpdates);\n        } else {\n            for (const item of this._items){\n                item._detach();\n            }\n            this._items = [];\n            this.invalidate();\n        }\n    }\n    set(index, item) {\n        var _this__pool;\n        (_this__pool = this._pool) === null || _this__pool === void 0 ? void 0 : _this__pool.assertStorageIsWritable();\n        if (index < 0 || index >= this._items.length) {\n            throw new Error('Cannot set list item at index \"\\x1d'.concat(index, '\". index should be between 0 and ').concat(this._items.length - 1));\n        }\n        const existingItem = this._items[index];\n        const position = existingItem._getParentKeyOrThrow();\n        const existingId = existingItem._id;\n        existingItem._detach();\n        const value = lsonToLiveNode(item);\n        value._setParentLink(this, position);\n        this._items[index] = value;\n        this.invalidate();\n        if (this._pool && this._id) {\n            const id = this._pool.generateId();\n            value._attach(id, this._pool);\n            const storageUpdates = /* @__PURE__ */ new Map();\n            storageUpdates.set(this._id, makeUpdate(this, [\n                setDelta(index, value)\n            ]));\n            const ops = HACK_addIntentAndDeletedIdToOperation(value._toOps(this._id, position, this._pool), existingId);\n            this._unacknowledgedSets.set(position, nn(ops[0].opId));\n            const reverseOps = HACK_addIntentAndDeletedIdToOperation(existingItem._toOps(this._id, position, void 0), id);\n            this._pool.dispatch(ops, reverseOps, storageUpdates);\n        }\n    }\n    /**\n   * Returns an Array of all the elements in the LiveList.\n   */ toArray() {\n        return this._items.map((entry)=>liveNodeToLson(entry));\n    }\n    /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */ every(predicate) {\n        return this.toArray().every(predicate);\n    }\n    /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */ filter(predicate) {\n        return this.toArray().filter(predicate);\n    }\n    /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */ find(predicate) {\n        return this.toArray().find(predicate);\n    }\n    /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */ findIndex(predicate) {\n        return this.toArray().findIndex(predicate);\n    }\n    /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */ forEach(callbackfn) {\n        return this.toArray().forEach(callbackfn);\n    }\n    /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */ get(index) {\n        if (index < 0 || index >= this._items.length) {\n            return void 0;\n        }\n        return liveNodeToLson(this._items[index]);\n    }\n    /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */ indexOf(searchElement, fromIndex) {\n        return this.toArray().indexOf(searchElement, fromIndex);\n    }\n    /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */ lastIndexOf(searchElement, fromIndex) {\n        return this.toArray().lastIndexOf(searchElement, fromIndex);\n    }\n    /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */ map(callback) {\n        return this._items.map((entry, i)=>callback(liveNodeToLson(entry), //                    ^^^^^^^^\n            //                    FIXME! This isn't safe.\n            i));\n    }\n    /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */ some(predicate) {\n        return this.toArray().some(predicate);\n    }\n    [Symbol.iterator]() {\n        return new LiveListIterator(this._items);\n    }\n    /** @internal */ _createAttachItemAndSort(op, key) {\n        const newItem = creationOpToLiveNode(op);\n        newItem._attach(op.id, nn(this._pool));\n        newItem._setParentLink(this, key);\n        this._insertAndSort(newItem);\n        const newIndex = this._indexOfPosition(key);\n        return {\n            newItem,\n            newIndex\n        };\n    }\n    /** @internal */ _shiftItemPosition(index, key) {\n        var _this__items_;\n        const shiftedPosition = makePosition(key, this._items.length > index + 1 ? (_this__items_ = this._items[index + 1]) === null || _this__items_ === void 0 ? void 0 : _this__items_._parentPos : void 0);\n        this._items[index]._setParentLink(this, shiftedPosition);\n    }\n    /** @internal */ _toTreeNode(key) {\n        var _this__id;\n        return {\n            type: \"LiveList\",\n            id: (_this__id = this._id) !== null && _this__id !== void 0 ? _this__id : nanoid(),\n            key,\n            payload: this._items.map((item, index)=>item.toTreeNode(index.toString()))\n        };\n    }\n    toImmutable() {\n        return super.toImmutable();\n    }\n    /** @internal */ _toImmutable() {\n        const result = this._items.map((node)=>node.toImmutable());\n        return  false ? 0 : Object.freeze(result);\n    }\n    clone() {\n        return new _LiveList(this._items.map((item)=>item.clone()));\n    }\n    constructor(items = []){\n        super();\n        this._items = [];\n        this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n        this._unacknowledgedSets = /* @__PURE__ */ new Map();\n        let position = void 0;\n        for (const item of items){\n            const newPosition = makePosition(position);\n            const node = lsonToLiveNode(item);\n            node._setParentLink(this, newPosition);\n            this._items.push(node);\n            position = newPosition;\n        }\n    }\n};\nvar LiveListIterator = class {\n    [Symbol.iterator]() {\n        return this;\n    }\n    next() {\n        const result = this._innerIterator.next();\n        if (result.done) {\n            return {\n                done: true,\n                value: void 0\n            };\n        }\n        const value = liveNodeToLson(result.value);\n        return {\n            value\n        };\n    }\n    constructor(items){\n        this._innerIterator = items[Symbol.iterator]();\n    }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n    return {\n        node: liveList,\n        type: \"LiveList\",\n        updates: deltaUpdates\n    };\n}\nfunction setDelta(index, item) {\n    return {\n        index,\n        type: \"set\",\n        item: item instanceof LiveRegister ? item.data : item\n    };\n}\nfunction deleteDelta(index) {\n    return {\n        index,\n        type: \"delete\"\n    };\n}\nfunction insertDelta(index, item) {\n    return {\n        index,\n        type: \"insert\",\n        item: item instanceof LiveRegister ? item.data : item\n    };\n}\nfunction moveDelta(previousIndex, index, item) {\n    return {\n        index,\n        type: \"move\",\n        previousIndex,\n        item: item instanceof LiveRegister ? item.data : item\n    };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n    return ops.map((op, index)=>{\n        if (index === 0) {\n            const firstOp = op;\n            return {\n                ...firstOp,\n                intent: \"set\",\n                deletedId\n            };\n        } else {\n            return op;\n        }\n    });\n}\n_c2 = HACK_addIntentAndDeletedIdToOperation;\n// src/lib/freeze.ts\nvar freeze =  false ? /* istanbul ignore next */ 0 : Object.freeze;\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n    /**\n   * @internal\n   */ _toOps(parentId, parentKey, pool) {\n        if (this._id === void 0) {\n            throw new Error(\"Cannot serialize item is not attached\");\n        }\n        const ops = [];\n        const op = {\n            id: this._id,\n            opId: pool === null || pool === void 0 ? void 0 : pool.generateOpId(),\n            type: 7 /* CREATE_MAP */ ,\n            parentId,\n            parentKey\n        };\n        ops.push(op);\n        for (const [key, value] of this._map){\n            ops.push(...value._toOps(this._id, key, pool));\n        }\n        return ops;\n    }\n    /**\n   * @internal\n   */ static _deserialize(param, parentToChildren, pool) {\n        let [id, _item] = param;\n        const map = new _LiveMap();\n        map._attach(id, pool);\n        const children = parentToChildren.get(id);\n        if (children === void 0) {\n            return map;\n        }\n        for (const [id2, crdt] of children){\n            const child = deserialize([\n                id2,\n                crdt\n            ], parentToChildren, pool);\n            child._setParentLink(map, crdt.parentKey);\n            map._map.set(crdt.parentKey, child);\n            map.invalidate();\n        }\n        return map;\n    }\n    /**\n   * @internal\n   */ _attach(id, pool) {\n        super._attach(id, pool);\n        for (const [_key, value] of this._map){\n            if (isLiveNode(value)) {\n                value._attach(pool.generateId(), pool);\n            }\n        }\n    }\n    /**\n   * @internal\n   */ _attachChild(op, source) {\n        if (this._pool === void 0) {\n            throw new Error(\"Can't attach child if managed pool is not present\");\n        }\n        const { id, parentKey, opId } = op;\n        const key = parentKey;\n        const child = creationOpToLiveNode(op);\n        if (this._pool.getNode(id) !== void 0) {\n            return {\n                modified: false\n            };\n        }\n        if (source === 2 /* ACK */ ) {\n            const lastUpdateOpId = this.unacknowledgedSet.get(key);\n            if (lastUpdateOpId === opId) {\n                this.unacknowledgedSet.delete(key);\n                return {\n                    modified: false\n                };\n            } else if (lastUpdateOpId !== void 0) {\n                return {\n                    modified: false\n                };\n            }\n        } else if (source === 1 /* REMOTE */ ) {\n            this.unacknowledgedSet.delete(key);\n        }\n        const previousValue = this._map.get(key);\n        let reverse;\n        if (previousValue) {\n            const thisId = nn(this._id);\n            reverse = previousValue._toOps(thisId, key);\n            previousValue._detach();\n        } else {\n            reverse = [\n                {\n                    type: 5 /* DELETE_CRDT */ ,\n                    id\n                }\n            ];\n        }\n        child._setParentLink(this, key);\n        child._attach(id, this._pool);\n        this._map.set(key, child);\n        this.invalidate();\n        return {\n            modified: {\n                node: this,\n                type: \"LiveMap\",\n                updates: {\n                    [key]: {\n                        type: \"update\"\n                    }\n                }\n            },\n            reverse\n        };\n    }\n    /**\n   * @internal\n   */ _detach() {\n        super._detach();\n        for (const item of this._map.values()){\n            item._detach();\n        }\n    }\n    /**\n   * @internal\n   */ _detachChild(child) {\n        const id = nn(this._id);\n        const parentKey = nn(child._parentKey);\n        const reverse = child._toOps(id, parentKey, this._pool);\n        for (const [key, value] of this._map){\n            if (value === child) {\n                this._map.delete(key);\n                this.invalidate();\n            }\n        }\n        child._detach();\n        const storageUpdate = {\n            node: this,\n            type: \"LiveMap\",\n            updates: {\n                [parentKey]: {\n                    type: \"delete\"\n                }\n            }\n        };\n        return {\n            modified: storageUpdate,\n            reverse\n        };\n    }\n    /**\n   * @internal\n   */ _serialize() {\n        if (this.parent.type !== \"HasParent\") {\n            throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n        }\n        return {\n            type: 2 /* MAP */ ,\n            parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n            parentKey: this.parent.key\n        };\n    }\n    /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */ get(key) {\n        const value = this._map.get(key);\n        if (value === void 0) {\n            return void 0;\n        }\n        return liveNodeToLson(value);\n    }\n    /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */ set(key, value) {\n        var _this__pool;\n        (_this__pool = this._pool) === null || _this__pool === void 0 ? void 0 : _this__pool.assertStorageIsWritable();\n        const oldValue = this._map.get(key);\n        if (oldValue) {\n            oldValue._detach();\n        }\n        const item = lsonToLiveNode(value);\n        item._setParentLink(this, key);\n        this._map.set(key, item);\n        this.invalidate();\n        if (this._pool && this._id) {\n            const id = this._pool.generateId();\n            item._attach(id, this._pool);\n            const storageUpdates = /* @__PURE__ */ new Map();\n            storageUpdates.set(this._id, {\n                node: this,\n                type: \"LiveMap\",\n                updates: {\n                    [key]: {\n                        type: \"update\"\n                    }\n                }\n            });\n            const ops = item._toOps(this._id, key, this._pool);\n            this.unacknowledgedSet.set(key, nn(ops[0].opId));\n            this._pool.dispatch(item._toOps(this._id, key, this._pool), oldValue ? oldValue._toOps(this._id, key) : [\n                {\n                    type: 5 /* DELETE_CRDT */ ,\n                    id\n                }\n            ], storageUpdates);\n        }\n    }\n    /**\n   * Returns the number of elements in the LiveMap.\n   */ get size() {\n        return this._map.size;\n    }\n    /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */ has(key) {\n        return this._map.has(key);\n    }\n    /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */ delete(key) {\n        var _this__pool;\n        (_this__pool = this._pool) === null || _this__pool === void 0 ? void 0 : _this__pool.assertStorageIsWritable();\n        const item = this._map.get(key);\n        if (item === void 0) {\n            return false;\n        }\n        item._detach();\n        this._map.delete(key);\n        this.invalidate();\n        if (this._pool && item._id) {\n            const thisId = nn(this._id);\n            const storageUpdates = /* @__PURE__ */ new Map();\n            storageUpdates.set(thisId, {\n                node: this,\n                type: \"LiveMap\",\n                updates: {\n                    [key]: {\n                        type: \"delete\"\n                    }\n                }\n            });\n            this._pool.dispatch([\n                {\n                    type: 5 /* DELETE_CRDT */ ,\n                    id: item._id,\n                    opId: this._pool.generateOpId()\n                }\n            ], item._toOps(thisId, key), storageUpdates);\n        }\n        return true;\n    }\n    /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */ entries() {\n        const innerIterator = this._map.entries();\n        return {\n            [Symbol.iterator] () {\n                return this;\n            },\n            next () {\n                const iteratorValue = innerIterator.next();\n                if (iteratorValue.done) {\n                    return {\n                        done: true,\n                        value: void 0\n                    };\n                }\n                const entry = iteratorValue.value;\n                const key = entry[0];\n                const value = liveNodeToLson(iteratorValue.value[1]);\n                return {\n                    value: [\n                        key,\n                        value\n                    ]\n                };\n            }\n        };\n    }\n    /**\n   * Same function object as the initial value of the entries method.\n   */ [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */ keys() {\n        return this._map.keys();\n    }\n    /**\n   * Returns a new Iterator object that contains the values for each element.\n   */ values() {\n        const innerIterator = this._map.values();\n        return {\n            [Symbol.iterator] () {\n                return this;\n            },\n            next () {\n                const iteratorValue = innerIterator.next();\n                if (iteratorValue.done) {\n                    return {\n                        done: true,\n                        value: void 0\n                    };\n                }\n                const value = liveNodeToLson(iteratorValue.value);\n                return {\n                    value\n                };\n            }\n        };\n    }\n    /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */ forEach(callback) {\n        for (const entry of this){\n            callback(entry[1], entry[0], this);\n        }\n    }\n    /** @internal */ _toTreeNode(key) {\n        var _this__id;\n        return {\n            type: \"LiveMap\",\n            id: (_this__id = this._id) !== null && _this__id !== void 0 ? _this__id : nanoid(),\n            key,\n            payload: Array.from(this._map.entries()).map((param)=>{\n                let [key2, val] = param;\n                return val.toTreeNode(key2);\n            })\n        };\n    }\n    toImmutable() {\n        return super.toImmutable();\n    }\n    /** @internal */ _toImmutable() {\n        const result = /* @__PURE__ */ new Map();\n        for (const [key, value] of this._map){\n            result.set(key, value.toImmutable());\n        }\n        return freeze(result);\n    }\n    clone() {\n        return new _LiveMap(Array.from(this._map).map((param)=>{\n            let [key, node] = param;\n            return [\n                key,\n                node.clone()\n            ];\n        }));\n    }\n    constructor(entries2){\n        super();\n        this.unacknowledgedSet = /* @__PURE__ */ new Map();\n        if (entries2) {\n            const mappedEntries = [];\n            for (const [key, value] of entries2){\n                const node = lsonToLiveNode(value);\n                node._setParentLink(this, key);\n                mappedEntries.push([\n                    key,\n                    node\n                ]);\n            }\n            this._map = new Map(mappedEntries);\n        } else {\n            this._map = /* @__PURE__ */ new Map();\n        }\n    }\n};\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n    /** @internal */ static _buildRootAndParentToChildren(items) {\n        const parentToChildren = /* @__PURE__ */ new Map();\n        let root = null;\n        for (const [id, crdt] of items){\n            if (isRootCrdt(crdt)) {\n                root = [\n                    id,\n                    crdt\n                ];\n            } else {\n                const tuple = [\n                    id,\n                    crdt\n                ];\n                const children = parentToChildren.get(crdt.parentId);\n                if (children !== void 0) {\n                    children.push(tuple);\n                } else {\n                    parentToChildren.set(crdt.parentId, [\n                        tuple\n                    ]);\n                }\n            }\n        }\n        if (root === null) {\n            throw new Error(\"Root can't be null\");\n        }\n        return [\n            root,\n            parentToChildren\n        ];\n    }\n    /** @internal */ static _fromItems(items, pool) {\n        const [root, parentToChildren] = _LiveObject._buildRootAndParentToChildren(items);\n        return _LiveObject._deserialize(root, parentToChildren, pool);\n    }\n    /** @internal */ _toOps(parentId, parentKey, pool) {\n        if (this._id === void 0) {\n            throw new Error(\"Cannot serialize item is not attached\");\n        }\n        const opId = pool === null || pool === void 0 ? void 0 : pool.generateOpId();\n        const ops = [];\n        const op = {\n            type: 4 /* CREATE_OBJECT */ ,\n            id: this._id,\n            opId,\n            parentId,\n            parentKey,\n            data: {}\n        };\n        ops.push(op);\n        for (const [key, value] of this._map){\n            if (isLiveNode(value)) {\n                ops.push(...value._toOps(this._id, key, pool));\n            } else {\n                op.data[key] = value;\n            }\n        }\n        return ops;\n    }\n    /** @internal */ static _deserialize(param, parentToChildren, pool) {\n        let [id, item] = param;\n        const liveObj = new _LiveObject(item.data);\n        liveObj._attach(id, pool);\n        return this._deserializeChildren(liveObj, parentToChildren, pool);\n    }\n    /** @internal */ static _deserializeChildren(liveObj, parentToChildren, pool) {\n        const children = parentToChildren.get(nn(liveObj._id));\n        if (children === void 0) {\n            return liveObj;\n        }\n        for (const [id, crdt] of children){\n            const child = deserializeToLson([\n                id,\n                crdt\n            ], parentToChildren, pool);\n            if (isLiveStructure(child)) {\n                child._setParentLink(liveObj, crdt.parentKey);\n            }\n            liveObj._map.set(crdt.parentKey, child);\n            liveObj.invalidate();\n        }\n        return liveObj;\n    }\n    /** @internal */ _attach(id, pool) {\n        super._attach(id, pool);\n        for (const [_key, value] of this._map){\n            if (isLiveNode(value)) {\n                value._attach(pool.generateId(), pool);\n            }\n        }\n    }\n    /** @internal */ _attachChild(op, source) {\n        if (this._pool === void 0) {\n            throw new Error(\"Can't attach child if managed pool is not present\");\n        }\n        const { id, opId, parentKey: key } = op;\n        const child = creationOpToLson(op);\n        if (this._pool.getNode(id) !== void 0) {\n            if (this._propToLastUpdate.get(key) === opId) {\n                this._propToLastUpdate.delete(key);\n            }\n            return {\n                modified: false\n            };\n        }\n        if (source === 0 /* UNDOREDO_RECONNECT */ ) {\n            this._propToLastUpdate.set(key, nn(opId));\n        } else if (this._propToLastUpdate.get(key) === void 0) {} else if (this._propToLastUpdate.get(key) === opId) {\n            this._propToLastUpdate.delete(key);\n            return {\n                modified: false\n            };\n        } else {\n            return {\n                modified: false\n            };\n        }\n        const thisId = nn(this._id);\n        const previousValue = this._map.get(key);\n        let reverse;\n        if (isLiveNode(previousValue)) {\n            reverse = previousValue._toOps(thisId, key);\n            previousValue._detach();\n        } else if (previousValue === void 0) {\n            reverse = [\n                {\n                    type: 6 /* DELETE_OBJECT_KEY */ ,\n                    id: thisId,\n                    key\n                }\n            ];\n        } else {\n            reverse = [\n                {\n                    type: 3 /* UPDATE_OBJECT */ ,\n                    id: thisId,\n                    data: {\n                        [key]: previousValue\n                    }\n                }\n            ];\n        }\n        this._map.set(key, child);\n        this.invalidate();\n        if (isLiveStructure(child)) {\n            child._setParentLink(this, key);\n            child._attach(id, this._pool);\n        }\n        return {\n            reverse,\n            modified: {\n                node: this,\n                type: \"LiveObject\",\n                updates: {\n                    [key]: {\n                        type: \"update\"\n                    }\n                }\n            }\n        };\n    }\n    /** @internal */ _detachChild(child) {\n        if (child) {\n            const id = nn(this._id);\n            const parentKey = nn(child._parentKey);\n            const reverse = child._toOps(id, parentKey, this._pool);\n            for (const [key, value] of this._map){\n                if (value === child) {\n                    this._map.delete(key);\n                    this.invalidate();\n                }\n            }\n            child._detach();\n            const storageUpdate = {\n                node: this,\n                type: \"LiveObject\",\n                updates: {\n                    [parentKey]: {\n                        type: \"delete\"\n                    }\n                }\n            };\n            return {\n                modified: storageUpdate,\n                reverse\n            };\n        }\n        return {\n            modified: false\n        };\n    }\n    /**\n   * @internal\n   */ _detach() {\n        super._detach();\n        for (const value of this._map.values()){\n            if (isLiveNode(value)) {\n                value._detach();\n            }\n        }\n    }\n    /** @internal */ _apply(op, isLocal) {\n        if (op.type === 3 /* UPDATE_OBJECT */ ) {\n            return this._applyUpdate(op, isLocal);\n        } else if (op.type === 6 /* DELETE_OBJECT_KEY */ ) {\n            return this._applyDeleteObjectKey(op, isLocal);\n        }\n        return super._apply(op, isLocal);\n    }\n    /**\n   * @internal\n   */ _serialize() {\n        const data = {};\n        for (const [key, value] of this._map){\n            if (!isLiveNode(value)) {\n                data[key] = value;\n            }\n        }\n        if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n            return {\n                type: 0 /* OBJECT */ ,\n                parentId: this.parent.node._id,\n                parentKey: this.parent.key,\n                data\n            };\n        } else {\n            return {\n                type: 0 /* OBJECT */ ,\n                data\n            };\n        }\n    }\n    /** @internal */ _applyUpdate(op, isLocal) {\n        let isModified = false;\n        const id = nn(this._id);\n        const reverse = [];\n        const reverseUpdate = {\n            type: 3 /* UPDATE_OBJECT */ ,\n            id,\n            data: {}\n        };\n        for(const key in op.data){\n            const oldValue = this._map.get(key);\n            if (isLiveNode(oldValue)) {\n                reverse.push(...oldValue._toOps(id, key));\n                oldValue._detach();\n            } else if (oldValue !== void 0) {\n                reverseUpdate.data[key] = oldValue;\n            } else if (oldValue === void 0) {\n                reverse.push({\n                    type: 6 /* DELETE_OBJECT_KEY */ ,\n                    id,\n                    key\n                });\n            }\n        }\n        const updateDelta = {};\n        for(const key in op.data){\n            const value = op.data[key];\n            if (value === void 0) {\n                continue;\n            }\n            if (isLocal) {\n                this._propToLastUpdate.set(key, nn(op.opId));\n            } else if (this._propToLastUpdate.get(key) === void 0) {\n                isModified = true;\n            } else if (this._propToLastUpdate.get(key) === op.opId) {\n                this._propToLastUpdate.delete(key);\n                continue;\n            } else {\n                continue;\n            }\n            const oldValue = this._map.get(key);\n            if (isLiveNode(oldValue)) {\n                oldValue._detach();\n            }\n            isModified = true;\n            updateDelta[key] = {\n                type: \"update\"\n            };\n            this._map.set(key, value);\n            this.invalidate();\n        }\n        if (Object.keys(reverseUpdate.data).length !== 0) {\n            reverse.unshift(reverseUpdate);\n        }\n        return isModified ? {\n            modified: {\n                node: this,\n                type: \"LiveObject\",\n                updates: updateDelta\n            },\n            reverse\n        } : {\n            modified: false\n        };\n    }\n    /** @internal */ _applyDeleteObjectKey(op, isLocal) {\n        const key = op.key;\n        if (this._map.has(key) === false) {\n            return {\n                modified: false\n            };\n        }\n        if (!isLocal && this._propToLastUpdate.get(key) !== void 0) {\n            return {\n                modified: false\n            };\n        }\n        const oldValue = this._map.get(key);\n        const id = nn(this._id);\n        let reverse = [];\n        if (isLiveNode(oldValue)) {\n            reverse = oldValue._toOps(id, op.key);\n            oldValue._detach();\n        } else if (oldValue !== void 0) {\n            reverse = [\n                {\n                    type: 3 /* UPDATE_OBJECT */ ,\n                    id,\n                    data: {\n                        [key]: oldValue\n                    }\n                }\n            ];\n        }\n        this._map.delete(key);\n        this.invalidate();\n        return {\n            modified: {\n                node: this,\n                type: \"LiveObject\",\n                updates: {\n                    [op.key]: {\n                        type: \"delete\"\n                    }\n                }\n            },\n            reverse\n        };\n    }\n    /**\n   * Transform the LiveObject into a javascript object\n   */ toObject() {\n        return Object.fromEntries(this._map);\n    }\n    /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */ set(key, value) {\n        var _this__pool;\n        (_this__pool = this._pool) === null || _this__pool === void 0 ? void 0 : _this__pool.assertStorageIsWritable();\n        this.update({\n            [key]: value\n        });\n    }\n    /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */ get(key) {\n        return this._map.get(key);\n    }\n    /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */ delete(key) {\n        var _this__pool;\n        (_this__pool = this._pool) === null || _this__pool === void 0 ? void 0 : _this__pool.assertStorageIsWritable();\n        const keyAsString = key;\n        const oldValue = this._map.get(keyAsString);\n        if (oldValue === void 0) {\n            return;\n        }\n        if (this._pool === void 0 || this._id === void 0) {\n            if (isLiveNode(oldValue)) {\n                oldValue._detach();\n            }\n            this._map.delete(keyAsString);\n            this.invalidate();\n            return;\n        }\n        let reverse;\n        if (isLiveNode(oldValue)) {\n            oldValue._detach();\n            reverse = oldValue._toOps(this._id, keyAsString);\n        } else {\n            reverse = [\n                {\n                    type: 3 /* UPDATE_OBJECT */ ,\n                    data: {\n                        [keyAsString]: oldValue\n                    },\n                    id: this._id\n                }\n            ];\n        }\n        this._map.delete(keyAsString);\n        this.invalidate();\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(this._id, {\n            node: this,\n            type: \"LiveObject\",\n            updates: {\n                [key]: {\n                    type: \"delete\"\n                }\n            }\n        });\n        this._pool.dispatch([\n            {\n                type: 6 /* DELETE_OBJECT_KEY */ ,\n                key: keyAsString,\n                id: this._id,\n                opId: this._pool.generateOpId()\n            }\n        ], reverse, storageUpdates);\n    }\n    /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */ update(patch) {\n        var _this__pool;\n        (_this__pool = this._pool) === null || _this__pool === void 0 ? void 0 : _this__pool.assertStorageIsWritable();\n        if (this._pool === void 0 || this._id === void 0) {\n            for(const key in patch){\n                const newValue = patch[key];\n                if (newValue === void 0) {\n                    continue;\n                }\n                const oldValue = this._map.get(key);\n                if (isLiveNode(oldValue)) {\n                    oldValue._detach();\n                }\n                if (isLiveNode(newValue)) {\n                    newValue._setParentLink(this, key);\n                }\n                this._map.set(key, newValue);\n                this.invalidate();\n            }\n            return;\n        }\n        const ops = [];\n        const reverseOps = [];\n        const opId = this._pool.generateOpId();\n        const updatedProps = {};\n        const reverseUpdateOp = {\n            id: this._id,\n            type: 3 /* UPDATE_OBJECT */ ,\n            data: {}\n        };\n        const updateDelta = {};\n        for(const key in patch){\n            const newValue = patch[key];\n            if (newValue === void 0) {\n                continue;\n            }\n            const oldValue = this._map.get(key);\n            if (isLiveNode(oldValue)) {\n                reverseOps.push(...oldValue._toOps(this._id, key));\n                oldValue._detach();\n            } else if (oldValue === void 0) {\n                reverseOps.push({\n                    type: 6 /* DELETE_OBJECT_KEY */ ,\n                    id: this._id,\n                    key\n                });\n            } else {\n                reverseUpdateOp.data[key] = oldValue;\n            }\n            if (isLiveNode(newValue)) {\n                newValue._setParentLink(this, key);\n                newValue._attach(this._pool.generateId(), this._pool);\n                const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n                const createCrdtOp = newAttachChildOps.find((op)=>op.parentId === this._id);\n                if (createCrdtOp) {\n                    this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n                }\n                ops.push(...newAttachChildOps);\n            } else {\n                updatedProps[key] = newValue;\n                this._propToLastUpdate.set(key, opId);\n            }\n            this._map.set(key, newValue);\n            this.invalidate();\n            updateDelta[key] = {\n                type: \"update\"\n            };\n        }\n        if (Object.keys(reverseUpdateOp.data).length !== 0) {\n            reverseOps.unshift(reverseUpdateOp);\n        }\n        if (Object.keys(updatedProps).length !== 0) {\n            ops.unshift({\n                opId,\n                id: this._id,\n                type: 3 /* UPDATE_OBJECT */ ,\n                data: updatedProps\n            });\n        }\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(this._id, {\n            node: this,\n            type: \"LiveObject\",\n            updates: updateDelta\n        });\n        this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n    toImmutable() {\n        return super.toImmutable();\n    }\n    /** @internal */ toTreeNode(key) {\n        return super.toTreeNode(key);\n    }\n    /** @internal */ _toTreeNode(key) {\n        var _this__id;\n        const nodeId = (_this__id = this._id) !== null && _this__id !== void 0 ? _this__id : nanoid();\n        return {\n            type: \"LiveObject\",\n            id: nodeId,\n            key,\n            payload: Array.from(this._map.entries()).map((param)=>{\n                let [key2, value] = param;\n                return isLiveNode(value) ? value.toTreeNode(key2) : {\n                    type: \"Json\",\n                    id: \"\".concat(nodeId, \":\").concat(key2),\n                    key: key2,\n                    payload: value\n                };\n            })\n        };\n    }\n    /** @internal */ _toImmutable() {\n        const result = {};\n        for (const [key, val] of this._map){\n            result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n        }\n        return  false ? 0 : Object.freeze(result);\n    }\n    clone() {\n        return new _LiveObject(Object.fromEntries(Array.from(this._map).map((param)=>{\n            let [key, value] = param;\n            return [\n                key,\n                isLiveStructure(value) ? value.clone() : deepClone(value)\n            ];\n        })));\n    }\n    constructor(obj = {}){\n        super();\n        this._propToLastUpdate = /* @__PURE__ */ new Map();\n        for(const key in obj){\n            const value = obj[key];\n            if (value === void 0) {\n                continue;\n            } else if (isLiveNode(value)) {\n                value._setParentLink(this, key);\n            }\n        }\n        this._map = new Map(Object.entries(obj));\n    }\n};\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n    return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n    switch(op.type){\n        case 8 /* CREATE_REGISTER */ :\n            return op.data;\n        case 4 /* CREATE_OBJECT */ :\n            return new LiveObject(op.data);\n        case 7 /* CREATE_MAP */ :\n            return new LiveMap();\n        case 2 /* CREATE_LIST */ :\n            return new LiveList();\n        default:\n            return assertNever(op, \"Unknown creation Op\");\n    }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n    if (node === parent) {\n        return true;\n    }\n    if (node.parent.type === \"HasParent\") {\n        return isSameNodeOrChildOf(node.parent.node, parent);\n    }\n    return false;\n}\nfunction deserialize(param, parentToChildren, pool) {\n    let [id, crdt] = param;\n    switch(crdt.type){\n        case 0 /* OBJECT */ :\n            {\n                return LiveObject._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        case 1 /* LIST */ :\n            {\n                return LiveList._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        case 2 /* MAP */ :\n            {\n                return LiveMap._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        case 3 /* REGISTER */ :\n            {\n                return LiveRegister._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        default:\n            {\n                throw new Error(\"Unexpected CRDT type\");\n            }\n    }\n}\nfunction deserializeToLson(param, parentToChildren, pool) {\n    let [id, crdt] = param;\n    switch(crdt.type){\n        case 0 /* OBJECT */ :\n            {\n                return LiveObject._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        case 1 /* LIST */ :\n            {\n                return LiveList._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        case 2 /* MAP */ :\n            {\n                return LiveMap._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        case 3 /* REGISTER */ :\n            {\n                return crdt.data;\n            }\n        default:\n            {\n                throw new Error(\"Unexpected CRDT type\");\n            }\n    }\n}\nfunction isLiveStructure(value) {\n    return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n    return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n    return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n    return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n    return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n    return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n    return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n    if (obj instanceof LiveRegister) {\n        return obj.data;\n    } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n        return obj;\n    } else {\n        return assertNever(obj, \"Unknown AbstractCrdt\");\n    }\n}\nfunction lsonToLiveNode(value) {\n    if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n        return value;\n    } else {\n        return new LiveRegister(value);\n    }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n    const ops = [];\n    currentItems.forEach((_, id)=>{\n        if (!newItems.get(id)) {\n            ops.push({\n                type: 5 /* DELETE_CRDT */ ,\n                id\n            });\n        }\n    });\n    newItems.forEach((crdt, id)=>{\n        const currentCrdt = currentItems.get(id);\n        if (currentCrdt) {\n            if (crdt.type === 0 /* OBJECT */ ) {\n                if (currentCrdt.type !== 0 /* OBJECT */  || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {\n                    ops.push({\n                        type: 3 /* UPDATE_OBJECT */ ,\n                        id,\n                        data: crdt.data\n                    });\n                }\n            }\n            if (crdt.parentKey !== currentCrdt.parentKey) {\n                ops.push({\n                    type: 1 /* SET_PARENT_KEY */ ,\n                    id,\n                    parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n                });\n            }\n        } else {\n            switch(crdt.type){\n                case 3 /* REGISTER */ :\n                    ops.push({\n                        type: 8 /* CREATE_REGISTER */ ,\n                        id,\n                        parentId: crdt.parentId,\n                        parentKey: crdt.parentKey,\n                        data: crdt.data\n                    });\n                    break;\n                case 1 /* LIST */ :\n                    ops.push({\n                        type: 2 /* CREATE_LIST */ ,\n                        id,\n                        parentId: crdt.parentId,\n                        parentKey: crdt.parentKey\n                    });\n                    break;\n                case 0 /* OBJECT */ :\n                    if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n                        throw new Error(\"Internal error. Cannot serialize storage root into an operation\");\n                    }\n                    ops.push({\n                        type: 4 /* CREATE_OBJECT */ ,\n                        id,\n                        parentId: crdt.parentId,\n                        parentKey: crdt.parentKey,\n                        data: crdt.data\n                    });\n                    break;\n                case 2 /* MAP */ :\n                    ops.push({\n                        type: 7 /* CREATE_MAP */ ,\n                        id,\n                        parentId: crdt.parentId,\n                        parentKey: crdt.parentKey\n                    });\n                    break;\n            }\n        }\n    });\n    return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n    const updates = first.updates;\n    for (const [key, value] of entries(second.updates)){\n        updates[key] = value;\n    }\n    return {\n        ...second,\n        updates\n    };\n}\nfunction mergeMapStorageUpdates(first, second) {\n    const updates = first.updates;\n    for (const [key, value] of entries(second.updates)){\n        updates[key] = value;\n    }\n    return {\n        ...second,\n        updates\n    };\n}\nfunction mergeListStorageUpdates(first, second) {\n    const updates = first.updates;\n    return {\n        ...second,\n        updates: updates.concat(second.updates)\n    };\n}\nfunction mergeStorageUpdates(first, second) {\n    if (first === void 0) {\n        return second;\n    }\n    if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n        return mergeObjectStorageUpdates(first, second);\n    } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n        return mergeMapStorageUpdates(first, second);\n    } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n        return mergeListStorageUpdates(first, second);\n    } else {}\n    return second;\n}\nfunction isPlain(value) {\n    const type = typeof value;\n    return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value) {\n    let path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n    if (!isPlain) {\n        return {\n            path: path || \"root\",\n            value\n        };\n    }\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    for (const [key, nestedValue] of Object.entries(value)){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (!isPlain(nestedValue)) {\n            return {\n                path: nestedPath,\n                value: nestedValue\n            };\n        }\n        if (typeof nestedValue === \"object\") {\n            const nonSerializableNestedValue = findNonSerializableValue(nestedValue, nestedPath);\n            if (nonSerializableNestedValue) {\n                return nonSerializableNestedValue;\n            }\n        }\n    }\n    return false;\n}\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n    const errorLike = {\n        name: msg\n    };\n    if (typeof Error.captureStackTrace !== \"function\") {\n        return void 0;\n    }\n    Error.captureStackTrace(errorLike, traceRoot);\n    return errorLike.stack;\n}\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n    return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n    return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n    return !isJsonScalar(data) && !isJsonArray(data);\n}\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2)=>{\n    ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n    ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n    ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n    ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n    ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n    ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n    return ClientMsgCode2;\n})(ClientMsgCode || {});\n// src/refs/ImmutableRef.ts\nfunction merge(target, patch) {\n    let updated = false;\n    const newValue = {\n        ...target\n    };\n    Object.keys(patch).forEach((k)=>{\n        const key = k;\n        const val = patch[key];\n        if (newValue[key] !== val) {\n            if (val === void 0) {\n                delete newValue[key];\n            } else {\n                newValue[key] = val;\n            }\n            updated = true;\n        }\n    });\n    return updated ? newValue : target;\n}\nvar ImmutableRef = class {\n    get didInvalidate() {\n        return this._ev.observable;\n    }\n    invalidate() {\n        if (this._cache !== void 0) {\n            this._cache = void 0;\n            this._ev.notify();\n        }\n    }\n    get current() {\n        var _this__cache;\n        return (_this__cache = this._cache) !== null && _this__cache !== void 0 ? _this__cache : this._cache = this._toImmutable();\n    }\n    constructor(){\n        this._ev = makeEventSource();\n    }\n};\n// src/refs/OthersRef.ts\nfunction makeUser(conn, presence) {\n    const { connectionId, id, info } = conn;\n    const canWrite = canWriteStorage(conn.scopes);\n    return freeze(compactObject({\n        connectionId,\n        id,\n        info,\n        canWrite,\n        canComment: canComment(conn.scopes),\n        isReadOnly: !canWrite,\n        // Deprecated, kept for backward-compatibility\n        presence\n    }));\n}\nvar OthersRef = class extends ImmutableRef {\n    connectionIds() {\n        return this._connections.keys();\n    }\n    /** @internal */ _toImmutable() {\n        const users = compact(Array.from(this._presences.keys()).map((connectionId)=>this.getUser(Number(connectionId))));\n        return users;\n    }\n    clearOthers() {\n        this._connections = /* @__PURE__ */ new Map();\n        this._presences = /* @__PURE__ */ new Map();\n        this._users = /* @__PURE__ */ new Map();\n        this.invalidate();\n    }\n    /** @internal */ _getUser(connectionId) {\n        const conn = this._connections.get(connectionId);\n        const presence = this._presences.get(connectionId);\n        if (conn !== void 0 && presence !== void 0) {\n            return makeUser(conn, presence);\n        }\n        return void 0;\n    }\n    getUser(connectionId) {\n        const cachedUser = this._users.get(connectionId);\n        if (cachedUser) {\n            return cachedUser;\n        }\n        const computedUser = this._getUser(connectionId);\n        if (computedUser) {\n            this._users.set(connectionId, computedUser);\n            return computedUser;\n        }\n        return void 0;\n    }\n    /** @internal */ _invalidateUser(connectionId) {\n        if (this._users.has(connectionId)) {\n            this._users.delete(connectionId);\n        }\n        this.invalidate();\n    }\n    /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */ setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n        this._connections.set(connectionId, freeze({\n            connectionId,\n            id: metaUserId,\n            info: metaUserInfo,\n            scopes\n        }));\n        if (this._presences.has(connectionId)) {\n            this._invalidateUser(connectionId);\n        }\n    }\n    /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */ removeConnection(connectionId) {\n        this._connections.delete(connectionId);\n        this._presences.delete(connectionId);\n        this._invalidateUser(connectionId);\n    }\n    /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */ setOther(connectionId, presence) {\n        this._presences.set(connectionId, freeze(compactObject(presence)));\n        if (this._connections.has(connectionId)) {\n            this._invalidateUser(connectionId);\n        }\n    }\n    /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */ patchOther(connectionId, patch) {\n        const oldPresence = this._presences.get(connectionId);\n        if (oldPresence === void 0) {\n            return;\n        }\n        const newPresence = merge(oldPresence, patch);\n        if (oldPresence !== newPresence) {\n            this._presences.set(connectionId, freeze(newPresence));\n            this._invalidateUser(connectionId);\n        }\n    }\n    //\n    // --------------------------------------------------------------\n    //\n    constructor(){\n        super();\n        this._connections = /* @__PURE__ */ new Map();\n        this._presences = /* @__PURE__ */ new Map();\n        this._users = /* @__PURE__ */ new Map();\n    }\n};\n// src/refs/PatchableRef.ts\nvar PatchableRef = class extends ImmutableRef {\n    /** @internal */ _toImmutable() {\n        return this._data;\n    }\n    /**\n   * Patches the current object.\n   */ patch(patch) {\n        const oldData = this._data;\n        const newData = merge(oldData, patch);\n        if (oldData !== newData) {\n            this._data = freeze(newData);\n            this.invalidate();\n        }\n    }\n    constructor(data){\n        super();\n        this._data = freeze(compactObject(data));\n    }\n};\n// src/refs/ValueRef.ts\nvar ValueRef = class extends ImmutableRef {\n    /** @internal */ _toImmutable() {\n        return this._value;\n    }\n    set(newValue) {\n        this._value = freeze(newValue);\n        this.invalidate();\n    }\n    constructor(initialValue){\n        super();\n        this._value = freeze(initialValue);\n    }\n};\nvar DerivedRef = class extends ImmutableRef {\n    /** @internal */ _toImmutable() {\n        return this._transform(...this._refs.map((ref)=>ref.current));\n    }\n    constructor(...args){\n        super();\n        const transformFn = args.pop();\n        const otherRefs = args;\n        this._refs = otherRefs;\n        this._refs.forEach((ref)=>{\n            ref.didInvalidate.subscribe(()=>this.invalidate());\n        });\n        this._transform = transformFn;\n    }\n};\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 1024;\nfunction makeIdFactory(connectionId) {\n    let count = 0;\n    return ()=>\"\".concat(connectionId, \":\").concat(count++);\n}\nfunction userToTreeNode(key, user) {\n    return {\n        type: \"User\",\n        id: \"\".concat(user.connectionId),\n        key,\n        payload: user\n    };\n}\nfunction installBackgroundTabSpy() {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const inBackgroundSince = {\n        current: null\n    };\n    function onVisibilityChange() {\n        if ((doc === null || doc === void 0 ? void 0 : doc.visibilityState) === \"hidden\") {\n            var _inBackgroundSince_current;\n            inBackgroundSince.current = (_inBackgroundSince_current = inBackgroundSince.current) !== null && _inBackgroundSince_current !== void 0 ? _inBackgroundSince_current : Date.now();\n        } else {\n            inBackgroundSince.current = null;\n        }\n    }\n    doc === null || doc === void 0 ? void 0 : doc.addEventListener(\"visibilitychange\", onVisibilityChange);\n    const unsub = ()=>{\n        doc === null || doc === void 0 ? void 0 : doc.removeEventListener(\"visibilitychange\", onVisibilityChange);\n    };\n    return [\n        inBackgroundSince,\n        unsub\n    ];\n}\nfunction createRoom(options, config) {\n    const initialPresence = typeof options.initialPresence === \"function\" ? options.initialPresence(config.roomId) : options.initialPresence;\n    const initialStorage = typeof options.initialStorage === \"function\" ? options.initialStorage(config.roomId) : options.initialStorage;\n    const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n    const delegates = {\n        ...config.delegates,\n        // A connection is allowed to go into \"zombie state\" only if all of the\n        // following conditions apply:\n        //\n        // - The `backgroundKeepAliveTimeout` client option is configured\n        // - The browser window has been in the background for at least\n        //   `backgroundKeepAliveTimeout` milliseconds\n        // - There are no pending changes\n        //\n        canZombie () {\n            return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n        }\n    };\n    const managedSocket = new ManagedSocket(delegates, config.enableDebugLogging);\n    const context = {\n        buffer: {\n            flushTimerID: void 0,\n            lastFlushedAt: 0,\n            presenceUpdates: // Queue up the initial presence message as a Full Presence update\n            {\n                type: \"full\",\n                data: initialPresence\n            },\n            messages: [],\n            storageOperations: []\n        },\n        staticSessionInfo: new ValueRef(null),\n        dynamicSessionInfo: new ValueRef(null),\n        myPresence: new PatchableRef(initialPresence),\n        others: new OthersRef(),\n        initialStorage,\n        idFactory: null,\n        // Storage\n        clock: 0,\n        opClock: 0,\n        nodes: /* @__PURE__ */ new Map(),\n        root: void 0,\n        undoStack: [],\n        redoStack: [],\n        pausedHistory: null,\n        activeBatch: null,\n        unacknowledgedOps: /* @__PURE__ */ new Map(),\n        // Debug\n        opStackTraces:  true ? /* @__PURE__ */ new Map() : 0\n    };\n    const doNotBatchUpdates = (cb)=>cb();\n    var _config_unstable_batchedUpdates;\n    const batchUpdates = (_config_unstable_batchedUpdates = config.unstable_batchedUpdates) !== null && _config_unstable_batchedUpdates !== void 0 ? _config_unstable_batchedUpdates : doNotBatchUpdates;\n    let lastTokenKey;\n    function onStatusDidChange(newStatus) {\n        const authValue = managedSocket.authValue;\n        if (authValue !== null) {\n            const tokenKey = authValue.type === \"secret\" ? authValue.token.raw : authValue.publicApiKey;\n            if (tokenKey !== lastTokenKey) {\n                lastTokenKey = tokenKey;\n                if (authValue.type === \"secret\") {\n                    const token = authValue.token.parsed;\n                    context.staticSessionInfo.set({\n                        userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */  ? token.id : token.uid,\n                        userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */  ? token.info : token.ui\n                    });\n                } else {\n                    context.staticSessionInfo.set({\n                        userId: void 0,\n                        userInfo: void 0\n                    });\n                }\n            }\n        }\n        batchUpdates(()=>{\n            eventHub.status.notify(newStatus);\n            notifySelfChanged(doNotBatchUpdates);\n        });\n    }\n    let _connectionLossTimerId;\n    let _hasLostConnection = false;\n    function handleConnectionLossEvent(newStatus) {\n        if (newStatus === \"reconnecting\") {\n            _connectionLossTimerId = setTimeout(()=>{\n                batchUpdates(()=>{\n                    eventHub.lostConnection.notify(\"lost\");\n                    _hasLostConnection = true;\n                    context.others.clearOthers();\n                    notify({\n                        others: [\n                            {\n                                type: \"reset\"\n                            }\n                        ]\n                    }, doNotBatchUpdates);\n                });\n            }, config.lostConnectionTimeout);\n        } else {\n            clearTimeout(_connectionLossTimerId);\n            if (_hasLostConnection) {\n                if (newStatus === \"disconnected\") {\n                    batchUpdates(()=>{\n                        eventHub.lostConnection.notify(\"failed\");\n                    });\n                } else {\n                    batchUpdates(()=>{\n                        eventHub.lostConnection.notify(\"restored\");\n                    });\n                }\n                _hasLostConnection = false;\n            }\n        }\n    }\n    function onDidConnect() {\n        context.buffer.presenceUpdates = {\n            type: \"full\",\n            data: // Because context.me.current is a readonly object, we'll have to\n            // make a copy here. Otherwise, type errors happen later when\n            // \"patching\" my presence.\n            {\n                ...context.myPresence.current\n            }\n        };\n        if (_getStorage$ !== null) {\n            refreshStorage({\n                flush: false\n            });\n        }\n        flushNowOrSoon();\n    }\n    function onDidDisconnect() {\n        clearTimeout(context.buffer.flushTimerID);\n    }\n    managedSocket.events.onMessage.subscribe(handleServerMessage);\n    managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n    managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n    managedSocket.events.didConnect.subscribe(onDidConnect);\n    managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n    managedSocket.events.onLiveblocksError.subscribe((err)=>{\n        batchUpdates(()=>{\n            if (true) {\n                error2(\"Connection to websocket server closed. Reason: \".concat(err.message, \" (code: \").concat(err.code, \").\"));\n            }\n            eventHub.error.notify(err);\n        });\n    });\n    const pool = {\n        roomId: config.roomId,\n        getNode: (id)=>context.nodes.get(id),\n        addNode: (id, node)=>void context.nodes.set(id, node),\n        deleteNode: (id)=>void context.nodes.delete(id),\n        generateId: ()=>\"\".concat(getConnectionId(), \":\").concat(context.clock++),\n        generateOpId: ()=>\"\".concat(getConnectionId(), \":\").concat(context.opClock++),\n        dispatch (ops, reverse, storageUpdates) {\n            const activeBatch = context.activeBatch;\n            if (true) {\n                const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n                if (stackTrace) {\n                    for (const op of ops){\n                        if (op.opId) {\n                            nn(context.opStackTraces).set(op.opId, stackTrace);\n                        }\n                    }\n                }\n            }\n            if (activeBatch) {\n                activeBatch.ops.push(...ops);\n                for (const [key, value] of storageUpdates){\n                    activeBatch.updates.storageUpdates.set(key, mergeStorageUpdates(activeBatch.updates.storageUpdates.get(key), value));\n                }\n                activeBatch.reverseOps.unshift(...reverse);\n            } else {\n                batchUpdates(()=>{\n                    addToUndoStack(reverse, doNotBatchUpdates);\n                    context.redoStack.length = 0;\n                    dispatchOps(ops);\n                    notify({\n                        storageUpdates\n                    }, doNotBatchUpdates);\n                });\n            }\n        },\n        assertStorageIsWritable: ()=>{\n            var _context_dynamicSessionInfo_current;\n            const scopes = (_context_dynamicSessionInfo_current = context.dynamicSessionInfo.current) === null || _context_dynamicSessionInfo_current === void 0 ? void 0 : _context_dynamicSessionInfo_current.scopes;\n            if (scopes === void 0) {\n                return;\n            }\n            const canWrite = canWriteStorage(scopes);\n            if (!canWrite) {\n                throw new Error(\"Cannot write to storage with a read only user, please ensure the user has write permissions\");\n            }\n        }\n    };\n    const eventHub = {\n        connection: makeEventSource(),\n        // Old/deprecated API\n        status: makeEventSource(),\n        // New/recommended API\n        lostConnection: makeEventSource(),\n        customEvent: makeEventSource(),\n        self: makeEventSource(),\n        myPresence: makeEventSource(),\n        others: makeEventSource(),\n        error: makeEventSource(),\n        storage: makeEventSource(),\n        history: makeEventSource(),\n        storageDidLoad: makeEventSource(),\n        storageStatus: makeEventSource(),\n        ydoc: makeEventSource(),\n        comments: makeEventSource()\n    };\n    async function streamFetch(authTokenOrPublicApiKey, roomId) {\n        var _config_polyfills;\n        const url = new URL(\"/v2/c/rooms/\".concat(encodeURIComponent(roomId), \"/storage\"), config.baseUrl).toString();\n        const fetcher = ((_config_polyfills = config.polyfills) === null || _config_polyfills === void 0 ? void 0 : _config_polyfills.fetch) || /* istanbul ignore next */ fetch;\n        return fetcher(url.toString(), {\n            method: \"GET\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: \"Bearer \".concat(authTokenOrPublicApiKey)\n            }\n        });\n    }\n    async function httpPostToRoom(endpoint, body) {\n        var _config_polyfills;\n        if (!managedSocket.authValue) {\n            throw new Error(\"Not authorized\");\n        }\n        const authTokenOrPublicApiKey = managedSocket.authValue.type === \"public\" ? managedSocket.authValue.publicApiKey : managedSocket.authValue.token.raw;\n        const url = new URL(\"/v2/c/rooms/\".concat(encodeURIComponent(config.roomId)).concat(endpoint), config.baseUrl).toString();\n        const fetcher = ((_config_polyfills = config.polyfills) === null || _config_polyfills === void 0 ? void 0 : _config_polyfills.fetch) || /* istanbul ignore next */ fetch;\n        return fetcher(url, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: \"Bearer \".concat(authTokenOrPublicApiKey)\n            },\n            body: JSON.stringify(body)\n        });\n    }\n    function sendMessages(messages) {\n        var _context_dynamicSessionInfo_current;\n        const serializedPayload = JSON.stringify(messages);\n        const nonce = (_context_dynamicSessionInfo_current = context.dynamicSessionInfo.current) === null || _context_dynamicSessionInfo_current === void 0 ? void 0 : _context_dynamicSessionInfo_current.nonce;\n        if (config.unstable_fallbackToHTTP && nonce) {\n            const size = new TextEncoder().encode(serializedPayload).length;\n            if (size > MAX_SOCKET_MESSAGE_SIZE) {\n                void httpPostToRoom(\"/send-message\", {\n                    nonce,\n                    messages\n                }).then((resp)=>{\n                    if (!resp.ok && resp.status === 403) {\n                        managedSocket.reconnect();\n                    }\n                });\n                warn(\"Message was too large for websockets and sent over HTTP instead\");\n                return;\n            }\n        }\n        managedSocket.send(serializedPayload);\n    }\n    const self = new DerivedRef(context.staticSessionInfo, context.dynamicSessionInfo, context.myPresence, (staticSession, dynamicSession, myPresence)=>{\n        if (staticSession === null || dynamicSession === null) {\n            return null;\n        } else {\n            const canWrite = canWriteStorage(dynamicSession.scopes);\n            return {\n                connectionId: dynamicSession.actor,\n                id: staticSession.userId,\n                info: staticSession.userInfo,\n                presence: myPresence,\n                canWrite,\n                canComment: canComment(dynamicSession.scopes),\n                isReadOnly: !canWrite\n            };\n        }\n    });\n    let _lastSelf;\n    function notifySelfChanged(batchedUpdatesWrapper) {\n        const currSelf = self.current;\n        if (currSelf !== null && currSelf !== _lastSelf) {\n            batchedUpdatesWrapper(()=>{\n                eventHub.self.notify(currSelf);\n            });\n            _lastSelf = currSelf;\n        }\n    }\n    const selfAsTreeNode = new DerivedRef(self, (me)=>me !== null ? userToTreeNode(\"Me\", me) : null);\n    function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {\n        if (message.items.length === 0) {\n            throw new Error(\"Internal error: cannot load storage without items\");\n        }\n        if (context.root !== void 0) {\n            updateRoot(message.items, batchedUpdatesWrapper);\n        } else {\n            context.root = LiveObject._fromItems(message.items, pool);\n        }\n        const stackSizeBefore = context.undoStack.length;\n        for(const key in context.initialStorage){\n            if (context.root.get(key) === void 0) {\n                context.root.set(key, cloneLson(context.initialStorage[key]));\n            }\n        }\n        context.undoStack.length = stackSizeBefore;\n    }\n    function updateRoot(items, batchedUpdatesWrapper) {\n        if (context.root === void 0) {\n            return;\n        }\n        const currentItems = /* @__PURE__ */ new Map();\n        for (const [id, node] of context.nodes){\n            currentItems.set(id, node._serialize());\n        }\n        const ops = getTreesDiffOperations(currentItems, new Map(items));\n        const result = applyOps(ops, false);\n        notify(result.updates, batchedUpdatesWrapper);\n    }\n    function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {\n        if (context.undoStack.length >= 50) {\n            context.undoStack.shift();\n        }\n        context.undoStack.push(historyOps);\n        onHistoryChange(batchedUpdatesWrapper);\n    }\n    function addToUndoStack(historyOps, batchedUpdatesWrapper) {\n        if (context.pausedHistory !== null) {\n            context.pausedHistory.unshift(...historyOps);\n        } else {\n            _addToRealUndoStack(historyOps, batchedUpdatesWrapper);\n        }\n    }\n    function notify(updates, batchedUpdatesWrapper) {\n        const storageUpdates = updates.storageUpdates;\n        const othersUpdates = updates.others;\n        batchedUpdatesWrapper(()=>{\n            if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n                const others = context.others.current;\n                for (const event of othersUpdates){\n                    eventHub.others.notify({\n                        ...event,\n                        others\n                    });\n                }\n            }\n            var _updates_presence;\n            if ((_updates_presence = updates.presence) !== null && _updates_presence !== void 0 ? _updates_presence : false) {\n                notifySelfChanged(doNotBatchUpdates);\n                eventHub.myPresence.notify(context.myPresence.current);\n            }\n            if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n                const updates2 = Array.from(storageUpdates.values());\n                eventHub.storage.notify(updates2);\n            }\n            notifyStorageStatus();\n        });\n    }\n    function getConnectionId() {\n        const info = context.dynamicSessionInfo.current;\n        if (info) {\n            return info.actor;\n        }\n        throw new Error(\"Internal. Tried to get connection id but connection was never open\");\n    }\n    function applyOps(rawOps, isLocal) {\n        const output = {\n            reverse: [],\n            storageUpdates: /* @__PURE__ */ new Map(),\n            presence: false\n        };\n        const createdNodeIds = /* @__PURE__ */ new Set();\n        const ops = rawOps.map((op)=>{\n            if (op.type !== \"presence\" && !op.opId) {\n                return {\n                    ...op,\n                    opId: pool.generateOpId()\n                };\n            } else {\n                return op;\n            }\n        });\n        for (const op of ops){\n            if (op.type === \"presence\") {\n                const reverse = {\n                    type: \"presence\",\n                    data: {}\n                };\n                for(const key in op.data){\n                    reverse.data[key] = context.myPresence.current[key];\n                }\n                context.myPresence.patch(op.data);\n                if (context.buffer.presenceUpdates === null) {\n                    context.buffer.presenceUpdates = {\n                        type: \"partial\",\n                        data: op.data\n                    };\n                } else {\n                    for(const key in op.data){\n                        context.buffer.presenceUpdates.data[key] = op.data[key];\n                    }\n                }\n                output.reverse.unshift(reverse);\n                output.presence = true;\n            } else {\n                let source;\n                if (isLocal) {\n                    source = 0 /* UNDOREDO_RECONNECT */ ;\n                } else {\n                    const opId = nn(op.opId);\n                    if (true) {\n                        nn(context.opStackTraces).delete(opId);\n                    }\n                    const deleted = context.unacknowledgedOps.delete(opId);\n                    source = deleted ? 2 /* ACK */  : 1 /* REMOTE */ ;\n                }\n                const applyOpResult = applyOp(op, source);\n                if (applyOpResult.modified) {\n                    const nodeId = applyOpResult.modified.node._id;\n                    if (!(nodeId && createdNodeIds.has(nodeId))) {\n                        output.storageUpdates.set(nn(applyOpResult.modified.node._id), mergeStorageUpdates(output.storageUpdates.get(nn(applyOpResult.modified.node._id)), applyOpResult.modified));\n                        output.reverse.unshift(...applyOpResult.reverse);\n                    }\n                    if (op.type === 2 /* CREATE_LIST */  || op.type === 7 /* CREATE_MAP */  || op.type === 4 /* CREATE_OBJECT */ ) {\n                        createdNodeIds.add(nn(op.id));\n                    }\n                }\n            }\n        }\n        return {\n            ops,\n            reverse: output.reverse,\n            updates: {\n                storageUpdates: output.storageUpdates,\n                presence: output.presence\n            }\n        };\n    }\n    function applyOp(op, source) {\n        if (isAckOp(op)) {\n            return {\n                modified: false\n            };\n        }\n        switch(op.type){\n            case 6 /* DELETE_OBJECT_KEY */ :\n            case 3 /* UPDATE_OBJECT */ :\n            case 5 /* DELETE_CRDT */ :\n                {\n                    const node = context.nodes.get(op.id);\n                    if (node === void 0) {\n                        return {\n                            modified: false\n                        };\n                    }\n                    return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */ );\n                }\n            case 1 /* SET_PARENT_KEY */ :\n                {\n                    const node = context.nodes.get(op.id);\n                    if (node === void 0) {\n                        return {\n                            modified: false\n                        };\n                    }\n                    if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n                        return node.parent.node._setChildKey(asPos(op.parentKey), node, source);\n                    }\n                    return {\n                        modified: false\n                    };\n                }\n            case 4 /* CREATE_OBJECT */ :\n            case 2 /* CREATE_LIST */ :\n            case 7 /* CREATE_MAP */ :\n            case 8 /* CREATE_REGISTER */ :\n                {\n                    if (op.parentId === void 0) {\n                        return {\n                            modified: false\n                        };\n                    }\n                    const parentNode = context.nodes.get(op.parentId);\n                    if (parentNode === void 0) {\n                        return {\n                            modified: false\n                        };\n                    }\n                    return parentNode._attachChild(op, source);\n                }\n        }\n    }\n    function updatePresence(patch, options2) {\n        const oldValues = {};\n        if (context.buffer.presenceUpdates === null) {\n            context.buffer.presenceUpdates = {\n                type: \"partial\",\n                data: {}\n            };\n        }\n        for(const key in patch){\n            const overrideValue = patch[key];\n            if (overrideValue === void 0) {\n                continue;\n            }\n            context.buffer.presenceUpdates.data[key] = overrideValue;\n            oldValues[key] = context.myPresence.current[key];\n        }\n        context.myPresence.patch(patch);\n        if (context.activeBatch) {\n            if (options2 === null || options2 === void 0 ? void 0 : options2.addToHistory) {\n                context.activeBatch.reverseOps.unshift({\n                    type: \"presence\",\n                    data: oldValues\n                });\n            }\n            context.activeBatch.updates.presence = true;\n        } else {\n            flushNowOrSoon();\n            batchUpdates(()=>{\n                if (options2 === null || options2 === void 0 ? void 0 : options2.addToHistory) {\n                    addToUndoStack([\n                        {\n                            type: \"presence\",\n                            data: oldValues\n                        }\n                    ], doNotBatchUpdates);\n                }\n                notify({\n                    presence: true\n                }, doNotBatchUpdates);\n            });\n        }\n    }\n    function onUpdatePresenceMessage(message) {\n        if (message.targetActor !== void 0) {\n            const oldUser = context.others.getUser(message.actor);\n            context.others.setOther(message.actor, message.data);\n            const newUser = context.others.getUser(message.actor);\n            if (oldUser === void 0 && newUser !== void 0) {\n                return {\n                    type: \"enter\",\n                    user: newUser\n                };\n            }\n        } else {\n            context.others.patchOther(message.actor, message.data), message;\n        }\n        const user = context.others.getUser(message.actor);\n        if (user) {\n            return {\n                type: \"update\",\n                updates: message.data,\n                user\n            };\n        } else {\n            return void 0;\n        }\n    }\n    function onUserLeftMessage(message) {\n        const user = context.others.getUser(message.actor);\n        if (user) {\n            context.others.removeConnection(message.actor);\n            return {\n                type: \"leave\",\n                user\n            };\n        }\n        return null;\n    }\n    function onRoomStateMessage(message, batchedUpdatesWrapper) {\n        context.dynamicSessionInfo.set({\n            actor: message.actor,\n            nonce: message.nonce,\n            scopes: message.scopes\n        });\n        context.idFactory = makeIdFactory(message.actor);\n        notifySelfChanged(batchedUpdatesWrapper);\n        for (const connectionId of context.others.connectionIds()){\n            const user = message.users[connectionId];\n            if (user === void 0) {\n                context.others.removeConnection(connectionId);\n            }\n        }\n        for(const key in message.users){\n            const user = message.users[key];\n            const connectionId = Number(key);\n            context.others.setConnection(connectionId, user.id, user.info, user.scopes);\n        }\n        return {\n            type: \"reset\"\n        };\n    }\n    function canUndo() {\n        return context.undoStack.length > 0;\n    }\n    function canRedo() {\n        return context.redoStack.length > 0;\n    }\n    function onHistoryChange(batchedUpdatesWrapper) {\n        batchedUpdatesWrapper(()=>{\n            eventHub.history.notify({\n                canUndo: canUndo(),\n                canRedo: canRedo()\n            });\n        });\n    }\n    function onUserJoinedMessage(message) {\n        context.others.setConnection(message.actor, message.id, message.info, message.scopes);\n        context.buffer.messages.push({\n            type: 100 /* UPDATE_PRESENCE */ ,\n            data: context.myPresence.current,\n            targetActor: message.actor\n        });\n        flushNowOrSoon();\n        const user = context.others.getUser(message.actor);\n        return user ? {\n            type: \"enter\",\n            user\n        } : void 0;\n    }\n    function parseServerMessage(data) {\n        if (!isJsonObject(data)) {\n            return null;\n        }\n        return data;\n    }\n    function parseServerMessages(text) {\n        const data = tryParseJson(text);\n        if (data === void 0) {\n            return null;\n        } else if (isJsonArray(data)) {\n            return compact(data.map((item)=>parseServerMessage(item)));\n        } else {\n            return compact([\n                parseServerMessage(data)\n            ]);\n        }\n    }\n    function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {\n        if (offlineOps.size === 0) {\n            return;\n        }\n        const messages = [];\n        const ops = Array.from(offlineOps.values());\n        const result = applyOps(ops, true);\n        messages.push({\n            type: 201 /* UPDATE_STORAGE */ ,\n            ops: result.ops\n        });\n        notify(result.updates, batchedUpdatesWrapper);\n        sendMessages(messages);\n    }\n    function handleServerMessage(event) {\n        if (typeof event.data !== \"string\") {\n            return;\n        }\n        const messages = parseServerMessages(event.data);\n        if (messages === null || messages.length === 0) {\n            return;\n        }\n        const updates = {\n            storageUpdates: /* @__PURE__ */ new Map(),\n            others: []\n        };\n        batchUpdates(()=>{\n            for (const message of messages){\n                switch(message.type){\n                    case 101 /* USER_JOINED */ :\n                        {\n                            const userJoinedUpdate = onUserJoinedMessage(message);\n                            if (userJoinedUpdate) {\n                                updates.others.push(userJoinedUpdate);\n                            }\n                            break;\n                        }\n                    case 100 /* UPDATE_PRESENCE */ :\n                        {\n                            const othersPresenceUpdate = onUpdatePresenceMessage(message);\n                            if (othersPresenceUpdate) {\n                                updates.others.push(othersPresenceUpdate);\n                            }\n                            break;\n                        }\n                    case 103 /* BROADCASTED_EVENT */ :\n                        {\n                            const others = context.others.current;\n                            var _others_find;\n                            eventHub.customEvent.notify({\n                                connectionId: message.actor,\n                                user: message.actor < 0 ? null : (_others_find = others.find((u)=>u.connectionId === message.actor)) !== null && _others_find !== void 0 ? _others_find : null,\n                                event: message.event\n                            });\n                            break;\n                        }\n                    case 102 /* USER_LEFT */ :\n                        {\n                            const event2 = onUserLeftMessage(message);\n                            if (event2) {\n                                updates.others.push(event2);\n                            }\n                            break;\n                        }\n                    case 300 /* UPDATE_YDOC */ :\n                        {\n                            eventHub.ydoc.notify(message);\n                            break;\n                        }\n                    case 104 /* ROOM_STATE */ :\n                        {\n                            updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));\n                            break;\n                        }\n                    case 200 /* INITIAL_STORAGE_STATE */ :\n                        {\n                            processInitialStorage(message);\n                            break;\n                        }\n                    case 201 /* UPDATE_STORAGE */ :\n                        {\n                            const applyResult = applyOps(message.ops, false);\n                            for (const [key, value] of applyResult.updates.storageUpdates){\n                                updates.storageUpdates.set(key, mergeStorageUpdates(updates.storageUpdates.get(key), value));\n                            }\n                            break;\n                        }\n                    case 299 /* REJECT_STORAGE_OP */ :\n                        {\n                            errorWithTitle(\"Storage mutation rejection error\", message.reason);\n                            if (true) {\n                                const traces = /* @__PURE__ */ new Set();\n                                for (const opId of message.opIds){\n                                    var _context_opStackTraces;\n                                    const trace = (_context_opStackTraces = context.opStackTraces) === null || _context_opStackTraces === void 0 ? void 0 : _context_opStackTraces.get(opId);\n                                    if (trace) {\n                                        traces.add(trace);\n                                    }\n                                }\n                                if (traces.size > 0) {\n                                    warnWithTitle(\"The following function calls caused the rejected storage mutations:\", \"\\n\\n\".concat(Array.from(traces).join(\"\\n\\n\")));\n                                }\n                                throw new Error(\"Storage mutations rejected by server: \".concat(message.reason));\n                            }\n                            break;\n                        }\n                    case 400 /* THREAD_CREATED */ :\n                    case 401 /* THREAD_METADATA_UPDATED */ :\n                    case 405 /* COMMENT_REACTION_ADDED */ :\n                    case 406 /* COMMENT_REACTION_REMOVED */ :\n                    case 402 /* COMMENT_CREATED */ :\n                    case 403 /* COMMENT_EDITED */ :\n                    case 404 /* COMMENT_DELETED */ :\n                        {\n                            eventHub.comments.notify(message);\n                            break;\n                        }\n                }\n            }\n            notify(updates, doNotBatchUpdates);\n        });\n    }\n    function flushNowOrSoon() {\n        const storageOps = context.buffer.storageOperations;\n        if (storageOps.length > 0) {\n            for (const op of storageOps){\n                context.unacknowledgedOps.set(nn(op.opId), op);\n            }\n            notifyStorageStatus();\n        }\n        if (managedSocket.getStatus() !== \"connected\") {\n            context.buffer.storageOperations = [];\n            return;\n        }\n        const now = Date.now();\n        const elapsedMillis = now - context.buffer.lastFlushedAt;\n        if (elapsedMillis >= config.throttleDelay) {\n            const messagesToFlush = serializeBuffer();\n            if (messagesToFlush.length === 0) {\n                return;\n            }\n            sendMessages(messagesToFlush);\n            context.buffer = {\n                flushTimerID: void 0,\n                lastFlushedAt: now,\n                messages: [],\n                storageOperations: [],\n                presenceUpdates: null\n            };\n        } else {\n            clearTimeout(context.buffer.flushTimerID);\n            context.buffer.flushTimerID = setTimeout(flushNowOrSoon, config.throttleDelay - elapsedMillis);\n        }\n    }\n    function serializeBuffer() {\n        const messages = [];\n        if (context.buffer.presenceUpdates) {\n            messages.push(context.buffer.presenceUpdates.type === \"full\" ? {\n                type: 100 /* UPDATE_PRESENCE */ ,\n                // Populating the `targetActor` field turns this message into\n                // a Full Presence update message (not a patch), which will get\n                // interpreted by other clients as such.\n                targetActor: -1,\n                data: context.buffer.presenceUpdates.data\n            } : {\n                type: 100 /* UPDATE_PRESENCE */ ,\n                data: context.buffer.presenceUpdates.data\n            });\n        }\n        for (const event of context.buffer.messages){\n            messages.push(event);\n        }\n        if (context.buffer.storageOperations.length > 0) {\n            messages.push({\n                type: 201 /* UPDATE_STORAGE */ ,\n                ops: context.buffer.storageOperations\n            });\n        }\n        return messages;\n    }\n    function updateYDoc(update, guid) {\n        const clientMsg = {\n            type: 301 /* UPDATE_YDOC */ ,\n            update,\n            guid\n        };\n        context.buffer.messages.push(clientMsg);\n        eventHub.ydoc.notify(clientMsg);\n        flushNowOrSoon();\n    }\n    function broadcastEvent(event) {\n        let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n            shouldQueueEventIfNotReady: false\n        };\n        if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n            return;\n        }\n        context.buffer.messages.push({\n            type: 103 /* BROADCAST_EVENT */ ,\n            event\n        });\n        flushNowOrSoon();\n    }\n    function dispatchOps(ops) {\n        context.buffer.storageOperations.push(...ops);\n        flushNowOrSoon();\n    }\n    let _getStorage$ = null;\n    let _resolveStoragePromise = null;\n    function processInitialStorage(message) {\n        const unacknowledgedOps = new Map(context.unacknowledgedOps);\n        createOrUpdateRootFromMessage(message, doNotBatchUpdates);\n        applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);\n        _resolveStoragePromise === null || _resolveStoragePromise === void 0 ? void 0 : _resolveStoragePromise();\n        notifyStorageStatus();\n        eventHub.storageDidLoad.notify();\n    }\n    async function streamStorage() {\n        if (!managedSocket.authValue) {\n            return;\n        }\n        const result = await streamFetch(managedSocket.authValue.type === \"public\" ? managedSocket.authValue.publicApiKey : managedSocket.authValue.token.raw, config.roomId);\n        const items = await result.json();\n        processInitialStorage({\n            type: 200 /* INITIAL_STORAGE_STATE */ ,\n            items\n        });\n    }\n    function refreshStorage(options2) {\n        const messages = context.buffer.messages;\n        if (config.unstable_streamData) {\n            void streamStorage();\n        } else if (!messages.some((msg)=>msg.type === 200 /* FETCH_STORAGE */ )) {\n            messages.push({\n                type: 200 /* FETCH_STORAGE */ \n            });\n        }\n        if (options2.flush) {\n            flushNowOrSoon();\n        }\n    }\n    function startLoadingStorage() {\n        if (_getStorage$ === null) {\n            refreshStorage({\n                flush: true\n            });\n            _getStorage$ = new Promise((resolve)=>{\n                _resolveStoragePromise = resolve;\n            });\n            notifyStorageStatus();\n        }\n        return _getStorage$;\n    }\n    function getStorageSnapshot() {\n        const root = context.root;\n        if (root !== void 0) {\n            return root;\n        } else {\n            void startLoadingStorage();\n            return null;\n        }\n    }\n    async function getStorage() {\n        if (context.root !== void 0) {\n            return Promise.resolve({\n                root: context.root\n            });\n        }\n        await startLoadingStorage();\n        return {\n            root: nn(context.root)\n        };\n    }\n    function fetchYDoc(vector, guid) {\n        if (!context.buffer.messages.find((m)=>{\n            return m.type === 300 /* FETCH_YDOC */  && m.vector === vector && m.guid === guid;\n        })) {\n            context.buffer.messages.push({\n                type: 300 /* FETCH_YDOC */ ,\n                vector,\n                guid\n            });\n        }\n        flushNowOrSoon();\n    }\n    function undo() {\n        if (context.activeBatch) {\n            throw new Error(\"undo is not allowed during a batch\");\n        }\n        const historyOps = context.undoStack.pop();\n        if (historyOps === void 0) {\n            return;\n        }\n        context.pausedHistory = null;\n        const result = applyOps(historyOps, true);\n        batchUpdates(()=>{\n            notify(result.updates, doNotBatchUpdates);\n            context.redoStack.push(result.reverse);\n            onHistoryChange(doNotBatchUpdates);\n        });\n        for (const op of result.ops){\n            if (op.type !== \"presence\") {\n                context.buffer.storageOperations.push(op);\n            }\n        }\n        flushNowOrSoon();\n    }\n    function redo() {\n        if (context.activeBatch) {\n            throw new Error(\"redo is not allowed during a batch\");\n        }\n        const historyOps = context.redoStack.pop();\n        if (historyOps === void 0) {\n            return;\n        }\n        context.pausedHistory = null;\n        const result = applyOps(historyOps, true);\n        batchUpdates(()=>{\n            notify(result.updates, doNotBatchUpdates);\n            context.undoStack.push(result.reverse);\n            onHistoryChange(doNotBatchUpdates);\n        });\n        for (const op of result.ops){\n            if (op.type !== \"presence\") {\n                context.buffer.storageOperations.push(op);\n            }\n        }\n        flushNowOrSoon();\n    }\n    function clear() {\n        context.undoStack.length = 0;\n        context.redoStack.length = 0;\n    }\n    function batch(callback) {\n        if (context.activeBatch) {\n            return callback();\n        }\n        let returnValue = void 0;\n        batchUpdates(()=>{\n            context.activeBatch = {\n                ops: [],\n                updates: {\n                    storageUpdates: /* @__PURE__ */ new Map(),\n                    presence: false,\n                    others: []\n                },\n                reverseOps: []\n            };\n            try {\n                returnValue = callback();\n            } finally{\n                const currentBatch = context.activeBatch;\n                context.activeBatch = null;\n                if (currentBatch.reverseOps.length > 0) {\n                    addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);\n                }\n                if (currentBatch.ops.length > 0) {\n                    context.redoStack.length = 0;\n                }\n                if (currentBatch.ops.length > 0) {\n                    dispatchOps(currentBatch.ops);\n                }\n                notify(currentBatch.updates, doNotBatchUpdates);\n                flushNowOrSoon();\n            }\n        });\n        return returnValue;\n    }\n    function pauseHistory() {\n        if (context.pausedHistory === null) {\n            context.pausedHistory = [];\n        }\n    }\n    function resumeHistory() {\n        const historyOps = context.pausedHistory;\n        context.pausedHistory = null;\n        if (historyOps !== null && historyOps.length > 0) {\n            _addToRealUndoStack(historyOps, batchUpdates);\n        }\n    }\n    function getStorageStatus() {\n        if (context.root === void 0) {\n            return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n        } else {\n            return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n        }\n    }\n    let _lastStorageStatus = getStorageStatus();\n    function notifyStorageStatus() {\n        const storageStatus = getStorageStatus();\n        if (_lastStorageStatus !== storageStatus) {\n            _lastStorageStatus = storageStatus;\n            eventHub.storageStatus.notify(storageStatus);\n        }\n    }\n    const others_forDevTools = new DerivedRef(context.others, (others)=>others.map((other, index)=>userToTreeNode(\"Other \".concat(index), other)));\n    const events = {\n        status: eventHub.status.observable,\n        lostConnection: eventHub.lostConnection.observable,\n        customEvent: eventHub.customEvent.observable,\n        others: eventHub.others.observable,\n        self: eventHub.self.observable,\n        myPresence: eventHub.myPresence.observable,\n        error: eventHub.error.observable,\n        storage: eventHub.storage.observable,\n        history: eventHub.history.observable,\n        storageDidLoad: eventHub.storageDidLoad.observable,\n        storageStatus: eventHub.storageStatus.observable,\n        ydoc: eventHub.ydoc.observable,\n        comments: eventHub.comments.observable\n    };\n    const commentsApi = createCommentsApi(config.roomId, delegates.authenticate, {\n        baseUrl: config.baseUrl\n    });\n    return Object.defineProperty({\n        /* NOTE: Exposing __internal here only to allow testing implementation details in unit tests */ __internal: {\n            get presenceBuffer () {\n                var _context_buffer_presenceUpdates;\n                var _context_buffer_presenceUpdates_data;\n                return deepClone((_context_buffer_presenceUpdates_data = (_context_buffer_presenceUpdates = context.buffer.presenceUpdates) === null || _context_buffer_presenceUpdates === void 0 ? void 0 : _context_buffer_presenceUpdates.data) !== null && _context_buffer_presenceUpdates_data !== void 0 ? _context_buffer_presenceUpdates_data : null);\n            },\n            // prettier-ignore\n            get undoStack () {\n                return deepClone(context.undoStack);\n            },\n            // prettier-ignore\n            get nodeCount () {\n                return context.nodes.size;\n            },\n            // prettier-ignore\n            // Support for the Liveblocks browser extension\n            getSelf_forDevTools: ()=>selfAsTreeNode.current,\n            getOthers_forDevTools: ()=>others_forDevTools.current,\n            // prettier-ignore\n            simulate: {\n                // These exist only for our E2E testing app\n                explicitClose: (event)=>managedSocket._privateSendMachineEvent({\n                        type: \"EXPLICIT_SOCKET_CLOSE\",\n                        event\n                    }),\n                rawSend: (data)=>managedSocket.send(data)\n            }\n        },\n        id: config.roomId,\n        subscribe: makeClassicSubscribeFn(events),\n        connect: ()=>managedSocket.connect(),\n        reconnect: ()=>managedSocket.reconnect(),\n        disconnect: ()=>managedSocket.disconnect(),\n        destroy: ()=>{\n            uninstallBgTabSpy();\n            managedSocket.destroy();\n        },\n        // Presence\n        updatePresence,\n        updateYDoc,\n        broadcastEvent,\n        // Storage\n        batch,\n        history: {\n            undo,\n            redo,\n            canUndo,\n            canRedo,\n            clear,\n            pause: pauseHistory,\n            resume: resumeHistory\n        },\n        fetchYDoc,\n        getStorage,\n        getStorageSnapshot,\n        getStorageStatus,\n        events,\n        // Core\n        getStatus: ()=>managedSocket.getStatus(),\n        getConnectionState: ()=>managedSocket.getLegacyStatus(),\n        getSelf: ()=>self.current,\n        // Presence\n        getPresence: ()=>context.myPresence.current,\n        getOthers: ()=>context.others.current,\n        ...commentsApi\n    }, // Explictly make the __internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    \"__internal\", {\n        enumerable: false\n    });\n}\nfunction makeClassicSubscribeFn(events) {\n    function subscribeToLiveStructureDeeply(node, callback) {\n        return events.storage.subscribe((updates)=>{\n            const relatedUpdates = updates.filter((update)=>isSameNodeOrChildOf(update.node, node));\n            if (relatedUpdates.length > 0) {\n                callback(relatedUpdates);\n            }\n        });\n    }\n    function subscribeToLiveStructureShallowly(node, callback) {\n        return events.storage.subscribe((updates)=>{\n            for (const update of updates){\n                if (update.node._id === node._id) {\n                    callback(update.node);\n                }\n            }\n        });\n    }\n    function subscribe(first, second, options) {\n        if (typeof first === \"string\" && isRoomEventName(first)) {\n            if (typeof second !== \"function\") {\n                throw new Error(\"Second argument must be a callback function\");\n            }\n            const callback = second;\n            switch(first){\n                case \"event\":\n                    return events.customEvent.subscribe(callback);\n                case \"my-presence\":\n                    return events.myPresence.subscribe(callback);\n                case \"others\":\n                    {\n                        const cb = callback;\n                        return events.others.subscribe((event)=>{\n                            const { others, ...internalEvent } = event;\n                            return cb(others, internalEvent);\n                        });\n                    }\n                case \"error\":\n                    return events.error.subscribe(callback);\n                case \"connection\":\n                    {\n                        const cb = callback;\n                        return events.status.subscribe((status)=>cb(newToLegacyStatus(status)));\n                    }\n                case \"status\":\n                    return events.status.subscribe(callback);\n                case \"lost-connection\":\n                    return events.lostConnection.subscribe(callback);\n                case \"history\":\n                    return events.history.subscribe(callback);\n                case \"storage-status\":\n                    return events.storageStatus.subscribe(callback);\n                default:\n                    return assertNever(first, '\"'.concat(String(first), '\" is not a valid event name'));\n            }\n        }\n        if (second === void 0 || typeof first === \"function\") {\n            if (typeof first === \"function\") {\n                const storageCallback = first;\n                return events.storage.subscribe(storageCallback);\n            } else {\n                throw new Error(\"Please specify a listener callback\");\n            }\n        }\n        if (isLiveNode(first)) {\n            const node = first;\n            if (options === null || options === void 0 ? void 0 : options.isDeep) {\n                const storageCallback = second;\n                return subscribeToLiveStructureDeeply(node, storageCallback);\n            } else {\n                const nodeCallback = second;\n                return subscribeToLiveStructureShallowly(node, nodeCallback);\n            }\n        }\n        throw new Error(\"\".concat(String(first), \" is not a value that can be subscribed to.\"));\n    }\n    return subscribe;\n}\nfunction isRoomEventName(value) {\n    return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n    return async ()=>{\n        return authManager.getAuthValue(\"room:read\", roomId);\n    };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n    return (authValue)=>{\n        const ws = WebSocketPolyfill !== null && WebSocketPolyfill !== void 0 ? WebSocketPolyfill : typeof WebSocket === \"undefined\" ? void 0 : WebSocket;\n        if (ws === void 0) {\n            throw new StopRetrying(\"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\");\n        }\n        const url = new URL(baseUrl);\n        url.protocol = url.protocol === \"http:\" ? \"ws\" : \"wss\";\n        url.pathname = \"/v7\";\n        url.searchParams.set(\"roomId\", roomId);\n        if (authValue.type === \"secret\") {\n            url.searchParams.set(\"tok\", authValue.token.raw);\n        } else if (authValue.type === \"public\") {\n            url.searchParams.set(\"pubkey\", authValue.publicApiKey);\n        } else {\n            return assertNever(authValue, \"Unhandled case\");\n        }\n        url.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n        return new ws(url.toString());\n    };\n}\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nfunction getBaseUrlFromClientOptions(clientOptions) {\n    if (\"liveblocksServer\" in clientOptions) {\n        throw new Error(\"Client option no longer supported\");\n    }\n    if (typeof clientOptions.baseUrl === \"string\" && clientOptions.baseUrl.startsWith(\"http\")) {\n        return clientOptions.baseUrl;\n    } else {\n        return DEFAULT_BASE_URL;\n    }\n}\nfunction createClient(options) {\n    const clientOptions = options;\n    var _clientOptions_throttle;\n    const throttleDelay = getThrottle((_clientOptions_throttle = clientOptions.throttle) !== null && _clientOptions_throttle !== void 0 ? _clientOptions_throttle : DEFAULT_THROTTLE);\n    var _clientOptions_lostConnectionTimeout;\n    const lostConnectionTimeout = getLostConnectionTimeout((_clientOptions_lostConnectionTimeout = clientOptions.lostConnectionTimeout) !== null && _clientOptions_lostConnectionTimeout !== void 0 ? _clientOptions_lostConnectionTimeout : DEFAULT_LOST_CONNECTION_TIMEOUT);\n    const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(clientOptions.backgroundKeepAliveTimeout);\n    const authManager = createAuthManager(options);\n    const roomsById = /* @__PURE__ */ new Map();\n    function teardownRoom(room) {\n        unlinkDevTools(room.id);\n        roomsById.delete(room.id);\n        room.destroy();\n    }\n    function leaseRoom(info) {\n        const leave = ()=>{\n            const self = leave;\n            if (!info.unsubs.delete(self)) {\n                warn(\"This leave function was already called. Calling it more than once has no effect.\");\n            } else {\n                if (info.unsubs.size === 0) {\n                    teardownRoom(info.room);\n                }\n            }\n        };\n        info.unsubs.add(leave);\n        return {\n            room: info.room,\n            leave\n        };\n    }\n    function enterRoom(roomId, options2) {\n        var _clientOptions_polyfills;\n        const existing = roomsById.get(roomId);\n        if (existing !== void 0) {\n            return leaseRoom(existing);\n        }\n        deprecateIf(options2.initialPresence === null || options2.initialPresence === void 0, \"Please provide an initial presence value for the current user when entering the room.\");\n        const baseUrl = getBaseUrlFromClientOptions(clientOptions);\n        var _options2_initialPresence, _clientOptions_mockedDelegates;\n        const newRoom = createRoom({\n            initialPresence: (_options2_initialPresence = options2.initialPresence) !== null && _options2_initialPresence !== void 0 ? _options2_initialPresence : {},\n            initialStorage: options2.initialStorage\n        }, {\n            roomId,\n            throttleDelay,\n            lostConnectionTimeout,\n            backgroundKeepAliveTimeout,\n            polyfills: clientOptions.polyfills,\n            delegates: (_clientOptions_mockedDelegates = clientOptions.mockedDelegates) !== null && _clientOptions_mockedDelegates !== void 0 ? _clientOptions_mockedDelegates : {\n                createSocket: makeCreateSocketDelegateForRoom(roomId, baseUrl, (_clientOptions_polyfills = clientOptions.polyfills) === null || _clientOptions_polyfills === void 0 ? void 0 : _clientOptions_polyfills.WebSocket),\n                authenticate: makeAuthDelegateForRoom(roomId, authManager)\n            },\n            enableDebugLogging: clientOptions.enableDebugLogging,\n            unstable_batchedUpdates: options2 === null || options2 === void 0 ? void 0 : options2.unstable_batchedUpdates,\n            baseUrl,\n            unstable_fallbackToHTTP: !!clientOptions.unstable_fallbackToHTTP,\n            unstable_streamData: !!clientOptions.unstable_streamData\n        });\n        const newRoomInfo = {\n            room: newRoom,\n            unsubs: /* @__PURE__ */ new Set()\n        };\n        roomsById.set(roomId, newRoomInfo);\n        setupDevTools(()=>Array.from(roomsById.keys()));\n        linkDevTools(roomId, newRoom);\n        var _options2_autoConnect, _ref;\n        const shouldConnect = (_ref = (_options2_autoConnect = options2.autoConnect) !== null && _options2_autoConnect !== void 0 ? _options2_autoConnect : options2.shouldInitiallyConnect) !== null && _ref !== void 0 ? _ref : true;\n        if (shouldConnect) {\n            if (typeof atob === \"undefined\") {\n                var _clientOptions_polyfills1;\n                if (((_clientOptions_polyfills1 = clientOptions.polyfills) === null || _clientOptions_polyfills1 === void 0 ? void 0 : _clientOptions_polyfills1.atob) === void 0) {\n                    throw new Error(\"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\");\n                }\n                global.atob = clientOptions.polyfills.atob;\n            }\n            newRoom.connect();\n        }\n        return leaseRoom(newRoomInfo);\n    }\n    function enter(roomId, options2) {\n        const { room, leave: _ } = enterRoom(roomId, options2);\n        return room;\n    }\n    function getRoom(roomId) {\n        var _roomsById_get;\n        const room = (_roomsById_get = roomsById.get(roomId)) === null || _roomsById_get === void 0 ? void 0 : _roomsById_get.room;\n        return room ? room : null;\n    }\n    function forceLeave(roomId) {\n        var _roomsById_get;\n        var _roomsById_get_unsubs;\n        const unsubs = (_roomsById_get_unsubs = (_roomsById_get = roomsById.get(roomId)) === null || _roomsById_get === void 0 ? void 0 : _roomsById_get.unsubs) !== null && _roomsById_get_unsubs !== void 0 ? _roomsById_get_unsubs : /* @__PURE__ */ new Set();\n        for (const unsub of unsubs){\n            unsub();\n        }\n    }\n    function logout() {\n        authManager.reset();\n        for (const { room } of roomsById.values()){\n            if (!isIdle(room.getStatus())) {\n                room.reconnect();\n            }\n        }\n    }\n    return {\n        logout,\n        // Old, deprecated APIs\n        enter,\n        getRoom,\n        leave: forceLeave,\n        // New, preferred API\n        enterRoom\n    };\n}\nfunction checkBounds(option, value, min, max, recommendedMin) {\n    if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n        throw new Error(max !== void 0 ? \"\".concat(option, \" should be between \").concat(recommendedMin !== null && recommendedMin !== void 0 ? recommendedMin : min, \" and \").concat(max, \".\") : \"\".concat(option, \" should be at least \").concat(recommendedMin !== null && recommendedMin !== void 0 ? recommendedMin : min, \".\"));\n    }\n    return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n    if (value === void 0) return void 0;\n    return checkBounds(\"backgroundKeepAliveTimeout\", value, MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT);\n}\nfunction getThrottle(value) {\n    return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n    return checkBounds(\"lostConnectionTimeout\", value, MIN_LOST_CONNECTION_TIMEOUT, MAX_LOST_CONNECTION_TIMEOUT, RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT);\n}\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n    if (lson instanceof LiveObject) {\n        return {\n            liveblocksType: \"LiveObject\",\n            data: Object.fromEntries(Object.entries(lson.toObject()).flatMap((param)=>{\n                let [key, value] = param;\n                return value !== void 0 ? [\n                    [\n                        key,\n                        toPlainLson(value)\n                    ]\n                ] : [];\n            }))\n        };\n    } else if (lson instanceof LiveMap) {\n        return {\n            liveblocksType: \"LiveMap\",\n            data: Object.fromEntries([\n                ...lson\n            ].map((param)=>{\n                let [key, value] = param;\n                return [\n                    key,\n                    toPlainLson(value)\n                ];\n            }))\n        };\n    } else if (lson instanceof LiveList) {\n        return {\n            liveblocksType: \"LiveList\",\n            data: [\n                ...lson\n            ].map((item)=>toPlainLson(item))\n        };\n    } else {\n        return lson;\n    }\n}\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n    const result = {};\n    for(const key in obj){\n        const val = obj[key];\n        if (val !== void 0) {\n            result[key] = lsonToJson(val);\n        }\n    }\n    return result;\n}\nfunction liveObjectToJson(liveObject) {\n    return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n    const result = {};\n    for (const [key, value] of map.entries()){\n        result[key] = lsonToJson(value);\n    }\n    return result;\n}\nfunction lsonListToJson(value) {\n    return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n    return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n    if (value instanceof LiveObject) {\n        return liveObjectToJson(value);\n    } else if (value instanceof LiveList) {\n        return liveListToJson(value);\n    } else if (value instanceof LiveMap) {\n        return liveMapToJson(value);\n    } else if (value instanceof LiveRegister) {\n        return value.data;\n    }\n    if (Array.isArray(value)) {\n        return lsonListToJson(value);\n    } else if (isPlainObject(value)) {\n        return lsonObjectToJson(value);\n    }\n    return value;\n}\nfunction deepLiveify(value) {\n    if (Array.isArray(value)) {\n        return new LiveList(value.map(deepLiveify));\n    } else if (isPlainObject(value)) {\n        const init = {};\n        for(const key in value){\n            const val = value[key];\n            if (val === void 0) {\n                continue;\n            }\n            init[key] = deepLiveify(val);\n        }\n        return new LiveObject(init);\n    } else {\n        return value;\n    }\n}\nfunction patchLiveList(liveList, prev, next) {\n    let i = 0;\n    let prevEnd = prev.length - 1;\n    let nextEnd = next.length - 1;\n    let prevNode = prev[0];\n    let nextNode = next[0];\n    outer: {\n        while(prevNode === nextNode){\n            ++i;\n            if (i > prevEnd || i > nextEnd) {\n                break outer;\n            }\n            prevNode = prev[i];\n            nextNode = next[i];\n        }\n        prevNode = prev[prevEnd];\n        nextNode = next[nextEnd];\n        while(prevNode === nextNode){\n            prevEnd--;\n            nextEnd--;\n            if (i > prevEnd || i > nextEnd) {\n                break outer;\n            }\n            prevNode = prev[prevEnd];\n            nextNode = next[nextEnd];\n        }\n    }\n    if (i > prevEnd) {\n        if (i <= nextEnd) {\n            while(i <= nextEnd){\n                liveList.insert(deepLiveify(next[i]), i);\n                i++;\n            }\n        }\n    } else if (i > nextEnd) {\n        let localI = i;\n        while(localI <= prevEnd){\n            liveList.delete(i);\n            localI++;\n        }\n    } else {\n        while(i <= prevEnd && i <= nextEnd){\n            prevNode = prev[i];\n            nextNode = next[i];\n            const liveListNode = liveList.get(i);\n            if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n                patchLiveObject(liveListNode, prevNode, nextNode);\n            } else {\n                liveList.set(i, deepLiveify(nextNode));\n            }\n            i++;\n        }\n        while(i <= nextEnd){\n            liveList.insert(deepLiveify(next[i]), i);\n            i++;\n        }\n        let localI = i;\n        while(localI <= prevEnd){\n            liveList.delete(i);\n            localI++;\n        }\n    }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n    if (true) {\n        const nonSerializableValue = findNonSerializableValue(next);\n        if (nonSerializableValue) {\n            error2(\"New state path: '\".concat(nonSerializableValue.path, \"' value: '\").concat(String(nonSerializableValue.value), \"' is not serializable.\\nOnly serializable value can be synced with Liveblocks.\"));\n            return;\n        }\n    }\n    const value = liveObject.get(key);\n    if (next === void 0) {\n        liveObject.delete(key);\n    } else if (value === void 0) {\n        liveObject.set(key, deepLiveify(next));\n    } else if (prev === next) {\n        return;\n    } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n        patchLiveList(value, prev, next);\n    } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n        patchLiveObject(value, prev, next);\n    } else {\n        liveObject.set(key, deepLiveify(next));\n    }\n}\nfunction patchLiveObject(root, prev, next) {\n    const updates = {};\n    for(const key in next){\n        patchLiveObjectKey(root, key, prev[key], next[key]);\n    }\n    for(const key in prev){\n        if (next[key] === void 0) {\n            root.delete(key);\n        }\n    }\n    if (Object.keys(updates).length > 0) {\n        root.update(updates);\n    }\n}\nfunction getParentsPath(node) {\n    const path = [];\n    while(node.parent.type === \"HasParent\"){\n        if (isLiveList(node.parent.node)) {\n            path.push(node.parent.node._indexOfPosition(node.parent.key));\n        } else {\n            path.push(node.parent.key);\n        }\n        node = node.parent.node;\n    }\n    return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n    return updates.reduce((state2, update)=>legacy_patchImmutableObjectWithUpdate(state2, update), state);\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n    const path = getParentsPath(update.node);\n    return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n    const pathItem = path.pop();\n    if (pathItem === void 0) {\n        switch(update.type){\n            case \"LiveObject\":\n                {\n                    if (!isJsonObject(state)) {\n                        throw new Error(\"Internal: received update on LiveObject but state was not an object\");\n                    }\n                    const newState = Object.assign({}, state);\n                    for(const key in update.updates){\n                        var _update_updates_key, _update_updates_key1;\n                        if (((_update_updates_key = update.updates[key]) === null || _update_updates_key === void 0 ? void 0 : _update_updates_key.type) === \"update\") {\n                            const val = update.node.get(key);\n                            if (val !== void 0) {\n                                newState[key] = lsonToJson(val);\n                            }\n                        } else if (((_update_updates_key1 = update.updates[key]) === null || _update_updates_key1 === void 0 ? void 0 : _update_updates_key1.type) === \"delete\") {\n                            delete newState[key];\n                        }\n                    }\n                    return newState;\n                }\n            case \"LiveList\":\n                {\n                    if (!Array.isArray(state)) {\n                        throw new Error(\"Internal: received update on LiveList but state was not an array\");\n                    }\n                    let newState = state.map((x)=>x);\n                    for (const listUpdate of update.updates){\n                        if (listUpdate.type === \"set\") {\n                            newState = newState.map((item, index)=>index === listUpdate.index ? lsonToJson(listUpdate.item) : item);\n                        } else if (listUpdate.type === \"insert\") {\n                            if (listUpdate.index === newState.length) {\n                                newState.push(lsonToJson(listUpdate.item));\n                            } else {\n                                newState = [\n                                    ...newState.slice(0, listUpdate.index),\n                                    lsonToJson(listUpdate.item),\n                                    ...newState.slice(listUpdate.index)\n                                ];\n                            }\n                        } else if (listUpdate.type === \"delete\") {\n                            newState.splice(listUpdate.index, 1);\n                        } else if (listUpdate.type === \"move\") {\n                            if (listUpdate.previousIndex > listUpdate.index) {\n                                newState = [\n                                    ...newState.slice(0, listUpdate.index),\n                                    lsonToJson(listUpdate.item),\n                                    ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                                    ...newState.slice(listUpdate.previousIndex + 1)\n                                ];\n                            } else {\n                                newState = [\n                                    ...newState.slice(0, listUpdate.previousIndex),\n                                    ...newState.slice(listUpdate.previousIndex + 1, listUpdate.index + 1),\n                                    lsonToJson(listUpdate.item),\n                                    ...newState.slice(listUpdate.index + 1)\n                                ];\n                            }\n                        }\n                    }\n                    return newState;\n                }\n            case \"LiveMap\":\n                {\n                    if (!isJsonObject(state)) {\n                        throw new Error(\"Internal: received update on LiveMap but state was not an object\");\n                    }\n                    const newState = Object.assign({}, state);\n                    for(const key in update.updates){\n                        var _update_updates_key2, _update_updates_key3;\n                        if (((_update_updates_key2 = update.updates[key]) === null || _update_updates_key2 === void 0 ? void 0 : _update_updates_key2.type) === \"update\") {\n                            const value = update.node.get(key);\n                            if (value !== void 0) {\n                                newState[key] = lsonToJson(value);\n                            }\n                        } else if (((_update_updates_key3 = update.updates[key]) === null || _update_updates_key3 === void 0 ? void 0 : _update_updates_key3.type) === \"delete\") {\n                            delete newState[key];\n                        }\n                    }\n                    return newState;\n                }\n        }\n    }\n    if (Array.isArray(state)) {\n        const newArray = [\n            ...state\n        ];\n        newArray[pathItem] = legacy_patchImmutableNode(state[pathItem], path, update);\n        return newArray;\n    } else if (isJsonObject(state)) {\n        const node = state[pathItem];\n        if (node === void 0) {\n            return state;\n        } else {\n            const stateAsObj = state;\n            return {\n                ...stateAsObj,\n                [pathItem]: legacy_patchImmutableNode(node, path, update)\n            };\n        }\n    } else {\n        return state;\n    }\n}\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n    if (xs.length !== ys.length) {\n        return false;\n    }\n    for(let i = 0; i < xs.length; i++){\n        if (!Object.is(xs[i], ys[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction shallowObj(objA, objB) {\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null || Object.prototype.toString.call(objA) !== \"[object Object]\" || Object.prototype.toString.call(objB) !== \"[object Object]\") {\n        return false;\n    }\n    const keysA = Object.keys(objA);\n    if (keysA.length !== Object.keys(objB).length) {\n        return false;\n    }\n    return keysA.every((key)=>Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key]));\n}\nfunction shallow(a, b) {\n    if (Object.is(a, b)) {\n        return true;\n    }\n    const isArrayA = Array.isArray(a);\n    const isArrayB = Array.isArray(b);\n    if (isArrayA || isArrayB) {\n        if (!isArrayA || !isArrayB) {\n            return false;\n        }\n        return shallowArray(a, b);\n    }\n    return shallowObj(a, b);\n}\n// src/lib/AsyncCache.ts\nvar noop = ()=>{};\nfunction isShallowEqual(a, b) {\n    if (a.isLoading !== b.isLoading || a.data === void 0 !== (b.data === void 0) || a.error === void 0 !== (b.error === void 0)) {\n        return false;\n    } else {\n        return shallow(a.data, b.data) && shallow(a.error, b.error);\n    }\n}\nfunction createCacheItem(key, asyncFunction, options) {\n    const $asyncFunction = async ()=>asyncFunction(key);\n    const context = {\n        isInvalid: true\n    };\n    let state = {\n        isLoading: false\n    };\n    let previousState = {\n        isLoading: false\n    };\n    const eventSource2 = makeEventSource();\n    function notify() {\n        var _options_isStateEqual;\n        const isEqual = (_options_isStateEqual = options === null || options === void 0 ? void 0 : options.isStateEqual) !== null && _options_isStateEqual !== void 0 ? _options_isStateEqual : isShallowEqual;\n        if (!isEqual(previousState, state)) {\n            previousState = state;\n            eventSource2.notify(state);\n        }\n    }\n    async function resolve() {\n        if (!context.promise) {\n            return;\n        }\n        try {\n            const data = await context.promise;\n            context.isInvalid = false;\n            state = {\n                isLoading: false,\n                data\n            };\n        } catch (error3) {\n            state = {\n                isLoading: false,\n                data: state.data,\n                error: error3\n            };\n        }\n        context.promise = void 0;\n        notify();\n    }\n    async function revalidate() {\n        context.isInvalid = true;\n        return get();\n    }\n    async function get() {\n        if (context.isInvalid) {\n            if (!context.promise) {\n                context.isInvalid = true;\n                context.promise = $asyncFunction();\n                state = {\n                    isLoading: true,\n                    data: state.data\n                };\n                notify();\n            }\n            await resolve();\n        }\n        return getState();\n    }\n    function getState() {\n        return state;\n    }\n    return {\n        ...eventSource2.observable,\n        get,\n        getState,\n        revalidate\n    };\n}\nfunction createAsyncCache(asyncFunction, options) {\n    const cache = /* @__PURE__ */ new Map();\n    function create(key) {\n        let cacheItem = cache.get(key);\n        if (cacheItem) {\n            return cacheItem;\n        }\n        cacheItem = createCacheItem(key, asyncFunction, options);\n        cache.set(key, cacheItem);\n        return cacheItem;\n    }\n    function get(key) {\n        return create(key).get();\n    }\n    function getState(key) {\n        var _cache_get;\n        return (_cache_get = cache.get(key)) === null || _cache_get === void 0 ? void 0 : _cache_get.getState();\n    }\n    function revalidate(key) {\n        return create(key).revalidate();\n    }\n    function subscribe(key, callback) {\n        var _create_subscribe;\n        return (_create_subscribe = create(key).subscribe(callback)) !== null && _create_subscribe !== void 0 ? _create_subscribe : noop;\n    }\n    function subscribeOnce(key, callback) {\n        var _create_subscribeOnce;\n        return (_create_subscribeOnce = create(key).subscribeOnce(callback)) !== null && _create_subscribeOnce !== void 0 ? _create_subscribeOnce : noop;\n    }\n    function has(key) {\n        return cache.has(key);\n    }\n    function clear() {\n        cache.clear();\n    }\n    return {\n        create,\n        get,\n        getState,\n        revalidate,\n        subscribe,\n        subscribeOnce,\n        has,\n        clear\n    };\n}\n// src/lib/Poller.ts\nfunction makePoller(callback) {\n    let context = {\n        state: \"stopped\",\n        timeoutHandle: null,\n        interval: null,\n        lastScheduledAt: null,\n        remainingInterval: null\n    };\n    function poll() {\n        if (context.state === \"running\") {\n            schedule(context.interval);\n        }\n        void callback();\n    }\n    function schedule(interval) {\n        context = {\n            state: \"running\",\n            interval: context.state !== \"stopped\" ? context.interval : interval,\n            lastScheduledAt: performance.now(),\n            timeoutHandle: setTimeout(poll, interval),\n            remainingInterval: null\n        };\n    }\n    function scheduleRemaining(remaining) {\n        if (context.state !== \"paused\") {\n            return;\n        }\n        context = {\n            state: \"running\",\n            interval: context.interval,\n            lastScheduledAt: context.lastScheduledAt,\n            timeoutHandle: setTimeout(poll, remaining),\n            remainingInterval: null\n        };\n    }\n    function start(interval) {\n        if (context.state === \"running\") {\n            return;\n        }\n        schedule(interval);\n    }\n    function restart(interval) {\n        stop();\n        start(interval);\n    }\n    function pause() {\n        if (context.state !== \"running\") {\n            return;\n        }\n        clearTimeout(context.timeoutHandle);\n        context = {\n            state: \"paused\",\n            interval: context.interval,\n            lastScheduledAt: context.lastScheduledAt,\n            timeoutHandle: null,\n            remainingInterval: context.interval - (performance.now() - context.lastScheduledAt)\n        };\n    }\n    function resume() {\n        if (context.state !== \"paused\") {\n            return;\n        }\n        scheduleRemaining(context.remainingInterval);\n    }\n    function stop() {\n        if (context.state === \"stopped\") {\n            return;\n        }\n        if (context.timeoutHandle) {\n            clearTimeout(context.timeoutHandle);\n        }\n        context = {\n            state: \"stopped\",\n            interval: null,\n            lastScheduledAt: null,\n            timeoutHandle: null,\n            remainingInterval: null\n        };\n    }\n    return {\n        start,\n        restart,\n        pause,\n        resume,\n        stop\n    };\n}\n// src/lib/stringify.ts\nfunction stringify(object) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (typeof object !== \"object\" || object === null || Array.isArray(object)) {\n        return JSON.stringify(object, ...args);\n    }\n    const sortedObject = Object.keys(object).sort().reduce((sortedObject2, key)=>{\n        sortedObject2[key] = object[key];\n        return sortedObject2;\n    }, {});\n    return JSON.stringify(sortedObject, ...args);\n}\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n //# sourceMappingURL=index.mjs.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"HasParent\");\n$RefreshReg$(_c1, \"Orphaned\");\n$RefreshReg$(_c2, \"HACK_addIntentAndDeletedIdToOperation\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9jb3JlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxZQUFZQyxPQUFPQyxjQUFjO0FBQ3JDLElBQUlDLFdBQVcsQ0FBQ0MsUUFBUUM7SUFDdEIsSUFBSyxJQUFJQyxRQUFRRCxJQUNmTCxVQUFVSSxRQUFRRSxNQUFNO1FBQUVDLEtBQUtGLEdBQUcsQ0FBQ0MsS0FBSztRQUFFRSxZQUFZO0lBQUs7QUFDL0Q7QUFFQSxpQkFBaUI7QUFDakIsSUFBSUMsV0FBVztBQUNmLElBQUlDLGNBQWM7QUFDbEIsSUFBSUMsYUFBYTtBQUVqQix3QkFBd0I7QUFDeEIsSUFBSUMsSUFBSSxPQUFPQyxlQUFlLGNBQWNBLGFBQWEsS0FBNkIsR0FBR0MsU0FBUyxDQUEyQztBQUM3SSxJQUFJRSxrQkFBa0I7QUFDdEIsSUFBSUMsWUFBWTtBQUNoQixJQUFJQyxRQUFRO0FBQ1osU0FBU0MsTUFBTUMsR0FBRztJQUNoQixJQUFJQyxLQUFxQyxFQUFFLEVBRTFDLE1BQU07UUFDTCxNQUFNLElBQUlFLE1BQU1IO0lBQ2xCO0FBQ0Y7QUFDQSxTQUFTSSxZQUFZQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsU0FBUztJQUNqRCxNQUFNQyxRQUFRQyxPQUFPQyxHQUFHLENBQUNMO0lBQ3pCLE1BQU1NLGVBQWVKLFlBQVksR0FBMkJBLE9BQXhCRCxjQUFjLE9BQU0sTUFBYyxPQUFWQyxXQUFVLE9BQUtELGNBQWM7SUFDekYsSUFBSSxDQUFDZCxDQUFDLENB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O1FBQ0FtaUM7UUFDQWpuQztRQUNBKytCO1FBQ0EvNUI7SUFDRjtBQUNGO0FBRUEsdUJBQXVCO0FBQ3ZCLFNBQVM0QixVQUFVc2dDLE1BQU07SUFBRTtRQUFHcGxDLEtBQUgsMkJBQU87O0lBQ2hDLElBQUksT0FBT29sQyxXQUFXLFlBQVlBLFdBQVcsUUFBUXArQixNQUFNQyxPQUFPLENBQUNtK0IsU0FBUztRQUMxRSxPQUFPdmdDLEtBQUtDLFNBQVMsQ0FBQ3NnQyxXQUFXcGxDO0lBQ25DO0lBQ0EsTUFBTXFsQyxlQUFlcnFDLE9BQU9vTyxJQUFJLENBQUNnOEIsUUFBUTFlLElBQUksR0FBRy9MLE1BQU0sQ0FDcEQsQ0FBQzJxQixlQUFlcGpDO1FBQ2RvakMsYUFBYSxDQUFDcGpDLElBQUksR0FBR2tqQyxNQUFNLENBQUNsakMsSUFBSTtRQUNoQyxPQUFPb2pDO0lBQ1QsR0FDQSxDQUFDO0lBRUgsT0FBT3pnQyxLQUFLQyxTQUFTLENBQUN1Z0MsaUJBQWlCcmxDO0FBQ3pDO0FBRUEsZUFBZTtBQUNmekQsWUFBWWYsVUFBVUMsYUFBYUM7QUFvRGpDLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9jb3JlL2Rpc3QvaW5kZXgubWpzPzg3MTUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL3ZlcnNpb24udHNcbnZhciBQS0dfTkFNRSA9IFwiQGxpdmVibG9ja3MvY29yZVwiO1xudmFyIFBLR19WRVJTSU9OID0gXCIxLjkuN1wiO1xudmFyIFBLR19GT1JNQVQgPSBcImVzbVwiO1xuXG4vLyBzcmMvZHVwZS1kZXRlY3Rpb24udHNcbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fTtcbnZhciBjcm9zc0xpbmtlZERvY3MgPSBcImh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2Vycm9ycy9jcm9zcy1saW5rZWRcIjtcbnZhciBkdXBlc0RvY3MgPSBcImh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2Vycm9ycy9kdXBlc1wiO1xudmFyIFNQQUNFID0gXCIgXCI7XG5mdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfVxufVxuZnVuY3Rpb24gZGV0ZWN0RHVwZXMocGtnTmFtZSwgcGtnVmVyc2lvbiwgcGtnRm9ybWF0KSB7XG4gIGNvbnN0IHBrZ0lkID0gU3ltYm9sLmZvcihwa2dOYW1lKTtcbiAgY29uc3QgcGtnQnVpbGRJbmZvID0gcGtnRm9ybWF0ID8gYCR7cGtnVmVyc2lvbiB8fCBcImRldlwifSAoJHtwa2dGb3JtYXR9KWAgOiBwa2dWZXJzaW9uIHx8IFwiZGV2XCI7XG4gIGlmICghZ1twa2dJZF0pIHtcbiAgICBnW3BrZ0lkXSA9IHBrZ0J1aWxkSW5mbztcbiAgfSBlbHNlIGlmIChnW3BrZ0lkXSA9PT0gcGtnQnVpbGRJbmZvKSB7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbXNnID0gW1xuICAgICAgYE11bHRpcGxlIGNvcGllcyBvZiBMaXZlYmxvY2tzIGFyZSBiZWluZyBsb2FkZWQgaW4geW91ciBwcm9qZWN0LiBUaGlzIHdpbGwgY2F1c2UgaXNzdWVzISBTZWUgJHtkdXBlc0RvY3MgKyBTUEFDRX1gLFxuICAgICAgXCJcIixcbiAgICAgIFwiQ29uZmxpY3RzOlwiLFxuICAgICAgYC0gJHtwa2dOYW1lfSAke2dbcGtnSWRdfSAoYWxyZWFkeSBsb2FkZWQpYCxcbiAgICAgIGAtICR7cGtnTmFtZX0gJHtwa2dCdWlsZEluZm99ICh0cnlpbmcgdG8gbG9hZCB0aGlzIG5vdylgXG4gICAgXS5qb2luKFwiXFxuXCIpO1xuICAgIGVycm9yKG1zZyk7XG4gIH1cbiAgaWYgKHBrZ1ZlcnNpb24gJiYgUEtHX1ZFUlNJT04gJiYgcGtnVmVyc2lvbiAhPT0gUEtHX1ZFUlNJT04pIHtcbiAgICBlcnJvcihcbiAgICAgIFtcbiAgICAgICAgYENyb3NzLWxpbmtlZCB2ZXJzaW9ucyBvZiBMaXZlYmxvY2tzIGZvdW5kLCB3aGljaCB3aWxsIGNhdXNlIGlzc3VlcyEgU2VlICR7Y3Jvc3NMaW5rZWREb2NzICsgU1BBQ0V9YCxcbiAgICAgICAgXCJcIixcbiAgICAgICAgXCJDb25mbGljdHM6XCIsXG4gICAgICAgIGAtICR7UEtHX05BTUV9IGlzIGF0ICR7UEtHX1ZFUlNJT059YCxcbiAgICAgICAgYC0gJHtwa2dOYW1lfSBpcyBhdCAke3BrZ1ZlcnNpb259YCxcbiAgICAgICAgXCJcIixcbiAgICAgICAgXCJBbHdheXMgdXBncmFkZSBhbGwgTGl2ZWJsb2NrcyBwYWNrYWdlcyB0byB0aGUgc2FtZSB2ZXJzaW9uIG51bWJlci5cIlxuICAgICAgXS5qb2luKFwiXFxuXCIpXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL2Fzc2VydC50c1xuZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3ZhbHVlLCBlcnJtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKGVycm1zZyk7XG59XG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBlcnJtc2cpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoZXJybXNnKTtcbiAgICAgIGVyci5uYW1lID0gXCJBc3NlcnRpb24gZmFpbHVyZVwiO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbm4odmFsdWUsIGVycm1zZyA9IFwiRXhwZWN0ZWQgdmFsdWUgdG8gYmUgbm9uLW51bGxhYmxlXCIpIHtcbiAgYXNzZXJ0KHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAsIGVycm1zZyk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gc3JjL2xpYi9jb250cm9sbGVkUHJvbWlzZS50c1xuZnVuY3Rpb24gY29udHJvbGxlZFByb21pc2UoKSB7XG4gIGxldCBmbGFnZ2VyO1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgIGZsYWdnZXIgPSByZXM7XG4gIH0pO1xuICBpZiAoIWZsYWdnZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaG91bGQgbmV2ZXIgaGFwcGVuXCIpO1xuICB9XG4gIHJldHVybiBbcHJvbWlzZSwgZmxhZ2dlcl07XG59XG5cbi8vIHNyYy9saWIvRXZlbnRTb3VyY2UudHNcbmZ1bmN0aW9uIG1ha2VFdmVudFNvdXJjZSgpIHtcbiAgY29uc3QgX29uZXRpbWVPYnNlcnZlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBfb2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IF9idWZmZXIgPSBudWxsO1xuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBfYnVmZmVyID0gW107XG4gIH1cbiAgZnVuY3Rpb24gdW5wYXVzZSgpIHtcbiAgICBpZiAoX2J1ZmZlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIF9idWZmZXIpIHtcbiAgICAgIG5vdGlmeShldmVudCk7XG4gICAgfVxuICAgIF9idWZmZXIgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgIF9vYnNlcnZlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4gX29ic2VydmVycy5kZWxldGUoY2FsbGJhY2spO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZU9uY2UoY2FsbGJhY2spIHtcbiAgICBfb25ldGltZU9ic2VydmVycy5hZGQoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiBfb25ldGltZU9ic2VydmVycy5kZWxldGUoY2FsbGJhY2spO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbChwcmVkaWNhdGUpIHtcbiAgICBsZXQgdW5zdWI7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgIHVuc3ViID0gc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICBpZiAocHJlZGljYXRlID09PSB2b2lkIDAgfHwgcHJlZGljYXRlKGV2ZW50KSkge1xuICAgICAgICAgIHJlcyhldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4gdW5zdWI/LigpKTtcbiAgfVxuICBmdW5jdGlvbiBub3RpZnlPckJ1ZmZlcihldmVudCkge1xuICAgIGlmIChfYnVmZmVyICE9PSBudWxsKSB7XG4gICAgICBfYnVmZmVyLnB1c2goZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3RpZnkoZXZlbnQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBub3RpZnkoZXZlbnQpIHtcbiAgICBfb25ldGltZU9ic2VydmVycy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soZXZlbnQpKTtcbiAgICBfb25ldGltZU9ic2VydmVycy5jbGVhcigpO1xuICAgIF9vYnNlcnZlcnMuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGV2ZW50KSk7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuY2xlYXIoKTtcbiAgICBfb2JzZXJ2ZXJzLmNsZWFyKCk7XG4gIH1cbiAgZnVuY3Rpb24gY291bnQoKSB7XG4gICAgcmV0dXJuIF9vbmV0aW1lT2JzZXJ2ZXJzLnNpemUgKyBfb2JzZXJ2ZXJzLnNpemU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAvLyBQcml2YXRlL2ludGVybmFsIGNvbnRyb2wgb3ZlciBldmVudCBlbWlzc2lvblxuICAgIG5vdGlmeTogbm90aWZ5T3JCdWZmZXIsXG4gICAgc3Vic2NyaWJlLFxuICAgIHN1YnNjcmliZU9uY2UsXG4gICAgY2xlYXIsXG4gICAgY291bnQsXG4gICAgd2FpdFVudGlsLFxuICAgIHBhdXNlLFxuICAgIHVucGF1c2UsXG4gICAgLy8gUHVibGljbHkgZXhwb3NhYmxlIHN1YnNjcmlwdGlvbiBBUElcbiAgICBvYnNlcnZhYmxlOiB7XG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBzdWJzY3JpYmVPbmNlLFxuICAgICAgd2FpdFVudGlsXG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbGliL2ZhbmN5LWNvbnNvbGUudHNcbnZhciBmYW5jeV9jb25zb2xlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGZhbmN5X2NvbnNvbGVfZXhwb3J0cywge1xuICBlcnJvcjogKCkgPT4gZXJyb3IyLFxuICBlcnJvcldpdGhUaXRsZTogKCkgPT4gZXJyb3JXaXRoVGl0bGUsXG4gIHdhcm46ICgpID0+IHdhcm4sXG4gIHdhcm5XaXRoVGl0bGU6ICgpID0+IHdhcm5XaXRoVGl0bGVcbn0pO1xudmFyIGJhZGdlID0gXCJiYWNrZ3JvdW5kOiMwZTBkMTI7Ym9yZGVyLXJhZGl1czo5OTk5cHg7Y29sb3I6I2ZmZjtwYWRkaW5nOjNweCA3cHg7Zm9udC1mYW1pbHk6c2Fucy1zZXJpZjtmb250LXdlaWdodDo2MDA7XCI7XG52YXIgYm9sZCA9IFwiZm9udC13ZWlnaHQ6NjAwXCI7XG5mdW5jdGlvbiB3cmFwKG1ldGhvZCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIgPyBjb25zb2xlW21ldGhvZF0gOiAoXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAobWVzc2FnZSwgLi4uYXJncykgPT4gY29uc29sZVttZXRob2RdKFwiJWNMaXZlYmxvY2tzXCIsIGJhZGdlLCBtZXNzYWdlLCAuLi5hcmdzKVxuICApO1xufVxudmFyIHdhcm4gPSB3cmFwKFwid2FyblwiKTtcbnZhciBlcnJvcjIgPSB3cmFwKFwiZXJyb3JcIik7XG5mdW5jdGlvbiB3cmFwV2l0aFRpdGxlKG1ldGhvZCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIgPyBjb25zb2xlW21ldGhvZF0gOiAoXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAodGl0bGUsIG1lc3NhZ2UsIC4uLmFyZ3MpID0+IGNvbnNvbGVbbWV0aG9kXShcbiAgICAgIGAlY0xpdmVibG9ja3MlYyAke3RpdGxlfWAsXG4gICAgICBiYWRnZSxcbiAgICAgIGJvbGQsXG4gICAgICBtZXNzYWdlLFxuICAgICAgLi4uYXJnc1xuICAgIClcbiAgKTtcbn1cbnZhciB3YXJuV2l0aFRpdGxlID0gd3JhcFdpdGhUaXRsZShcIndhcm5cIik7XG52YXIgZXJyb3JXaXRoVGl0bGUgPSB3cmFwV2l0aFRpdGxlKFwiZXJyb3JcIik7XG5cbi8vIHNyYy9saWIvZnNtLnRzXG5mdW5jdGlvbiBkaXN0YW5jZShzdGF0ZTEsIHN0YXRlMikge1xuICBpZiAoc3RhdGUxID09PSBzdGF0ZTIpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG4gIGNvbnN0IGNodW5rczEgPSBzdGF0ZTEuc3BsaXQoXCIuXCIpO1xuICBjb25zdCBjaHVua3MyID0gc3RhdGUyLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgbWluTGVuID0gTWF0aC5taW4oY2h1bmtzMS5sZW5ndGgsIGNodW5rczIubGVuZ3RoKTtcbiAgbGV0IHNoYXJlZCA9IDA7XG4gIGZvciAoOyBzaGFyZWQgPCBtaW5MZW47IHNoYXJlZCsrKSB7XG4gICAgaWYgKGNodW5rczFbc2hhcmVkXSAhPT0gY2h1bmtzMltzaGFyZWRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgdXAgPSBjaHVua3MxLmxlbmd0aCAtIHNoYXJlZDtcbiAgY29uc3QgZG93biA9IGNodW5rczIubGVuZ3RoIC0gc2hhcmVkO1xuICByZXR1cm4gW3VwLCBkb3duXTtcbn1cbmZ1bmN0aW9uIHBhdHRlcm5zKHRhcmdldFN0YXRlLCBsZXZlbHMpIHtcbiAgY29uc3QgcGFydHMgPSB0YXJnZXRTdGF0ZS5zcGxpdChcIi5cIik7XG4gIGlmIChsZXZlbHMgPCAxIHx8IGxldmVscyA+IHBhcnRzLmxlbmd0aCArIDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBsZXZlbHNcIik7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGlmIChsZXZlbHMgPiBwYXJ0cy5sZW5ndGgpIHtcbiAgICByZXN1bHQucHVzaChcIipcIik7XG4gIH1cbiAgZm9yIChsZXQgaSA9IHBhcnRzLmxlbmd0aCAtIGxldmVscyArIDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNsaWNlID0gcGFydHMuc2xpY2UoMCwgaSk7XG4gICAgaWYgKHNsaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKHNsaWNlLmpvaW4oXCIuXCIpICsgXCIuKlwiKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0LnB1c2godGFyZ2V0U3RhdGUpO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIFNhZmVDb250ZXh0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsQ29udGV4dCkge1xuICAgIHRoaXMuY3VyciA9IGluaXRpYWxDb250ZXh0O1xuICB9XG4gIGdldCBjdXJyZW50KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnI7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGFsbG93cyBwYXRjaGluZyBvZiB0aGUgY29udGV4dCwgYnlcbiAgICogY2FsbGluZyBgY29udGV4dC5wYXRjaCgpYC4gUGF0Y2hpbmcgaXMgb25seSBhbGxvd2VkIGZvciB0aGUgZHVyYXRpb25cbiAgICogb2YgdGhpcyB3aW5kb3cuXG4gICAqL1xuICBhbGxvd1BhdGNoaW5nKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGFsbG93ZWQgPSB0cnVlO1xuICAgIGNvbnN0IHBhdGNoYWJsZUNvbnRleHQgPSB7XG4gICAgICAuLi50aGlzLmN1cnIsXG4gICAgICBwYXRjaChwYXRjaCkge1xuICAgICAgICBpZiAoYWxsb3dlZCkge1xuICAgICAgICAgIHNlbGYuY3VyciA9IE9iamVjdC5hc3NpZ24oe30sIHNlbGYuY3VyciwgcGF0Y2gpO1xuICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBPYmplY3QuZW50cmllcyhwYXRjaCkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHBhaXI7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBcInBhdGNoXCIpIHtcbiAgICAgICAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBubyBsb25nZXIgcGF0Y2ggc3RhbGUgY29udGV4dFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY2FsbGJhY2socGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgYWxsb3dlZCA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxufTtcbnZhciBuZXh0SWQgPSAxO1xudmFyIEZTTSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluaXRpYWwgc3RhdGUsIHdoaWNoIGlzIGRlZmluZWQgYnkgdGhlIGZpcnN0IGNhbGwgbWFkZSB0b1xuICAgKiAuYWRkU3RhdGUoKS5cbiAgICovXG4gIGdldCBpbml0aWFsU3RhdGUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zdGF0ZXMudmFsdWVzKClbU3ltYm9sLml0ZXJhdG9yXSgpLm5leHQoKTtcbiAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN0YXRlcyBkZWZpbmVkIHlldFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0IGN1cnJlbnRTdGF0ZSgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50U3RhdGVPck51bGwgPT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSA9PT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHN0YXJ0ZWQgeWV0XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdG9wcGVkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U3RhdGVPck51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgbWFjaGluZSBieSBlbnRlcmluZyB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXRlIG1hY2hpbmUgaGFzIGFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5ydW5uaW5nU3RhdGUgPSAxIC8qIFNUQVJURUQgKi87XG4gICAgdGhpcy5jdXJyZW50U3RhdGVPck51bGwgPSB0aGlzLmluaXRpYWxTdGF0ZTtcbiAgICB0aGlzLmVudGVyKG51bGwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgc3RhdGUgbWFjaGluZS4gU3RvcHBpbmcgdGhlIHN0YXRlIG1hY2hpbmUgd2lsbCBjYWxsIGV4aXRcbiAgICogaGFuZGxlcnMgZm9yIHRoZSBjdXJyZW50IHN0YXRlLCBidXQgbm90IGVudGVyIGEgbmV3IHN0YXRlLlxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDEgLyogU1RBUlRFRCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN0b3AgYSBzdGF0ZSBtYWNoaW5lIHRoYXQgaGFzbid0IHN0YXJ0ZWQgeWV0XCIpO1xuICAgIH1cbiAgICB0aGlzLmV4aXQobnVsbCk7XG4gICAgdGhpcy5ydW5uaW5nU3RhdGUgPSAyIC8qIFNUT1BQRUQgKi87XG4gICAgdGhpcy5jdXJyZW50U3RhdGVPck51bGwgPSBudWxsO1xuICB9XG4gIGNvbnN0cnVjdG9yKGluaXRpYWxDb250ZXh0KSB7XG4gICAgdGhpcy5pZCA9IG5leHRJZCsrO1xuICAgIHRoaXMucnVubmluZ1N0YXRlID0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi87XG4gICAgdGhpcy5jdXJyZW50U3RhdGVPck51bGwgPSBudWxsO1xuICAgIHRoaXMuc3RhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmVudGVyRm5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmNsZWFudXBTdGFjayA9IFtdO1xuICAgIHRoaXMua25vd25FdmVudFR5cGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmFsbG93ZWRUcmFuc2l0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5jdXJyZW50Q29udGV4dCA9IG5ldyBTYWZlQ29udGV4dChpbml0aWFsQ29udGV4dCk7XG4gICAgdGhpcy5ldmVudEh1YiA9IHtcbiAgICAgIGRpZFJlY2VpdmVFdmVudDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICB3aWxsVHJhbnNpdGlvbjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICBkaWRJZ25vcmVFdmVudDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICB3aWxsRXhpdFN0YXRlOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIGRpZEVudGVyU3RhdGU6IG1ha2VFdmVudFNvdXJjZSgpXG4gICAgfTtcbiAgICB0aGlzLmV2ZW50cyA9IHtcbiAgICAgIGRpZFJlY2VpdmVFdmVudDogdGhpcy5ldmVudEh1Yi5kaWRSZWNlaXZlRXZlbnQub2JzZXJ2YWJsZSxcbiAgICAgIHdpbGxUcmFuc2l0aW9uOiB0aGlzLmV2ZW50SHViLndpbGxUcmFuc2l0aW9uLm9ic2VydmFibGUsXG4gICAgICBkaWRJZ25vcmVFdmVudDogdGhpcy5ldmVudEh1Yi5kaWRJZ25vcmVFdmVudC5vYnNlcnZhYmxlLFxuICAgICAgd2lsbEV4aXRTdGF0ZTogdGhpcy5ldmVudEh1Yi53aWxsRXhpdFN0YXRlLm9ic2VydmFibGUsXG4gICAgICBkaWRFbnRlclN0YXRlOiB0aGlzLmV2ZW50SHViLmRpZEVudGVyU3RhdGUub2JzZXJ2YWJsZVxuICAgIH07XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudDtcbiAgfVxuICAvKipcbiAgICogRGVmaW5lIGFuIGV4cGxpY2l0IGZpbml0ZSBzdGF0ZSBpbiB0aGUgc3RhdGUgbWFjaGluZS5cbiAgICovXG4gIGFkZFN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlcy5hZGQoc3RhdGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9uRW50ZXIobmFtZU9yUGF0dGVybiwgZW50ZXJGbikge1xuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZW50ZXJGbnMuaGFzKG5hbWVPclBhdHRlcm4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIC8vIFRPRE8gV2UgX2N1cnJlbnRseV8gZG9uJ3Qgc3VwcG9ydCBtdWx0aXBsZSAub25FbnRlcnMoKSBmb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gc3RhdGUsIGJ1dCB0aGlzIGlzIG5vdCBhIGZ1bmRhbWVudGFsIGxpbWl0YXRpb24uIEp1c3Qgbm90XG4gICAgICAgIC8vIGltcGxlbWVudGVkIHlldC4gSWYgd2Ugd2FudGVkIHRvLCB3ZSBjb3VsZCBtYWtlIHRoaXMgYW4gYXJyYXkuXG4gICAgICAgIGBlbnRlci9leGl0IGZ1bmN0aW9uIGZvciAke25hbWVPclBhdHRlcm59IGFscmVhZHkgZXhpc3RzYFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5lbnRlckZucy5zZXQobmFtZU9yUGF0dGVybiwgZW50ZXJGbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb25FbnRlckFzeW5jKG5hbWVPclBhdHRlcm4sIHByb21pc2VGbiwgb25PSywgb25FcnJvcikge1xuICAgIHJldHVybiB0aGlzLm9uRW50ZXIobmFtZU9yUGF0dGVybiwgKCkgPT4ge1xuICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgdm9pZCBwcm9taXNlRm4odGhpcy5jdXJyZW50Q29udGV4dC5jdXJyZW50KS50aGVuKFxuICAgICAgICAvLyBPbiBPS1xuICAgICAgICAoZGF0YSkgPT4ge1xuICAgICAgICAgIGlmICghY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24oeyB0eXBlOiBcIkFTWU5DX09LXCIsIGRhdGEgfSwgb25PSyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBPbiBFcnJvclxuICAgICAgICAocmVhc29uKSA9PiB7XG4gICAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbih7IHR5cGU6IFwiQVNZTkNfRVJST1JcIiwgcmVhc29uIH0sIG9uRXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGdldFN0YXRlc01hdGNoaW5nKG5hbWVPclBhdHRlcm4pIHtcbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgaWYgKG5hbWVPclBhdHRlcm4gPT09IFwiKlwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHN0YXRlIG9mIHRoaXMuc3RhdGVzKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChzdGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lT3JQYXR0ZXJuLmVuZHNXaXRoKFwiLipcIikpIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IG5hbWVPclBhdHRlcm4uc2xpY2UoMCwgLTEpO1xuICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiB0aGlzLnN0YXRlcykge1xuICAgICAgICBpZiAoc3RhdGUuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuYW1lID0gbmFtZU9yUGF0dGVybjtcbiAgICAgIGlmICh0aGlzLnN0YXRlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3RhdGVzIG1hdGNoICR7SlNPTi5zdHJpbmdpZnkobmFtZU9yUGF0dGVybil9YCk7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG4gIC8qKlxuICAgKiBEZWZpbmUgYWxsIGFsbG93ZWQgb3V0Z29pbmcgdHJhbnNpdGlvbnMgZm9yIGEgc3RhdGUuXG4gICAqXG4gICAqIFRoZSB0YXJnZXRzIGZvciBlYWNoIGV2ZW50IGNhbiBiZSBkZWZpbmVkIGFzIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGVcbiAgICogbmV4dCBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvLiBUaGVzZSBmdW5jdGlvbnMgY2FuIGxvb2sgYXQgdGhlIGBldmVudGAgb3JcbiAgICogYGNvbnRleHRgIHBhcmFtcyB0byBjb25kaXRpb25hbGx5IGRlY2lkZSB3aGljaCBuZXh0IHN0YXRlIHRvIHRyYW5zaXRpb25cbiAgICogdG8uXG4gICAqXG4gICAqIElmIHlvdSBzZXQgaXQgdG8gYG51bGxgLCB0aGVuIHRoZSB0cmFuc2l0aW9uIHdpbGwgYmUgZXhwbGljaXRseSBmb3JiaWRkZW5cbiAgICogYW5kIHRocm93IGFuIGVycm9yLiBJZiB5b3UgZG9uJ3QgZGVmaW5lIGEgdGFyZ2V0IGZvciBhIHRyYW5zaXRpb24sIHRoZW5cbiAgICogc3VjaCBldmVudHMgd2lsbCBnZXQgaWdub3JlZC5cbiAgICovXG4gIGFkZFRyYW5zaXRpb25zKG5hbWVPclBhdHRlcm4sIG1hcHBpbmcpIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3JjU3RhdGUgb2YgdGhpcy5nZXRTdGF0ZXNNYXRjaGluZyhuYW1lT3JQYXR0ZXJuKSkge1xuICAgICAgbGV0IG1hcCA9IHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zLmdldChzcmNTdGF0ZSk7XG4gICAgICBpZiAobWFwID09PSB2b2lkIDApIHtcbiAgICAgICAgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hbGxvd2VkVHJhbnNpdGlvbnMuc2V0KHNyY1N0YXRlLCBtYXApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbdHlwZSwgdGFyZ2V0X10gb2YgT2JqZWN0LmVudHJpZXMobWFwcGluZykpIHtcbiAgICAgICAgaWYgKG1hcC5oYXModHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVHJ5aW5nIHRvIHNldCB0cmFuc2l0aW9uIFwiJHt0eXBlfVwiIG9uIFwiJHtzcmNTdGF0ZX1cIiAodmlhIFwiJHtuYW1lT3JQYXR0ZXJufVwiKSwgYnV0IGEgdHJhbnNpdGlvbiBhbHJlYWR5IGV4aXN0cyB0aGVyZS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRfO1xuICAgICAgICB0aGlzLmtub3duRXZlbnRUeXBlcy5hZGQodHlwZSk7XG4gICAgICAgIGlmICh0YXJnZXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnN0IHRhcmdldEZuID0gdHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiID8gdGFyZ2V0IDogKCkgPT4gdGFyZ2V0O1xuICAgICAgICAgIG1hcC5zZXQodHlwZSwgdGFyZ2V0Rm4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBMaWtlIGAuYWRkVHJhbnNpdGlvbigpYCwgYnV0IHRha2VzIGFuIChhbm9ueW1vdXMpIHRyYW5zaXRpb24gd2hlbmV2ZXIgdGhlXG4gICAqIHRpbWVyIGZpcmVzLlxuICAgKlxuICAgKiBAcGFyYW0gc3RhdGVPclBhdHRlcm4gVGhlIHN0YXRlIG5hbWUsIG9yIHN0YXRlIGdyb3VwIHBhdHRlcm4gbmFtZS5cbiAgICogQHBhcmFtIGFmdGVyICAgICAgICAgIE51bWJlciBvZiBtaWxsaXNlY29uZHMgYWZ0ZXIgd2hpY2ggdG8gdGFrZSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uIElmIGluIHRoZSBtZWFuIHRpbWUsIGFub3RoZXIgdHJhbnNpdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgaXMgdGFrZW4sIHRoZSB0aW1lciB3aWxsIGdldCBjYW5jZWxsZWQuXG4gICAqIEBwYXJhbSB0YXJnZXQgICAgIFRoZSB0YXJnZXQgc3RhdGUgdG8gZ28gdG8uXG4gICAqL1xuICBhZGRUaW1lZFRyYW5zaXRpb24oc3RhdGVPclBhdHRlcm4sIGFmdGVyMiwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMub25FbnRlcihzdGF0ZU9yUGF0dGVybiwgKCkgPT4ge1xuICAgICAgY29uc3QgbXMgPSB0eXBlb2YgYWZ0ZXIyID09PSBcImZ1bmN0aW9uXCIgPyBhZnRlcjIodGhpcy5jdXJyZW50Q29udGV4dC5jdXJyZW50KSA6IGFmdGVyMjtcbiAgICAgIGNvbnN0IHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb24oeyB0eXBlOiBcIlRJTUVSXCIgfSwgdGFyZ2V0KTtcbiAgICAgIH0sIG1zKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBnZXRUYXJnZXRGbihldmVudE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxvd2VkVHJhbnNpdGlvbnMuZ2V0KHRoaXMuY3VycmVudFN0YXRlKT8uZ2V0KGV2ZW50TmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4aXRzIHRoZSBjdXJyZW50IHN0YXRlLCBhbmQgZXhlY3V0ZXMgYW55IG5lY2Vzc2FyeSBjbGVhbnVwIGZ1bmN0aW9ucy5cbiAgICogQ2FsbCB0aGlzIGJlZm9yZSBjaGFuZ2luZyB0aGUgY3VycmVudCBzdGF0ZSB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIGxldmVscyBEZWZpbmVzIGhvdyBtYW55IFwibGV2ZWxzXCIgb2YgbmVzdGluZyB3aWxsIGJlXG4gICAqIGV4aXRlZC4gRm9yIGV4YW1wbGUsIGlmIHlvdSB0cmFuc2l0aW9uIGZyb20gYGZvby5iYXIucXV4YCB0b1xuICAgKiBgZm9vLmJhci5iYXpgLCB0aGVuIHRoZSBsZXZlbCBpcyAxLiBCdXQgaWYgeW91IHRyYW5zaXRpb24gZnJvbVxuICAgKiBgZm9vLmJhci5xdXhgIHRvIGBibGEuYmxhYCwgdGhlbiB0aGUgbGV2ZWwgaXMgMy5cbiAgICogSWYgYG51bGxgLCBpdCB3aWxsIGV4aXQgYWxsIGxldmVscy5cbiAgICovXG4gIGV4aXQobGV2ZWxzKSB7XG4gICAgdGhpcy5ldmVudEh1Yi53aWxsRXhpdFN0YXRlLm5vdGlmeSh0aGlzLmN1cnJlbnRTdGF0ZSk7XG4gICAgdGhpcy5jdXJyZW50Q29udGV4dC5hbGxvd1BhdGNoaW5nKChwYXRjaGFibGVDb250ZXh0KSA9PiB7XG4gICAgICBsZXZlbHMgPSBsZXZlbHMgPz8gdGhpcy5jbGVhbnVwU3RhY2subGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHM7IGkrKykge1xuICAgICAgICB0aGlzLmNsZWFudXBTdGFjay5wb3AoKT8uKHBhdGNoYWJsZUNvbnRleHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFbnRlcnMgdGhlIGN1cnJlbnQgc3RhdGUsIGFuZCBleGVjdXRlcyBhbnkgbmVjZXNzYXJ5IG9uRW50ZXIgaGFuZGxlcnMuXG4gICAqIENhbGwgdGhpcyBkaXJlY3RseSBfYWZ0ZXJfIHNldHRpbmcgdGhlIGN1cnJlbnQgc3RhdGUgdG8gdGhlIG5leHQgc3RhdGUuXG4gICAqL1xuICBlbnRlcihsZXZlbHMpIHtcbiAgICBjb25zdCBlbnRlclBhdHRlcm5zID0gcGF0dGVybnMoXG4gICAgICB0aGlzLmN1cnJlbnRTdGF0ZSxcbiAgICAgIGxldmVscyA/PyB0aGlzLmN1cnJlbnRTdGF0ZS5zcGxpdChcIi5cIikubGVuZ3RoICsgMVxuICAgICk7XG4gICAgdGhpcy5jdXJyZW50Q29udGV4dC5hbGxvd1BhdGNoaW5nKChwYXRjaGFibGVDb250ZXh0KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgZW50ZXJQYXR0ZXJucykge1xuICAgICAgICBjb25zdCBlbnRlckZuID0gdGhpcy5lbnRlckZucy5nZXQocGF0dGVybik7XG4gICAgICAgIGNvbnN0IGNsZWFudXBGbiA9IGVudGVyRm4/LihwYXRjaGFibGVDb250ZXh0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhbnVwRm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRoaXMuY2xlYW51cFN0YWNrLnB1c2goY2xlYW51cEZuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNsZWFudXBTdGFjay5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5ldmVudEh1Yi5kaWRFbnRlclN0YXRlLm5vdGlmeSh0aGlzLmN1cnJlbnRTdGF0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGFuIGV2ZW50IHRvIHRoZSBtYWNoaW5lLCB3aGljaCBtYXkgY2F1c2UgYW4gaW50ZXJuYWwgc3RhdGVcbiAgICogdHJhbnNpdGlvbiB0byBoYXBwZW4uIFdoZW4gdGhhdCBoYXBwZW5zLCB3aWxsIHRyaWdnZXIgc2lkZSBlZmZlY3RzLlxuICAgKi9cbiAgc2VuZChldmVudCkge1xuICAgIGlmICghdGhpcy5rbm93bkV2ZW50VHlwZXMuaGFzKGV2ZW50LnR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZXZlbnQgJHtKU09OLnN0cmluZ2lmeShldmVudC50eXBlKX1gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlID09PSAyIC8qIFNUT1BQRUQgKi8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0Rm4gPSB0aGlzLmdldFRhcmdldEZuKGV2ZW50LnR5cGUpO1xuICAgIGlmICh0YXJnZXRGbiAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uKGV2ZW50LCB0YXJnZXRGbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXZlbnRIdWIuZGlkSWdub3JlRXZlbnQubm90aWZ5KGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgdHJhbnNpdGlvbihldmVudCwgdGFyZ2V0KSB7XG4gICAgdGhpcy5ldmVudEh1Yi5kaWRSZWNlaXZlRXZlbnQubm90aWZ5KGV2ZW50KTtcbiAgICBjb25zdCBvbGRTdGF0ZSA9IHRoaXMuY3VycmVudFN0YXRlO1xuICAgIGNvbnN0IHRhcmdldEZuID0gdHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiID8gdGFyZ2V0IDogKCkgPT4gdGFyZ2V0O1xuICAgIGNvbnN0IG5leHRUYXJnZXQgPSB0YXJnZXRGbihldmVudCwgdGhpcy5jdXJyZW50Q29udGV4dC5jdXJyZW50KTtcbiAgICBsZXQgbmV4dFN0YXRlO1xuICAgIGxldCBlZmZlY3RzID0gdm9pZCAwO1xuICAgIGlmIChuZXh0VGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICB0aGlzLmV2ZW50SHViLmRpZElnbm9yZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV4dFRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbmV4dFN0YXRlID0gbmV4dFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFN0YXRlID0gbmV4dFRhcmdldC50YXJnZXQ7XG4gICAgICBlZmZlY3RzID0gQXJyYXkuaXNBcnJheShuZXh0VGFyZ2V0LmVmZmVjdCkgPyBuZXh0VGFyZ2V0LmVmZmVjdCA6IFtuZXh0VGFyZ2V0LmVmZmVjdF07XG4gICAgfVxuICAgIGlmICghdGhpcy5zdGF0ZXMuaGFzKG5leHRTdGF0ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuZXh0IHN0YXRlIG5hbWU6ICR7SlNPTi5zdHJpbmdpZnkobmV4dFN0YXRlKX1gKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudEh1Yi53aWxsVHJhbnNpdGlvbi5ub3RpZnkoeyBmcm9tOiBvbGRTdGF0ZSwgdG86IG5leHRTdGF0ZSB9KTtcbiAgICBjb25zdCBbdXAsIGRvd25dID0gZGlzdGFuY2UodGhpcy5jdXJyZW50U3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgaWYgKHVwID4gMCkge1xuICAgICAgdGhpcy5leGl0KHVwKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50U3RhdGVPck51bGwgPSBuZXh0U3RhdGU7XG4gICAgaWYgKGVmZmVjdHMgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgZWZmZWN0c1RvUnVuID0gZWZmZWN0cztcbiAgICAgIHRoaXMuY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiBlZmZlY3RzVG9SdW4pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBlZmZlY3QocGF0Y2hhYmxlQ29udGV4dCwgZXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRjaGFibGVDb250ZXh0LnBhdGNoKGVmZmVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRvd24gPiAwKSB7XG4gICAgICB0aGlzLmVudGVyKGRvd24pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2xpYi91dGlscy50c1xuZnVuY3Rpb24gcmFpc2UobXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChibG9iKSB7XG4gIHJldHVybiBibG9iICE9PSBudWxsICYmIHR5cGVvZiBibG9iID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChibG9iKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbn1cbmZ1bmN0aW9uIGVudHJpZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvYmopO1xufVxuZnVuY3Rpb24gdHJ5UGFyc2VKc29uKHJhd01lc3NhZ2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyYXdNZXNzYWdlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZXBDbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gYjY0ZGVjb2RlKGI2NHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZm9ybWF0dGVkVmFsdWUgPSBiNjR2YWx1ZS5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbiAgICBjb25zdCBkZWNvZGVkVmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoXG4gICAgICBhdG9iKGZvcm1hdHRlZFZhbHVlKS5zcGxpdChcIlwiKS5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gXCIlXCIgKyAoXCIwMFwiICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICAgICAgfSkuam9pbihcIlwiKVxuICAgICk7XG4gICAgcmV0dXJuIGRlY29kZWRWYWx1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGF0b2IoYjY0dmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBjb21wYWN0KGl0ZW1zKSB7XG4gIHJldHVybiBpdGVtcy5maWx0ZXIoXG4gICAgKGl0ZW0pID0+IGl0ZW0gIT09IG51bGwgJiYgaXRlbSAhPT0gdm9pZCAwXG4gICk7XG59XG5mdW5jdGlvbiBjb21wYWN0T2JqZWN0KG9iaikge1xuICBjb25zdCBuZXdPYmogPSB7IC4uLm9iaiB9O1xuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goKGspID0+IHtcbiAgICBjb25zdCBrZXkgPSBrO1xuICAgIGlmIChuZXdPYmpba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxldGUgbmV3T2JqW2tleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ld09iajtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdpdGhUaW1lb3V0KHByb21pc2UsIG1pbGxpcywgZXJybXNnKSB7XG4gIGxldCB0aW1lcklEO1xuICBjb25zdCB0aW1lciQgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgdGltZXJJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJtc2cpKTtcbiAgICB9LCBtaWxsaXMpO1xuICB9KTtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbcHJvbWlzZSwgdGltZXIkXSkuZmluYWxseSgoKSA9PiBjbGVhclRpbWVvdXQodGltZXJJRCkpO1xufVxuXG4vLyBzcmMvcHJvdG9jb2wvU2VydmVyTXNnLnRzXG52YXIgU2VydmVyTXNnQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFNlcnZlck1zZ0NvZGUyKSA9PiB7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVBEQVRFX1BSRVNFTkNFXCJdID0gMTAwXSA9IFwiVVBEQVRFX1BSRVNFTkNFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVNFUl9KT0lORURcIl0gPSAxMDFdID0gXCJVU0VSX0pPSU5FRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVTRVJfTEVGVFwiXSA9IDEwMl0gPSBcIlVTRVJfTEVGVFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkJST0FEQ0FTVEVEX0VWRU5UXCJdID0gMTAzXSA9IFwiQlJPQURDQVNURURfRVZFTlRcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJST09NX1NUQVRFXCJdID0gMTA0XSA9IFwiUk9PTV9TVEFURVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIklOSVRJQUxfU1RPUkFHRV9TVEFURVwiXSA9IDIwMF0gPSBcIklOSVRJQUxfU1RPUkFHRV9TVEFURVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVQREFURV9TVE9SQUdFXCJdID0gMjAxXSA9IFwiVVBEQVRFX1NUT1JBR0VcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJSRUpFQ1RfU1RPUkFHRV9PUFwiXSA9IDI5OV0gPSBcIlJFSkVDVF9TVE9SQUdFX09QXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVBEQVRFX1lET0NcIl0gPSAzMDBdID0gXCJVUERBVEVfWURPQ1wiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9DUkVBVEVEXCJdID0gNDAwXSA9IFwiVEhSRUFEX0NSRUFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfTUVUQURBVEFfVVBEQVRFRFwiXSA9IDQwMV0gPSBcIlRIUkVBRF9NRVRBREFUQV9VUERBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9DUkVBVEVEXCJdID0gNDAyXSA9IFwiQ09NTUVOVF9DUkVBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9FRElURURcIl0gPSA0MDNdID0gXCJDT01NRU5UX0VESVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfREVMRVRFRFwiXSA9IDQwNF0gPSBcIkNPTU1FTlRfREVMRVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfUkVBQ1RJT05fQURERURcIl0gPSA0MDVdID0gXCJDT01NRU5UX1JFQUNUSU9OX0FEREVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEXCJdID0gNDA2XSA9IFwiQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEXCI7XG4gIHJldHVybiBTZXJ2ZXJNc2dDb2RlMjtcbn0pKFNlcnZlck1zZ0NvZGUgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvSVdlYlNvY2tldC50c1xudmFyIFdlYnNvY2tldENsb3NlQ29kZXMgPSAvKiBAX19QVVJFX18gKi8gKChXZWJzb2NrZXRDbG9zZUNvZGVzMikgPT4ge1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIkNMT1NFX0FCTk9STUFMXCJdID0gMTAwNl0gPSBcIkNMT1NFX0FCTk9STUFMXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiVU5FWFBFQ1RFRF9DT05ESVRJT05cIl0gPSAxMDExXSA9IFwiVU5FWFBFQ1RFRF9DT05ESVRJT05cIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJUUllfQUdBSU5fTEFURVJcIl0gPSAxMDEzXSA9IFwiVFJZX0FHQUlOX0xBVEVSXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiSU5WQUxJRF9NRVNTQUdFX0ZPUk1BVFwiXSA9IDRlM10gPSBcIklOVkFMSURfTUVTU0FHRV9GT1JNQVRcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJOT1RfQUxMT1dFRFwiXSA9IDQwMDFdID0gXCJOT1RfQUxMT1dFRFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX1NFQ09ORFNcIl0gPSA0MDAyXSA9IFwiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfU0VDT05EU1wiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU1wiXSA9IDQwMDNdID0gXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9EQVlfUEVSX0FQUFwiXSA9IDQwMDRdID0gXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9EQVlfUEVSX0FQUFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU19QRVJfUk9PTVwiXSA9IDQwMDVdID0gXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNfUEVSX1JPT01cIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJUT0tFTl9FWFBJUkVEXCJdID0gNDEwOV0gPSBcIlRPS0VOX0VYUElSRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJDTE9TRV9XSVRIT1VUX1JFVFJZXCJdID0gNDk5OV0gPSBcIkNMT1NFX1dJVEhPVVRfUkVUUllcIjtcbiAgcmV0dXJuIFdlYnNvY2tldENsb3NlQ29kZXMyO1xufSkoV2Vic29ja2V0Q2xvc2VDb2RlcyB8fCB7fSk7XG5mdW5jdGlvbiBzaG91bGREaXNjb25uZWN0KGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDQ5OTkgLyogQ0xPU0VfV0lUSE9VVF9SRVRSWSAqLyB8fCBjb2RlID49IDRlMyAmJiBjb2RlIDwgNDEwMDtcbn1cbmZ1bmN0aW9uIHNob3VsZFJlYXV0aChjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDQxMDAgJiYgY29kZSA8IDQyMDA7XG59XG5mdW5jdGlvbiBzaG91bGRSZXRyeVdpdGhvdXRSZWF1dGgoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAxMyAvKiBUUllfQUdBSU5fTEFURVIgKi8gfHwgY29kZSA+PSA0MjAwICYmIGNvZGUgPCA0MzAwO1xufVxuXG4vLyBzcmMvY29ubmVjdGlvbi50c1xuZnVuY3Rpb24gaXNJZGxlKHN0YXR1cykge1xuICByZXR1cm4gc3RhdHVzID09PSBcImluaXRpYWxcIiB8fCBzdGF0dXMgPT09IFwiZGlzY29ubmVjdGVkXCI7XG59XG5mdW5jdGlvbiBuZXdUb0xlZ2FjeVN0YXR1cyhzdGF0dXMpIHtcbiAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICBjYXNlIFwiY29ubmVjdGluZ1wiOlxuICAgICAgcmV0dXJuIFwiY29ubmVjdGluZ1wiO1xuICAgIGNhc2UgXCJjb25uZWN0ZWRcIjpcbiAgICAgIHJldHVybiBcIm9wZW5cIjtcbiAgICBjYXNlIFwicmVjb25uZWN0aW5nXCI6XG4gICAgICByZXR1cm4gXCJ1bmF2YWlsYWJsZVwiO1xuICAgIGNhc2UgXCJkaXNjb25uZWN0ZWRcIjpcbiAgICAgIHJldHVybiBcImZhaWxlZFwiO1xuICAgIGNhc2UgXCJpbml0aWFsXCI6XG4gICAgICByZXR1cm4gXCJjbG9zZWRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiY2xvc2VkXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvTmV3Q29ubmVjdGlvblN0YXR1cyhtYWNoaW5lKSB7XG4gIGNvbnN0IHN0YXRlID0gbWFjaGluZS5jdXJyZW50U3RhdGU7XG4gIHN3aXRjaCAoc3RhdGUpIHtcbiAgICBjYXNlIFwiQG9rLmNvbm5lY3RlZFwiOlxuICAgIGNhc2UgXCJAb2suYXdhaXRpbmctcG9uZ1wiOlxuICAgICAgcmV0dXJuIFwiY29ubmVjdGVkXCI7XG4gICAgY2FzZSBcIkBpZGxlLmluaXRpYWxcIjpcbiAgICAgIHJldHVybiBcImluaXRpYWxcIjtcbiAgICBjYXNlIFwiQGF1dGguYnVzeVwiOlxuICAgIGNhc2UgXCJAYXV0aC5iYWNrb2ZmXCI6XG4gICAgY2FzZSBcIkBjb25uZWN0aW5nLmJ1c3lcIjpcbiAgICBjYXNlIFwiQGNvbm5lY3RpbmcuYmFja29mZlwiOlxuICAgIGNhc2UgXCJAaWRsZS56b21iaWVcIjpcbiAgICAgIHJldHVybiBtYWNoaW5lLmNvbnRleHQuc3VjY2Vzc0NvdW50ID4gMCA/IFwicmVjb25uZWN0aW5nXCIgOiBcImNvbm5lY3RpbmdcIjtcbiAgICBjYXNlIFwiQGlkbGUuZmFpbGVkXCI6XG4gICAgICByZXR1cm4gXCJkaXNjb25uZWN0ZWRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHN0YXRlLCBcIlVua25vd24gc3RhdGVcIik7XG4gIH1cbn1cbnZhciBCQUNLT0ZGX0RFTEFZUyA9IFsyNTAsIDUwMCwgMWUzLCAyZTMsIDRlMywgOGUzLCAxZTRdO1xudmFyIFJFU0VUX0RFTEFZID0gQkFDS09GRl9ERUxBWVNbMF0gLSAxO1xudmFyIEJBQ0tPRkZfREVMQVlTX1NMT1cgPSBbMmUzLCAzZTQsIDZlNCwgM2U1XTtcbnZhciBIRUFSVEJFQVRfSU5URVJWQUwgPSAzZTQ7XG52YXIgUE9OR19USU1FT1VUID0gMmUzO1xudmFyIEFVVEhfVElNRU9VVCA9IDFlNDtcbnZhciBTT0NLRVRfQ09OTkVDVF9USU1FT1VUID0gMWU0O1xudmFyIFN0b3BSZXRyeWluZyA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihyZWFzb24pO1xuICB9XG59O1xudmFyIExpdmVibG9ja3NFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufTtcbmZ1bmN0aW9uIG5leHRCYWNrb2ZmRGVsYXkoY3VycmVudERlbGF5LCBkZWxheXMgPSBCQUNLT0ZGX0RFTEFZUykge1xuICByZXR1cm4gZGVsYXlzLmZpbmQoKGRlbGF5KSA9PiBkZWxheSA+IGN1cnJlbnREZWxheSkgPz8gZGVsYXlzW2RlbGF5cy5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGluY3JlYXNlQmFja29mZkRlbGF5KGNvbnRleHQpIHtcbiAgY29udGV4dC5wYXRjaCh7IGJhY2tvZmZEZWxheTogbmV4dEJhY2tvZmZEZWxheShjb250ZXh0LmJhY2tvZmZEZWxheSkgfSk7XG59XG5mdW5jdGlvbiBpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseShjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goe1xuICAgIGJhY2tvZmZEZWxheTogbmV4dEJhY2tvZmZEZWxheShjb250ZXh0LmJhY2tvZmZEZWxheSwgQkFDS09GRl9ERUxBWVNfU0xPVylcbiAgfSk7XG59XG5mdW5jdGlvbiByZXNldFN1Y2Nlc3NDb3VudChjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goeyBzdWNjZXNzQ291bnQ6IDAgfSk7XG59XG5mdW5jdGlvbiBsb2cobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgY29uc3QgbG9nZ2VyID0gbGV2ZWwgPT09IDIgLyogRVJST1IgKi8gPyBlcnJvcjIgOiBsZXZlbCA9PT0gMSAvKiBXQVJOICovID8gd2FybiA6IChcbiAgICAvKiBibGFjayBob2xlICovXG4gICAgKCkgPT4ge1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsb2dnZXIobWVzc2FnZSk7XG4gIH07XG59XG5mdW5jdGlvbiBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlKSB7XG4gIGNvbnN0IGNvbm4gPSBcIkNvbm5lY3Rpb24gdG8gTGl2ZWJsb2NrcyB3ZWJzb2NrZXQgc2VydmVyXCI7XG4gIHJldHVybiAoY3R4KSA9PiB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgd2FybihgJHtjb25ufSBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQuICR7U3RyaW5nKGUpfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBpc0Nsb3NlRXZlbnQoZSkgPyBgJHtjb25ufSBjbG9zZWQgcHJlbWF0dXJlbHkgKGNvZGU6ICR7ZS5jb2RlfSkuIFJldHJ5aW5nIGluICR7Y3R4LmJhY2tvZmZEZWxheX1tcy5gIDogYCR7Y29ubn0gY291bGQgbm90IGJlIGVzdGFibGlzaGVkLmBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbG9nQ2xvc2VFdmVudChldmVudCkge1xuICByZXR1cm4gKGN0eCkgPT4ge1xuICAgIHdhcm4oXG4gICAgICBgQ29ubmVjdGlvbiB0byBMaXZlYmxvY2tzIHdlYnNvY2tldCBzZXJ2ZXIgY2xvc2VkIChjb2RlOiAke2V2ZW50LmNvZGV9KS4gUmV0cnlpbmcgaW4gJHtjdHguYmFja29mZkRlbGF5fW1zLmBcbiAgICApO1xuICB9O1xufVxudmFyIGxvZ1Blcm1hbmVudENsb3NlID0gbG9nKFxuICAxIC8qIFdBUk4gKi8sXG4gIFwiQ29ubmVjdGlvbiB0byBXZWJTb2NrZXQgY2xvc2VkIHBlcm1hbmVudGx5LiBXb24ndCByZXRyeS5cIlxuKTtcbmZ1bmN0aW9uIGlzQ2xvc2VFdmVudChlcnJvcjMpIHtcbiAgcmV0dXJuICEoZXJyb3IzIGluc3RhbmNlb2YgRXJyb3IpICYmIGVycm9yMy50eXBlID09PSBcImNsb3NlXCI7XG59XG5mdW5jdGlvbiBlbmFibGVUcmFjaW5nKG1hY2hpbmUpIHtcbiAgY29uc3Qgc3RhcnQgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgZnVuY3Rpb24gbG9nMiguLi5hcmdzKSB7XG4gICAgd2FybihcbiAgICAgIGAkeygoKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydCkgLyAxZTMpLnRvRml4ZWQoMil9IFtGU00gIyR7bWFjaGluZS5pZH1dYCxcbiAgICAgIC4uLmFyZ3NcbiAgICApO1xuICB9XG4gIGNvbnN0IHVuc3VicyA9IFtcbiAgICBtYWNoaW5lLmV2ZW50cy5kaWRSZWNlaXZlRXZlbnQuc3Vic2NyaWJlKChlKSA9PiBsb2cyKGBFdmVudCAke2UudHlwZX1gKSksXG4gICAgbWFjaGluZS5ldmVudHMud2lsbFRyYW5zaXRpb24uc3Vic2NyaWJlKFxuICAgICAgKHsgZnJvbSwgdG8gfSkgPT4gbG9nMihcIlRyYW5zaXRpb25pbmdcIiwgZnJvbSwgXCJcXHUyMTkyXCIsIHRvKVxuICAgICksXG4gICAgbWFjaGluZS5ldmVudHMuZGlkSWdub3JlRXZlbnQuc3Vic2NyaWJlKFxuICAgICAgKGUpID0+IGxvZzIoXCJJZ25vcmVkIGV2ZW50XCIsIGUudHlwZSwgZSwgXCIoY3VycmVudCBzdGF0ZSB3b24ndCBoYW5kbGUgaXQpXCIpXG4gICAgKVxuICAgIC8vIG1hY2hpbmUuZXZlbnRzLndpbGxFeGl0U3RhdGUuc3Vic2NyaWJlKChzKSA9PiBsb2coXCJFeGl0aW5nIHN0YXRlXCIsIHMpKSxcbiAgICAvLyBtYWNoaW5lLmV2ZW50cy5kaWRFbnRlclN0YXRlLnN1YnNjcmliZSgocykgPT4gbG9nKFwiRW50ZXJpbmcgc3RhdGVcIiwgcykpLFxuICBdO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGZvciAoY29uc3QgdW5zdWIgb2YgdW5zdWJzKSB7XG4gICAgICB1bnN1YigpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmluZUNvbm5lY3Rpdml0eUV2ZW50cyhtYWNoaW5lKSB7XG4gIGNvbnN0IHN0YXR1c0RpZENoYW5nZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBjb25zdCBkaWRDb25uZWN0ID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGNvbnN0IGRpZERpc2Nvbm5lY3QgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgbGV0IGxhc3RTdGF0dXMgPSBudWxsO1xuICBjb25zdCB1bnN1YnNjcmliZSA9IG1hY2hpbmUuZXZlbnRzLmRpZEVudGVyU3RhdGUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICBjb25zdCBjdXJyU3RhdHVzID0gdG9OZXdDb25uZWN0aW9uU3RhdHVzKG1hY2hpbmUpO1xuICAgIGlmIChjdXJyU3RhdHVzICE9PSBsYXN0U3RhdHVzKSB7XG4gICAgICBzdGF0dXNEaWRDaGFuZ2Uubm90aWZ5KGN1cnJTdGF0dXMpO1xuICAgIH1cbiAgICBpZiAobGFzdFN0YXR1cyA9PT0gXCJjb25uZWN0ZWRcIiAmJiBjdXJyU3RhdHVzICE9PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBkaWREaXNjb25uZWN0Lm5vdGlmeSgpO1xuICAgIH0gZWxzZSBpZiAobGFzdFN0YXR1cyAhPT0gXCJjb25uZWN0ZWRcIiAmJiBjdXJyU3RhdHVzID09PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBkaWRDb25uZWN0Lm5vdGlmeSgpO1xuICAgIH1cbiAgICBsYXN0U3RhdHVzID0gY3VyclN0YXR1cztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzRGlkQ2hhbmdlOiBzdGF0dXNEaWRDaGFuZ2Uub2JzZXJ2YWJsZSxcbiAgICBkaWRDb25uZWN0OiBkaWRDb25uZWN0Lm9ic2VydmFibGUsXG4gICAgZGlkRGlzY29ubmVjdDogZGlkRGlzY29ubmVjdC5vYnNlcnZhYmxlLFxuICAgIHVuc3Vic2NyaWJlXG4gIH07XG59XG52YXIgYXNzaWduID0gKHBhdGNoKSA9PiAoY3R4KSA9PiBjdHgucGF0Y2gocGF0Y2gpO1xuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvblN0YXRlTWFjaGluZShkZWxlZ2F0ZXMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb25NZXNzYWdlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIG9uTWVzc2FnZS5wYXVzZSgpO1xuICBjb25zdCBvbkxpdmVibG9ja3NFcnJvciA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBmdW5jdGlvbiBmaXJlRXJyb3JFdmVudChlcnJtc2csIGVycmNvZGUpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gbmV3IExpdmVibG9ja3NFcnJvcihlcnJtc2csIGVycmNvZGUpO1xuICAgICAgb25MaXZlYmxvY2tzRXJyb3Iubm90aWZ5KGVycik7XG4gICAgfTtcbiAgfVxuICBjb25zdCBpbml0aWFsQ29udGV4dCA9IHtcbiAgICBzdWNjZXNzQ291bnQ6IDAsXG4gICAgYXV0aFZhbHVlOiBudWxsLFxuICAgIHNvY2tldDogbnVsbCxcbiAgICBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZXG4gIH07XG4gIGNvbnN0IG1hY2hpbmUgPSBuZXcgRlNNKGluaXRpYWxDb250ZXh0KS5hZGRTdGF0ZShcIkBpZGxlLmluaXRpYWxcIikuYWRkU3RhdGUoXCJAaWRsZS5mYWlsZWRcIikuYWRkU3RhdGUoXCJAaWRsZS56b21iaWVcIikuYWRkU3RhdGUoXCJAYXV0aC5idXN5XCIpLmFkZFN0YXRlKFwiQGF1dGguYmFja29mZlwiKS5hZGRTdGF0ZShcIkBjb25uZWN0aW5nLmJ1c3lcIikuYWRkU3RhdGUoXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIpLmFkZFN0YXRlKFwiQG9rLmNvbm5lY3RlZFwiKS5hZGRTdGF0ZShcIkBvay5hd2FpdGluZy1wb25nXCIpO1xuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiKlwiLCB7XG4gICAgUkVDT05ORUNUOiB7XG4gICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIHJlc2V0U3VjY2Vzc0NvdW50XVxuICAgIH0sXG4gICAgRElTQ09OTkVDVDogXCJAaWRsZS5pbml0aWFsXCJcbiAgfSk7XG4gIG1hY2hpbmUub25FbnRlcihcIkBpZGxlLipcIiwgcmVzZXRTdWNjZXNzQ291bnQpLmFkZFRyYW5zaXRpb25zKFwiQGlkbGUuKlwiLCB7XG4gICAgQ09OTkVDVDogKF8sIGN0eCkgPT4gKFxuICAgICAgLy8gSWYgd2Ugc3RpbGwgaGF2ZSBhIGtub3duIGF1dGhWYWx1ZSwgdHJ5IHRvIHJlY29ubmVjdCB0byB0aGUgc29ja2V0IGRpcmVjdGx5LFxuICAgICAgLy8gb3RoZXJ3aXNlLCB0cnkgdG8gb2J0YWluIGEgbmV3IGF1dGhWYWx1ZVxuICAgICAgY3R4LmF1dGhWYWx1ZSAhPT0gbnVsbCA/IFwiQGNvbm5lY3RpbmcuYnVzeVwiIDogXCJAYXV0aC5idXN5XCJcbiAgICApXG4gIH0pO1xuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiQGF1dGguYmFja29mZlwiLCB7XG4gICAgTkFWSUdBVE9SX09OTElORToge1xuICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHsgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWSB9KVxuICAgIH1cbiAgfSkuYWRkVGltZWRUcmFuc2l0aW9uKFxuICAgIFwiQGF1dGguYmFja29mZlwiLFxuICAgIChjdHgpID0+IGN0eC5iYWNrb2ZmRGVsYXksXG4gICAgXCJAYXV0aC5idXN5XCJcbiAgKS5vbkVudGVyQXN5bmMoXG4gICAgXCJAYXV0aC5idXN5XCIsXG4gICAgKCkgPT4gd2l0aFRpbWVvdXQoXG4gICAgICBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlKCksXG4gICAgICBBVVRIX1RJTUVPVVQsXG4gICAgICBcIlRpbWVkIG91dCBkdXJpbmcgYXV0aFwiXG4gICAgKSxcbiAgICAvLyBPbiBzdWNjZXNzZnVsIGF1dGhlbnRpY2F0aW9uXG4gICAgKG9rRXZlbnQpID0+ICh7XG4gICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oe1xuICAgICAgICBhdXRoVmFsdWU6IG9rRXZlbnQuZGF0YSxcbiAgICAgICAgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWVxuICAgICAgfSlcbiAgICB9KSxcbiAgICAvLyBBdXRoIGZhaWxlZFxuICAgIChmYWlsZWRFdmVudCkgPT4ge1xuICAgICAgaWYgKGZhaWxlZEV2ZW50LnJlYXNvbiBpbnN0YW5jZW9mIFN0b3BSZXRyeWluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgIGxvZygyIC8qIEVSUk9SICovLCBmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSksXG4gICAgICAgICAgICBmaXJlRXJyb3JFdmVudChmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSwgLTEpXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgaW5jcmVhc2VCYWNrb2ZmRGVsYXksXG4gICAgICAgICAgbG9nKFxuICAgICAgICAgICAgMiAvKiBFUlJPUiAqLyxcbiAgICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZmFpbGVkRXZlbnQucmVhc29uIGluc3RhbmNlb2YgRXJyb3IgPyBmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSA6IFN0cmluZyhmYWlsZWRFdmVudC5yZWFzb24pfWBcbiAgICAgICAgICApXG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuICApO1xuICBjb25zdCBvblNvY2tldEVycm9yID0gKGV2ZW50KSA9PiBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkVYUExJQ0lUX1NPQ0tFVF9FUlJPUlwiLCBldmVudCB9KTtcbiAgY29uc3Qgb25Tb2NrZXRDbG9zZSA9IChldmVudCkgPT4gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJFWFBMSUNJVF9TT0NLRVRfQ0xPU0VcIiwgZXZlbnQgfSk7XG4gIGNvbnN0IG9uU29ja2V0TWVzc2FnZSA9IChldmVudCkgPT4gZXZlbnQuZGF0YSA9PT0gXCJwb25nXCIgPyBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIlBPTkdcIiB9KSA6IG9uTWVzc2FnZS5ub3RpZnkoZXZlbnQpO1xuICBmdW5jdGlvbiB0ZWFyZG93blNvY2tldChzb2NrZXQpIHtcbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uU29ja2V0RXJyb3IpO1xuICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCBvblNvY2tldENsb3NlKTtcbiAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvblNvY2tldE1lc3NhZ2UpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgfVxuICB9XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsIHtcbiAgICBOQVZJR0FUT1JfT05MSU5FOiB7XG4gICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oeyBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZIH0pXG4gICAgfVxuICB9KS5hZGRUaW1lZFRyYW5zaXRpb24oXG4gICAgXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgKGN0eCkgPT4gY3R4LmJhY2tvZmZEZWxheSxcbiAgICBcIkBjb25uZWN0aW5nLmJ1c3lcIlxuICApLm9uRW50ZXJBc3luYyhcbiAgICBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAvL1xuICAgIC8vIFVzZSB0aGUgXCJjcmVhdGVTb2NrZXRcIiBkZWxlZ2F0ZSBmdW5jdGlvbiAocHJvdmlkZWQgdG8gdGhlXG4gICAgLy8gTWFuYWdlZFNvY2tldCkgdG8gY3JlYXRlIHRoZSBhY3R1YWwgV2ViU29ja2V0IGNvbm5lY3Rpb24gaW5zdGFuY2UuXG4gICAgLy8gVGhlbiwgc2V0IHVwIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycywgYW5kIHdhaXQgZm9yIHRoZVxuICAgIC8vIFwib3BlblwiIGV2ZW50IHRvIG9jY3VyLlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgXCJvcGVuXCIgZXZlbnQgaGFwcGVucywgd2UncmUgcmVhZHkgdG8gdHJhbnNpdGlvbiB0byB0aGVcbiAgICAvLyBPSyBzdGF0ZS4gVGhpcyBpcyBkb25lIGJ5IHJlc29sdmluZyB0aGUgUHJvbWlzZS5cbiAgICAvL1xuICAgIGFzeW5jIChjdHgpID0+IHtcbiAgICAgIGxldCBjYXB0dXJlZFByZW1hdHVyZUV2ZW50ID0gbnVsbDtcbiAgICAgIGNvbnN0IGNvbm5lY3QkID0gbmV3IFByb21pc2UoXG4gICAgICAgIChyZXNvbHZlLCByZWopID0+IHtcbiAgICAgICAgICBpZiAoY3R4LmF1dGhWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXV0aCBhdXRoVmFsdWVcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNvY2tldCA9IGRlbGVnYXRlcy5jcmVhdGVTb2NrZXQoY3R4LmF1dGhWYWx1ZSk7XG4gICAgICAgICAgZnVuY3Rpb24gcmVqZWN0KGV2ZW50KSB7XG4gICAgICAgICAgICBjYXB0dXJlZFByZW1hdHVyZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25Tb2NrZXRNZXNzYWdlKTtcbiAgICAgICAgICAgIHJlaihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IFthY3RvciQsIGRpZFJlY2VpdmVBY3Rvcl0gPSBjb250cm9sbGVkUHJvbWlzZSgpO1xuICAgICAgICAgIGlmICghb3B0aW9ucy53YWl0Rm9yQWN0b3JJZCkge1xuICAgICAgICAgICAgZGlkUmVjZWl2ZUFjdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHdhaXRGb3JBY3RvcklkKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJNc2cgPSB0cnlQYXJzZUpzb24oZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBpZiAoc2VydmVyTXNnPy50eXBlID09PSAxMDQgLyogUk9PTV9TVEFURSAqLykge1xuICAgICAgICAgICAgICBkaWRSZWNlaXZlQWN0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uU29ja2V0TWVzc2FnZSk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMud2FpdEZvckFjdG9ySWQpIHtcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB3YWl0Rm9yQWN0b3JJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIHJlamVjdCk7XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsICgpID0+IHtcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Tb2NrZXRFcnJvcik7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIG9uU29ja2V0Q2xvc2UpO1xuICAgICAgICAgICAgY29uc3QgdW5zdWIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCByZWplY3QpO1xuICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgd2FpdEZvckFjdG9ySWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZvaWQgYWN0b3IkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKFtzb2NrZXQsIHVuc3ViXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB3aXRoVGltZW91dChcbiAgICAgICAgY29ubmVjdCQsXG4gICAgICAgIFNPQ0tFVF9DT05ORUNUX1RJTUVPVVQsXG4gICAgICAgIFwiVGltZWQgb3V0IGR1cmluZyB3ZWJzb2NrZXQgY29ubmVjdGlvblwiXG4gICAgICApLnRoZW4oXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFBhcnQgMzpcbiAgICAgICAgLy8gQnkgbm93LCBvdXIgXCJvcGVuXCIgZXZlbnQgaGFzIGZpcmVkLCBhbmQgdGhlIHByb21pc2UgaGFzIGJlZW5cbiAgICAgICAgLy8gcmVzb2x2ZWQuIFR3byBwb3NzaWJsZSBzY2VuYXJpb3M6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDEuIFRoZSBoYXBweSBwYXRoLiBNb3N0IGxpa2VseS5cbiAgICAgICAgLy8gMi4gVWgtb2guIEEgcHJlbWF0dXJlIGNsb3NlL2Vycm9yIGV2ZW50IGhhcyBiZWVuIG9ic2VydmVkLiBMZXQnc1xuICAgICAgICAvLyAgICByZWplY3QgdGhlIHByb21pc2UgYWZ0ZXIgYWxsLlxuICAgICAgICAvL1xuICAgICAgICAvLyBBbnkgY2xvc2UvZXJyb3IgZXZlbnQgdGhhdCB3aWxsIGdldCBzY2hlZHVsZWQgYWZ0ZXIgdGhpcyBwb2ludFxuICAgICAgICAvLyBvbndhcmRzLCB3aWxsIGJlIGNhdWdodCBpbiB0aGUgT0sgc3RhdGUsIGFuZCBkZWFsdCB3aXRoXG4gICAgICAgIC8vIGFjY29yZGluZ2x5LlxuICAgICAgICAvL1xuICAgICAgICAoW3NvY2tldCwgdW5zdWJdKSA9PiB7XG4gICAgICAgICAgdW5zdWIoKTtcbiAgICAgICAgICBpZiAoY2FwdHVyZWRQcmVtYXR1cmVFdmVudCkge1xuICAgICAgICAgICAgdGhyb3cgY2FwdHVyZWRQcmVtYXR1cmVFdmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIC8vIE9ubHkgdHJhbnNpdGlvbiB0byBPSyBzdGF0ZSBhZnRlciBhIHN1Y2Nlc3NmdWxseSBvcGVuZWQgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgICAob2tFdmVudCkgPT4gKHtcbiAgICAgIHRhcmdldDogXCJAb2suY29ubmVjdGVkXCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7XG4gICAgICAgIHNvY2tldDogb2tFdmVudC5kYXRhLFxuICAgICAgICBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZXG4gICAgICB9KVxuICAgIH0pLFxuICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjYW5ub3QgYmUgZXN0YWJsaXNoZWRcbiAgICAoZmFpbHVyZSkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gZmFpbHVyZS5yZWFzb247XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgU3RvcFJldHJ5aW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgbG9nKDIgLyogRVJST1IgKi8sIGVyci5tZXNzYWdlKSxcbiAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGVyci5tZXNzYWdlLCAtMSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaXNDbG9zZUV2ZW50KGVycikpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSA0MTA5IC8qIFRPS0VOX0VYUElSRUQgKi8pIHtcbiAgICAgICAgICByZXR1cm4gXCJAYXV0aC5idXN5XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFJldHJ5V2l0aG91dFJlYXV0aChlcnIuY29kZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgICBpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseSxcbiAgICAgICAgICAgICAgbG9nUHJlbWF0dXJlRXJyb3JPckNsb3NlRXZlbnQoZXJyKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZERpc2Nvbm5lY3QoZXJyLmNvZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZXJyLnJlYXNvbiksXG4gICAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGVyci5yZWFzb24sIGVyci5jb2RlKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlcnIpXVxuICAgICAgfTtcbiAgICB9XG4gICk7XG4gIGNvbnN0IHNlbmRIZWFydGJlYXQgPSB7XG4gICAgdGFyZ2V0OiBcIkBvay5hd2FpdGluZy1wb25nXCIsXG4gICAgZWZmZWN0OiAoY3R4KSA9PiB7XG4gICAgICBjdHguc29ja2V0Py5zZW5kKFwicGluZ1wiKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1heWJlSGVhcnRiZWF0ID0gKCkgPT4ge1xuICAgIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICAgIGNvbnN0IGNhblpvbWJpZSA9IGRvYz8udmlzaWJpbGl0eVN0YXRlID09PSBcImhpZGRlblwiICYmIGRlbGVnYXRlcy5jYW5ab21iaWUoKTtcbiAgICByZXR1cm4gY2FuWm9tYmllID8gXCJAaWRsZS56b21iaWVcIiA6IHNlbmRIZWFydGJlYXQ7XG4gIH07XG4gIG1hY2hpbmUuYWRkVGltZWRUcmFuc2l0aW9uKFwiQG9rLmNvbm5lY3RlZFwiLCBIRUFSVEJFQVRfSU5URVJWQUwsIG1heWJlSGVhcnRiZWF0KS5hZGRUcmFuc2l0aW9ucyhcIkBvay5jb25uZWN0ZWRcIiwge1xuICAgIE5BVklHQVRPUl9PRkZMSU5FOiBtYXliZUhlYXJ0YmVhdCxcbiAgICAvLyBEb24ndCB0YWtlIHRoZSBicm93c2VyJ3Mgd29yZCBmb3IgaXQgd2hlbiBpdCBzYXlzIGl0J3Mgb2ZmbGluZS4gRG8gYSBwaW5nL3BvbmcgdG8gbWFrZSBzdXJlLlxuICAgIFdJTkRPV19HT1RfRk9DVVM6IHNlbmRIZWFydGJlYXRcbiAgfSk7XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCJAaWRsZS56b21iaWVcIiwge1xuICAgIFdJTkRPV19HT1RfRk9DVVM6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiXG4gICAgLy8gV2hlbiBpbiB6b21iaWUgc3RhdGUsIHRoZSBjbGllbnQgd2lsbCB0cnkgdG8gd2FrZSB1cCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHdpbmRvdyByZWdhaW5zIGZvY3VzXG4gIH0pO1xuICBtYWNoaW5lLm9uRW50ZXIoXCJAb2suKlwiLCAoY3R4KSA9PiB7XG4gICAgY3R4LnBhdGNoKHsgc3VjY2Vzc0NvdW50OiBjdHguc3VjY2Vzc0NvdW50ICsgMSB9KTtcbiAgICBjb25zdCB0aW1lcklEID0gc2V0VGltZW91dChcbiAgICAgIC8vIE9uIHRoZSBuZXh0IHRpY2ssIHN0YXJ0IGRlbGl2ZXJpbmcgYWxsIG1lc3NhZ2VzIHRoYXQgaGF2ZSBhbHJlYWR5XG4gICAgICAvLyBiZWVuIHJlY2VpdmVkLCBhbmQgY29udGludWUgc3luY2hyb25vdXMgZGVsaXZlcnkgb2YgYWxsIGZ1dHVyZVxuICAgICAgLy8gaW5jb21pbmcgbWVzc2FnZXMuXG4gICAgICBvbk1lc3NhZ2UudW5wYXVzZSxcbiAgICAgIDBcbiAgICApO1xuICAgIHJldHVybiAoY3R4MikgPT4ge1xuICAgICAgdGVhcmRvd25Tb2NrZXQoY3R4Mi5zb2NrZXQpO1xuICAgICAgY3R4Mi5wYXRjaCh7IHNvY2tldDogbnVsbCB9KTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklEKTtcbiAgICAgIG9uTWVzc2FnZS5wYXVzZSgpO1xuICAgIH07XG4gIH0pLmFkZFRyYW5zaXRpb25zKFwiQG9rLmF3YWl0aW5nLXBvbmdcIiwgeyBQT05HOiBcIkBvay5jb25uZWN0ZWRcIiB9KS5hZGRUaW1lZFRyYW5zaXRpb24oXCJAb2suYXdhaXRpbmctcG9uZ1wiLCBQT05HX1RJTUVPVVQsIHtcbiAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgIC8vIExvZyBpbXBsaWNpdCBjb25uZWN0aW9uIGxvc3MgYW5kIGRyb3AgdGhlIGN1cnJlbnQgb3BlbiBzb2NrZXRcbiAgICBlZmZlY3Q6IGxvZyhcbiAgICAgIDEgLyogV0FSTiAqLyxcbiAgICAgIFwiUmVjZWl2ZWQgbm8gcG9uZyBmcm9tIHNlcnZlciwgYXNzdW1lIGltcGxpY2l0IGNvbm5lY3Rpb24gbG9zcy5cIlxuICAgIClcbiAgfSkuYWRkVHJhbnNpdGlvbnMoXCJAb2suKlwiLCB7XG4gICAgLy8gV2hlbiBhIHNvY2tldCByZWNlaXZlcyBhbiBlcnJvciwgdGhpcyBjYW4gY2F1c2UgdGhlIGNsb3Npbmcgb2YgdGhlXG4gICAgLy8gc29ja2V0LCBvciBub3QuIFNvIGFsd2F5cyBjaGVjayB0byBzZWUgaWYgdGhlIHNvY2tldCBpcyBzdGlsbCBPUEVOIG9yXG4gICAgLy8gbm90LiBXaGVuIHN0aWxsIE9QRU4sIGRvbid0IHRyYW5zaXRpb24uXG4gICAgRVhQTElDSVRfU09DS0VUX0VSUk9SOiAoXywgY29udGV4dCkgPT4ge1xuICAgICAgaWYgKGNvbnRleHQuc29ja2V0Py5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBpbmNyZWFzZUJhY2tvZmZEZWxheVxuICAgICAgfTtcbiAgICB9LFxuICAgIEVYUExJQ0lUX1NPQ0tFVF9DTE9TRTogKGUpID0+IHtcbiAgICAgIGlmIChzaG91bGREaXNjb25uZWN0KGUuZXZlbnQuY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2dQZXJtYW5lbnRDbG9zZSxcbiAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGUuZXZlbnQucmVhc29uLCBlLmV2ZW50LmNvZGUpXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJlYXV0aChlLmV2ZW50LmNvZGUpKSB7XG4gICAgICAgIGlmIChlLmV2ZW50LmNvZGUgPT09IDQxMDkgLyogVE9LRU5fRVhQSVJFRCAqLykge1xuICAgICAgICAgIHJldHVybiBcIkBhdXRoLmJ1c3lcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dDbG9zZUV2ZW50KGUuZXZlbnQpXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZXRyeVdpdGhvdXRSZWF1dGgoZS5ldmVudC5jb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXlBZ2dyZXNzaXZlbHksIGxvZ0Nsb3NlRXZlbnQoZS5ldmVudCldXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheSwgbG9nQ2xvc2VFdmVudChlLmV2ZW50KV1cbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICAgIGNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB2b2lkIDA7XG4gICAgY29uc3Qgcm9vdCA9IHdpbiA/PyBkb2M7XG4gICAgbWFjaGluZS5vbkVudGVyKFwiKlwiLCAoY3R4KSA9PiB7XG4gICAgICBmdW5jdGlvbiBvbk5ldHdvcmtPZmZsaW5lKCkge1xuICAgICAgICBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIk5BVklHQVRPUl9PRkZMSU5FXCIgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvbk5ldHdvcmtCYWNrT25saW5lKCkge1xuICAgICAgICBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIk5BVklHQVRPUl9PTkxJTkVcIiB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICAgICAgaWYgKGRvYz8udmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIikge1xuICAgICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiV0lORE9XX0dPVF9GT0NVU1wiIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aW4/LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgb25OZXR3b3JrQmFja09ubGluZSk7XG4gICAgICB3aW4/LmFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIG9uTmV0d29ya09mZmxpbmUpO1xuICAgICAgcm9vdD8uYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJvb3Q/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICAgIHdpbj8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvbk5ldHdvcmtCYWNrT25saW5lKTtcbiAgICAgICAgd2luPy5yZW1vdmVFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBvbk5ldHdvcmtPZmZsaW5lKTtcbiAgICAgICAgdGVhcmRvd25Tb2NrZXQoY3R4LnNvY2tldCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IGNsZWFudXBzID0gW107XG4gIGNvbnN0IHsgc3RhdHVzRGlkQ2hhbmdlLCBkaWRDb25uZWN0LCBkaWREaXNjb25uZWN0LCB1bnN1YnNjcmliZSB9ID0gZGVmaW5lQ29ubmVjdGl2aXR5RXZlbnRzKG1hY2hpbmUpO1xuICBjbGVhbnVwcy5wdXNoKHVuc3Vic2NyaWJlKTtcbiAgaWYgKG9wdGlvbnMuZW5hYmxlRGVidWdMb2dnaW5nKSB7XG4gICAgY2xlYW51cHMucHVzaChlbmFibGVUcmFjaW5nKG1hY2hpbmUpKTtcbiAgfVxuICBtYWNoaW5lLnN0YXJ0KCk7XG4gIHJldHVybiB7XG4gICAgbWFjaGluZSxcbiAgICBjbGVhbnVwcyxcbiAgICAvLyBPYnNlcnZhYmxlIGV2ZW50cyB0aGF0IHdpbGwgYmUgZW1pdHRlZCBieSB0aGlzIG1hY2hpbmVcbiAgICBldmVudHM6IHtcbiAgICAgIHN0YXR1c0RpZENoYW5nZSxcbiAgICAgIGRpZENvbm5lY3QsXG4gICAgICBkaWREaXNjb25uZWN0LFxuICAgICAgb25NZXNzYWdlOiBvbk1lc3NhZ2Uub2JzZXJ2YWJsZSxcbiAgICAgIG9uTGl2ZWJsb2Nrc0Vycm9yOiBvbkxpdmVibG9ja3NFcnJvci5vYnNlcnZhYmxlXG4gICAgfVxuICB9O1xufVxudmFyIE1hbmFnZWRTb2NrZXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRlbGVnYXRlcywgZW5hYmxlRGVidWdMb2dnaW5nID0gZmFsc2UsIHdhaXRGb3JBY3RvcklkID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgbWFjaGluZSwgZXZlbnRzLCBjbGVhbnVwcyB9ID0gY3JlYXRlQ29ubmVjdGlvblN0YXRlTWFjaGluZShcbiAgICAgIGRlbGVnYXRlcyxcbiAgICAgIHsgd2FpdEZvckFjdG9ySWQsIGVuYWJsZURlYnVnTG9nZ2luZyB9XG4gICAgKTtcbiAgICB0aGlzLm1hY2hpbmUgPSBtYWNoaW5lO1xuICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgIHRoaXMuY2xlYW51cHMgPSBjbGVhbnVwcztcbiAgfVxuICBnZXRMZWdhY3lTdGF0dXMoKSB7XG4gICAgcmV0dXJuIG5ld1RvTGVnYWN5U3RhdHVzKHRoaXMuZ2V0U3RhdHVzKCkpO1xuICB9XG4gIGdldFN0YXR1cygpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRvTmV3Q29ubmVjdGlvblN0YXR1cyh0aGlzLm1hY2hpbmUpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIFwiaW5pdGlhbFwiO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBhdXRoIGF1dGhWYWx1ZS5cbiAgICovXG4gIGdldCBhdXRoVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFjaGluZS5jb250ZXh0LmF1dGhWYWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIG1ldGhvZCB0byB0cnkgdG8gY29ubmVjdCB0byBhIFdlYlNvY2tldC4gVGhpcyBvbmx5IGhhcyBhbiBlZmZlY3RcbiAgICogaWYgdGhlIG1hY2hpbmUgaXMgaWRsZSBhdCB0aGUgbW9tZW50LCBvdGhlcndpc2UgdGhpcyBpcyBhIG5vLW9wLlxuICAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICB0aGlzLm1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiQ09OTkVDVFwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJZiBpZGxlLCB3aWxsIHRyeSB0byBjb25uZWN0LiBPdGhlcndpc2UsIGl0IHdpbGwgYXR0ZW1wdCB0byByZWNvbm5lY3QgdG9cbiAgICogdGhlIHNvY2tldCwgcG90ZW50aWFsbHkgb2J0YWluaW5nIGEgbmV3IGF1dGhWYWx1ZSBmaXJzdCwgaWYgbmVlZGVkLlxuICAgKi9cbiAgcmVjb25uZWN0KCkge1xuICAgIHRoaXMubWFjaGluZS5zZW5kKHsgdHlwZTogXCJSRUNPTk5FQ1RcIiB9KTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIG1ldGhvZCB0byBkaXNjb25uZWN0IGZyb20gdGhlIGN1cnJlbnQgV2ViU29ja2V0LiBJcyBnb2luZyB0byBiZVxuICAgKiBhIG5vLW9wIGlmIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb25uZWN0aW9uLlxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLm1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiRElTQ09OTkVDVFwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgdG8gc3RvcCB0aGUgbWFjaGluZSBhbmQgcnVuIG5lY2Vzc2FyeSBjbGVhbnVwIGZ1bmN0aW9ucy4gQWZ0ZXJcbiAgICogY2FsbGluZyBkZXN0cm95KCksIHlvdSBjYW4gbm8gbG9uZ2VyIHVzZSB0aGlzIGluc3RhbmNlLiBDYWxsIHRoaXMgYmVmb3JlXG4gICAqIGxldHRpbmcgdGhlIGluc3RhbmNlIGdldCBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5tYWNoaW5lLnN0b3AoKTtcbiAgICBsZXQgY2xlYW51cDtcbiAgICB3aGlsZSAoY2xlYW51cCA9IHRoaXMuY2xlYW51cHMucG9wKCkpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNhZmVseSBzZW5kIGEgbWVzc2FnZSB0byB0aGUgY3VycmVudCBXZWJTb2NrZXQgY29ubmVjdGlvbi4gV2lsbCBlbWl0IGEgbG9nXG4gICAqIG1lc3NhZ2UgaWYgdGhpcyBpcyBzb21laG93IGltcG9zc2libGUuXG4gICAqL1xuICBzZW5kKGRhdGEpIHtcbiAgICBjb25zdCBzb2NrZXQgPSB0aGlzLm1hY2hpbmUuY29udGV4dD8uc29ja2V0O1xuICAgIGlmIChzb2NrZXQgPT09IG51bGwpIHtcbiAgICAgIHdhcm4oXCJDYW5ub3Qgc2VuZDogbm90IGNvbm5lY3RlZCB5ZXRcIiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChzb2NrZXQucmVhZHlTdGF0ZSAhPT0gMSkge1xuICAgICAgd2FybihcIkNhbm5vdCBzZW5kOiBXZWJTb2NrZXQgbm8gbG9uZ2VyIG9wZW5cIiwgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvY2tldC5zZW5kKGRhdGEpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTk9URTogVXNlZCBieSB0aGUgRTJFIGFwcCBvbmx5LCB0byBzaW11bGF0ZSBleHBsaWNpdCBldmVudHMuXG4gICAqIE5vdCBpZGVhbCB0byBrZWVwIGV4cG9zZWQgOihcbiAgICovXG4gIF9wcml2YXRlU2VuZE1hY2hpbmVFdmVudChldmVudCkge1xuICAgIHRoaXMubWFjaGluZS5zZW5kKGV2ZW50KTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3RvY29sL0F1dGhUb2tlbi50c1xuZnVuY3Rpb24gY2FuV3JpdGVTdG9yYWdlKHNjb3Blcykge1xuICByZXR1cm4gc2NvcGVzLmluY2x1ZGVzKFwicm9vbTp3cml0ZVwiIC8qIFdyaXRlICovKTtcbn1cbmZ1bmN0aW9uIGNhbkNvbW1lbnQoc2NvcGVzKSB7XG4gIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czp3cml0ZVwiIC8qIENvbW1lbnRzV3JpdGUgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkQXV0aFRva2VuUGF5bG9hZChkYXRhKSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KGRhdGEpICYmIChkYXRhLmsgPT09IFwiYWNjXCIgLyogQUNDRVNTX1RPS0VOICovIHx8IGRhdGEuayA9PT0gXCJpZFwiIC8qIElEX1RPS0VOICovIHx8IGRhdGEuayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyk7XG59XG5mdW5jdGlvbiBwYXJzZUF1dGhUb2tlbihyYXdUb2tlblN0cmluZykge1xuICBjb25zdCB0b2tlblBhcnRzID0gcmF3VG9rZW5TdHJpbmcuc3BsaXQoXCIuXCIpO1xuICBpZiAodG9rZW5QYXJ0cy5sZW5ndGggIT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdXRoZW50aWNhdGlvbiBlcnJvcjogaW52YWxpZCBKV1QgdG9rZW5cIik7XG4gIH1cbiAgY29uc3QgcGF5bG9hZCA9IHRyeVBhcnNlSnNvbihiNjRkZWNvZGUodG9rZW5QYXJ0c1sxXSkpO1xuICBpZiAoIShwYXlsb2FkICYmIGlzVmFsaWRBdXRoVG9rZW5QYXlsb2FkKHBheWxvYWQpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiQXV0aGVudGljYXRpb24gZXJyb3I6IGV4cGVjdGVkIGEgdmFsaWQgdG9rZW4gYnV0IGRpZCBub3QgZ2V0IG9uZS4gSGludDogaWYgeW91IGFyZSB1c2luZyBhIGNhbGxiYWNrLCBlbnN1cmUgdGhlIHJvb20gaXMgcGFzc2VkIHdoZW4gY3JlYXRpbmcgdGhlIHRva2VuLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRDYWxsYmFja1wiXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJhdzogcmF3VG9rZW5TdHJpbmcsXG4gICAgcGFyc2VkOiBwYXlsb2FkXG4gIH07XG59XG5cbi8vIHNyYy9hdXRoLW1hbmFnZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZUF1dGhNYW5hZ2VyKGF1dGhPcHRpb25zKSB7XG4gIGNvbnN0IGF1dGhlbnRpY2F0aW9uID0gcHJlcGFyZUF1dGhlbnRpY2F0aW9uKGF1dGhPcHRpb25zKTtcbiAgY29uc3Qgc2VlblRva2VucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHRva2VucyA9IFtdO1xuICBjb25zdCBleHBpcnlUaW1lcyA9IFtdO1xuICBjb25zdCByZXF1ZXN0UHJvbWlzZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBzZWVuVG9rZW5zLmNsZWFyKCk7XG4gICAgdG9rZW5zLmxlbmd0aCA9IDA7XG4gICAgZXhwaXJ5VGltZXMubGVuZ3RoID0gMDtcbiAgICByZXF1ZXN0UHJvbWlzZXMuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RlZFNjb3BlLCBzY29wZXMpIHtcbiAgICBpZiAocmVxdWVzdGVkU2NvcGUgPT09IFwiY29tbWVudHM6cmVhZFwiKSB7XG4gICAgICByZXR1cm4gc2NvcGVzLmluY2x1ZGVzKFwiY29tbWVudHM6cmVhZFwiIC8qIENvbW1lbnRzUmVhZCAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwiY29tbWVudHM6d3JpdGVcIiAvKiBDb21tZW50c1dyaXRlICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOnJlYWRcIiAvKiBSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xuICAgIH0gZWxzZSBpZiAocmVxdWVzdGVkU2NvcGUgPT09IFwicm9vbTpyZWFkXCIpIHtcbiAgICAgIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJyb29tOnJlYWRcIiAvKiBSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2FjaGVkVG9rZW4ocmVxdWVzdGVkU2NvcGUsIHJvb21JZCkge1xuICAgIGNvbnN0IG5vdyA9IE1hdGguY2VpbChEYXRlLm5vdygpIC8gMWUzKTtcbiAgICBmb3IgKGxldCBpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IGV4cGlyeVRpbWVzW2ldO1xuICAgICAgaWYgKGV4cGlyZXNBdCA8PSBub3cpIHtcbiAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxKTtcbiAgICAgICAgZXhwaXJ5VGltZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5wYXJzZWQuayA9PT0gXCJpZFwiIC8qIElEX1RPS0VOICovKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH0gZWxzZSBpZiAodG9rZW4ucGFyc2VkLmsgPT09IFwiYWNjXCIgLyogQUNDRVNTX1RPS0VOICovKSB7XG4gICAgICAgIGZvciAoY29uc3QgW3Jlc291cmNlLCBzY29wZXNdIG9mIE9iamVjdC5lbnRyaWVzKHRva2VuLnBhcnNlZC5wZXJtcykpIHtcbiAgICAgICAgICBpZiAocmVzb3VyY2UuaW5jbHVkZXMoXCIqXCIpICYmIHJvb21JZC5zdGFydHNXaXRoKHJlc291cmNlLnJlcGxhY2UoXCIqXCIsIFwiXCIpKSB8fCByb29tSWQgPT09IHJlc291cmNlICYmIGhhc0NvcnJlc3BvbmRpbmdTY29wZXMocmVxdWVzdGVkU2NvcGUsIHNjb3BlcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYWtlQXV0aFJlcXVlc3Qocm9vbUlkKSB7XG4gICAgY29uc3QgZmV0Y2hlciA9IGF1dGhPcHRpb25zLnBvbHlmaWxscz8uZmV0Y2ggPz8gKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyB2b2lkIDAgOiB3aW5kb3cuZmV0Y2gpO1xuICAgIGlmIChhdXRoZW50aWNhdGlvbi50eXBlID09PSBcInByaXZhdGVcIikge1xuICAgICAgaWYgKGZldGNoZXIgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKFxuICAgICAgICAgIFwiVG8gdXNlIExpdmVibG9ja3MgY2xpZW50IGluIGEgbm9uLURPTSBlbnZpcm9ubWVudCB3aXRoIGEgdXJsIGFzIGF1dGggZW5kcG9pbnQsIHlvdSBuZWVkIHRvIHByb3ZpZGUgYSBmZXRjaCBwb2x5ZmlsbC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEF1dGhFbmRwb2ludChmZXRjaGVyLCBhdXRoZW50aWNhdGlvbi51cmwsIHtcbiAgICAgICAgcm9vbTogcm9vbUlkXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQXV0aFRva2VuKHJlc3BvbnNlLnRva2VuKTtcbiAgICAgIGlmIChzZWVuVG9rZW5zLmhhcyhwYXJzZWQucmF3KSkge1xuICAgICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKFxuICAgICAgICAgIFwiVGhlIHNhbWUgTGl2ZWJsb2NrcyBhdXRoIHRva2VuIHdhcyBpc3N1ZWQgZnJvbSB0aGUgYmFja2VuZCBiZWZvcmUuIENhY2hpbmcgTGl2ZWJsb2NrcyB0b2tlbnMgaXMgbm90IHN1cHBvcnRlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwiY3VzdG9tXCIpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXV0aGVudGljYXRpb24uY2FsbGJhY2socm9vbUlkKTtcbiAgICAgIGlmIChyZXNwb25zZSAmJiB0eXBlb2YgcmVzcG9uc2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS50b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiBwYXJzZUF1dGhUb2tlbihyZXNwb25zZS50b2tlbik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlc3BvbnNlLmVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc3QgcmVhc29uID0gYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtcInJlYXNvblwiIGluIHJlc3BvbnNlICYmIHR5cGVvZiByZXNwb25zZS5yZWFzb24gPT09IFwic3RyaW5nXCIgPyByZXNwb25zZS5yZWFzb24gOiBcIkZvcmJpZGRlblwifWA7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yID09PSBcImZvcmJpZGRlblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKHJlYXNvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnWW91ciBhdXRoZW50aWNhdGlvbiBjYWxsYmFjayBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgdG9rZW4sIGJ1dCBpdCBkaWQgbm90LiBIaW50OiB0aGUgcmV0dXJuIHZhbHVlIHNob3VsZCBsb29rIGxpa2U6IHsgdG9rZW46IFwiLi4uXCIgfSdcbiAgICAgICk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVW5leHBlY3RlZCBhdXRoZW50aWNhdGlvbiB0eXBlLiBNdXN0IGJlIHByaXZhdGUgb3IgY3VzdG9tLlwiXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRBdXRoVmFsdWUocmVxdWVzdGVkU2NvcGUsIHJvb21JZCkge1xuICAgIGlmIChhdXRoZW50aWNhdGlvbi50eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInB1YmxpY1wiLCBwdWJsaWNBcGlLZXk6IGF1dGhlbnRpY2F0aW9uLnB1YmxpY0FwaUtleSB9O1xuICAgIH1cbiAgICBjb25zdCBjYWNoZWRUb2tlbiA9IGdldENhY2hlZFRva2VuKHJlcXVlc3RlZFNjb3BlLCByb29tSWQpO1xuICAgIGlmIChjYWNoZWRUb2tlbiAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInNlY3JldFwiLCB0b2tlbjogY2FjaGVkVG9rZW4gfTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRQcm9taXNlID0gcmVxdWVzdFByb21pc2VzLmdldChyb29tSWQpO1xuICAgIGlmIChjdXJyZW50UHJvbWlzZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IG1ha2VBdXRoUmVxdWVzdChyb29tSWQpO1xuICAgICAgcmVxdWVzdFByb21pc2VzLnNldChyb29tSWQsIGN1cnJlbnRQcm9taXNlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgY3VycmVudFByb21pc2U7XG4gICAgICBjb25zdCBCVUZGRVIgPSAzMDtcbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMykgKyAodG9rZW4ucGFyc2VkLmV4cCAtIHRva2VuLnBhcnNlZC5pYXQpIC0gQlVGRkVSO1xuICAgICAgc2VlblRva2Vucy5hZGQodG9rZW4ucmF3KTtcbiAgICAgIGlmICh0b2tlbi5wYXJzZWQuayAhPT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLykge1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGV4cGlyeVRpbWVzLnB1c2goZXhwaXJlc0F0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHR5cGU6IFwic2VjcmV0XCIsIHRva2VuIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlcXVlc3RQcm9taXNlcy5kZWxldGUocm9vbUlkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZXNldCxcbiAgICBnZXRBdXRoVmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVBdXRoZW50aWNhdGlvbihhdXRoT3B0aW9ucykge1xuICBjb25zdCB7IHB1YmxpY0FwaUtleSwgYXV0aEVuZHBvaW50IH0gPSBhdXRoT3B0aW9ucztcbiAgaWYgKGF1dGhFbmRwb2ludCAhPT0gdm9pZCAwICYmIHB1YmxpY0FwaUtleSAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJZb3UgY2Fubm90IHNpbXVsdGFuZW91c2x5IHVzZSBgcHVibGljQXBpS2V5YCBhbmQgYGF1dGhFbmRwb2ludGAgb3B0aW9ucy4gUGxlYXNlIHBpY2sgb25lIGFuZCBsZWF2ZSB0aGUgb3RoZXIgb3B0aW9uIHVuc3BlY2lmaWVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRcIlxuICAgICk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwdWJsaWNBcGlLZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAocHVibGljQXBpS2V5LnN0YXJ0c1dpdGgoXCJza19cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJJbnZhbGlkIGBwdWJsaWNBcGlLZXlgIG9wdGlvbi4gVGhlIHZhbHVlIHlvdSBwYXNzZWQgaXMgYSBzZWNyZXQga2V5LCB3aGljaCBzaG91bGQgbm90IGJlIHVzZWQgZnJvbSB0aGUgY2xpZW50LiBQbGVhc2Ugb25seSBldmVyIHBhc3MgYSBwdWJsaWMga2V5IGhlcmUuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFB1YmxpY0tleVwiXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIXB1YmxpY0FwaUtleS5zdGFydHNXaXRoKFwicGtfXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiSW52YWxpZCBrZXkuIFBsZWFzZSB1c2UgdGhlIHB1YmxpYyBrZXkgZm9ybWF0OiBwa188cHVibGljIGtleT4uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFB1YmxpY0tleVwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJwdWJsaWNcIixcbiAgICAgIHB1YmxpY0FwaUtleVxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBhdXRoRW5kcG9pbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJwcml2YXRlXCIsXG4gICAgICB1cmw6IGF1dGhFbmRwb2ludFxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIGF1dGhFbmRwb2ludCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY3VzdG9tXCIsXG4gICAgICBjYWxsYmFjazogYXV0aEVuZHBvaW50XG4gICAgfTtcbiAgfSBlbHNlIGlmIChhdXRoRW5kcG9pbnQgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGhlIGBhdXRoRW5kcG9pbnRgIG9wdGlvbiBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudEF1dGhFbmRwb2ludFwiXG4gICAgKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgXCJJbnZhbGlkIExpdmVibG9ja3MgY2xpZW50IG9wdGlvbnMuIFBsZWFzZSBwcm92aWRlIGVpdGhlciBhIGBwdWJsaWNBcGlLZXlgIG9yIGBhdXRoRW5kcG9pbnRgIG9wdGlvbi4gVGhleSBjYW5ub3QgYm90aCBiZSBlbXB0eS4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50XCJcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQXV0aEVuZHBvaW50KGZldGNoMiwgZW5kcG9pbnQsIGJvZHkpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2gyKGVuZHBvaW50LCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0sXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgfSk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgY29uc3QgcmVhc29uID0gYCR7KGF3YWl0IHJlcy50ZXh0KCkpLnRyaW0oKSB8fCBcInJlYXNvbiBub3QgcHJvdmlkZWQgaW4gYXV0aCByZXNwb25zZVwifSAoJHtyZXMuc3RhdHVzfSByZXR1cm5lZCBieSBQT1NUICR7ZW5kcG9pbnR9KWA7XG4gICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwMSB8fCByZXMuc3RhdHVzID09PSA0MDMpIHtcbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoYFVuYXV0aG9yaXplZDogJHtyZWFzb259YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGF1dGhlbnRpY2F0ZTogJHtyZWFzb259YCk7XG4gICAgfVxuICB9XG4gIGxldCBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBhIEpTT04gcmVzcG9uc2Ugd2hlbiBkb2luZyBhIFBPU1QgcmVxdWVzdCBvbiBcIiR7ZW5kcG9pbnR9XCIuICR7U3RyaW5nKFxuICAgICAgICBlclxuICAgICAgKX1gXG4gICAgKTtcbiAgfVxuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkgfHwgdHlwZW9mIGRhdGEudG9rZW4gIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBKU09OIHJlc3BvbnNlIG9mIHRoZSBmb3JtIFxcYHsgdG9rZW46IFwiLi4uXCIgfVxcYCB3aGVuIGRvaW5nIGEgUE9TVCByZXF1ZXN0IG9uIFwiJHtlbmRwb2ludH1cIiwgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBkYXRhXG4gICAgICApfWBcbiAgICApO1xuICB9XG4gIGNvbnN0IHsgdG9rZW4gfSA9IGRhdGE7XG4gIHJldHVybiB7IHRva2VuIH07XG59XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBERUZBVUxUX0JBU0VfVVJMID0gXCJodHRwczovL2FwaS5saXZlYmxvY2tzLmlvXCI7XG5cbi8vIHNyYy9kZXZ0b29scy9icmlkZ2UudHNcbnZhciBfYnJpZGdlQWN0aXZlID0gZmFsc2U7XG5mdW5jdGlvbiBhY3RpdmF0ZUJyaWRnZShhbGxvd2VkKSB7XG4gIF9icmlkZ2VBY3RpdmUgPSBhbGxvd2VkO1xufVxuZnVuY3Rpb24gc2VuZFRvUGFuZWwobWVzc2FnZSwgb3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZnVsbE1zZyA9IHtcbiAgICAuLi5tZXNzYWdlLFxuICAgIHNvdXJjZTogXCJsaXZlYmxvY2tzLWRldnRvb2xzLWNsaWVudFwiXG4gIH07XG4gIGlmICghKG9wdGlvbnM/LmZvcmNlIHx8IF9icmlkZ2VBY3RpdmUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5wb3N0TWVzc2FnZShmdWxsTXNnLCBcIipcIik7XG59XG52YXIgZXZlbnRTb3VyY2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gd2luZG93ICYmIGV2ZW50LmRhdGE/LnNvdXJjZSA9PT0gXCJsaXZlYmxvY2tzLWRldnRvb2xzLXBhbmVsXCIpIHtcbiAgICAgIGV2ZW50U291cmNlLm5vdGlmeShldmVudC5kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgIH1cbiAgfSk7XG59XG52YXIgb25NZXNzYWdlRnJvbVBhbmVsID0gZXZlbnRTb3VyY2Uub2JzZXJ2YWJsZTtcblxuLy8gc3JjL2RldnRvb2xzL2luZGV4LnRzXG52YXIgVkVSU0lPTiA9IFBLR19WRVJTSU9OIHx8IFwiZGV2XCI7XG52YXIgX2RldnRvb2xzU2V0dXBIYXNSdW4gPSBmYWxzZTtcbmZ1bmN0aW9uIHNldHVwRGV2VG9vbHMoZ2V0QWxsUm9vbXMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChfZGV2dG9vbHNTZXR1cEhhc1J1bikge1xuICAgIHJldHVybjtcbiAgfVxuICBfZGV2dG9vbHNTZXR1cEhhc1J1biA9IHRydWU7XG4gIG9uTWVzc2FnZUZyb21QYW5lbC5zdWJzY3JpYmUoKG1zZykgPT4ge1xuICAgIHN3aXRjaCAobXNnLm1zZykge1xuICAgICAgY2FzZSBcImNvbm5lY3RcIjoge1xuICAgICAgICBhY3RpdmF0ZUJyaWRnZSh0cnVlKTtcbiAgICAgICAgZm9yIChjb25zdCByb29tSWQgb2YgZ2V0QWxsUm9vbXMoKSkge1xuICAgICAgICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgICAgICAgIG1zZzogXCJyb29tOjphdmFpbGFibGVcIixcbiAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgIGNsaWVudFZlcnNpb246IFZFUlNJT05cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBzZW5kVG9QYW5lbCh7IG1zZzogXCJ3YWtlLXVwLWRldnRvb2xzXCIgfSwgeyBmb3JjZTogdHJ1ZSB9KTtcbn1cbnZhciB1bnN1YnNCeVJvb21JZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBzdG9wU3luY1N0cmVhbShyb29tSWQpIHtcbiAgY29uc3QgdW5zdWJzID0gdW5zdWJzQnlSb29tSWQuZ2V0KHJvb21JZCkgPz8gW107XG4gIHVuc3Vic0J5Um9vbUlkLmRlbGV0ZShyb29tSWQpO1xuICBmb3IgKGNvbnN0IHVuc3ViIG9mIHVuc3Vicykge1xuICAgIHVuc3ViKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHN0YXJ0U3luY1N0cmVhbShyb29tKSB7XG4gIHN0b3BTeW5jU3RyZWFtKHJvb20uaWQpO1xuICBmdWxsU3luYyhyb29tKTtcbiAgdW5zdWJzQnlSb29tSWQuc2V0KHJvb20uaWQsIFtcbiAgICAvLyBXaGVuIHRoZSBjb25uZWN0aW9uIHN0YXR1cyBjaGFuZ2VzXG4gICAgcm9vbS5ldmVudHMuc3RhdHVzLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY0Nvbm5lY3Rpb24ocm9vbSkpLFxuICAgIC8vIFdoZW4gc3RvcmFnZSBpbml0aWFsaXplcywgc2VuZCB0aGUgdXBkYXRlXG4gICAgcm9vbS5ldmVudHMuc3RvcmFnZURpZExvYWQuc3Vic2NyaWJlT25jZSgoKSA9PiBwYXJ0aWFsU3luY1N0b3JhZ2Uocm9vbSkpLFxuICAgIC8vIEFueSB0aW1lIHN0b3JhZ2UgdXBkYXRlcywgc2VuZCB0aGUgbmV3IHN0b3JhZ2Ugcm9vdFxuICAgIHJvb20uZXZlbnRzLnN0b3JhZ2Uuc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jU3RvcmFnZShyb29tKSksXG4gICAgLy8gQW55IHRpbWUgXCJtZVwiIG9yIFwib3RoZXJzXCIgdXBkYXRlcywgc2VuZCB0aGUgbmV3IHZhbHVlcyBhY2NvcmRpbmdseVxuICAgIHJvb20uZXZlbnRzLnNlbGYuc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jTWUocm9vbSkpLFxuICAgIHJvb20uZXZlbnRzLm90aGVycy5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNPdGhlcnMocm9vbSkpLFxuICAgIC8vIEFueSB0aW1lIHlkb2MgaXMgdXBkYXRlZCwgZm9yd2FyZCB0aGUgdXBkYXRlXG4gICAgcm9vbS5ldmVudHMueWRvYy5zdWJzY3JpYmUoKHVwZGF0ZSkgPT4gc3luY1lkb2NVcGRhdGUocm9vbSwgdXBkYXRlKSksXG4gICAgLy8gQW55IHRpbWUgYSBjdXN0b20gcm9vbSBldmVudCBpcyByZWNlaXZlZCwgZm9yd2FyZCBpdFxuICAgIHJvb20uZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShcbiAgICAgIChldmVudERhdGEpID0+IGZvcndhcmRFdmVudChyb29tLCBldmVudERhdGEpXG4gICAgKVxuICBdKTtcbn1cbmZ1bmN0aW9uIHN5bmNZZG9jVXBkYXRlKHJvb20sIHVwZGF0ZSkge1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnN5bmM6Onlkb2NcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgdXBkYXRlXG4gIH0pO1xufVxudmFyIGxvYWRlZEF0ID0gRGF0ZS5ub3coKTtcbnZhciBldmVudENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gbmV4dEV2ZW50SWQoKSB7XG4gIHJldHVybiBgZXZlbnQtJHtsb2FkZWRBdH0tJHtldmVudENvdW50ZXIrK31gO1xufVxuZnVuY3Rpb24gZm9yd2FyZEV2ZW50KHJvb20sIGV2ZW50RGF0YSkge1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OmV2ZW50czo6Y3VzdG9tLWV2ZW50XCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIGV2ZW50OiB7XG4gICAgICB0eXBlOiBcIkN1c3RvbUV2ZW50XCIsXG4gICAgICBpZDogbmV4dEV2ZW50SWQoKSxcbiAgICAgIGtleTogXCJFdmVudFwiLFxuICAgICAgY29ubmVjdGlvbklkOiBldmVudERhdGEuY29ubmVjdGlvbklkLFxuICAgICAgcGF5bG9hZDogZXZlbnREYXRhLmV2ZW50XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jQ29ubmVjdGlvbihyb29tKSB7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICBzdGF0dXM6IHJvb20uZ2V0U3RhdHVzKClcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY1N0b3JhZ2Uocm9vbSkge1xuICBjb25zdCByb290ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKTtcbiAgaWYgKHJvb3QpIHtcbiAgICBzZW5kVG9QYW5lbCh7XG4gICAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgc3RvcmFnZTogcm9vdC50b1RyZWVOb2RlKFwicm9vdFwiKS5wYXlsb2FkXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jTWUocm9vbSkge1xuICBjb25zdCBtZSA9IHJvb20uX19pbnRlcm5hbC5nZXRTZWxmX2ZvckRldlRvb2xzKCk7XG4gIGlmIChtZSkge1xuICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICBtZVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY090aGVycyhyb29tKSB7XG4gIGNvbnN0IG90aGVycyA9IHJvb20uX19pbnRlcm5hbC5nZXRPdGhlcnNfZm9yRGV2VG9vbHMoKTtcbiAgaWYgKG90aGVycykge1xuICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICBvdGhlcnNcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZnVsbFN5bmMocm9vbSkge1xuICBjb25zdCByb290ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKTtcbiAgY29uc3QgbWUgPSByb29tLl9faW50ZXJuYWwuZ2V0U2VsZl9mb3JEZXZUb29scygpO1xuICBjb25zdCBvdGhlcnMgPSByb29tLl9faW50ZXJuYWwuZ2V0T3RoZXJzX2ZvckRldlRvb2xzKCk7XG4gIHJvb20uZmV0Y2hZRG9jKFwiXCIpO1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnN5bmM6OmZ1bGxcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgc3RhdHVzOiByb29tLmdldFN0YXR1cygpLFxuICAgIHN0b3JhZ2U6IHJvb3Q/LnRvVHJlZU5vZGUoXCJyb290XCIpLnBheWxvYWQgPz8gbnVsbCxcbiAgICBtZSxcbiAgICBvdGhlcnNcbiAgfSk7XG59XG52YXIgcm9vbUNoYW5uZWxMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gc3RvcFJvb21DaGFubmVsTGlzdGVuZXIocm9vbUlkKSB7XG4gIGNvbnN0IGxpc3RlbmVyID0gcm9vbUNoYW5uZWxMaXN0ZW5lcnMuZ2V0KHJvb21JZCk7XG4gIHJvb21DaGFubmVsTGlzdGVuZXJzLmRlbGV0ZShyb29tSWQpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBsaXN0ZW5lcigpO1xuICB9XG59XG5mdW5jdGlvbiBsaW5rRGV2VG9vbHMocm9vbUlkLCByb29tKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBzZW5kVG9QYW5lbCh7IG1zZzogXCJyb29tOjphdmFpbGFibGVcIiwgcm9vbUlkLCBjbGllbnRWZXJzaW9uOiBWRVJTSU9OIH0pO1xuICBzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lcihyb29tSWQpO1xuICByb29tQ2hhbm5lbExpc3RlbmVycy5zZXQoXG4gICAgcm9vbUlkLFxuICAgIC8vIFJldHVybnMgdGhlIHVuc3Vic2NyaWJlIGNhbGxiYWNrLCB0aGF0IHdlIHN0b3JlIGluIHRoZVxuICAgIC8vIHJvb21DaGFubmVsTGlzdGVuZXJzIHJlZ2lzdHJ5XG4gICAgb25NZXNzYWdlRnJvbVBhbmVsLnN1YnNjcmliZSgobXNnKSA9PiB7XG4gICAgICBzd2l0Y2ggKG1zZy5tc2cpIHtcbiAgICAgICAgY2FzZSBcInJvb206OnN1YnNjcmliZVwiOiB7XG4gICAgICAgICAgaWYgKG1zZy5yb29tSWQgPT09IHJvb21JZCkge1xuICAgICAgICAgICAgc3RhcnRTeW5jU3RyZWFtKHJvb20pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicm9vbTo6dW5zdWJzY3JpYmVcIjoge1xuICAgICAgICAgIGlmIChtc2cucm9vbUlkID09PSByb29tSWQpIHtcbiAgICAgICAgICAgIHN0b3BTeW5jU3RyZWFtKHJvb21JZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHVubGlua0RldlRvb2xzKHJvb21JZCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3RvcFN5bmNTdHJlYW0ocm9vbUlkKTtcbiAgc3RvcFJvb21DaGFubmVsTGlzdGVuZXIocm9vbUlkKTtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjp1bmF2YWlsYWJsZVwiLFxuICAgIHJvb21JZFxuICB9KTtcbn1cblxuLy8gc3JjL2xpYi9kZXByZWNhdGlvbi50c1xudmFyIF9lbWl0dGVkRGVwcmVjYXRpb25XYXJuaW5ncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG5mdW5jdGlvbiBkZXByZWNhdGUobWVzc2FnZSwga2V5ID0gbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFfZW1pdHRlZERlcHJlY2F0aW9uV2FybmluZ3MuaGFzKGtleSkpIHtcbiAgICAgIF9lbWl0dGVkRGVwcmVjYXRpb25XYXJuaW5ncy5hZGQoa2V5KTtcbiAgICAgIGVycm9yV2l0aFRpdGxlKFwiRGVwcmVjYXRpb24gd2FybmluZ1wiLCBtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlcHJlY2F0ZUlmKGNvbmRpdGlvbiwgbWVzc2FnZSwga2V5ID0gbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgZGVwcmVjYXRlKG1lc3NhZ2UsIGtleSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0aHJvd1VzYWdlRXJyb3IobWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgdXNhZ2VFcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB1c2FnZUVycm9yLm5hbWUgPSBcIlVzYWdlIGVycm9yXCI7XG4gICAgZXJyb3JXaXRoVGl0bGUoXCJVc2FnZSBlcnJvclwiLCBtZXNzYWdlKTtcbiAgICB0aHJvdyB1c2FnZUVycm9yO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcklmKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgdGhyb3dVc2FnZUVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvY29tbWVudHMvY29tbWVudC1ib2R5LnRzXG5mdW5jdGlvbiBpc0NvbW1lbnRCb2R5UGFyYWdyYXBoKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidHlwZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSBcIm1lbnRpb25cIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlUZXh0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidGV4dFwiIGluIGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQudGV4dCA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlNZW50aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidHlwZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSBcIm1lbnRpb25cIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlMaW5rKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidHlwZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSBcImxpbmtcIjtcbn1cbnZhciBjb21tZW50Qm9keUVsZW1lbnRzR3VhcmRzID0ge1xuICBwYXJhZ3JhcGg6IGlzQ29tbWVudEJvZHlQYXJhZ3JhcGgsXG4gIHRleHQ6IGlzQ29tbWVudEJvZHlUZXh0LFxuICBsaW5rOiBpc0NvbW1lbnRCb2R5TGluayxcbiAgbWVudGlvbjogaXNDb21tZW50Qm9keU1lbnRpb25cbn07XG52YXIgY29tbWVudEJvZHlFbGVtZW50c1R5cGVzID0ge1xuICBwYXJhZ3JhcGg6IFwiYmxvY2tcIixcbiAgdGV4dDogXCJpbmxpbmVcIixcbiAgbGluazogXCJpbmxpbmVcIixcbiAgbWVudGlvbjogXCJpbmxpbmVcIlxufTtcbmZ1bmN0aW9uIHRyYXZlcnNlQ29tbWVudEJvZHkoYm9keSwgZWxlbWVudE9yVmlzaXRvciwgcG9zc2libHlWaXNpdG9yKSB7XG4gIGlmICghYm9keSB8fCAhYm9keT8uY29udGVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBlbGVtZW50ID0gdHlwZW9mIGVsZW1lbnRPclZpc2l0b3IgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50T3JWaXNpdG9yIDogdm9pZCAwO1xuICBjb25zdCB0eXBlID0gZWxlbWVudCA/IGNvbW1lbnRCb2R5RWxlbWVudHNUeXBlc1tlbGVtZW50XSA6IFwiYWxsXCI7XG4gIGNvbnN0IGd1YXJkID0gZWxlbWVudCA/IGNvbW1lbnRCb2R5RWxlbWVudHNHdWFyZHNbZWxlbWVudF0gOiAoKSA9PiB0cnVlO1xuICBjb25zdCB2aXNpdG9yID0gdHlwZW9mIGVsZW1lbnRPclZpc2l0b3IgPT09IFwiZnVuY3Rpb25cIiA/IGVsZW1lbnRPclZpc2l0b3IgOiBwb3NzaWJseVZpc2l0b3I7XG4gIGZvciAoY29uc3QgYmxvY2sgb2YgYm9keS5jb250ZW50KSB7XG4gICAgaWYgKHR5cGUgPT09IFwiYWxsXCIgfHwgdHlwZSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICBpZiAoZ3VhcmQoYmxvY2spKSB7XG4gICAgICAgIHZpc2l0b3I/LihibG9jayk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImFsbFwiIHx8IHR5cGUgPT09IFwiaW5saW5lXCIpIHtcbiAgICAgIGZvciAoY29uc3QgaW5saW5lIG9mIGJsb2NrLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChndWFyZChpbmxpbmUpKSB7XG4gICAgICAgICAgdmlzaXRvcj8uKGlubGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keShib2R5KSB7XG4gIGNvbnN0IG1lbnRpb25lZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHRyYXZlcnNlQ29tbWVudEJvZHkoXG4gICAgYm9keSxcbiAgICBcIm1lbnRpb25cIixcbiAgICAobWVudGlvbikgPT4gbWVudGlvbmVkSWRzLmFkZChtZW50aW9uLmlkKVxuICApO1xuICByZXR1cm4gQXJyYXkuZnJvbShtZW50aW9uZWRJZHMpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVVzZXJzSW5Db21tZW50Qm9keShib2R5LCByZXNvbHZlVXNlcnMpIHtcbiAgY29uc3QgcmVzb2x2ZWRVc2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGlmICghcmVzb2x2ZVVzZXJzKSB7XG4gICAgcmV0dXJuIHJlc29sdmVkVXNlcnM7XG4gIH1cbiAgY29uc3QgdXNlcklkcyA9IGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keShib2R5KTtcbiAgY29uc3QgdXNlcnMgPSBhd2FpdCByZXNvbHZlVXNlcnMoe1xuICAgIHVzZXJJZHNcbiAgfSk7XG4gIGZvciAoY29uc3QgW2luZGV4LCB1c2VySWRdIG9mIHVzZXJJZHMuZW50cmllcygpKSB7XG4gICAgY29uc3QgdXNlciA9IHVzZXJzPy5baW5kZXhdO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICByZXNvbHZlZFVzZXJzLnNldCh1c2VySWQsIHVzZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRVc2Vycztcbn1cbnZhciBodG1sRXNjYXBhYmxlcyA9IHtcbiAgXCImXCI6IFwiJmFtcDtcIixcbiAgXCI8XCI6IFwiJmx0O1wiLFxuICBcIj5cIjogXCImZ3Q7XCIsXG4gICdcIic6IFwiJnF1b3Q7XCIsXG4gIFwiJ1wiOiBcIiYjMzk7XCJcbn07XG52YXIgaHRtbEVzY2FwYWJsZXNSZWdleCA9IG5ldyBSZWdFeHAoXG4gIE9iamVjdC5rZXlzKGh0bWxFc2NhcGFibGVzKS5tYXAoKGVudGl0eSkgPT4gYFxcXFwke2VudGl0eX1gKS5qb2luKFwifFwiKSxcbiAgXCJnXCJcbik7XG5mdW5jdGlvbiBodG1sU2FmZSh2YWx1ZSkge1xuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKFtTdHJpbmcodmFsdWUpXSwgW10pO1xufVxuZnVuY3Rpb24gam9pbkh0bWwoc3RyaW5ncykge1xuICBpZiAoc3RyaW5ncy5sZW5ndGggPD0gMCkge1xuICAgIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoW1wiXCJdLCBbXSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhcbiAgICBbXCJcIiwgLi4uQXJyYXkoc3RyaW5ncy5sZW5ndGggLSAxKS5maWxsKFwiXCIpLCBcIlwiXSxcbiAgICBzdHJpbmdzXG4gICk7XG59XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEh0bWxTYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGpvaW5IdG1sKHZhbHVlKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoXG4gICAgaHRtbEVzY2FwYWJsZXNSZWdleCxcbiAgICAoY2hhcmFjdGVyKSA9PiBodG1sRXNjYXBhYmxlc1tjaGFyYWN0ZXJdXG4gICk7XG59XG52YXIgSHRtbFNhZmVTdHJpbmcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ3MsIHZhbHVlcykge1xuICAgIHRoaXMuX3N0cmluZ3MgPSBzdHJpbmdzO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyaW5ncy5yZWR1Y2UoKHJlc3VsdCwgc3RyLCBpKSA9PiB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgZXNjYXBlSHRtbChubih0aGlzLl92YWx1ZXNbaSAtIDFdKSkgKyBzdHI7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBodG1sKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKHN0cmluZ3MsIHZhbHVlcyk7XG59XG52YXIgbWFya2Rvd25Fc2NhcGFibGVzID0ge1xuICBfOiBcIlxcXFxfXCIsXG4gIFwiKlwiOiBcIlxcXFwqXCIsXG4gIFwiI1wiOiBcIlxcXFwjXCIsXG4gIFwiYFwiOiBcIlxcXFxgXCIsXG4gIFwiflwiOiBcIlxcXFx+XCIsXG4gIFwiIVwiOiBcIlxcXFwhXCIsXG4gIFwifFwiOiBcIlxcXFx8XCIsXG4gIFwiKFwiOiBcIlxcXFwoXCIsXG4gIFwiKVwiOiBcIlxcXFwpXCIsXG4gIFwie1wiOiBcIlxcXFx7XCIsXG4gIFwifVwiOiBcIlxcXFx9XCIsXG4gIFwiW1wiOiBcIlxcXFxbXCIsXG4gIFwiXVwiOiBcIlxcXFxdXCJcbn07XG52YXIgbWFya2Rvd25Fc2NhcGFibGVzUmVnZXggPSBuZXcgUmVnRXhwKFxuICBPYmplY3Qua2V5cyhtYXJrZG93bkVzY2FwYWJsZXMpLm1hcCgoZW50aXR5KSA9PiBgXFxcXCR7ZW50aXR5fWApLmpvaW4oXCJ8XCIpLFxuICBcImdcIlxuKTtcbmZ1bmN0aW9uIGpvaW5NYXJrZG93bihzdHJpbmdzKSB7XG4gIGlmIChzdHJpbmdzLmxlbmd0aCA8PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBNYXJrZG93blNhZmVTdHJpbmcoW1wiXCJdLCBbXSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBNYXJrZG93blNhZmVTdHJpbmcoXG4gICAgW1wiXCIsIC4uLkFycmF5KHN0cmluZ3MubGVuZ3RoIC0gMSkuZmlsbChcIlwiKSwgXCJcIl0sXG4gICAgc3RyaW5nc1xuICApO1xufVxuZnVuY3Rpb24gZXNjYXBlTWFya2Rvd24odmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFya2Rvd25TYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGpvaW5NYXJrZG93bih2YWx1ZSkudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKHZhbHVlKS5yZXBsYWNlKFxuICAgIG1hcmtkb3duRXNjYXBhYmxlc1JlZ2V4LFxuICAgIChjaGFyYWN0ZXIpID0+IG1hcmtkb3duRXNjYXBhYmxlc1tjaGFyYWN0ZXJdXG4gICk7XG59XG52YXIgTWFya2Rvd25TYWZlU3RyaW5nID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzdHJpbmdzLCB2YWx1ZXMpIHtcbiAgICB0aGlzLl9zdHJpbmdzID0gc3RyaW5ncztcbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmluZ3MucmVkdWNlKChyZXN1bHQsIHN0ciwgaSkgPT4ge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZU1hcmtkb3duKG5uKHRoaXMuX3ZhbHVlc1tpIC0gMV0pKSArIHN0cjtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIG1hcmtkb3duKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhzdHJpbmdzLCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gdG9BYnNvbHV0ZVVybCh1cmwpIHtcbiAgaWYgKHVybC5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fCB1cmwuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfSBlbHNlIGlmICh1cmwuc3RhcnRzV2l0aChcInd3dy5cIikpIHtcbiAgICByZXR1cm4gXCJodHRwczovL1wiICsgdXJsO1xuICB9XG4gIHJldHVybjtcbn1cbnZhciBzdHJpbmdpZnlDb21tZW50Qm9keVBsYWluRWxlbWVudHMgPSB7XG4gIHBhcmFncmFwaDogKHsgY2hpbGRyZW4gfSkgPT4gY2hpbGRyZW4sXG4gIHRleHQ6ICh7IGVsZW1lbnQgfSkgPT4gZWxlbWVudC50ZXh0LFxuICBsaW5rOiAoeyBlbGVtZW50IH0pID0+IGVsZW1lbnQudXJsLFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyIH0pID0+IHtcbiAgICByZXR1cm4gYEAke3VzZXI/Lm5hbWUgPz8gZWxlbWVudC5pZH1gO1xuICB9XG59O1xudmFyIHN0cmluZ2lmeUNvbW1lbnRCb2R5SHRtbEVsZW1lbnRzID0ge1xuICBwYXJhZ3JhcGg6ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICByZXR1cm4gY2hpbGRyZW4gPyBodG1sYDxwPiR7aHRtbFNhZmUoY2hpbGRyZW4pfTwvcD5gIDogY2hpbGRyZW47XG4gIH0sXG4gIHRleHQ6ICh7IGVsZW1lbnQgfSkgPT4ge1xuICAgIGxldCBjaGlsZHJlbiA9IGVsZW1lbnQudGV4dDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmJvbGQpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8c3Ryb25nPiR7Y2hpbGRyZW59PC9zdHJvbmc+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaXRhbGljKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPGVtPiR7Y2hpbGRyZW59PC9lbT5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5zdHJpa2V0aHJvdWdoKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPHM+JHtjaGlsZHJlbn08L3M+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuY29kZSkge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxjb2RlPiR7Y2hpbGRyZW59PC9jb2RlPmA7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSxcbiAgbGluazogKHsgZWxlbWVudCwgaHJlZiB9KSA9PiB7XG4gICAgcmV0dXJuIGh0bWxgPGEgaHJlZj1cIiR7aHJlZn1cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub29wZW5lciBub3JlZmVycmVyXCI+JHtlbGVtZW50LnVybH08L2E+YDtcbiAgfSxcbiAgbWVudGlvbjogKHsgZWxlbWVudCwgdXNlciB9KSA9PiB7XG4gICAgcmV0dXJuIGh0bWxgPHNwYW4gZGF0YS1tZW50aW9uPkAke3VzZXI/Lm5hbWUgPz8gZWxlbWVudC5pZH08L3NwYW4+YDtcbiAgfVxufTtcbnZhciBzdHJpbmdpZnlDb21tZW50Qm9keU1hcmtkb3duRWxlbWVudHMgPSB7XG4gIHBhcmFncmFwaDogKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSxcbiAgdGV4dDogKHsgZWxlbWVudCB9KSA9PiB7XG4gICAgbGV0IGNoaWxkcmVuID0gZWxlbWVudC50ZXh0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuYm9sZCkge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmAqKiR7Y2hpbGRyZW59KipgO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pdGFsaWMpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gXyR7Y2hpbGRyZW59X2A7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnN0cmlrZXRocm91Z2gpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gfn4ke2NoaWxkcmVufX5+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuY29kZSkge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmBcXGAke2NoaWxkcmVufVxcYGA7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSxcbiAgbGluazogKHsgZWxlbWVudCwgaHJlZiB9KSA9PiB7XG4gICAgcmV0dXJuIG1hcmtkb3duYFske2VsZW1lbnQudXJsfV0oJHtocmVmfSlgO1xuICB9LFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyIH0pID0+IHtcbiAgICByZXR1cm4gbWFya2Rvd25gQCR7dXNlcj8ubmFtZSA/PyBlbGVtZW50LmlkfWA7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBzdHJpbmdpZnlDb21tZW50Qm9keShib2R5LCBvcHRpb25zKSB7XG4gIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnM/LmZvcm1hdCA/PyBcInBsYWluXCI7XG4gIGNvbnN0IHNlcGFyYXRvciA9IG9wdGlvbnM/LnNlcGFyYXRvciA/PyAoZm9ybWF0ID09PSBcIm1hcmtkb3duXCIgPyBcIlxcblxcblwiIDogXCJcXG5cIik7XG4gIGNvbnN0IGVsZW1lbnRzID0ge1xuICAgIC4uLmZvcm1hdCA9PT0gXCJodG1sXCIgPyBzdHJpbmdpZnlDb21tZW50Qm9keUh0bWxFbGVtZW50cyA6IGZvcm1hdCA9PT0gXCJtYXJrZG93blwiID8gc3RyaW5naWZ5Q29tbWVudEJvZHlNYXJrZG93bkVsZW1lbnRzIDogc3RyaW5naWZ5Q29tbWVudEJvZHlQbGFpbkVsZW1lbnRzLFxuICAgIC4uLm9wdGlvbnM/LmVsZW1lbnRzXG4gIH07XG4gIGNvbnN0IHJlc29sdmVkVXNlcnMgPSBhd2FpdCByZXNvbHZlVXNlcnNJbkNvbW1lbnRCb2R5KFxuICAgIGJvZHksXG4gICAgb3B0aW9ucz8ucmVzb2x2ZVVzZXJzXG4gICk7XG4gIGNvbnN0IGJsb2NrcyA9IGJvZHkuY29udGVudC5mbGF0TWFwKChibG9jaywgYmxvY2tJbmRleCkgPT4ge1xuICAgIHN3aXRjaCAoYmxvY2sudHlwZSkge1xuICAgICAgY2FzZSBcInBhcmFncmFwaFwiOiB7XG4gICAgICAgIGNvbnN0IGlubGluZXMgPSBibG9jay5jaGlsZHJlbi5mbGF0TWFwKChpbmxpbmUsIGlubGluZUluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKGlzQ29tbWVudEJvZHlNZW50aW9uKGlubGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmxpbmUuaWQgPyBbXG4gICAgICAgICAgICAgIGVsZW1lbnRzLm1lbnRpb24oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudDogaW5saW5lLFxuICAgICAgICAgICAgICAgICAgdXNlcjogcmVzb2x2ZWRVc2Vycy5nZXQoaW5saW5lLmlkKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5saW5lSW5kZXhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSA6IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keUxpbmsoaW5saW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgZWxlbWVudHMubGluayhcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiBpbmxpbmUsXG4gICAgICAgICAgICAgICAgICBocmVmOiB0b0Fic29sdXRlVXJsKGlubGluZS51cmwpID8/IGlubGluZS51cmxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlubGluZUluZGV4XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0NvbW1lbnRCb2R5VGV4dChpbmxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2VsZW1lbnRzLnRleHQoeyBlbGVtZW50OiBpbmxpbmUgfSwgaW5saW5lSW5kZXgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBlbGVtZW50cy5wYXJhZ3JhcGgoXG4gICAgICAgICAgICB7IGVsZW1lbnQ6IGJsb2NrLCBjaGlsZHJlbjogaW5saW5lcy5qb2luKFwiXCIpIH0sXG4gICAgICAgICAgICBibG9ja0luZGV4XG4gICAgICAgICAgKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBibG9ja3Muam9pbihzZXBhcmF0b3IpO1xufVxuZnVuY3Rpb24gY29udmVydFRvQ29tbWVudERhdGEoZGF0YSkge1xuICBjb25zdCBlZGl0ZWRBdCA9IGRhdGEuZWRpdGVkQXQgPyBuZXcgRGF0ZShkYXRhLmVkaXRlZEF0KSA6IHZvaWQgMDtcbiAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICBjb25zdCByZWFjdGlvbnMgPSBkYXRhLnJlYWN0aW9ucy5tYXAoKHJlYWN0aW9uKSA9PiAoe1xuICAgIC4uLnJlYWN0aW9uLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUocmVhY3Rpb24uY3JlYXRlZEF0KVxuICB9KSk7XG4gIGlmIChkYXRhLmJvZHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIHJlYWN0aW9ucyxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIGVkaXRlZEF0XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkZWxldGVkQXQgPSBuZXcgRGF0ZShkYXRhLmRlbGV0ZWRBdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICByZWFjdGlvbnMsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBlZGl0ZWRBdCxcbiAgICAgIGRlbGV0ZWRBdFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1RocmVhZERhdGEoZGF0YSkge1xuICBjb25zdCB1cGRhdGVkQXQgPSBkYXRhLnVwZGF0ZWRBdCA/IG5ldyBEYXRlKGRhdGEudXBkYXRlZEF0KSA6IHZvaWQgMDtcbiAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICBjb25zdCBjb21tZW50cyA9IGRhdGEuY29tbWVudHMubWFwKFxuICAgIChjb21tZW50KSA9PiBjb252ZXJ0VG9Db21tZW50RGF0YShjb21tZW50KVxuICApO1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgY3JlYXRlZEF0LFxuICAgIHVwZGF0ZWRBdCxcbiAgICBjb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbihkYXRhKSB7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KVxuICB9O1xufVxuXG4vLyBzcmMvY29tbWVudHMvaW5kZXgudHNcbmZ1bmN0aW9uIGdldEF1dGhCZWFyZXJIZWFkZXJGcm9tQXV0aFZhbHVlKGF1dGhWYWx1ZSkge1xuICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwicHVibGljXCIpIHtcbiAgICByZXR1cm4gYXV0aFZhbHVlLnB1YmxpY0FwaUtleTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXV0aFZhbHVlLnRva2VuLnJhdztcbiAgfVxufVxudmFyIENvbW1lbnRzQXBpRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlQ29tbWVudHNBcGkocm9vbUlkLCBnZXRBdXRoVmFsdWUsIGNvbmZpZykge1xuICBhc3luYyBmdW5jdGlvbiBmZXRjaEpzb24oZW5kcG9pbnQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQXBpKHJvb21JZCwgZW5kcG9pbnQsIG9wdGlvbnMpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDYwMCkge1xuICAgICAgICBsZXQgZXJyb3IzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICBlcnJvcjMgPSBuZXcgQ29tbWVudHNBcGlFcnJvcihcbiAgICAgICAgICAgIGVycm9yQm9keS5tZXNzYWdlLFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgZXJyb3JCb2R5XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IENvbW1lbnRzQXBpRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjM7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBib2R5O1xuICAgIHRyeSB7XG4gICAgICBib2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgYm9keSA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gYm9keTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBmZXRjaEFwaShyb29tSWQyLCBlbmRwb2ludCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IGF3YWl0IGdldEF1dGhWYWx1ZSgpO1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoXG4gICAgICBgL3YyL2Mvcm9vbXMvJHtlbmNvZGVVUklDb21wb25lbnQocm9vbUlkMil9JHtlbmRwb2ludH1gLFxuICAgICAgY29uZmlnLmJhc2VVcmxcbiAgICApO1xuICAgIHJldHVybiBhd2FpdCBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVycyxcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2dldEF1dGhCZWFyZXJIZWFkZXJGcm9tQXV0aFZhbHVlKGF1dGhWYWx1ZSl9YFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFRocmVhZHMob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hBcGkocm9vbUlkLCBcIi90aHJlYWRzL3NlYXJjaFwiLCB7XG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIC4uLm9wdGlvbnM/LnF1ZXJ5Py5tZXRhZGF0YSAmJiB7IG1ldGFkYXRhOiBvcHRpb25zLnF1ZXJ5Lm1ldGFkYXRhIH1cbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCJcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICByZXR1cm4ganNvbi5kYXRhLm1hcCgodGhyZWFkKSA9PiBjb252ZXJ0VG9UaHJlYWREYXRhKHRocmVhZCkpO1xuICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhyZWFkcy5cIik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRocmVhZCh7XG4gICAgbWV0YWRhdGEsXG4gICAgYm9keSxcbiAgICBjb21tZW50SWQsXG4gICAgdGhyZWFkSWRcbiAgfSkge1xuICAgIGNvbnN0IHRocmVhZCA9IGF3YWl0IGZldGNoSnNvbihcbiAgICAgIFwiL3RocmVhZHNcIixcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBpZDogdGhyZWFkSWQsXG4gICAgICAgICAgY29tbWVudDoge1xuICAgICAgICAgICAgaWQ6IGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGJvZHlcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvVGhyZWFkRGF0YSh0aHJlYWQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVkaXRUaHJlYWRNZXRhZGF0YSh7XG4gICAgbWV0YWRhdGEsXG4gICAgdGhyZWFkSWRcbiAgfSkge1xuICAgIHJldHVybiBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9tZXRhZGF0YWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQoe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZCxcbiAgICBib2R5XG4gIH0pIHtcbiAgICBjb25zdCBjb21tZW50ID0gYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vY29tbWVudHNgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgICAgYm9keVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVkaXRDb21tZW50KHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgYm9keVxuICB9KSB7XG4gICAgY29uc3QgY29tbWVudCA9IGF3YWl0IGZldGNoSnNvbihcbiAgICAgIGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9L2NvbW1lbnRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICBjb21tZW50SWRcbiAgICAgICl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBib2R5XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudERhdGEoY29tbWVudCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQ29tbWVudCh7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkXG4gIH0pIHtcbiAgICBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9jb21tZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY29tbWVudElkXG4gICAgICApfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJERUxFVEVcIlxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gYWRkUmVhY3Rpb24oe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZCxcbiAgICBlbW9qaVxuICB9KSB7XG4gICAgY29uc3QgcmVhY3Rpb24gPSBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9jb21tZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY29tbWVudElkXG4gICAgICApfS9yZWFjdGlvbnNgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbW9qaSB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24ocmVhY3Rpb24pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlbW92ZVJlYWN0aW9uKHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgZW1vamlcbiAgfSkge1xuICAgIGF3YWl0IGZldGNoSnNvbihcbiAgICAgIGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9L2NvbW1lbnRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICBjb21tZW50SWRcbiAgICAgICl9L3JlYWN0aW9ucy8ke2VuY29kZVVSSUNvbXBvbmVudChlbW9qaSl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldFRocmVhZHMsXG4gICAgY3JlYXRlVGhyZWFkLFxuICAgIGVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgICBjcmVhdGVDb21tZW50LFxuICAgIGVkaXRDb21tZW50LFxuICAgIGRlbGV0ZUNvbW1lbnQsXG4gICAgYWRkUmVhY3Rpb24sXG4gICAgcmVtb3ZlUmVhY3Rpb25cbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9wb3NpdGlvbi50c1xudmFyIE1JTl9DT0RFID0gMzI7XG52YXIgTUFYX0NPREUgPSAxMjY7XG52YXIgTlVNX0RJR0lUUyA9IE1BWF9DT0RFIC0gTUlOX0NPREUgKyAxO1xudmFyIFpFUk8gPSBudGhEaWdpdCgwKTtcbnZhciBPTkUgPSBudGhEaWdpdCgxKTtcbnZhciBaRVJPX05JTkUgPSBaRVJPICsgbnRoRGlnaXQoLTEpO1xuZnVuY3Rpb24gbnRoRGlnaXQobikge1xuICBjb25zdCBjb2RlID0gTUlOX0NPREUgKyAobiA8IDAgPyBOVU1fRElHSVRTICsgbiA6IG4pO1xuICBpZiAoY29kZSA8IE1JTl9DT0RFIHx8IGNvZGUgPiBNQVhfQ09ERSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuIHZhbHVlOiAke259YCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG59XG5mdW5jdGlvbiBtYWtlUG9zaXRpb24oeCwgeSkge1xuICBpZiAoeCAhPT0gdm9pZCAwICYmIHkgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiZXR3ZWVuKHgsIHkpO1xuICB9IGVsc2UgaWYgKHggIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBhZnRlcih4KTtcbiAgfSBlbHNlIGlmICh5ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gYmVmb3JlKHkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPTkU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJlZm9yZShwb3MpIHtcbiAgY29uc3QgbGFzdEluZGV4ID0gcG9zLmxlbmd0aCAtIDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHBvcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlIDw9IE1JTl9DT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGkgPT09IGxhc3RJbmRleCkge1xuICAgICAgaWYgKGNvZGUgPT09IE1JTl9DT0RFICsgMSkge1xuICAgICAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpKSArIFpFUk9fTklORTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkgKyAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9ORTtcbn1cbmZ1bmN0aW9uIGFmdGVyKHBvcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBwb3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHBvcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID49IE1BWF9DT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgKyAxKTtcbiAgfVxuICByZXR1cm4gcG9zICsgT05FO1xufVxuZnVuY3Rpb24gYmV0d2VlbihsbywgaGkpIHtcbiAgaWYgKGxvIDwgaGkpIHtcbiAgICByZXR1cm4gX2JldHdlZW4obG8sIGhpKTtcbiAgfSBlbHNlIGlmIChsbyA+IGhpKSB7XG4gICAgcmV0dXJuIF9iZXR3ZWVuKGhpLCBsbyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgdmFsdWUgYmV0d2VlbiB0d28gZXF1YWwgcG9zaXRpb25zXCIpO1xuICB9XG59XG5mdW5jdGlvbiBfYmV0d2VlbihsbywgaGkpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgY29uc3QgbG9MZW4gPSBsby5sZW5ndGg7XG4gIGNvbnN0IGhpTGVuID0gaGkubGVuZ3RoO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IGxvQ29kZSA9IGluZGV4IDwgbG9MZW4gPyBsby5jaGFyQ29kZUF0KGluZGV4KSA6IE1JTl9DT0RFO1xuICAgIGNvbnN0IGhpQ29kZSA9IGluZGV4IDwgaGlMZW4gPyBoaS5jaGFyQ29kZUF0KGluZGV4KSA6IE1BWF9DT0RFO1xuICAgIGlmIChsb0NvZGUgPT09IGhpQ29kZSkge1xuICAgICAgaW5kZXgrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaGlDb2RlIC0gbG9Db2RlID09PSAxKSB7XG4gICAgICBjb25zdCBzaXplID0gaW5kZXggKyAxO1xuICAgICAgbGV0IHByZWZpeCA9IGxvLnN1YnN0cmluZygwLCBzaXplKTtcbiAgICAgIGlmIChwcmVmaXgubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgICBwcmVmaXggKz0gWkVSTy5yZXBlYXQoc2l6ZSAtIHByZWZpeC5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3VmZml4ID0gbG8uc3Vic3RyaW5nKHNpemUpO1xuICAgICAgY29uc3QgbmluZXMgPSBcIlwiO1xuICAgICAgcmV0dXJuIHByZWZpeCArIF9iZXR3ZWVuKHN1ZmZpeCwgbmluZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGFrZU4obG8sIGluZGV4KSArIFN0cmluZy5mcm9tQ2hhckNvZGUoaGlDb2RlICsgbG9Db2RlID4+IDEpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdGFrZU4ocG9zLCBuKSB7XG4gIHJldHVybiBuIDwgcG9zLmxlbmd0aCA/IHBvcy5zdWJzdHJpbmcoMCwgbikgOiBwb3MgKyBaRVJPLnJlcGVhdChuIC0gcG9zLmxlbmd0aCk7XG59XG52YXIgTUlOX05PTl9aRVJPX0NPREUgPSBNSU5fQ09ERSArIDE7XG5mdW5jdGlvbiBpc1BvcyhzdHIpIHtcbiAgaWYgKHN0ciA9PT0gXCJcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsYXN0SWR4ID0gc3RyLmxlbmd0aCAtIDE7XG4gIGNvbnN0IGxhc3QgPSBzdHIuY2hhckNvZGVBdChsYXN0SWR4KTtcbiAgaWYgKGxhc3QgPCBNSU5fTk9OX1pFUk9fQ09ERSB8fCBsYXN0ID4gTUFYX0NPREUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SWR4OyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCBNSU5fQ09ERSB8fCBjb2RlID4gTUFYX0NPREUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Qb3Moc3RyKSB7XG4gIGNvbnN0IGNvZGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGNvZGVzLnB1c2goY29kZSA8IE1JTl9DT0RFID8gTUlOX0NPREUgOiBjb2RlID4gTUFYX0NPREUgPyBNQVhfQ09ERSA6IGNvZGUpO1xuICB9XG4gIHdoaWxlIChjb2Rlcy5sZW5ndGggPiAwICYmIGNvZGVzW2NvZGVzLmxlbmd0aCAtIDFdID09PSBNSU5fQ09ERSkge1xuICAgIGNvZGVzLmxlbmd0aC0tO1xuICB9XG4gIHJldHVybiBjb2Rlcy5sZW5ndGggPiAwID8gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5jb2RlcykgOiAoXG4gICAgLy8gRWRnZSBjYXNlOiB0aGUgc3RyIHdhcyBhIDAtb25seSBzdHJpbmcsIHdoaWNoIGlzIGludmFsaWQuIERlZmF1bHQgYmFjayB0byAuMVxuICAgIE9ORVxuICApO1xufVxuZnVuY3Rpb24gYXNQb3Moc3RyKSB7XG4gIHJldHVybiBpc1BvcyhzdHIpID8gc3RyIDogY29udmVydFRvUG9zKHN0cik7XG59XG5cbi8vIHNyYy9wcm90b2NvbC9PcC50c1xudmFyIE9wQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE9wQ29kZTIpID0+IHtcbiAgT3BDb2RlMltPcENvZGUyW1wiSU5JVFwiXSA9IDBdID0gXCJJTklUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIlNFVF9QQVJFTlRfS0VZXCJdID0gMV0gPSBcIlNFVF9QQVJFTlRfS0VZXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9MSVNUXCJdID0gMl0gPSBcIkNSRUFURV9MSVNUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIlVQREFURV9PQkpFQ1RcIl0gPSAzXSA9IFwiVVBEQVRFX09CSkVDVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfT0JKRUNUXCJdID0gNF0gPSBcIkNSRUFURV9PQkpFQ1RcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiREVMRVRFX0NSRFRcIl0gPSA1XSA9IFwiREVMRVRFX0NSRFRcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiREVMRVRFX09CSkVDVF9LRVlcIl0gPSA2XSA9IFwiREVMRVRFX09CSkVDVF9LRVlcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX01BUFwiXSA9IDddID0gXCJDUkVBVEVfTUFQXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9SRUdJU1RFUlwiXSA9IDhdID0gXCJDUkVBVEVfUkVHSVNURVJcIjtcbiAgcmV0dXJuIE9wQ29kZTI7XG59KShPcENvZGUgfHwge30pO1xuZnVuY3Rpb24gYWNrT3Aob3BJZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgaWQ6IFwiQUNLXCIsXG4gICAgLy8gKEgpQUNLXG4gICAgb3BJZFxuICB9O1xufVxuZnVuY3Rpb24gaXNBY2tPcChvcCkge1xuICByZXR1cm4gb3AudHlwZSA9PT0gNSAvKiBERUxFVEVfQ1JEVCAqLyAmJiBvcC5pZCA9PT0gXCJBQ0tcIjtcbn1cblxuLy8gc3JjL2NyZHRzL0Fic3RyYWN0Q3JkdC50c1xuZnVuY3Rpb24gY3JkdEFzTGl2ZU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gSGFzUGFyZW50KG5vZGUsIGtleSwgcG9zID0gYXNQb3Moa2V5KSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiSGFzUGFyZW50XCIsIG5vZGUsIGtleSwgcG9zIH0pO1xufVxudmFyIE5vUGFyZW50ID0gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiTm9QYXJlbnRcIiB9KTtcbmZ1bmN0aW9uIE9ycGhhbmVkKG9sZEtleSwgb2xkUG9zID0gYXNQb3Mob2xkS2V5KSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiT3JwaGFuZWRcIiwgb2xkS2V5LCBvbGRQb3MgfSk7XG59XG52YXIgQWJzdHJhY3RDcmR0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcGFyZW50ID0gTm9QYXJlbnQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZ2V0UGFyZW50S2V5T3JUaHJvdygpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmtleTtcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQga2V5IGlzIG1pc3NpbmdcIik7XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm9sZEtleTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfcGFyZW50UG9zKCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucG9zO1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBrZXkgaXMgbWlzc2luZ1wiKTtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkUG9zO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9wb29sKCkge1xuICAgIHJldHVybiB0aGlzLl9fcG9vbDtcbiAgfVxuICBnZXQgcm9vbUlkKCkge1xuICAgIHJldHVybiB0aGlzLl9fcG9vbCA/IHRoaXMuX19wb29sLnJvb21JZCA6IG51bGw7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX2lkKCkge1xuICAgIHJldHVybiB0aGlzLl9faWQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgcGFyZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX3BhcmVudEtleSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmtleTtcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkS2V5O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5KG9wLCBfaXNMb2NhbCkge1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSA1IC8qIERFTEVURV9DUkRUICovOiB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm5vZGUuX2RldGFjaENoaWxkKGNyZHRBc0xpdmVOb2RlKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2V0UGFyZW50TGluayhuZXdQYXJlbnROb2RlLCBuZXdQYXJlbnRLZXkpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Lm5vZGUgIT09IG5ld1BhcmVudE5vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHBhcmVudDogbm9kZSBhbHJlYWR5IGhhcyBhIHBhcmVudFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBIYXNQYXJlbnQobmV3UGFyZW50Tm9kZSwgbmV3UGFyZW50S2V5KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6IHtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gSGFzUGFyZW50KG5ld1BhcmVudE5vZGUsIG5ld1BhcmVudEtleSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBpZiAodGhpcy5fX2lkIHx8IHRoaXMuX19wb29sKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXR0YWNoIG5vZGU6IGFscmVhZHkgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIHBvb2wuYWRkTm9kZShpZCwgY3JkdEFzTGl2ZU5vZGUodGhpcykpO1xuICAgIHRoaXMuX19pZCA9IGlkO1xuICAgIHRoaXMuX19wb29sID0gcG9vbDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2goKSB7XG4gICAgaWYgKHRoaXMuX19wb29sICYmIHRoaXMuX19pZCkge1xuICAgICAgdGhpcy5fX3Bvb2wuZGVsZXRlTm9kZSh0aGlzLl9faWQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjoge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBPcnBoYW5lZCh0aGlzLnBhcmVudC5rZXksIHRoaXMucGFyZW50LnBvcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6IHtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gTm9QYXJlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6IHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgICB0aGlzLl9fcG9vbCA9IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIENsZWFyIHRoZSBJbW11dGFibGUgY2FjaGUsIHNvIHRoYXQgdGhlIG5leHQgY2FsbCB0byBgLnRvSW1tdXRhYmxlKClgIHdpbGxcbiAgICogcmVjb21wdXRlIHRoZSBlcXVpdmFsZW50IEltbXV0YWJsZSB2YWx1ZSBhZ2Fpbi4gIENhbGwgdGhpcyBhZnRlciBldmVyeVxuICAgKiBtdXRhdGlvbiB0byB0aGUgTGl2ZSBub2RlLlxuICAgKi9cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkSW1tdXRhYmxlICE9PSB2b2lkIDAgfHwgdGhpcy5fY2FjaGVkVHJlZU5vZGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fY2FjaGVkSW1tdXRhYmxlID0gdm9pZCAwO1xuICAgICAgdGhpcy5fY2FjaGVkVHJlZU5vZGUgPSB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgICB0aGlzLnBhcmVudC5ub2RlLmludmFsaWRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBSZXR1cm4gYW4gc25hcHNob3Qgb2YgdGhpcyBMaXZlIHRyZWUgZm9yIHVzZSBpbiBEZXZUb29scy5cbiAgICovXG4gIHRvVHJlZU5vZGUoa2V5KSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZFRyZWVOb2RlID09PSB2b2lkIDAgfHwgdGhpcy5fY2FjaGVkVHJlZU5vZGVLZXkgIT09IGtleSkge1xuICAgICAgdGhpcy5fY2FjaGVkVHJlZU5vZGVLZXkgPSBrZXk7XG4gICAgICB0aGlzLl9jYWNoZWRUcmVlTm9kZSA9IHRoaXMuX3RvVHJlZU5vZGUoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFRyZWVOb2RlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gaW1tdXRhYmxlIHNuYXBzaG90IG9mIHRoaXMgTGl2ZSBub2RlIGFuZCBpdHMgY2hpbGRyZW4uXG4gICAqL1xuICB0b0ltbXV0YWJsZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkSW1tdXRhYmxlID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX2NhY2hlZEltbXV0YWJsZSA9IHRoaXMuX3RvSW1tdXRhYmxlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRJbW11dGFibGU7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm90b2NvbC9TZXJpYWxpemVkQ3JkdC50c1xudmFyIENyZHRUeXBlID0gLyogQF9fUFVSRV9fICovICgoQ3JkdFR5cGUyKSA9PiB7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJPQkpFQ1RcIl0gPSAwXSA9IFwiT0JKRUNUXCI7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJMSVNUXCJdID0gMV0gPSBcIkxJU1RcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIk1BUFwiXSA9IDJdID0gXCJNQVBcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIlJFR0lTVEVSXCJdID0gM10gPSBcIlJFR0lTVEVSXCI7XG4gIHJldHVybiBDcmR0VHlwZTI7XG59KShDcmR0VHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBpc1Jvb3RDcmR0KGNyZHQpIHtcbiAgcmV0dXJuIGNyZHQudHlwZSA9PT0gMCAvKiBPQkpFQ1QgKi8gJiYgIWlzQ2hpbGRDcmR0KGNyZHQpO1xufVxuZnVuY3Rpb24gaXNDaGlsZENyZHQoY3JkdCkge1xuICByZXR1cm4gY3JkdC5wYXJlbnRJZCAhPT0gdm9pZCAwICYmIGNyZHQucGFyZW50S2V5ICE9PSB2b2lkIDA7XG59XG5cbi8vIHNyYy9saWIvbmFub2lkLnRzXG5mdW5jdGlvbiBuYW5vaWQobGVuZ3RoID0gNykge1xuICBjb25zdCBhbHBoYWJldCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODksLi87W11+IUAjJCUmKigpXys9LVwiO1xuICBjb25zdCBsZW4gPSBhbHBoYWJldC5sZW5ndGg7XG4gIHJldHVybiBBcnJheS5mcm9tKFxuICAgIHsgbGVuZ3RoIH0sXG4gICAgKCkgPT4gYWxwaGFiZXQuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxlbikpXG4gICkuam9pbihcIlwiKTtcbn1cblxuLy8gc3JjL2NyZHRzL0xpdmVSZWdpc3Rlci50c1xudmFyIExpdmVSZWdpc3RlciA9IGNsYXNzIF9MaXZlUmVnaXN0ZXIgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgX3BhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCByZWdpc3RlciA9IG5ldyBfTGl2ZVJlZ2lzdGVyKGl0ZW0uZGF0YSk7XG4gICAgcmVnaXN0ZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgcmV0dXJuIHJlZ2lzdGVyO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNhbm5vdCBzZXJpYWxpemUgcmVnaXN0ZXIgaWYgcGFyZW50SWQgb3IgcGFyZW50S2V5IGlzIHVuZGVmaW5lZFwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgcGFyZW50SWQsXG4gICAgICAgIHBhcmVudEtleSxcbiAgICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZVJlZ2lzdGVyIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMyAvKiBSRUdJU1RFUiAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXksXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKF9vcCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKF9jcmR0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkpzb25cIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IHRoaXMuX2RhdGFcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBkZWVwQ2xvbmUodGhpcy5kYXRhKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVMaXN0LnRzXG5mdW5jdGlvbiBjb21wYXJlTm9kZVBvc2l0aW9uKGl0ZW1BLCBpdGVtQikge1xuICBjb25zdCBwb3NBID0gaXRlbUEuX3BhcmVudFBvcztcbiAgY29uc3QgcG9zQiA9IGl0ZW1CLl9wYXJlbnRQb3M7XG4gIHJldHVybiBwb3NBID09PSBwb3NCID8gMCA6IHBvc0EgPCBwb3NCID8gLTEgOiAxO1xufVxudmFyIExpdmVMaXN0ID0gY2xhc3MgX0xpdmVMaXN0IGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgY29uc3RydWN0b3IoaXRlbXMgPSBbXSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgdGhpcy5fdW5hY2tub3dsZWRnZWRTZXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgcG9zaXRpb24gPSB2b2lkIDA7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBjb25zdCBuZXdQb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICBjb25zdCBub2RlID0gbHNvblRvTGl2ZU5vZGUoaXRlbSk7XG4gICAgICBub2RlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld1Bvc2l0aW9uKTtcbiAgICAgIHRoaXMuX2l0ZW1zLnB1c2gobm9kZSk7XG4gICAgICBwb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGxpc3QgPSBuZXcgX0xpdmVMaXN0KCk7XG4gICAgbGlzdC5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGlkKTtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkMiwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemUoW2lkMiwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsobGlzdCwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgbGlzdC5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlIHJlc3VsdGluZyBvcHMgd2lsbCBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIgaWYgdGhleSBoYXZlIGFuICdvcElkJ1xuICAgKiBzbyB3ZSBtdXRhdGUgX3VuYWNrbm93bGVkZ2VkU2V0cyB0byBhdm9pZCBwb3RlbnRpYWwgZmxpY2tlcmluZ1xuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWJsb2Nrcy9saXZlYmxvY2tzL3B1bGwvMTE3N1xuICAgKlxuICAgKiBUaGlzIGlzIHF1aXRlIHVuaW50dWl0aXZlIGFuZCBzaG91bGQgZGlzYXBwZWFyIGFzIHNvb24gYXNcbiAgICogd2UgaW50cm9kdWNlIGFuIGV4cGxpY2l0IExpdmVMaXN0LlNldCBvcGVyYXRpb25cbiAgICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICB0eXBlOiAyIC8qIENSRUFURV9MSVNUICovLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXlcbiAgICB9O1xuICAgIG9wcy5wdXNoKG9wKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleTIgPSBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCk7XG4gICAgICBjb25zdCBjaGlsZE9wcyA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXMuX2lkLCBwYXJlbnRLZXkyLCBwb29sKSxcbiAgICAgICAgdm9pZCAwXG4gICAgICApO1xuICAgICAgY29uc3QgY2hpbGRPcElkID0gY2hpbGRPcHNbMF0ub3BJZDtcbiAgICAgIGlmIChjaGlsZE9wSWQgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuc2V0KHBhcmVudEtleTIsIGNoaWxkT3BJZCk7XG4gICAgICB9XG4gICAgICBvcHMucHVzaCguLi5jaGlsZE9wcyk7XG4gICAgfVxuICAgIHJldHVybiBvcHM7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBBZGRzIGEgbmV3IGl0ZW0gaW50byB0aGUgc29ydGVkIGxpc3QsIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uLlxuICAgKi9cbiAgX2luc2VydEFuZFNvcnQoaXRlbSkge1xuICAgIHRoaXMuX2l0ZW1zLnB1c2goaXRlbSk7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc29ydEl0ZW1zKCkge1xuICAgIHRoaXMuX2l0ZW1zLnNvcnQoY29tcGFyZU5vZGVQb3NpdGlvbik7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW5kZXhPZlBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmZpbmRJbmRleChcbiAgICAgIChpdGVtKSA9PiBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkgPT09IHBvc2l0aW9uXG4gICAgKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgIGl0ZW0uX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRSZW1vdGUob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBkZWxldGVkSWQgPSBvcC5kZWxldGVkSWQ7XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXTtcbiAgICAgIGlmIChpdGVtV2l0aFNhbWVQb3NpdGlvbi5faWQgPT09IGRlbGV0ZWRJZCkge1xuICAgICAgICBpdGVtV2l0aFNhbWVQb3NpdGlvbi5fZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBzZXREZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIGNoaWxkKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmFkZChpdGVtV2l0aFNhbWVQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBbXG4gICAgICAgICAgc2V0RGVsdGEoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCBjaGlsZClcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgZGVsZXRlRGVsdGEyID0gdGhpcy5fZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihcbiAgICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGRlbGV0ZURlbHRhMikge1xuICAgICAgICAgIGRlbHRhLnB1c2goZGVsZXRlRGVsdGEyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1cGRhdGVzID0gW107XG4gICAgICBjb25zdCBkZWxldGVEZWx0YTIgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICk7XG4gICAgICBpZiAoZGVsZXRlRGVsdGEyKSB7XG4gICAgICAgIHVwZGF0ZXMucHVzaChkZWxldGVEZWx0YTIpO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICB1cGRhdGVzLnB1c2goaW5zZXJ0RGVsdGEodGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSksIGNoaWxkKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXZlcnNlOiBbXSxcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgdXBkYXRlcylcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0QWNrKG9wKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVsdGEgPSBbXTtcbiAgICBjb25zdCBkZWxldGVkRGVsdGEgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKG9wLmRlbGV0ZWRJZCk7XG4gICAgaWYgKGRlbGV0ZWREZWx0YSkge1xuICAgICAgZGVsdGEucHVzaChkZWxldGVkRGVsdGEpO1xuICAgIH1cbiAgICBjb25zdCB1bmFja25vd2xlZGdlZE9wSWQgPSB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuZ2V0KG9wLnBhcmVudEtleSk7XG4gICAgaWYgKHVuYWNrbm93bGVkZ2VkT3BJZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodW5hY2tub3dsZWRnZWRPcElkICE9PSBvcC5vcElkKSB7XG4gICAgICAgIHJldHVybiBkZWx0YS5sZW5ndGggPT09IDAgPyB7IG1vZGlmaWVkOiBmYWxzZSB9IDogeyBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSksIHJldmVyc2U6IFtdIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuZGVsZXRlKG9wLnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuX2l0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uX2lkID09PSBvcC5pZCk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtLl9wYXJlbnRLZXkgPT09IG9wLnBhcmVudEtleSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBkZWx0YS5sZW5ndGggPiAwID8gbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSkgOiBmYWxzZSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5hZGQoXG4gICAgICAgICAgdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCAxKTtcbiAgICAgICAgZGVsdGEucHVzaChkZWxldGVEZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24pKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBleGlzdGluZ0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBpZiAobmV3SW5kZXggIT09IHByZXZpb3VzSW5kZXgpIHtcbiAgICAgICAgZGVsdGEucHVzaChtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGV4aXN0aW5nSXRlbSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IGRlbHRhLmxlbmd0aCA+IDAgPyBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSA6IGZhbHNlLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JwaGFuID0gdGhpcy5fcG9vbC5nZXROb2RlKG9wLmlkKTtcbiAgICAgIGlmIChvcnBoYW4gJiYgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMob3JwaGFuKSkge1xuICAgICAgICBvcnBoYW4uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUob3JwaGFuKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChvcnBoYW4pO1xuICAgICAgICBjb25zdCByZWNyZWF0ZWRJdGVtSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKG9ycGhhbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaXRlbSBhdCB0aGlzIHBvc2l0aW9uLCB1cGRhdGUgaXMgYSBzZXQsIGVsc2UgaXQncyBhbiBpbnNlcnRcbiAgICAgICAgICAgIGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9PT0gLTEgPyBpbnNlcnREZWx0YShyZWNyZWF0ZWRJdGVtSW5kZXgsIG9ycGhhbikgOiBzZXREZWx0YShyZWNyZWF0ZWRJdGVtSW5kZXgsIG9ycGhhbiksXG4gICAgICAgICAgICAuLi5kZWx0YVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KFxuICAgICAgICAgIG9wLFxuICAgICAgICAgIG9wLnBhcmVudEtleVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhpcyBwb3NpdGlvbiwgdXBkYXRlIGlzIGEgc2V0LCBlbHNlIGl0J3MgYW4gaW5zZXJ0XG4gICAgICAgICAgICBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPT09IC0xID8gaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pIDogc2V0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pLFxuICAgICAgICAgICAgLi4uZGVsdGFcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdXBkYXRlIGRlbHRhIG9mIHRoZSBkZWxldGlvbiBvciBudWxsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oZGVsZXRlZElkKSB7XG4gICAgaWYgKGRlbGV0ZWRJZCA9PT0gdm9pZCAwIHx8IHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRlbGV0ZWRJdGVtID0gdGhpcy5fcG9vbC5nZXROb2RlKGRlbGV0ZWRJZCk7XG4gICAgaWYgKGRlbGV0ZWRJdGVtID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZXRhY2hDaGlsZChkZWxldGVkSXRlbSk7XG4gICAgaWYgKHJlc3VsdC5tb2RpZmllZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lm1vZGlmaWVkLnVwZGF0ZXNbMF07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlSZW1vdGVJbnNlcnQob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBhc1BvcyhvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5fc2hpZnRJdGVtUG9zaXRpb24oZXhpc3RpbmdJdGVtSW5kZXgsIGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pXSksXG4gICAgICByZXZlcnNlOiBbXVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlJbnNlcnRBY2sob3ApIHtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtcy5maW5kKChpdGVtKSA9PiBpdGVtLl9pZCA9PT0gb3AuaWQpO1xuICAgIGNvbnN0IGtleSA9IGFzUG9zKG9wLnBhcmVudEtleSk7XG4gICAgY29uc3QgaXRlbUluZGV4QXRQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW0pIHtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW0uX3BhcmVudEtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvbGRQb3NpdGlvbkluZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihleGlzdGluZ0l0ZW0pO1xuICAgICAgICBpZiAoaXRlbUluZGV4QXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zaGlmdEl0ZW1Qb3NpdGlvbihpdGVtSW5kZXhBdFBvc2l0aW9uLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4aXN0aW5nSXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICAgICAgaWYgKG5ld0luZGV4ID09PSBvbGRQb3NpdGlvbkluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBtb3ZlRGVsdGEob2xkUG9zaXRpb25JbmRleCwgbmV3SW5kZXgsIGV4aXN0aW5nSXRlbSlcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcnBoYW4gPSBubih0aGlzLl9wb29sKS5nZXROb2RlKG9wLmlkKTtcbiAgICAgIGlmIChvcnBoYW4gJiYgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMob3JwaGFuKSkge1xuICAgICAgICBvcnBoYW4uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUob3JwaGFuKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChvcnBoYW4pO1xuICAgICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgb3JwaGFuKV0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXRlbUluZGV4QXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zaGlmdEl0ZW1Qb3NpdGlvbihpdGVtSW5kZXhBdFBvc2l0aW9uLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgbmV3SXRlbSldKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseUluc2VydFVuZG9SZWRvKG9wKSB7XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGlmICh0aGlzLl9wb29sPy5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBsZXQgbmV3S2V5ID0ga2V5O1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGJlZm9yZTIgPSB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0/Ll9wYXJlbnRQb3M7XG4gICAgICBjb25zdCBhZnRlcjIgPSB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zO1xuICAgICAgbmV3S2V5ID0gbWFrZVBvc2l0aW9uKGJlZm9yZTIsIGFmdGVyMik7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgIH1cbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgcmV2ZXJzZTogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV1cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0VW5kb1JlZG8ob3ApIHtcbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2w/LmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuc2V0KGtleSwgbm4ob3Aub3BJZCkpO1xuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVLZXkgPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCBubih0aGlzLl9wb29sKSk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBuZXdLZXkgPSBrZXk7XG4gICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVLZXkgIT09IC0xKSB7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lS2V5XTtcbiAgICAgIGV4aXN0aW5nSXRlbS5fZGV0YWNoKCk7XG4gICAgICB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lS2V5XSA9IGNoaWxkO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGV4aXN0aW5nSXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBrZXksIHRoaXMuX3Bvb2wpLFxuICAgICAgICBvcC5pZFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gW3NldERlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVLZXksIGNoaWxkKV07XG4gICAgICBjb25zdCBkZWxldGVkRGVsdGEgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICk7XG4gICAgICBpZiAoZGVsZXRlZERlbHRhKSB7XG4gICAgICAgIGRlbHRhLnB1c2goZGVsZXRlZERlbHRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKG9wLmRlbGV0ZWRJZCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmV2ZXJzZTogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChvcC5pbnRlbnQgPT09IFwic2V0XCIpIHtcbiAgICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5U2V0UmVtb3RlKG9wKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVNldEFjayhvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVNldFVuZG9SZWRvKG9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlSZW1vdGVJbnNlcnQob3ApO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5SW5zZXJ0QWNrKG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5SW5zZXJ0VW5kb1JlZG8ob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0Lm1vZGlmaWVkICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IGNoaWxkLl90b09wcyhubih0aGlzLl9pZCksIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBpbmRleFRvRGVsZXRlID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAoaW5kZXhUb0RlbGV0ZSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleFRvRGVsZXRlLCAxKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2RlbGV0ZURlbHRhKGluZGV4VG9EZWxldGUpXSksXG4gICAgICAgIHJldmVyc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0Q2hpbGRLZXlSZW1vdGUobmV3S2V5LCBjaGlsZCkge1xuICAgIGlmICh0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhjaGlsZCkpIHtcbiAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKGNoaWxkKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBjaGlsZC5fcGFyZW50S2V5O1xuICAgIGlmIChuZXdLZXkgPT09IHByZXZpb3VzS2V5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ID09PSAtMSkge1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICApO1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVNldENoaWxkS2V5QWNrKG5ld0tleSwgY2hpbGQpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGlmICh0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhjaGlsZCkpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShjaGlsZCk7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXdLZXkgPT09IHByZXZpb3VzS2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBtYWtlUG9zaXRpb24obmV3S2V5LCB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChwcmV2aW91c0luZGV4ID09PSBuZXdJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0Q2hpbGRLZXlVbmRvUmVkbyhuZXdLZXksIGNoaWxkKSB7XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICApO1xuICAgIH1cbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgaWYgKHByZXZpb3VzSW5kZXggPT09IG5ld0luZGV4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgIHJldmVyc2U6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgaWQ6IG5uKGNoaWxkLl9pZCksXG4gICAgICAgICAgcGFyZW50S2V5OiBwcmV2aW91c0tleVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXRDaGlsZEtleShuZXdLZXksIGNoaWxkLCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2V0Q2hpbGRLZXlSZW1vdGUobmV3S2V5LCBjaGlsZCk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlTZXRDaGlsZEtleUFjayhuZXdLZXksIGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2V0Q2hpbGRLZXlVbmRvUmVkbyhuZXdLZXksIGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZUxpc3QgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAxIC8qIExJU1QgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzLlxuICAgKi9cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9uZSBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIExpdmVMaXN0LlxuICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgTGl2ZUxpc3QuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIHJldHVybiB0aGlzLmluc2VydChlbGVtZW50LCB0aGlzLmxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgb25lIGVsZW1lbnQgYXQgYSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGluc2VydC5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB5b3Ugd2FudCB0byBpbnNlcnQgdGhlIGVsZW1lbnQuXG4gICAqL1xuICBpbnNlcnQoZWxlbWVudCwgaW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBpbnNlcnQgbGlzdCBpdGVtIGF0IGluZGV4IFwiXHUwMDFkJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLl9pdGVtcy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgYmVmb3JlMiA9IHRoaXMuX2l0ZW1zW2luZGV4IC0gMV0gPyB0aGlzLl9pdGVtc1tpbmRleCAtIDFdLl9wYXJlbnRQb3MgOiB2b2lkIDA7XG4gICAgY29uc3QgYWZ0ZXIyID0gdGhpcy5faXRlbXNbaW5kZXhdID8gdGhpcy5faXRlbXNbaW5kZXhdLl9wYXJlbnRQb3MgOiB2b2lkIDA7XG4gICAgY29uc3QgcG9zaXRpb24gPSBtYWtlUG9zaXRpb24oYmVmb3JlMiwgYWZ0ZXIyKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxzb25Ub0xpdmVOb2RlKGVsZW1lbnQpO1xuICAgIHZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHBvc2l0aW9uKTtcbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KHZhbHVlKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIHZhbHVlLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgdmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBwb3NpdGlvbiwgdGhpcy5fcG9vbCksXG4gICAgICAgIFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgICAgW3RoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShpbmRleCwgdmFsdWUpXSldXG4gICAgICAgIF0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTW92ZSBvbmUgZWxlbWVudCBmcm9tIG9uZSBpbmRleCB0byBhbm90aGVyLlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIG1vdmVcbiAgICogQHBhcmFtIHRhcmdldEluZGV4IFRoZSBpbmRleCB3aGVyZSB0aGUgZWxlbWVudCBzaG91bGQgYmUgYWZ0ZXIgbW92aW5nLlxuICAgKi9cbiAgbW92ZShpbmRleCwgdGFyZ2V0SW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0YXJnZXRJbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcInRhcmdldEluZGV4IGNhbm5vdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRoYW4gdGhlIGxpc3QgbGVuZ3RoXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggY2Fubm90IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiB0aGUgbGlzdCBsZW5ndGhcIik7XG4gICAgfVxuICAgIGxldCBiZWZvcmVQb3NpdGlvbiA9IG51bGw7XG4gICAgbGV0IGFmdGVyUG9zaXRpb24gPSBudWxsO1xuICAgIGlmIChpbmRleCA8IHRhcmdldEluZGV4KSB7XG4gICAgICBhZnRlclBvc2l0aW9uID0gdGFyZ2V0SW5kZXggPT09IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEgPyB2b2lkIDAgOiB0aGlzLl9pdGVtc1t0YXJnZXRJbmRleCArIDFdLl9wYXJlbnRQb3M7XG4gICAgICBiZWZvcmVQb3NpdGlvbiA9IHRoaXMuX2l0ZW1zW3RhcmdldEluZGV4XS5fcGFyZW50UG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlclBvc2l0aW9uID0gdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXhdLl9wYXJlbnRQb3M7XG4gICAgICBiZWZvcmVQb3NpdGlvbiA9IHRhcmdldEluZGV4ID09PSAwID8gdm9pZCAwIDogdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXggLSAxXS5fcGFyZW50UG9zO1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihiZWZvcmVQb3NpdGlvbiwgYWZ0ZXJQb3NpdGlvbik7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4XTtcbiAgICBjb25zdCBwcmV2aW91c1Bvc2l0aW9uID0gaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpO1xuICAgIGl0ZW0uX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW3RoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFttb3ZlRGVsdGEoaW5kZXgsIHRhcmdldEluZGV4LCBpdGVtKV0pXVxuICAgICAgXSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICAgIGlkOiBubihpdGVtLl9pZCksXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwb3NpdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgICBpZDogbm4oaXRlbS5faWQpLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwcmV2aW91c1Bvc2l0aW9uXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUoaW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZGVsZXRlIGxpc3QgaXRlbSBhdCBpbmRleCBcIiR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy5faXRlbXMubGVuZ3RoIC0gMX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbaW5kZXhdO1xuICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wpIHtcbiAgICAgIGNvbnN0IGNoaWxkUmVjb3JkSWQgPSBpdGVtLl9pZDtcbiAgICAgIGlmIChjaGlsZFJlY29yZElkKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgIG5uKHRoaXMuX2lkKSxcbiAgICAgICAgICBtYWtlVXBkYXRlKHRoaXMsIFtkZWxldGVEZWx0YShpbmRleCldKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWQ6IGNoaWxkUmVjb3JkSWQsXG4gICAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKCksXG4gICAgICAgICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIGl0ZW0uX3RvT3BzKG5uKHRoaXMuX2lkKSwgaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpKSxcbiAgICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0aGlzLl9wb29sKSB7XG4gICAgICBjb25zdCBvcHMgPSBbXTtcbiAgICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICAgIGNvbnN0IHVwZGF0ZURlbHRhID0gW107XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgICAgIGNvbnN0IGNoaWxkSWQgPSBpdGVtLl9pZDtcbiAgICAgICAgaWYgKGNoaWxkSWQpIHtcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICAgICAgaWQ6IGNoaWxkSWQsXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV2ZXJzZU9wcy5wdXNoKFxuICAgICAgICAgICAgLi4uaXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB1cGRhdGVEZWx0YS5wdXNoKGRlbGV0ZURlbHRhKDApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KG5uKHRoaXMuX2lkKSwgbWFrZVVwZGF0ZSh0aGlzLCB1cGRhdGVEZWx0YSkpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBzZXQoaW5kZXgsIGl0ZW0pIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgc2V0IGxpc3QgaXRlbSBhdCBpbmRleCBcIlx1MDAxZCR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy5faXRlbXMubGVuZ3RoIC0gMX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleF07XG4gICAgY29uc3QgcG9zaXRpb24gPSBleGlzdGluZ0l0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKTtcbiAgICBjb25zdCBleGlzdGluZ0lkID0gZXhpc3RpbmdJdGVtLl9pZDtcbiAgICBleGlzdGluZ0l0ZW0uX2RldGFjaCgpO1xuICAgIGNvbnN0IHZhbHVlID0gbHNvblRvTGl2ZU5vZGUoaXRlbSk7XG4gICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX2l0ZW1zW2luZGV4XSA9IHZhbHVlO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgdmFsdWUuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW3NldERlbHRhKGluZGV4LCB2YWx1ZSldKSk7XG4gICAgICBjb25zdCBvcHMgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICB2YWx1ZS5fdG9PcHModGhpcy5faWQsIHBvc2l0aW9uLCB0aGlzLl9wb29sKSxcbiAgICAgICAgZXhpc3RpbmdJZFxuICAgICAgKTtcbiAgICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5zZXQocG9zaXRpb24sIG5uKG9wc1swXS5vcElkKSk7XG4gICAgICBjb25zdCByZXZlcnNlT3BzID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgZXhpc3RpbmdJdGVtLl90b09wcyh0aGlzLl9pZCwgcG9zaXRpb24sIHZvaWQgMCksXG4gICAgICAgIGlkXG4gICAgICApO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gQXJyYXkgb2YgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgTGl2ZUxpc3QuXG4gICAqL1xuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5tYXAoXG4gICAgICAoZW50cnkpID0+IGxpdmVOb2RlVG9Mc29uKGVudHJ5KVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5cbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZJWE1FISBUaGlzIGlzbid0IHNhZmUuXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVGVzdHMgd2hldGhlciBhbGwgZWxlbWVudHMgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gdGVzdCBmb3IgZWFjaCBlbGVtZW50LCB0YWtpbmcgdHdvIGFyZ3VtZW50cyAodGhlIGVsZW1lbnQgYW5kIGl0cyBpbmRleCkuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByZWRpY2F0ZSBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIGZvciBldmVyeSBlbGVtZW50LiBPdGhlcndpc2UsIGZhbHNlLlxuICAgKi9cbiAgZXZlcnkocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmV2ZXJ5KHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZWxlbWVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byB0ZXN0IGVhY2ggZWxlbWVudCBvZiB0aGUgTGl2ZUxpc3QuIFJldHVybiBhIHZhbHVlIHRoYXQgY29lcmNlcyB0byB0cnVlIHRvIGtlZXAgdGhlIGVsZW1lbnQsIG9yIHRvIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0LlxuICAgKi9cbiAgZmlsdGVyKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maWx0ZXIocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUuXG4gICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uIE90aGVyd2lzZSwgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICAgKi9cbiAgZmluZChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmluZChwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHZhbHVlIHVudGlsIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIGluZGljYXRpbmcgdGhhdCB0aGUgc2F0aXNmeWluZyBlbGVtZW50IHdhcyBmb3VuZC5cbiAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHBhc3NlcyB0aGUgdGVzdC4gT3RoZXJ3aXNlLCAtMS5cbiAgICovXG4gIGZpbmRJbmRleChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmluZEluZGV4KHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBmb3IgZWFjaCBlbGVtZW50LlxuICAgKiBAcGFyYW0gY2FsbGJhY2tmbiBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2tmbikge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5mb3JFYWNoKGNhbGxiYWNrZm4pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvbiB0aGUgZWxlbWVudCB0byBnZXQuXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0KGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsaXZlTm9kZVRvTHNvbih0aGlzLl9pdGVtc1tpbmRleF0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBMaXZlTGlzdCwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlLlxuICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoIGF0LlxuICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0OyAtMSBpZiBub3QgZm91bmQuXG4gICAqL1xuICBpbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5pbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50IGNhbiBiZSBmb3VuZCBpbiB0aGUgTGl2ZUxpc3QsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LiBUaGUgTGl2ZUxzaXQgaXMgc2VhcmNoZWQgYmFja3dhcmRzLCBzdGFydGluZyBhdCBmcm9tSW5kZXguXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlLlxuICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmcgYmFja3dhcmRzLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgcG9wdWxhdGVkIHdpdGggdGhlIHJlc3VsdHMgb2YgY2FsbGluZyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIGV2ZXJ5IGVsZW1lbnQuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBmb3IgZXZlcnkgZWxlbWVudC5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCBlYWNoIGVsZW1lbnQgYmVpbmcgdGhlIHJlc3VsdCBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqL1xuICBtYXAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMubWFwKFxuICAgICAgKGVudHJ5LCBpKSA9PiBjYWxsYmFjayhcbiAgICAgICAgbGl2ZU5vZGVUb0xzb24oZW50cnkpLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIEZJWE1FISBUaGlzIGlzbid0IHNhZmUuXG4gICAgICAgIGlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCBwYXNzZXMgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIHRlc3QgZm9yIGVhY2ggZWxlbWVudC5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZSBmb3IgYXQgbGVhc3Qgb25lIGVsZW1lbnQuIE90aGVyd2lzZSwgZmFsc2UuXG4gICAqL1xuICBzb21lKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5zb21lKHByZWRpY2F0ZSk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlTGlzdEl0ZXJhdG9yKHRoaXMuX2l0ZW1zKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9jcmVhdGVBdHRhY2hJdGVtQW5kU29ydChvcCwga2V5KSB7XG4gICAgY29uc3QgbmV3SXRlbSA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBuZXdJdGVtLl9hdHRhY2gob3AuaWQsIG5uKHRoaXMuX3Bvb2wpKTtcbiAgICBuZXdJdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgdGhpcy5faW5zZXJ0QW5kU29ydChuZXdJdGVtKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIHJldHVybiB7IG5ld0l0ZW0sIG5ld0luZGV4IH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2hpZnRJdGVtUG9zaXRpb24oaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IHNoaWZ0ZWRQb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihcbiAgICAgIGtleSxcbiAgICAgIHRoaXMuX2l0ZW1zLmxlbmd0aCA+IGluZGV4ICsgMSA/IHRoaXMuX2l0ZW1zW2luZGV4ICsgMV0/Ll9wYXJlbnRQb3MgOiB2b2lkIDBcbiAgICApO1xuICAgIHRoaXMuX2l0ZW1zW2luZGV4XS5fc2V0UGFyZW50TGluayh0aGlzLCBzaGlmdGVkUG9zaXRpb24pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IHRoaXMuX2l0ZW1zLm1hcChcbiAgICAgICAgKGl0ZW0sIGluZGV4KSA9PiBpdGVtLnRvVHJlZU5vZGUoaW5kZXgudG9TdHJpbmcoKSlcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2l0ZW1zLm1hcCgobm9kZSkgPT4gbm9kZS50b0ltbXV0YWJsZSgpKTtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gcmVzdWx0IDogT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0xpdmVMaXN0KHRoaXMuX2l0ZW1zLm1hcCgoaXRlbSkgPT4gaXRlbS5jbG9uZSgpKSk7XG4gIH1cbn07XG52YXIgTGl2ZUxpc3RJdGVyYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaXRlbXMpIHtcbiAgICB0aGlzLl9pbm5lckl0ZXJhdG9yID0gaXRlbXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG5leHQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5faW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGxpdmVOb2RlVG9Mc29uKHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIG1ha2VVcGRhdGUobGl2ZUxpc3QsIGRlbHRhVXBkYXRlcykge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IGxpdmVMaXN0LFxuICAgIHR5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICB1cGRhdGVzOiBkZWx0YVVwZGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHNldERlbHRhKGluZGV4LCBpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXgsXG4gICAgdHlwZTogXCJzZXRcIixcbiAgICBpdGVtOiBpdGVtIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gaXRlbS5kYXRhIDogaXRlbVxuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlRGVsdGEoaW5kZXgpIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleCxcbiAgICB0eXBlOiBcImRlbGV0ZVwiXG4gIH07XG59XG5mdW5jdGlvbiBpbnNlcnREZWx0YShpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwiaW5zZXJ0XCIsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVEZWx0YShwcmV2aW91c0luZGV4LCBpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwibW92ZVwiLFxuICAgIHByZXZpb3VzSW5kZXgsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24ob3BzLCBkZWxldGVkSWQpIHtcbiAgcmV0dXJuIG9wcy5tYXAoKG9wLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgY29uc3QgZmlyc3RPcCA9IG9wO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZmlyc3RPcCxcbiAgICAgICAgaW50ZW50OiBcInNldFwiLFxuICAgICAgICBkZWxldGVkSWRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcDtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvbGliL2ZyZWV6ZS50c1xudmFyIGZyZWV6ZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IChcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgKHgpID0+IHhcbikgOiBPYmplY3QuZnJlZXplO1xuXG4vLyBzcmMvY3JkdHMvTGl2ZU1hcC50c1xudmFyIExpdmVNYXAgPSBjbGFzcyBfTGl2ZU1hcCBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gIGNvbnN0cnVjdG9yKGVudHJpZXMyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBpZiAoZW50cmllczIpIHtcbiAgICAgIGNvbnN0IG1hcHBlZEVudHJpZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgICAgIG5vZGUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgbWFwcGVkRW50cmllcy5wdXNoKFtrZXksIG5vZGVdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAobWFwcGVkRW50cmllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICB0eXBlOiA3IC8qIENSRUFURV9NQVAgKi8sXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgb3BzLnB1c2goLi4udmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXksIHBvb2wpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZCwgX2l0ZW1dLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgbWFwID0gbmV3IF9MaXZlTWFwKCk7XG4gICAgbWFwLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQoaWQpO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZDIsIGNyZHRdIG9mIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGRlc2VyaWFsaXplKFtpZDIsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKG1hcCwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgbWFwLl9tYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBtYXAuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IFtfa2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5LCBvcElkIH0gPSBvcDtcbiAgICBjb25zdCBrZXkgPSBwYXJlbnRLZXk7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICBjb25zdCBsYXN0VXBkYXRlT3BJZCA9IHRoaXMudW5hY2tub3dsZWRnZWRTZXQuZ2V0KGtleSk7XG4gICAgICBpZiAobGFzdFVwZGF0ZU9wSWQgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy51bmFja25vd2xlZGdlZFNldC5kZWxldGUoa2V5KTtcbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9IGVsc2UgaWYgKGxhc3RVcGRhdGVPcElkICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChwcmV2aW91c1ZhbHVlKSB7XG4gICAgICBjb25zdCB0aGlzSWQgPSBubih0aGlzLl9pZCk7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XTtcbiAgICB9XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICB0aGlzLl9tYXAuc2V0KGtleSwgY2hpbGQpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcInVwZGF0ZVwiIH0gfVxuICAgICAgfSxcbiAgICAgIHJldmVyc2VcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2goKSB7XG4gICAgc3VwZXIuX2RldGFjaCgpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9tYXAudmFsdWVzKCkpIHtcbiAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBjb25zdCByZXZlcnNlID0gY2hpbGQuX3RvT3BzKGlkLCBwYXJlbnRLZXksIHRoaXMuX3Bvb2wpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGlsZC5fZGV0YWNoKCk7XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgIG5vZGU6IHRoaXMsXG4gICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgIHVwZGF0ZXM6IHsgW3BhcmVudEtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICB9O1xuICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlTWFwIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMiAvKiBNQVAgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhlIExpdmVNYXAuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBrZXkgY2FuJ3QgYmUgZm91bmQgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsaXZlTm9kZVRvTHNvbih2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpZWQga2V5IGFuZCBhIHZhbHVlLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgc2VyaWFsaXphYmxlIHRvIEpTT04uXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgaXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIHRoaXMuX21hcC5zZXQoa2V5LCBpdGVtKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIGl0ZW0uX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJ1cGRhdGVcIiB9IH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgb3BzID0gaXRlbS5fdG9PcHModGhpcy5faWQsIGtleSwgdGhpcy5fcG9vbCk7XG4gICAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LnNldChrZXksIG5uKG9wc1swXS5vcElkKSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBpdGVtLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKSxcbiAgICAgICAgb2xkVmFsdWUgPyBvbGRWYWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSkgOiBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLnNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIG9yIG5vdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHRlc3QgZm9yIHByZXNlbmNlLlxuICAgKi9cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBlbGVtZW50IGJ5IGtleS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiBhbiBlbGVtZW50IGV4aXN0ZWQgYW5kIGhhcyBiZWVuIHJlbW92ZWQsIG9yIGZhbHNlIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgZGVsZXRlKGtleSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBpZiAoaXRlbSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiBpdGVtLl9pZCkge1xuICAgICAgY29uc3QgdGhpc0lkID0gbm4odGhpcy5faWQpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXNJZCwge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH0gfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICAgICAgICAgIGlkOiBpdGVtLl9pZCxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKClcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXNJZCwga2V5KSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBba2V5LCB2YWx1ZV0gcGFpcnMgZm9yIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGVudHJpZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuX21hcC5lbnRyaWVzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvclZhbHVlID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVyYXRvclZhbHVlLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlcmF0b3JWYWx1ZS52YWx1ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gZW50cnlbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24oaXRlcmF0b3JWYWx1ZS52YWx1ZVsxXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IFtrZXksIHZhbHVlXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNhbWUgZnVuY3Rpb24gb2JqZWN0IGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBlbnRyaWVzIG1ldGhvZC5cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUga2V5cyBmb3IgZWFjaCBlbGVtZW50LlxuICAgKi9cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgdmFsdWVzIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICB2YWx1ZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuX21hcC52YWx1ZXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yVmFsdWUgPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yVmFsdWUuZG9uZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBsaXZlTm9kZVRvTHNvbihpdGVyYXRvclZhbHVlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgcGVyIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIE1hcCBvYmplY3QsIGluIGluc2VydGlvbiBvcmRlci5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZW50cnkgaW4gdGhlIG1hcC5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMpIHtcbiAgICAgIGNhbGxiYWNrKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLl9tYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsXSkgPT4gdmFsLnRvVHJlZU5vZGUoa2V5MilcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUudG9JbW11dGFibGUoKSk7XG4gICAgfVxuICAgIHJldHVybiBmcmVlemUocmVzdWx0KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlTWFwKFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLl9tYXApLm1hcCgoW2tleSwgbm9kZV0pID0+IFtrZXksIG5vZGUuY2xvbmUoKV0pXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVPYmplY3QudHNcbnZhciBMaXZlT2JqZWN0ID0gY2xhc3MgX0xpdmVPYmplY3QgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICBjb25zdHJ1Y3RvcihvYmogPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMob2JqKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2J1aWxkUm9vdEFuZFBhcmVudFRvQ2hpbGRyZW4oaXRlbXMpIHtcbiAgICBjb25zdCBwYXJlbnRUb0NoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgcm9vdCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBbaWQsIGNyZHRdIG9mIGl0ZW1zKSB7XG4gICAgICBpZiAoaXNSb290Q3JkdChjcmR0KSkge1xuICAgICAgICByb290ID0gW2lkLCBjcmR0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHR1cGxlID0gW2lkLCBjcmR0XTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRUb0NoaWxkcmVuLmdldChjcmR0LnBhcmVudElkKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHR1cGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnRUb0NoaWxkcmVuLnNldChjcmR0LnBhcmVudElkLCBbdHVwbGVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vdCBjYW4ndCBiZSBudWxsXCIpO1xuICAgIH1cbiAgICByZXR1cm4gW3Jvb3QsIHBhcmVudFRvQ2hpbGRyZW5dO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9mcm9tSXRlbXMoaXRlbXMsIHBvb2wpIHtcbiAgICBjb25zdCBbcm9vdCwgcGFyZW50VG9DaGlsZHJlbl0gPSBfTGl2ZU9iamVjdC5fYnVpbGRSb290QW5kUGFyZW50VG9DaGlsZHJlbihpdGVtcyk7XG4gICAgcmV0dXJuIF9MaXZlT2JqZWN0Ll9kZXNlcmlhbGl6ZShcbiAgICAgIHJvb3QsXG4gICAgICBwYXJlbnRUb0NoaWxkcmVuLFxuICAgICAgcG9vbFxuICAgICk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIGl0ZW0gaXMgbm90IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcElkID0gcG9vbD8uZ2VuZXJhdGVPcElkKCk7XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXksXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIG9wcy5wdXNoKC4uLnZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCBwb29sKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcC5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGxpdmVPYmogPSBuZXcgX0xpdmVPYmplY3QoaXRlbS5kYXRhKTtcbiAgICBsaXZlT2JqLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KG5uKGxpdmVPYmouX2lkKSk7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsaXZlT2JqO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemVUb0xzb24oW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhsaXZlT2JqLCBjcmR0LnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgICBsaXZlT2JqLl9tYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBsaXZlT2JqLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVPYmo7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgc3VwZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgZm9yIChjb25zdCBbX2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9hdHRhY2gocG9vbC5nZW5lcmF0ZUlkKCksIHBvb2wpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgb3BJZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTHNvbihvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBpZiAoc291cmNlID09PSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLykge1xuICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihvcElkKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChpc0xpdmVOb2RlKHByZXZpb3VzVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIGlmIChwcmV2aW91c1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZDogdGhpc0lkLCBrZXkgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgaWQ6IHRoaXNJZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBwcmV2aW91c1ZhbHVlIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy5fbWFwLnNldChrZXksIGNoaWxkKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmV2ZXJzZSxcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwidXBkYXRlXCIgfSB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMoaWQsIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICBbcGFyZW50S2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2goKSB7XG4gICAgc3VwZXIuX2RldGFjaCgpO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5fbWFwLnZhbHVlcygpKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIGlmIChvcC50eXBlID09PSAzIC8qIFVQREFURV9PQkpFQ1QgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseVVwZGF0ZShvcCwgaXNMb2NhbCk7XG4gICAgfSBlbHNlIGlmIChvcC50eXBlID09PSA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlEZWxldGVPYmplY3RLZXkob3AsIGlzTG9jYWwpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIGlmICghaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiICYmIHRoaXMucGFyZW50Lm5vZGUuX2lkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAwIC8qIE9CSkVDVCAqLyxcbiAgICAgICAgcGFyZW50SWQ6IHRoaXMucGFyZW50Lm5vZGUuX2lkLFxuICAgICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleSxcbiAgICAgICAgZGF0YVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMCAvKiBPQkpFQ1QgKi8sXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5VXBkYXRlKG9wLCBpc0xvY2FsKSB7XG4gICAgbGV0IGlzTW9kaWZpZWQgPSBmYWxzZTtcbiAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCByZXZlcnNlID0gW107XG4gICAgY29uc3QgcmV2ZXJzZVVwZGF0ZSA9IHtcbiAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgIGlkLFxuICAgICAgZGF0YToge31cbiAgICB9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIHJldmVyc2UucHVzaCguLi5vbGRWYWx1ZS5fdG9PcHMoaWQsIGtleSkpO1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV2ZXJzZVVwZGF0ZS5kYXRhW2tleV0gPSBvbGRWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICByZXZlcnNlLnB1c2goeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZCwga2V5IH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1cGRhdGVEZWx0YSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3AuZGF0YVtrZXldO1xuICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNMb2NhbCkge1xuICAgICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLnNldChrZXksIG5uKG9wLm9wSWQpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSBvcC5vcElkKSB7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICBpc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIHVwZGF0ZURlbHRhW2tleV0gPSB7IHR5cGU6IFwidXBkYXRlXCIgfTtcbiAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHJldmVyc2VVcGRhdGUuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXZlcnNlLnVuc2hpZnQocmV2ZXJzZVVwZGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBpc01vZGlmaWVkID8ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHVwZGF0ZURlbHRhXG4gICAgICB9LFxuICAgICAgcmV2ZXJzZVxuICAgIH0gOiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5RGVsZXRlT2JqZWN0S2V5KG9wLCBpc0xvY2FsKSB7XG4gICAgY29uc3Qga2V5ID0gb3Aua2V5O1xuICAgIGlmICh0aGlzLl9tYXAuaGFzKGtleSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKCFpc0xvY2FsICYmIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGxldCByZXZlcnNlID0gW107XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKGlkLCBvcC5rZXkpO1xuICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcmV2ZXJzZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBvbGRWYWx1ZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW29wLmtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBMaXZlT2JqZWN0IGludG8gYSBqYXZhc2NyaXB0IG9iamVjdFxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLl9tYXApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYSBwcm9wZXJ0eSB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgYSB2YWx1ZS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhZGRcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYWRkXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgdGhpcy51cGRhdGUoeyBba2V5XTogdmFsdWUgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSB0aGUgTGl2ZU9iamVjdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXRcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmdldChrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEga2V5IGZyb20gdGhlIExpdmVPYmplY3RcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IGtleUFzU3RyaW5nID0ga2V5O1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXlBc1N0cmluZyk7XG4gICAgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCB8fCB0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXlBc1N0cmluZyk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXlBc1N0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgZGF0YTogeyBba2V5QXNTdHJpbmddOiBvbGRWYWx1ZSB9LFxuICAgICAgICAgIGlkOiB0aGlzLl9pZFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLl9tYXAuZGVsZXRlKGtleUFzU3RyaW5nKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgfSk7XG4gICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sXG4gICAgICAgICAga2V5OiBrZXlBc1N0cmluZyxcbiAgICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgcmV2ZXJzZSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZSB3aXRoIGFuIG9iamVjdC5cbiAgICogQHBhcmFtIHBhdGNoIFRoZSBvYmplY3QgdXNlZCB0byBvdmVycmlkZXMgcHJvcGVydGllc1xuICAgKi9cbiAgdXBkYXRlKHBhdGNoKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwIHx8IHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpdmVOb2RlKG5ld1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICBjb25zdCBvcElkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKTtcbiAgICBjb25zdCB1cGRhdGVkUHJvcHMgPSB7fTtcbiAgICBjb25zdCByZXZlcnNlVXBkYXRlT3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgY29uc3QgdXBkYXRlRGVsdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXRjaCkge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICByZXZlcnNlT3BzLnB1c2goLi4ub2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXkpKTtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2VPcHMucHVzaCh7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkOiB0aGlzLl9pZCwga2V5IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV2ZXJzZVVwZGF0ZU9wLmRhdGFba2V5XSA9IG9sZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzTGl2ZU5vZGUobmV3VmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIG5ld1ZhbHVlLl9hdHRhY2godGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCksIHRoaXMuX3Bvb2wpO1xuICAgICAgICBjb25zdCBuZXdBdHRhY2hDaGlsZE9wcyA9IG5ld1ZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKTtcbiAgICAgICAgY29uc3QgY3JlYXRlQ3JkdE9wID0gbmV3QXR0YWNoQ2hpbGRPcHMuZmluZChcbiAgICAgICAgICAob3ApID0+IG9wLnBhcmVudElkID09PSB0aGlzLl9pZFxuICAgICAgICApO1xuICAgICAgICBpZiAoY3JlYXRlQ3JkdE9wKSB7XG4gICAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihjcmVhdGVDcmR0T3Aub3BJZCkpO1xuICAgICAgICB9XG4gICAgICAgIG9wcy5wdXNoKC4uLm5ld0F0dGFjaENoaWxkT3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZWRQcm9wc1trZXldID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgb3BJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tYXAuc2V0KGtleSwgbmV3VmFsdWUpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB1cGRhdGVEZWx0YVtrZXldID0geyB0eXBlOiBcInVwZGF0ZVwiIH07XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhyZXZlcnNlVXBkYXRlT3AuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXZlcnNlT3BzLnVuc2hpZnQocmV2ZXJzZVVwZGF0ZU9wKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZWRQcm9wcykubGVuZ3RoICE9PSAwKSB7XG4gICAgICBvcHMudW5zaGlmdCh7XG4gICAgICAgIG9wSWQsXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICBkYXRhOiB1cGRhdGVkUHJvcHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB1cGRhdGVEZWx0YVxuICAgIH0pO1xuICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2gob3BzLCByZXZlcnNlT3BzLCBzdG9yYWdlVXBkYXRlcyk7XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB0b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiBzdXBlci50b1RyZWVOb2RlKGtleSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICBjb25zdCBub2RlSWQgPSB0aGlzLl9pZCA/PyBuYW5vaWQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICBpZDogbm9kZUlkLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLl9tYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsdWVdKSA9PiBpc0xpdmVOb2RlKHZhbHVlKSA/IHZhbHVlLnRvVHJlZU5vZGUoa2V5MikgOiB7IHR5cGU6IFwiSnNvblwiLCBpZDogYCR7bm9kZUlkfToke2tleTJ9YCwga2V5OiBrZXkyLCBwYXlsb2FkOiB2YWx1ZSB9XG4gICAgICApXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGlzTGl2ZVN0cnVjdHVyZSh2YWwpID8gdmFsLnRvSW1tdXRhYmxlKCkgOiB2YWw7XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyByZXN1bHQgOiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZU9iamVjdChcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9tYXApLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgPyB2YWx1ZS5jbG9uZSgpIDogZGVlcENsb25lKHZhbHVlKVxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jcmR0cy9saXZlYmxvY2tzLWhlbHBlcnMudHNcbmZ1bmN0aW9uIGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKSB7XG4gIHJldHVybiBsc29uVG9MaXZlTm9kZShjcmVhdGlvbk9wVG9Mc29uKG9wKSk7XG59XG5mdW5jdGlvbiBjcmVhdGlvbk9wVG9Mc29uKG9wKSB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgOCAvKiBDUkVBVEVfUkVHSVNURVIgKi86XG4gICAgICByZXR1cm4gb3AuZGF0YTtcbiAgICBjYXNlIDQgLyogQ1JFQVRFX09CSkVDVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU9iamVjdChvcC5kYXRhKTtcbiAgICBjYXNlIDcgLyogQ1JFQVRFX01BUCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU1hcCgpO1xuICAgIGNhc2UgMiAvKiBDUkVBVEVfTElTVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZUxpc3QoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKG9wLCBcIlVua25vd24gY3JlYXRpb24gT3BcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU2FtZU5vZGVPckNoaWxkT2Yobm9kZSwgcGFyZW50KSB7XG4gIGlmIChub2RlID09PSBwYXJlbnQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgIHJldHVybiBpc1NhbWVOb2RlT3JDaGlsZE9mKG5vZGUucGFyZW50Lm5vZGUsIHBhcmVudCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICBzd2l0Y2ggKGNyZHQudHlwZSkge1xuICAgIGNhc2UgMCAvKiBPQkpFQ1QgKi86IHtcbiAgICAgIHJldHVybiBMaXZlT2JqZWN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAxIC8qIExJU1QgKi86IHtcbiAgICAgIHJldHVybiBMaXZlTGlzdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMiAvKiBNQVAgKi86IHtcbiAgICAgIHJldHVybiBMaXZlTWFwLl9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAzIC8qIFJFR0lTVEVSICovOiB7XG4gICAgICByZXR1cm4gTGl2ZVJlZ2lzdGVyLl9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBDUkRUIHR5cGVcIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVRvTHNvbihbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgY2FzZSAwIC8qIE9CSkVDVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDEgLyogTElTVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVMaXN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAyIC8qIE1BUCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVNYXAuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86IHtcbiAgICAgIHJldHVybiBjcmR0LmRhdGE7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgQ1JEVCB0eXBlXCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNMaXZlU3RydWN0dXJlKHZhbHVlKSB7XG4gIHJldHVybiBpc0xpdmVMaXN0KHZhbHVlKSB8fCBpc0xpdmVNYXAodmFsdWUpIHx8IGlzTGl2ZU9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0xpdmVOb2RlKHZhbHVlKSB7XG4gIHJldHVybiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpIHx8IGlzTGl2ZVJlZ2lzdGVyKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzTGl2ZUxpc3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3Q7XG59XG5mdW5jdGlvbiBpc0xpdmVNYXAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTGl2ZU1hcDtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlT2JqZWN0O1xufVxuZnVuY3Rpb24gaXNMaXZlUmVnaXN0ZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyO1xufVxuZnVuY3Rpb24gY2xvbmVMc29uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXNMaXZlU3RydWN0dXJlKHZhbHVlKSA/IHZhbHVlLmNsb25lKCkgOiBkZWVwQ2xvbmUodmFsdWUpO1xufVxuZnVuY3Rpb24gbGl2ZU5vZGVUb0xzb24ob2JqKSB7XG4gIGlmIChvYmogaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIpIHtcbiAgICByZXR1cm4gb2JqLmRhdGE7XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTGl2ZUxpc3QgfHwgb2JqIGluc3RhbmNlb2YgTGl2ZU1hcCB8fCBvYmogaW5zdGFuY2VvZiBMaXZlT2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXNzZXJ0TmV2ZXIob2JqLCBcIlVua25vd24gQWJzdHJhY3RDcmR0XCIpO1xuICB9XG59XG5mdW5jdGlvbiBsc29uVG9MaXZlTm9kZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlT2JqZWN0IHx8IHZhbHVlIGluc3RhbmNlb2YgTGl2ZU1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIExpdmVMaXN0KSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgTGl2ZVJlZ2lzdGVyKHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHJlZXNEaWZmT3BlcmF0aW9ucyhjdXJyZW50SXRlbXMsIG5ld0l0ZW1zKSB7XG4gIGNvbnN0IG9wcyA9IFtdO1xuICBjdXJyZW50SXRlbXMuZm9yRWFjaCgoXywgaWQpID0+IHtcbiAgICBpZiAoIW5ld0l0ZW1zLmdldChpZCkpIHtcbiAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICAgICAgaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIG5ld0l0ZW1zLmZvckVhY2goKGNyZHQsIGlkKSA9PiB7XG4gICAgY29uc3QgY3VycmVudENyZHQgPSBjdXJyZW50SXRlbXMuZ2V0KGlkKTtcbiAgICBpZiAoY3VycmVudENyZHQpIHtcbiAgICAgIGlmIChjcmR0LnR5cGUgPT09IDAgLyogT0JKRUNUICovKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q3JkdC50eXBlICE9PSAwIC8qIE9CSkVDVCAqLyB8fCBKU09OLnN0cmluZ2lmeShjcmR0LmRhdGEpICE9PSBKU09OLnN0cmluZ2lmeShjdXJyZW50Q3JkdC5kYXRhKSkge1xuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgZGF0YTogY3JkdC5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjcmR0LnBhcmVudEtleSAhPT0gY3VycmVudENyZHQucGFyZW50S2V5KSB7XG4gICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAxIC8qIFNFVF9QQVJFTlRfS0VZICovLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBhcmVudEtleTogbm4oY3JkdC5wYXJlbnRLZXksIFwiUGFyZW50IGtleSBtdXN0IG5vdCBiZSBtaXNzaW5nXCIpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGNyZHQudHlwZSkge1xuICAgICAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogOCAvKiBDUkVBVEVfUkVHSVNURVIgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleSxcbiAgICAgICAgICAgIGRhdGE6IGNyZHQuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgLyogTElTVCAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyIC8qIENSRUFURV9MSVNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXJlbnRJZDogY3JkdC5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBhcmVudEtleTogY3JkdC5wYXJlbnRLZXlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAwIC8qIE9CSkVDVCAqLzpcbiAgICAgICAgICBpZiAoY3JkdC5wYXJlbnRJZCA9PT0gdm9pZCAwIHx8IGNyZHQucGFyZW50S2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJbnRlcm5hbCBlcnJvci4gQ2Fubm90IHNlcmlhbGl6ZSBzdG9yYWdlIHJvb3QgaW50byBhbiBvcGVyYXRpb25cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogNCAvKiBDUkVBVEVfT0JKRUNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXJlbnRJZDogY3JkdC5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBhcmVudEtleTogY3JkdC5wYXJlbnRLZXksXG4gICAgICAgICAgICBkYXRhOiBjcmR0LmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyIC8qIE1BUCAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA3IC8qIENSRUFURV9NQVAgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvcHM7XG59XG5mdW5jdGlvbiBtZXJnZU9iamVjdFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMoc2Vjb25kLnVwZGF0ZXMpKSB7XG4gICAgdXBkYXRlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VNYXBTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKSB7XG4gIGNvbnN0IHVwZGF0ZXMgPSBmaXJzdC51cGRhdGVzO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzKHNlY29uZC51cGRhdGVzKSkge1xuICAgIHVwZGF0ZXNba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uc2Vjb25kLFxuICAgIHVwZGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlTGlzdFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIHJldHVybiB7XG4gICAgLi4uc2Vjb25kLFxuICAgIHVwZGF0ZXM6IHVwZGF0ZXMuY29uY2F0KHNlY29uZC51cGRhdGVzKVxuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKSB7XG4gIGlmIChmaXJzdCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHNlY29uZDtcbiAgfVxuICBpZiAoZmlyc3QudHlwZSA9PT0gXCJMaXZlT2JqZWN0XCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZU9iamVjdFwiKSB7XG4gICAgcmV0dXJuIG1lcmdlT2JqZWN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCk7XG4gIH0gZWxzZSBpZiAoZmlyc3QudHlwZSA9PT0gXCJMaXZlTWFwXCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZU1hcFwiKSB7XG4gICAgcmV0dXJuIG1lcmdlTWFwU3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCk7XG4gIH0gZWxzZSBpZiAoZmlyc3QudHlwZSA9PT0gXCJMaXZlTGlzdFwiICYmIHNlY29uZC50eXBlID09PSBcIkxpdmVMaXN0XCIpIHtcbiAgICByZXR1cm4gbWVyZ2VMaXN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCk7XG4gIH0gZWxzZSB7XG4gIH1cbiAgcmV0dXJuIHNlY29uZDtcbn1cbmZ1bmN0aW9uIGlzUGxhaW4odmFsdWUpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpO1xufVxuZnVuY3Rpb24gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHZhbHVlLCBwYXRoID0gXCJcIikge1xuICBpZiAoIWlzUGxhaW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogcGF0aCB8fCBcInJvb3RcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgbmVzdGVkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgIGNvbnN0IG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xuICAgIGlmICghaXNQbGFpbihuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IG5lc3RlZFBhdGgsXG4gICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3Qgbm9uU2VyaWFsaXphYmxlTmVzdGVkVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoXG4gICAgICAgIG5lc3RlZFZhbHVlLFxuICAgICAgICBuZXN0ZWRQYXRoXG4gICAgICApO1xuICAgICAgaWYgKG5vblNlcmlhbGl6YWJsZU5lc3RlZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBub25TZXJpYWxpemFibGVOZXN0ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzcmMvbGliL2RlYnVnLnRzXG5mdW5jdGlvbiBjYXB0dXJlU3RhY2tUcmFjZShtc2csIHRyYWNlUm9vdCkge1xuICBjb25zdCBlcnJvckxpa2UgPSB7IG5hbWU6IG1zZyB9O1xuICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yTGlrZSwgdHJhY2VSb290KTtcbiAgcmV0dXJuIGVycm9yTGlrZS5zdGFjaztcbn1cblxuLy8gc3JjL2xpYi9Kc29uLnRzXG5mdW5jdGlvbiBpc0pzb25TY2FsYXIoZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gbnVsbCB8fCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgZGF0YSA9PT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBpc0pzb25BcnJheShkYXRhKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRhdGEpO1xufVxuZnVuY3Rpb24gaXNKc29uT2JqZWN0KGRhdGEpIHtcbiAgcmV0dXJuICFpc0pzb25TY2FsYXIoZGF0YSkgJiYgIWlzSnNvbkFycmF5KGRhdGEpO1xufVxuXG4vLyBzcmMvcHJvdG9jb2wvQ2xpZW50TXNnLnRzXG52YXIgQ2xpZW50TXNnQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKENsaWVudE1zZ0NvZGUyKSA9PiB7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiVVBEQVRFX1BSRVNFTkNFXCJdID0gMTAwXSA9IFwiVVBEQVRFX1BSRVNFTkNFXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiQlJPQURDQVNUX0VWRU5UXCJdID0gMTAzXSA9IFwiQlJPQURDQVNUX0VWRU5UXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiRkVUQ0hfU1RPUkFHRVwiXSA9IDIwMF0gPSBcIkZFVENIX1NUT1JBR0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJVUERBVEVfU1RPUkFHRVwiXSA9IDIwMV0gPSBcIlVQREFURV9TVE9SQUdFXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiRkVUQ0hfWURPQ1wiXSA9IDMwMF0gPSBcIkZFVENIX1lET0NcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJVUERBVEVfWURPQ1wiXSA9IDMwMV0gPSBcIlVQREFURV9ZRE9DXCI7XG4gIHJldHVybiBDbGllbnRNc2dDb2RlMjtcbn0pKENsaWVudE1zZ0NvZGUgfHwge30pO1xuXG4vLyBzcmMvcmVmcy9JbW11dGFibGVSZWYudHNcbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgcGF0Y2gpIHtcbiAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgY29uc3QgbmV3VmFsdWUgPSB7IC4uLnRhcmdldCB9O1xuICBPYmplY3Qua2V5cyhwYXRjaCkuZm9yRWFjaCgoaykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGs7XG4gICAgY29uc3QgdmFsID0gcGF0Y2hba2V5XTtcbiAgICBpZiAobmV3VmFsdWVba2V5XSAhPT0gdmFsKSB7XG4gICAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVsZXRlIG5ld1ZhbHVlW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZVtrZXldID0gdmFsO1xuICAgICAgfVxuICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHVwZGF0ZWQgPyBuZXdWYWx1ZSA6IHRhcmdldDtcbn1cbnZhciBJbW11dGFibGVSZWYgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2V2ID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIH1cbiAgZ2V0IGRpZEludmFsaWRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V2Lm9ic2VydmFibGU7XG4gIH1cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fY2FjaGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9ldi5ub3RpZnkoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlID8/ICh0aGlzLl9jYWNoZSA9IHRoaXMuX3RvSW1tdXRhYmxlKCkpO1xuICB9XG59O1xuXG4vLyBzcmMvcmVmcy9PdGhlcnNSZWYudHNcbmZ1bmN0aW9uIG1ha2VVc2VyKGNvbm4sIHByZXNlbmNlKSB7XG4gIGNvbnN0IHsgY29ubmVjdGlvbklkLCBpZCwgaW5mbyB9ID0gY29ubjtcbiAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2UoY29ubi5zY29wZXMpO1xuICByZXR1cm4gZnJlZXplKFxuICAgIGNvbXBhY3RPYmplY3Qoe1xuICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgaWQsXG4gICAgICBpbmZvLFxuICAgICAgY2FuV3JpdGUsXG4gICAgICBjYW5Db21tZW50OiBjYW5Db21tZW50KGNvbm4uc2NvcGVzKSxcbiAgICAgIGlzUmVhZE9ubHk6ICFjYW5Xcml0ZSxcbiAgICAgIC8vIERlcHJlY2F0ZWQsIGtlcHQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHlcbiAgICAgIHByZXNlbmNlXG4gICAgfSlcbiAgKTtcbn1cbnZhciBPdGhlcnNSZWYgPSBjbGFzcyBleHRlbmRzIEltbXV0YWJsZVJlZiB7XG4gIC8vXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3ByZXNlbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fdXNlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGNvbm5lY3Rpb25JZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25zLmtleXMoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCB1c2VycyA9IGNvbXBhY3QoXG4gICAgICBBcnJheS5mcm9tKHRoaXMuX3ByZXNlbmNlcy5rZXlzKCkpLm1hcChcbiAgICAgICAgKGNvbm5lY3Rpb25JZCkgPT4gdGhpcy5nZXRVc2VyKE51bWJlcihjb25uZWN0aW9uSWQpKVxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuIHVzZXJzO1xuICB9XG4gIGNsZWFyT3RoZXJzKCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9wcmVzZW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3VzZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9nZXRVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGNvbnN0IGNvbm4gPSB0aGlzLl9jb25uZWN0aW9ucy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICBjb25zdCBwcmVzZW5jZSA9IHRoaXMuX3ByZXNlbmNlcy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICBpZiAoY29ubiAhPT0gdm9pZCAwICYmIHByZXNlbmNlICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBtYWtlVXNlcihjb25uLCBwcmVzZW5jZSk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgZ2V0VXNlcihjb25uZWN0aW9uSWQpIHtcbiAgICBjb25zdCBjYWNoZWRVc2VyID0gdGhpcy5fdXNlcnMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNhY2hlZFVzZXIpIHtcbiAgICAgIHJldHVybiBjYWNoZWRVc2VyO1xuICAgIH1cbiAgICBjb25zdCBjb21wdXRlZFVzZXIgPSB0aGlzLl9nZXRVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNvbXB1dGVkVXNlcikge1xuICAgICAgdGhpcy5fdXNlcnMuc2V0KGNvbm5lY3Rpb25JZCwgY29tcHV0ZWRVc2VyKTtcbiAgICAgIHJldHVybiBjb21wdXRlZFVzZXI7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJzLmhhcyhjb25uZWN0aW9uSWQpKSB7XG4gICAgICB0aGlzLl91c2Vycy5kZWxldGUoY29ubmVjdGlvbklkKTtcbiAgICB9XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlY29yZHMgYSBrbm93biBjb25uZWN0aW9uLiBUaGlzIHJlY29yZHMgdGhlIGNvbm5lY3Rpb24gSUQgYW5kIHRoZVxuICAgKiBhc3NvY2lhdGVkIG1ldGFkYXRhLlxuICAgKi9cbiAgc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQsIG1ldGFVc2VySWQsIG1ldGFVc2VySW5mbywgc2NvcGVzKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMuc2V0KFxuICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgZnJlZXplKHtcbiAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICBpZDogbWV0YVVzZXJJZCxcbiAgICAgICAgaW5mbzogbWV0YVVzZXJJbmZvLFxuICAgICAgICBzY29wZXNcbiAgICAgIH0pXG4gICAgKTtcbiAgICBpZiAodGhpcy5fcHJlc2VuY2VzLmhhcyhjb25uZWN0aW9uSWQpKSB7XG4gICAgICB0aGlzLl9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhIGtub3duIGNvbm5lY3Rpb25JZC4gUmVtb3ZlcyBib3RoIHRoZSBjb25uZWN0aW9uJ3MgbWV0YWRhdGEgYW5kXG4gICAqIHRoZSBwcmVzZW5jZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIHJlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbklkKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMuZGVsZXRlKGNvbm5lY3Rpb25JZCk7XG4gICAgdGhpcy5fcHJlc2VuY2VzLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgIHRoaXMuX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3JlcyBhIG5ldyB1c2VyIGZyb20gYSBmdWxsIHByZXNlbmNlIHVwZGF0ZS4gSWYgdGhlIHVzZXIgYWxyZWFkeSBleGlzdHMsXG4gICAqIGl0cyBrbm93biBwcmVzZW5jZSBkYXRhIGlzIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgc2V0T3RoZXIoY29ubmVjdGlvbklkLCBwcmVzZW5jZSkge1xuICAgIHRoaXMuX3ByZXNlbmNlcy5zZXQoY29ubmVjdGlvbklkLCBmcmVlemUoY29tcGFjdE9iamVjdChwcmVzZW5jZSkpKTtcbiAgICBpZiAodGhpcy5fY29ubmVjdGlvbnMuaGFzKGNvbm5lY3Rpb25JZCkpIHtcbiAgICAgIHRoaXMuX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXRjaGVzIHRoZSBwcmVzZW5jZSBkYXRhIGZvciBhbiBleGlzdGluZyBcIm90aGVyXCIuIElmIHdlIGRvbid0IGtub3cgdGhlXG4gICAqIGluaXRpYWwgcHJlc2VuY2UgZGF0YSBmb3IgdGhpcyB1c2VyIHlldCwgZGlzY2FyZCB0aGlzIHBhdGNoIGFuZCBhd2FpdCB0aGVcbiAgICogZnVsbCAuc2V0T3RoZXIoKSBjYWxsIGZpcnN0LlxuICAgKi9cbiAgcGF0Y2hPdGhlcihjb25uZWN0aW9uSWQsIHBhdGNoKSB7XG4gICAgY29uc3Qgb2xkUHJlc2VuY2UgPSB0aGlzLl9wcmVzZW5jZXMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKG9sZFByZXNlbmNlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV3UHJlc2VuY2UgPSBtZXJnZShvbGRQcmVzZW5jZSwgcGF0Y2gpO1xuICAgIGlmIChvbGRQcmVzZW5jZSAhPT0gbmV3UHJlc2VuY2UpIHtcbiAgICAgIHRoaXMuX3ByZXNlbmNlcy5zZXQoY29ubmVjdGlvbklkLCBmcmVlemUobmV3UHJlc2VuY2UpKTtcbiAgICAgIHRoaXMuX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcmVmcy9QYXRjaGFibGVSZWYudHNcbnZhciBQYXRjaGFibGVSZWYgPSBjbGFzcyBleHRlbmRzIEltbXV0YWJsZVJlZiB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RhdGEgPSBmcmVlemUoY29tcGFjdE9iamVjdChkYXRhKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgLyoqXG4gICAqIFBhdGNoZXMgdGhlIGN1cnJlbnQgb2JqZWN0LlxuICAgKi9cbiAgcGF0Y2gocGF0Y2gpIHtcbiAgICBjb25zdCBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBuZXdEYXRhID0gbWVyZ2Uob2xkRGF0YSwgcGF0Y2gpO1xuICAgIGlmIChvbGREYXRhICE9PSBuZXdEYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gZnJlZXplKG5ld0RhdGEpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcmVmcy9WYWx1ZVJlZi50c1xudmFyIFZhbHVlUmVmID0gY2xhc3MgZXh0ZW5kcyBJbW11dGFibGVSZWYge1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsVmFsdWUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3ZhbHVlID0gZnJlZXplKGluaXRpYWxWYWx1ZSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldChuZXdWYWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlID0gZnJlZXplKG5ld1ZhbHVlKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxufTtcbnZhciBEZXJpdmVkUmVmID0gY2xhc3MgZXh0ZW5kcyBJbW11dGFibGVSZWYge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1GbiA9IGFyZ3MucG9wKCk7XG4gICAgY29uc3Qgb3RoZXJSZWZzID0gYXJncztcbiAgICB0aGlzLl9yZWZzID0gb3RoZXJSZWZzO1xuICAgIHRoaXMuX3JlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICByZWYuZGlkSW52YWxpZGF0ZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5pbnZhbGlkYXRlKCkpO1xuICAgIH0pO1xuICAgIHRoaXMuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybUZuO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm0oXG4gICAgICAuLi50aGlzLl9yZWZzLm1hcCgocmVmKSA9PiByZWYuY3VycmVudClcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvcm9vbS50c1xudmFyIE1BWF9TT0NLRVRfTUVTU0FHRV9TSVpFID0gMTAyNCAqIDEwMjQgLSAxMDI0O1xuZnVuY3Rpb24gbWFrZUlkRmFjdG9yeShjb25uZWN0aW9uSWQpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgcmV0dXJuICgpID0+IGAke2Nvbm5lY3Rpb25JZH06JHtjb3VudCsrfWA7XG59XG5mdW5jdGlvbiB1c2VyVG9UcmVlTm9kZShrZXksIHVzZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlVzZXJcIixcbiAgICBpZDogYCR7dXNlci5jb25uZWN0aW9uSWR9YCxcbiAgICBrZXksXG4gICAgcGF5bG9hZDogdXNlclxuICB9O1xufVxuZnVuY3Rpb24gaW5zdGFsbEJhY2tncm91bmRUYWJTcHkoKSB7XG4gIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICBjb25zdCBpbkJhY2tncm91bmRTaW5jZSA9IHsgY3VycmVudDogbnVsbCB9O1xuICBmdW5jdGlvbiBvblZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgaWYgKGRvYz8udmlzaWJpbGl0eVN0YXRlID09PSBcImhpZGRlblwiKSB7XG4gICAgICBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID0gaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCA/PyBEYXRlLm5vdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZG9jPy5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICBjb25zdCB1bnN1YiA9ICgpID0+IHtcbiAgICBkb2M/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIH07XG4gIHJldHVybiBbaW5CYWNrZ3JvdW5kU2luY2UsIHVuc3ViXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb20ob3B0aW9ucywgY29uZmlnKSB7XG4gIGNvbnN0IGluaXRpYWxQcmVzZW5jZSA9IHR5cGVvZiBvcHRpb25zLmluaXRpYWxQcmVzZW5jZSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5pbml0aWFsUHJlc2VuY2UoY29uZmlnLnJvb21JZCkgOiBvcHRpb25zLmluaXRpYWxQcmVzZW5jZTtcbiAgY29uc3QgaW5pdGlhbFN0b3JhZ2UgPSB0eXBlb2Ygb3B0aW9ucy5pbml0aWFsU3RvcmFnZSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5pbml0aWFsU3RvcmFnZShjb25maWcucm9vbUlkKSA6IG9wdGlvbnMuaW5pdGlhbFN0b3JhZ2U7XG4gIGNvbnN0IFtpbkJhY2tncm91bmRTaW5jZSwgdW5pbnN0YWxsQmdUYWJTcHldID0gaW5zdGFsbEJhY2tncm91bmRUYWJTcHkoKTtcbiAgY29uc3QgZGVsZWdhdGVzID0ge1xuICAgIC4uLmNvbmZpZy5kZWxlZ2F0ZXMsXG4gICAgLy8gQSBjb25uZWN0aW9uIGlzIGFsbG93ZWQgdG8gZ28gaW50byBcInpvbWJpZSBzdGF0ZVwiIG9ubHkgaWYgYWxsIG9mIHRoZVxuICAgIC8vIGZvbGxvd2luZyBjb25kaXRpb25zIGFwcGx5OlxuICAgIC8vXG4gICAgLy8gLSBUaGUgYGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0YCBjbGllbnQgb3B0aW9uIGlzIGNvbmZpZ3VyZWRcbiAgICAvLyAtIFRoZSBicm93c2VyIHdpbmRvdyBoYXMgYmVlbiBpbiB0aGUgYmFja2dyb3VuZCBmb3IgYXQgbGVhc3RcbiAgICAvLyAgIGBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dGAgbWlsbGlzZWNvbmRzXG4gICAgLy8gLSBUaGVyZSBhcmUgbm8gcGVuZGluZyBjaGFuZ2VzXG4gICAgLy9cbiAgICBjYW5ab21iaWUoKSB7XG4gICAgICByZXR1cm4gY29uZmlnLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0ICE9PSB2b2lkIDAgJiYgaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCAhPT0gbnVsbCAmJiBEYXRlLm5vdygpID4gaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCArIGNvbmZpZy5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCAmJiBnZXRTdG9yYWdlU3RhdHVzKCkgIT09IFwic3luY2hyb25pemluZ1wiO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbWFuYWdlZFNvY2tldCA9IG5ldyBNYW5hZ2VkU29ja2V0KFxuICAgIGRlbGVnYXRlcyxcbiAgICBjb25maWcuZW5hYmxlRGVidWdMb2dnaW5nXG4gICk7XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgYnVmZmVyOiB7XG4gICAgICBmbHVzaFRpbWVySUQ6IHZvaWQgMCxcbiAgICAgIGxhc3RGbHVzaGVkQXQ6IDAsXG4gICAgICBwcmVzZW5jZVVwZGF0ZXM6IChcbiAgICAgICAgLy8gUXVldWUgdXAgdGhlIGluaXRpYWwgcHJlc2VuY2UgbWVzc2FnZSBhcyBhIEZ1bGwgUHJlc2VuY2XihKIgdXBkYXRlXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImZ1bGxcIixcbiAgICAgICAgICBkYXRhOiBpbml0aWFsUHJlc2VuY2VcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgIHN0b3JhZ2VPcGVyYXRpb25zOiBbXVxuICAgIH0sXG4gICAgc3RhdGljU2Vzc2lvbkluZm86IG5ldyBWYWx1ZVJlZihudWxsKSxcbiAgICBkeW5hbWljU2Vzc2lvbkluZm86IG5ldyBWYWx1ZVJlZihudWxsKSxcbiAgICBteVByZXNlbmNlOiBuZXcgUGF0Y2hhYmxlUmVmKGluaXRpYWxQcmVzZW5jZSksXG4gICAgb3RoZXJzOiBuZXcgT3RoZXJzUmVmKCksXG4gICAgaW5pdGlhbFN0b3JhZ2UsXG4gICAgaWRGYWN0b3J5OiBudWxsLFxuICAgIC8vIFN0b3JhZ2VcbiAgICBjbG9jazogMCxcbiAgICBvcENsb2NrOiAwLFxuICAgIG5vZGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIHJvb3Q6IHZvaWQgMCxcbiAgICB1bmRvU3RhY2s6IFtdLFxuICAgIHJlZG9TdGFjazogW10sXG4gICAgcGF1c2VkSGlzdG9yeTogbnVsbCxcbiAgICBhY3RpdmVCYXRjaDogbnVsbCxcbiAgICB1bmFja25vd2xlZGdlZE9wczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAvLyBEZWJ1Z1xuICAgIG9wU3RhY2tUcmFjZXM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkgOiB2b2lkIDBcbiAgfTtcbiAgY29uc3QgZG9Ob3RCYXRjaFVwZGF0ZXMgPSAoY2IpID0+IGNiKCk7XG4gIGNvbnN0IGJhdGNoVXBkYXRlcyA9IGNvbmZpZy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA/PyBkb05vdEJhdGNoVXBkYXRlcztcbiAgbGV0IGxhc3RUb2tlbktleTtcbiAgZnVuY3Rpb24gb25TdGF0dXNEaWRDaGFuZ2UobmV3U3RhdHVzKSB7XG4gICAgY29uc3QgYXV0aFZhbHVlID0gbWFuYWdlZFNvY2tldC5hdXRoVmFsdWU7XG4gICAgaWYgKGF1dGhWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgdG9rZW5LZXkgPSBhdXRoVmFsdWUudHlwZSA9PT0gXCJzZWNyZXRcIiA/IGF1dGhWYWx1ZS50b2tlbi5yYXcgOiBhdXRoVmFsdWUucHVibGljQXBpS2V5O1xuICAgICAgaWYgKHRva2VuS2V5ICE9PSBsYXN0VG9rZW5LZXkpIHtcbiAgICAgICAgbGFzdFRva2VuS2V5ID0gdG9rZW5LZXk7XG4gICAgICAgIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJzZWNyZXRcIikge1xuICAgICAgICAgIGNvbnN0IHRva2VuID0gYXV0aFZhbHVlLnRva2VuLnBhcnNlZDtcbiAgICAgICAgICBjb250ZXh0LnN0YXRpY1Nlc3Npb25JbmZvLnNldCh7XG4gICAgICAgICAgICB1c2VySWQ6IHRva2VuLmsgPT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8gPyB0b2tlbi5pZCA6IHRva2VuLnVpZCxcbiAgICAgICAgICAgIHVzZXJJbmZvOiB0b2tlbi5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovID8gdG9rZW4uaW5mbyA6IHRva2VuLnVpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5zdGF0aWNTZXNzaW9uSW5mby5zZXQoe1xuICAgICAgICAgICAgdXNlcklkOiB2b2lkIDAsXG4gICAgICAgICAgICB1c2VySW5mbzogdm9pZCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGV2ZW50SHViLnN0YXR1cy5ub3RpZnkobmV3U3RhdHVzKTtcbiAgICAgIG5vdGlmeVNlbGZDaGFuZ2VkKGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICB9KTtcbiAgfVxuICBsZXQgX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZDtcbiAgbGV0IF9oYXNMb3N0Q29ubmVjdGlvbiA9IGZhbHNlO1xuICBmdW5jdGlvbiBoYW5kbGVDb25uZWN0aW9uTG9zc0V2ZW50KG5ld1N0YXR1cykge1xuICAgIGlmIChuZXdTdGF0dXMgPT09IFwicmVjb25uZWN0aW5nXCIpIHtcbiAgICAgIF9jb25uZWN0aW9uTG9zc1RpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5ub3RpZnkoXCJsb3N0XCIpO1xuICAgICAgICAgIF9oYXNMb3N0Q29ubmVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgY29udGV4dC5vdGhlcnMuY2xlYXJPdGhlcnMoKTtcbiAgICAgICAgICBub3RpZnkoeyBvdGhlcnM6IFt7IHR5cGU6IFwicmVzZXRcIiB9XSB9LCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgY29uZmlnLmxvc3RDb25uZWN0aW9uVGltZW91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyVGltZW91dChfY29ubmVjdGlvbkxvc3NUaW1lcklkKTtcbiAgICAgIGlmIChfaGFzTG9zdENvbm5lY3Rpb24pIHtcbiAgICAgICAgaWYgKG5ld1N0YXR1cyA9PT0gXCJkaXNjb25uZWN0ZWRcIikge1xuICAgICAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgICBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5ub3RpZnkoXCJmYWlsZWRcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICAgIGV2ZW50SHViLmxvc3RDb25uZWN0aW9uLm5vdGlmeShcInJlc3RvcmVkXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIF9oYXNMb3N0Q29ubmVjdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkRpZENvbm5lY3QoKSB7XG4gICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID0ge1xuICAgICAgdHlwZTogXCJmdWxsXCIsXG4gICAgICBkYXRhOiAoXG4gICAgICAgIC8vIEJlY2F1c2UgY29udGV4dC5tZS5jdXJyZW50IGlzIGEgcmVhZG9ubHkgb2JqZWN0LCB3ZSdsbCBoYXZlIHRvXG4gICAgICAgIC8vIG1ha2UgYSBjb3B5IGhlcmUuIE90aGVyd2lzZSwgdHlwZSBlcnJvcnMgaGFwcGVuIGxhdGVyIHdoZW5cbiAgICAgICAgLy8gXCJwYXRjaGluZ1wiIG15IHByZXNlbmNlLlxuICAgICAgICB7IC4uLmNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50IH1cbiAgICAgIClcbiAgICB9O1xuICAgIGlmIChfZ2V0U3RvcmFnZSQgIT09IG51bGwpIHtcbiAgICAgIHJlZnJlc2hTdG9yYWdlKHsgZmx1c2g6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIG9uRGlkRGlzY29ubmVjdCgpIHtcbiAgICBjbGVhclRpbWVvdXQoY29udGV4dC5idWZmZXIuZmx1c2hUaW1lcklEKTtcbiAgfVxuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5vbk1lc3NhZ2Uuc3Vic2NyaWJlKGhhbmRsZVNlcnZlck1lc3NhZ2UpO1xuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5zdGF0dXNEaWRDaGFuZ2Uuc3Vic2NyaWJlKG9uU3RhdHVzRGlkQ2hhbmdlKTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuc3RhdHVzRGlkQ2hhbmdlLnN1YnNjcmliZShoYW5kbGVDb25uZWN0aW9uTG9zc0V2ZW50KTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuZGlkQ29ubmVjdC5zdWJzY3JpYmUob25EaWRDb25uZWN0KTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuZGlkRGlzY29ubmVjdC5zdWJzY3JpYmUob25EaWREaXNjb25uZWN0KTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMub25MaXZlYmxvY2tzRXJyb3Iuc3Vic2NyaWJlKChlcnIpID0+IHtcbiAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBlcnJvcjIoXG4gICAgICAgICAgYENvbm5lY3Rpb24gdG8gd2Vic29ja2V0IHNlcnZlciBjbG9zZWQuIFJlYXNvbjogJHtlcnIubWVzc2FnZX0gKGNvZGU6ICR7ZXJyLmNvZGV9KS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBldmVudEh1Yi5lcnJvci5ub3RpZnkoZXJyKTtcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IHBvb2wgPSB7XG4gICAgcm9vbUlkOiBjb25maWcucm9vbUlkLFxuICAgIGdldE5vZGU6IChpZCkgPT4gY29udGV4dC5ub2Rlcy5nZXQoaWQpLFxuICAgIGFkZE5vZGU6IChpZCwgbm9kZSkgPT4gdm9pZCBjb250ZXh0Lm5vZGVzLnNldChpZCwgbm9kZSksXG4gICAgZGVsZXRlTm9kZTogKGlkKSA9PiB2b2lkIGNvbnRleHQubm9kZXMuZGVsZXRlKGlkKSxcbiAgICBnZW5lcmF0ZUlkOiAoKSA9PiBgJHtnZXRDb25uZWN0aW9uSWQoKX06JHtjb250ZXh0LmNsb2NrKyt9YCxcbiAgICBnZW5lcmF0ZU9wSWQ6ICgpID0+IGAke2dldENvbm5lY3Rpb25JZCgpfToke2NvbnRleHQub3BDbG9jaysrfWAsXG4gICAgZGlzcGF0Y2gob3BzLCByZXZlcnNlLCBzdG9yYWdlVXBkYXRlcykge1xuICAgICAgY29uc3QgYWN0aXZlQmF0Y2ggPSBjb250ZXh0LmFjdGl2ZUJhdGNoO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zdCBzdGFja1RyYWNlID0gY2FwdHVyZVN0YWNrVHJhY2UoXCJTdG9yYWdlIG11dGF0aW9uXCIsIHRoaXMuZGlzcGF0Y2gpO1xuICAgICAgICBpZiAoc3RhY2tUcmFjZSkge1xuICAgICAgICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICAgICAgICBpZiAob3Aub3BJZCkge1xuICAgICAgICAgICAgICBubihjb250ZXh0Lm9wU3RhY2tUcmFjZXMpLnNldChvcC5vcElkLCBzdGFja1RyYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhY3RpdmVCYXRjaCkge1xuICAgICAgICBhY3RpdmVCYXRjaC5vcHMucHVzaCguLi5vcHMpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdG9yYWdlVXBkYXRlcykge1xuICAgICAgICAgIGFjdGl2ZUJhdGNoLnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgbWVyZ2VTdG9yYWdlVXBkYXRlcyhcbiAgICAgICAgICAgICAgYWN0aXZlQmF0Y2gudXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5nZXQoa2V5KSxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZUJhdGNoLnJldmVyc2VPcHMudW5zaGlmdCguLi5yZXZlcnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgYWRkVG9VbmRvU3RhY2socmV2ZXJzZSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgICAgZGlzcGF0Y2hPcHMob3BzKTtcbiAgICAgICAgICBub3RpZnkoeyBzdG9yYWdlVXBkYXRlcyB9LCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGU6ICgpID0+IHtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLmN1cnJlbnQ/LnNjb3BlcztcbiAgICAgIGlmIChzY29wZXMgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjYW5Xcml0ZSA9IGNhbldyaXRlU3RvcmFnZShzY29wZXMpO1xuICAgICAgaWYgKCFjYW5Xcml0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDYW5ub3Qgd3JpdGUgdG8gc3RvcmFnZSB3aXRoIGEgcmVhZCBvbmx5IHVzZXIsIHBsZWFzZSBlbnN1cmUgdGhlIHVzZXIgaGFzIHdyaXRlIHBlcm1pc3Npb25zXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IGV2ZW50SHViID0ge1xuICAgIGNvbm5lY3Rpb246IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIC8vIE9sZC9kZXByZWNhdGVkIEFQSVxuICAgIHN0YXR1czogbWFrZUV2ZW50U291cmNlKCksXG4gICAgLy8gTmV3L3JlY29tbWVuZGVkIEFQSVxuICAgIGxvc3RDb25uZWN0aW9uOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBjdXN0b21FdmVudDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgc2VsZjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgbXlQcmVzZW5jZTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgb3RoZXJzOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBlcnJvcjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgc3RvcmFnZTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgaGlzdG9yeTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgc3RvcmFnZURpZExvYWQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VTdGF0dXM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHlkb2M6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGNvbW1lbnRzOiBtYWtlRXZlbnRTb3VyY2UoKVxuICB9O1xuICBhc3luYyBmdW5jdGlvbiBzdHJlYW1GZXRjaChhdXRoVG9rZW5PclB1YmxpY0FwaUtleSwgcm9vbUlkKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChcbiAgICAgIGAvdjIvYy9yb29tcy8ke2VuY29kZVVSSUNvbXBvbmVudChyb29tSWQpfS9zdG9yYWdlYCxcbiAgICAgIGNvbmZpZy5iYXNlVXJsXG4gICAgKS50b1N0cmluZygpO1xuICAgIGNvbnN0IGZldGNoZXIgPSBjb25maWcucG9seWZpbGxzPy5mZXRjaCB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZldGNoO1xuICAgIHJldHVybiBmZXRjaGVyKHVybC50b1N0cmluZygpLCB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YXV0aFRva2VuT3JQdWJsaWNBcGlLZXl9YFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGh0dHBQb3N0VG9Sb29tKGVuZHBvaW50LCBib2R5KSB7XG4gICAgaWYgKCFtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGF1dGhvcml6ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IGF1dGhUb2tlbk9yUHVibGljQXBpS2V5ID0gbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIiA/IG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLnB1YmxpY0FwaUtleSA6IG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLnRva2VuLnJhdztcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKFxuICAgICAgYC92Mi9jL3Jvb21zLyR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5yb29tSWQpfSR7ZW5kcG9pbnR9YCxcbiAgICAgIGNvbmZpZy5iYXNlVXJsXG4gICAgKS50b1N0cmluZygpO1xuICAgIGNvbnN0IGZldGNoZXIgPSBjb25maWcucG9seWZpbGxzPy5mZXRjaCB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZldGNoO1xuICAgIHJldHVybiBmZXRjaGVyKHVybCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthdXRoVG9rZW5PclB1YmxpY0FwaUtleX1gXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzZW5kTWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkUGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2VzKTtcbiAgICBjb25zdCBub25jZSA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLmN1cnJlbnQ/Lm5vbmNlO1xuICAgIGlmIChjb25maWcudW5zdGFibGVfZmFsbGJhY2tUb0hUVFAgJiYgbm9uY2UpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc2VyaWFsaXplZFBheWxvYWQpLmxlbmd0aDtcbiAgICAgIGlmIChzaXplID4gTUFYX1NPQ0tFVF9NRVNTQUdFX1NJWkUpIHtcbiAgICAgICAgdm9pZCBodHRwUG9zdFRvUm9vbShcIi9zZW5kLW1lc3NhZ2VcIiwgeyBub25jZSwgbWVzc2FnZXMgfSkudGhlbihcbiAgICAgICAgICAocmVzcCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXNwLm9rICYmIHJlc3Auc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgICAgICAgbWFuYWdlZFNvY2tldC5yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXNzYWdlIHdhcyB0b28gbGFyZ2UgZm9yIHdlYnNvY2tldHMgYW5kIHNlbnQgb3ZlciBIVFRQIGluc3RlYWRcIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG1hbmFnZWRTb2NrZXQuc2VuZChzZXJpYWxpemVkUGF5bG9hZCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IG5ldyBEZXJpdmVkUmVmKFxuICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm8sXG4gICAgY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm8sXG4gICAgY29udGV4dC5teVByZXNlbmNlLFxuICAgIChzdGF0aWNTZXNzaW9uLCBkeW5hbWljU2Vzc2lvbiwgbXlQcmVzZW5jZSkgPT4ge1xuICAgICAgaWYgKHN0YXRpY1Nlc3Npb24gPT09IG51bGwgfHwgZHluYW1pY1Nlc3Npb24gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjYW5Xcml0ZSA9IGNhbldyaXRlU3RvcmFnZShkeW5hbWljU2Vzc2lvbi5zY29wZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbm5lY3Rpb25JZDogZHluYW1pY1Nlc3Npb24uYWN0b3IsXG4gICAgICAgICAgaWQ6IHN0YXRpY1Nlc3Npb24udXNlcklkLFxuICAgICAgICAgIGluZm86IHN0YXRpY1Nlc3Npb24udXNlckluZm8sXG4gICAgICAgICAgcHJlc2VuY2U6IG15UHJlc2VuY2UsXG4gICAgICAgICAgY2FuV3JpdGUsXG4gICAgICAgICAgY2FuQ29tbWVudDogY2FuQ29tbWVudChkeW5hbWljU2Vzc2lvbi5zY29wZXMpLFxuICAgICAgICAgIGlzUmVhZE9ubHk6ICFjYW5Xcml0ZVxuICAgICAgICAgIC8vIERlcHJlY2F0ZWQsIGtlcHQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIGxldCBfbGFzdFNlbGY7XG4gIGZ1bmN0aW9uIG5vdGlmeVNlbGZDaGFuZ2VkKGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGNvbnN0IGN1cnJTZWxmID0gc2VsZi5jdXJyZW50O1xuICAgIGlmIChjdXJyU2VsZiAhPT0gbnVsbCAmJiBjdXJyU2VsZiAhPT0gX2xhc3RTZWxmKSB7XG4gICAgICBiYXRjaGVkVXBkYXRlc1dyYXBwZXIoKCkgPT4ge1xuICAgICAgICBldmVudEh1Yi5zZWxmLm5vdGlmeShjdXJyU2VsZik7XG4gICAgICB9KTtcbiAgICAgIF9sYXN0U2VsZiA9IGN1cnJTZWxmO1xuICAgIH1cbiAgfVxuICBjb25zdCBzZWxmQXNUcmVlTm9kZSA9IG5ldyBEZXJpdmVkUmVmKFxuICAgIHNlbGYsXG4gICAgKG1lKSA9PiBtZSAhPT0gbnVsbCA/IHVzZXJUb1RyZWVOb2RlKFwiTWVcIiwgbWUpIDogbnVsbFxuICApO1xuICBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZVJvb3RGcm9tTWVzc2FnZShtZXNzYWdlLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAobWVzc2FnZS5pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIGVycm9yOiBjYW5ub3QgbG9hZCBzdG9yYWdlIHdpdGhvdXQgaXRlbXNcIik7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LnJvb3QgIT09IHZvaWQgMCkge1xuICAgICAgdXBkYXRlUm9vdChtZXNzYWdlLml0ZW1zLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnJvb3QgPSBMaXZlT2JqZWN0Ll9mcm9tSXRlbXMobWVzc2FnZS5pdGVtcywgcG9vbCk7XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrU2l6ZUJlZm9yZSA9IGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjb250ZXh0LmluaXRpYWxTdG9yYWdlKSB7XG4gICAgICBpZiAoY29udGV4dC5yb290LmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGV4dC5yb290LnNldChrZXksIGNsb25lTHNvbihjb250ZXh0LmluaXRpYWxTdG9yYWdlW2tleV0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29udGV4dC51bmRvU3RhY2subGVuZ3RoID0gc3RhY2tTaXplQmVmb3JlO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVJvb3QoaXRlbXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChjb250ZXh0LnJvb3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50SXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2lkLCBub2RlXSBvZiBjb250ZXh0Lm5vZGVzKSB7XG4gICAgICBjdXJyZW50SXRlbXMuc2V0KGlkLCBub2RlLl9zZXJpYWxpemUoKSk7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IGdldFRyZWVzRGlmZk9wZXJhdGlvbnMoY3VycmVudEl0ZW1zLCBuZXcgTWFwKGl0ZW1zKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMob3BzLCBmYWxzZSk7XG4gICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICB9XG4gIGZ1bmN0aW9uIF9hZGRUb1JlYWxVbmRvU3RhY2soaGlzdG9yeU9wcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA+PSA1MCkge1xuICAgICAgY29udGV4dC51bmRvU3RhY2suc2hpZnQoKTtcbiAgICB9XG4gICAgY29udGV4dC51bmRvU3RhY2sucHVzaChoaXN0b3J5T3BzKTtcbiAgICBvbkhpc3RvcnlDaGFuZ2UoYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRUb1VuZG9TdGFjayhoaXN0b3J5T3BzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAoY29udGV4dC5wYXVzZWRIaXN0b3J5ICE9PSBudWxsKSB7XG4gICAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkudW5zaGlmdCguLi5oaXN0b3J5T3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2FkZFRvUmVhbFVuZG9TdGFjayhoaXN0b3J5T3BzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBub3RpZnkodXBkYXRlcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSB1cGRhdGVzLnN0b3JhZ2VVcGRhdGVzO1xuICAgIGNvbnN0IG90aGVyc1VwZGF0ZXMgPSB1cGRhdGVzLm90aGVycztcbiAgICBiYXRjaGVkVXBkYXRlc1dyYXBwZXIoKCkgPT4ge1xuICAgICAgaWYgKG90aGVyc1VwZGF0ZXMgIT09IHZvaWQgMCAmJiBvdGhlcnNVcGRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gY29udGV4dC5vdGhlcnMuY3VycmVudDtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBvdGhlcnNVcGRhdGVzKSB7XG4gICAgICAgICAgZXZlbnRIdWIub3RoZXJzLm5vdGlmeSh7IC4uLmV2ZW50LCBvdGhlcnMgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh1cGRhdGVzLnByZXNlbmNlID8/IGZhbHNlKSB7XG4gICAgICAgIG5vdGlmeVNlbGZDaGFuZ2VkKGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgZXZlbnRIdWIubXlQcmVzZW5jZS5ub3RpZnkoY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0b3JhZ2VVcGRhdGVzICE9PSB2b2lkIDAgJiYgc3RvcmFnZVVwZGF0ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgY29uc3QgdXBkYXRlczIgPSBBcnJheS5mcm9tKHN0b3JhZ2VVcGRhdGVzLnZhbHVlcygpKTtcbiAgICAgICAgZXZlbnRIdWIuc3RvcmFnZS5ub3RpZnkodXBkYXRlczIpO1xuICAgICAgfVxuICAgICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldENvbm5lY3Rpb25JZCgpIHtcbiAgICBjb25zdCBpbmZvID0gY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm8uY3VycmVudDtcbiAgICBpZiAoaW5mbykge1xuICAgICAgcmV0dXJuIGluZm8uYWN0b3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW50ZXJuYWwuIFRyaWVkIHRvIGdldCBjb25uZWN0aW9uIGlkIGJ1dCBjb25uZWN0aW9uIHdhcyBuZXZlciBvcGVuXCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5T3BzKHJhd09wcywgaXNMb2NhbCkge1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIHJldmVyc2U6IFtdLFxuICAgICAgc3RvcmFnZVVwZGF0ZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBwcmVzZW5jZTogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZWROb2RlSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBvcHMgPSByYXdPcHMubWFwKChvcCkgPT4ge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIiAmJiAhb3Aub3BJZCkge1xuICAgICAgICByZXR1cm4geyAuLi5vcCwgb3BJZDogcG9vbC5nZW5lcmF0ZU9wSWQoKSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJwcmVzZW5jZVwiKSB7XG4gICAgICAgIGNvbnN0IHJldmVyc2UgPSB7XG4gICAgICAgICAgdHlwZTogXCJwcmVzZW5jZVwiLFxuICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgICAgICByZXZlcnNlLmRhdGFba2V5XSA9IGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50W2tleV07XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5teVByZXNlbmNlLnBhdGNoKG9wLmRhdGEpO1xuICAgICAgICBpZiAoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID0geyB0eXBlOiBcInBhcnRpYWxcIiwgZGF0YTogb3AuZGF0YSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgICAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhW2tleV0gPSBvcC5kYXRhW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5yZXZlcnNlLnVuc2hpZnQocmV2ZXJzZSk7XG4gICAgICAgIG91dHB1dC5wcmVzZW5jZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgc291cmNlO1xuICAgICAgICBpZiAoaXNMb2NhbCkge1xuICAgICAgICAgIHNvdXJjZSA9IDAgLyogVU5ET1JFRE9fUkVDT05ORUNUICovO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG9wSWQgPSBubihvcC5vcElkKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBubihjb250ZXh0Lm9wU3RhY2tUcmFjZXMpLmRlbGV0ZShvcElkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZGVsZXRlZCA9IGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMuZGVsZXRlKG9wSWQpO1xuICAgICAgICAgIHNvdXJjZSA9IGRlbGV0ZWQgPyAyIC8qIEFDSyAqLyA6IDEgLyogUkVNT1RFICovO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcGx5T3BSZXN1bHQgPSBhcHBseU9wKG9wLCBzb3VyY2UpO1xuICAgICAgICBpZiAoYXBwbHlPcFJlc3VsdC5tb2RpZmllZCkge1xuICAgICAgICAgIGNvbnN0IG5vZGVJZCA9IGFwcGx5T3BSZXN1bHQubW9kaWZpZWQubm9kZS5faWQ7XG4gICAgICAgICAgaWYgKCEobm9kZUlkICYmIGNyZWF0ZWROb2RlSWRzLmhhcyhub2RlSWQpKSkge1xuICAgICAgICAgICAgb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICAgICAgbm4oYXBwbHlPcFJlc3VsdC5tb2RpZmllZC5ub2RlLl9pZCksXG4gICAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXMoXG4gICAgICAgICAgICAgICAgb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLmdldChubihhcHBseU9wUmVzdWx0Lm1vZGlmaWVkLm5vZGUuX2lkKSksXG4gICAgICAgICAgICAgICAgYXBwbHlPcFJlc3VsdC5tb2RpZmllZFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb3V0cHV0LnJldmVyc2UudW5zaGlmdCguLi5hcHBseU9wUmVzdWx0LnJldmVyc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3AudHlwZSA9PT0gMiAvKiBDUkVBVEVfTElTVCAqLyB8fCBvcC50eXBlID09PSA3IC8qIENSRUFURV9NQVAgKi8gfHwgb3AudHlwZSA9PT0gNCAvKiBDUkVBVEVfT0JKRUNUICovKSB7XG4gICAgICAgICAgICBjcmVhdGVkTm9kZUlkcy5hZGQobm4ob3AuaWQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wcyxcbiAgICAgIHJldmVyc2U6IG91dHB1dC5yZXZlcnNlLFxuICAgICAgdXBkYXRlczoge1xuICAgICAgICBzdG9yYWdlVXBkYXRlczogb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLFxuICAgICAgICBwcmVzZW5jZTogb3V0cHV0LnByZXNlbmNlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseU9wKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAoaXNBY2tPcChvcCkpIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLzpcbiAgICAgIGNhc2UgMyAvKiBVUERBVEVfT0JKRUNUICovOlxuICAgICAgY2FzZSA1IC8qIERFTEVURV9DUkRUICovOiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBjb250ZXh0Lm5vZGVzLmdldChvcC5pZCk7XG4gICAgICAgIGlmIChub2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5fYXBwbHkob3AsIHNvdXJjZSA9PT0gMCAvKiBVTkRPUkVET19SRUNPTk5FQ1QgKi8pO1xuICAgICAgfVxuICAgICAgY2FzZSAxIC8qIFNFVF9QQVJFTlRfS0VZICovOiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBjb250ZXh0Lm5vZGVzLmdldChvcC5pZCk7XG4gICAgICAgIGlmIChub2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIiAmJiBpc0xpdmVMaXN0KG5vZGUucGFyZW50Lm5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50Lm5vZGUuX3NldENoaWxkS2V5KFxuICAgICAgICAgICAgYXNQb3Mob3AucGFyZW50S2V5KSxcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBzb3VyY2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgICAgY2FzZSA0IC8qIENSRUFURV9PQkpFQ1QgKi86XG4gICAgICBjYXNlIDIgLyogQ1JFQVRFX0xJU1QgKi86XG4gICAgICBjYXNlIDcgLyogQ1JFQVRFX01BUCAqLzpcbiAgICAgIGNhc2UgOCAvKiBDUkVBVEVfUkVHSVNURVIgKi86IHtcbiAgICAgICAgaWYgKG9wLnBhcmVudElkID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gY29udGV4dC5ub2Rlcy5nZXQob3AucGFyZW50SWQpO1xuICAgICAgICBpZiAocGFyZW50Tm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudE5vZGUuX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVQcmVzZW5jZShwYXRjaCwgb3B0aW9uczIpIHtcbiAgICBjb25zdCBvbGRWYWx1ZXMgPSB7fTtcbiAgICBpZiAoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPSB7XG4gICAgICAgIHR5cGU6IFwicGFydGlhbFwiLFxuICAgICAgICBkYXRhOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGF0Y2gpIHtcbiAgICAgIGNvbnN0IG92ZXJyaWRlVmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgaWYgKG92ZXJyaWRlVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhW2tleV0gPSBvdmVycmlkZVZhbHVlO1xuICAgICAgb2xkVmFsdWVzW2tleV0gPSBjb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudFtrZXldO1xuICAgIH1cbiAgICBjb250ZXh0Lm15UHJlc2VuY2UucGF0Y2gocGF0Y2gpO1xuICAgIGlmIChjb250ZXh0LmFjdGl2ZUJhdGNoKSB7XG4gICAgICBpZiAob3B0aW9uczI/LmFkZFRvSGlzdG9yeSkge1xuICAgICAgICBjb250ZXh0LmFjdGl2ZUJhdGNoLnJldmVyc2VPcHMudW5zaGlmdCh7XG4gICAgICAgICAgdHlwZTogXCJwcmVzZW5jZVwiLFxuICAgICAgICAgIGRhdGE6IG9sZFZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2gudXBkYXRlcy5wcmVzZW5jZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICBpZiAob3B0aW9uczI/LmFkZFRvSGlzdG9yeSkge1xuICAgICAgICAgIGFkZFRvVW5kb1N0YWNrKFxuICAgICAgICAgICAgW3sgdHlwZTogXCJwcmVzZW5jZVwiLCBkYXRhOiBvbGRWYWx1ZXMgfV0sXG4gICAgICAgICAgICBkb05vdEJhdGNoVXBkYXRlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbm90aWZ5KHsgcHJlc2VuY2U6IHRydWUgfSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uVXBkYXRlUHJlc2VuY2VNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS50YXJnZXRBY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBvbGRVc2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICAgIGNvbnRleHQub3RoZXJzLnNldE90aGVyKG1lc3NhZ2UuYWN0b3IsIG1lc3NhZ2UuZGF0YSk7XG4gICAgICBjb25zdCBuZXdVc2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICAgIGlmIChvbGRVc2VyID09PSB2b2lkIDAgJiYgbmV3VXNlciAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZW50ZXJcIiwgdXNlcjogbmV3VXNlciB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0Lm90aGVycy5wYXRjaE90aGVyKG1lc3NhZ2UuYWN0b3IsIG1lc3NhZ2UuZGF0YSksIG1lc3NhZ2U7XG4gICAgfVxuICAgIGNvbnN0IHVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInVwZGF0ZVwiLFxuICAgICAgICB1cGRhdGVzOiBtZXNzYWdlLmRhdGEsXG4gICAgICAgIHVzZXJcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uVXNlckxlZnRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB1c2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgY29udGV4dC5vdGhlcnMucmVtb3ZlQ29ubmVjdGlvbihtZXNzYWdlLmFjdG9yKTtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibGVhdmVcIiwgdXNlciB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBvblJvb21TdGF0ZU1lc3NhZ2UobWVzc2FnZSwgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm8uc2V0KHtcbiAgICAgIGFjdG9yOiBtZXNzYWdlLmFjdG9yLFxuICAgICAgbm9uY2U6IG1lc3NhZ2Uubm9uY2UsXG4gICAgICBzY29wZXM6IG1lc3NhZ2Uuc2NvcGVzXG4gICAgfSk7XG4gICAgY29udGV4dC5pZEZhY3RvcnkgPSBtYWtlSWRGYWN0b3J5KG1lc3NhZ2UuYWN0b3IpO1xuICAgIG5vdGlmeVNlbGZDaGFuZ2VkKGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gICAgZm9yIChjb25zdCBjb25uZWN0aW9uSWQgb2YgY29udGV4dC5vdGhlcnMuY29ubmVjdGlvbklkcygpKSB7XG4gICAgICBjb25zdCB1c2VyID0gbWVzc2FnZS51c2Vyc1tjb25uZWN0aW9uSWRdO1xuICAgICAgaWYgKHVzZXIgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250ZXh0Lm90aGVycy5yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIG1lc3NhZ2UudXNlcnMpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBtZXNzYWdlLnVzZXJzW2tleV07XG4gICAgICBjb25zdCBjb25uZWN0aW9uSWQgPSBOdW1iZXIoa2V5KTtcbiAgICAgIGNvbnRleHQub3RoZXJzLnNldENvbm5lY3Rpb24oXG4gICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgdXNlci5pZCxcbiAgICAgICAgdXNlci5pbmZvLFxuICAgICAgICB1c2VyLnNjb3Blc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJyZXNldFwiIH07XG4gIH1cbiAgZnVuY3Rpb24gY2FuVW5kbygpIHtcbiAgICByZXR1cm4gY29udGV4dC51bmRvU3RhY2subGVuZ3RoID4gMDtcbiAgfVxuICBmdW5jdGlvbiBjYW5SZWRvKCkge1xuICAgIHJldHVybiBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPiAwO1xuICB9XG4gIGZ1bmN0aW9uIG9uSGlzdG9yeUNoYW5nZShiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBiYXRjaGVkVXBkYXRlc1dyYXBwZXIoKCkgPT4ge1xuICAgICAgZXZlbnRIdWIuaGlzdG9yeS5ub3RpZnkoeyBjYW5VbmRvOiBjYW5VbmRvKCksIGNhblJlZG86IGNhblJlZG8oKSB9KTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBvblVzZXJKb2luZWRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb250ZXh0Lm90aGVycy5zZXRDb25uZWN0aW9uKFxuICAgICAgbWVzc2FnZS5hY3RvcixcbiAgICAgIG1lc3NhZ2UuaWQsXG4gICAgICBtZXNzYWdlLmluZm8sXG4gICAgICBtZXNzYWdlLnNjb3Blc1xuICAgICk7XG4gICAgY29udGV4dC5idWZmZXIubWVzc2FnZXMucHVzaCh7XG4gICAgICB0eXBlOiAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovLFxuICAgICAgZGF0YTogY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnQsXG4gICAgICB0YXJnZXRBY3RvcjogbWVzc2FnZS5hY3RvclxuICAgIH0pO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgcmV0dXJuIHVzZXIgPyB7IHR5cGU6IFwiZW50ZXJcIiwgdXNlciB9IDogdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU2VydmVyTWVzc2FnZShkYXRhKSB7XG4gICAgaWYgKCFpc0pzb25PYmplY3QoZGF0YSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVNlcnZlck1lc3NhZ2VzKHRleHQpIHtcbiAgICBjb25zdCBkYXRhID0gdHJ5UGFyc2VKc29uKHRleHQpO1xuICAgIGlmIChkYXRhID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoaXNKc29uQXJyYXkoZGF0YSkpIHtcbiAgICAgIHJldHVybiBjb21wYWN0KGRhdGEubWFwKChpdGVtKSA9PiBwYXJzZVNlcnZlck1lc3NhZ2UoaXRlbSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbXBhY3QoW3BhcnNlU2VydmVyTWVzc2FnZShkYXRhKV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhcHBseUFuZFNlbmRPcHMob2ZmbGluZU9wcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKG9mZmxpbmVPcHMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGNvbnN0IG9wcyA9IEFycmF5LmZyb20ob2ZmbGluZU9wcy52YWx1ZXMoKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMob3BzLCB0cnVlKTtcbiAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgIHR5cGU6IDIwMSAvKiBVUERBVEVfU1RPUkFHRSAqLyxcbiAgICAgIG9wczogcmVzdWx0Lm9wc1xuICAgIH0pO1xuICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgICBzZW5kTWVzc2FnZXMobWVzc2FnZXMpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVNlcnZlck1lc3NhZ2UoZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBwYXJzZVNlcnZlck1lc3NhZ2VzKGV2ZW50LmRhdGEpO1xuICAgIGlmIChtZXNzYWdlcyA9PT0gbnVsbCB8fCBtZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlcyA9IHtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgb3RoZXJzOiBbXVxuICAgIH07XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgIGNhc2UgMTAxIC8qIFVTRVJfSk9JTkVEICovOiB7XG4gICAgICAgICAgICBjb25zdCB1c2VySm9pbmVkVXBkYXRlID0gb25Vc2VySm9pbmVkTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICh1c2VySm9pbmVkVXBkYXRlKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2godXNlckpvaW5lZFVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovOiB7XG4gICAgICAgICAgICBjb25zdCBvdGhlcnNQcmVzZW5jZVVwZGF0ZSA9IG9uVXBkYXRlUHJlc2VuY2VNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG90aGVyc1ByZXNlbmNlVXBkYXRlKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2gob3RoZXJzUHJlc2VuY2VVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTAzIC8qIEJST0FEQ0FTVEVEX0VWRU5UICovOiB7XG4gICAgICAgICAgICBjb25zdCBvdGhlcnMgPSBjb250ZXh0Lm90aGVycy5jdXJyZW50O1xuICAgICAgICAgICAgZXZlbnRIdWIuY3VzdG9tRXZlbnQubm90aWZ5KHtcbiAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiBtZXNzYWdlLmFjdG9yLFxuICAgICAgICAgICAgICB1c2VyOiBtZXNzYWdlLmFjdG9yIDwgMCA/IG51bGwgOiBvdGhlcnMuZmluZCgodSkgPT4gdS5jb25uZWN0aW9uSWQgPT09IG1lc3NhZ2UuYWN0b3IpID8/IG51bGwsXG4gICAgICAgICAgICAgIGV2ZW50OiBtZXNzYWdlLmV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwMiAvKiBVU0VSX0xFRlQgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50MiA9IG9uVXNlckxlZnRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKGV2ZW50Mikge1xuICAgICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKGV2ZW50Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAzMDAgLyogVVBEQVRFX1lET0MgKi86IHtcbiAgICAgICAgICAgIGV2ZW50SHViLnlkb2Mubm90aWZ5KG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTA0IC8qIFJPT01fU1RBVEUgKi86IHtcbiAgICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2gob25Sb29tU3RhdGVNZXNzYWdlKG1lc3NhZ2UsIGRvTm90QmF0Y2hVcGRhdGVzKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMDAgLyogSU5JVElBTF9TVE9SQUdFX1NUQVRFICovOiB7XG4gICAgICAgICAgICBwcm9jZXNzSW5pdGlhbFN0b3JhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IGFwcGx5UmVzdWx0ID0gYXBwbHlPcHMobWVzc2FnZS5vcHMsIGZhbHNlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGFwcGx5UmVzdWx0LnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgdXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXModXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5nZXQoa2V5KSwgdmFsdWUpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyOTkgLyogUkVKRUNUX1NUT1JBR0VfT1AgKi86IHtcbiAgICAgICAgICAgIGVycm9yV2l0aFRpdGxlKFxuICAgICAgICAgICAgICBcIlN0b3JhZ2UgbXV0YXRpb24gcmVqZWN0aW9uIGVycm9yXCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2UucmVhc29uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICBjb25zdCB0cmFjZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IG9wSWQgb2YgbWVzc2FnZS5vcElkcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNlID0gY29udGV4dC5vcFN0YWNrVHJhY2VzPy5nZXQob3BJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNlKSB7XG4gICAgICAgICAgICAgICAgICB0cmFjZXMuYWRkKHRyYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRyYWNlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIHdhcm5XaXRoVGl0bGUoXG4gICAgICAgICAgICAgICAgICBcIlRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gY2FsbHMgY2F1c2VkIHRoZSByZWplY3RlZCBzdG9yYWdlIG11dGF0aW9uczpcIixcbiAgICAgICAgICAgICAgICAgIGBcblxuJHtBcnJheS5mcm9tKHRyYWNlcykuam9pbihcIlxcblxcblwiKX1gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYFN0b3JhZ2UgbXV0YXRpb25zIHJlamVjdGVkIGJ5IHNlcnZlcjogJHttZXNzYWdlLnJlYXNvbn1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA0MDAgLyogVEhSRUFEX0NSRUFURUQgKi86XG4gICAgICAgICAgY2FzZSA0MDEgLyogVEhSRUFEX01FVEFEQVRBX1VQREFURUQgKi86XG4gICAgICAgICAgY2FzZSA0MDUgLyogQ09NTUVOVF9SRUFDVElPTl9BRERFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwNiAvKiBDT01NRU5UX1JFQUNUSU9OX1JFTU9WRUQgKi86XG4gICAgICAgICAgY2FzZSA0MDIgLyogQ09NTUVOVF9DUkVBVEVEICovOlxuICAgICAgICAgIGNhc2UgNDAzIC8qIENPTU1FTlRfRURJVEVEICovOlxuICAgICAgICAgIGNhc2UgNDA0IC8qIENPTU1FTlRfREVMRVRFRCAqLzoge1xuICAgICAgICAgICAgZXZlbnRIdWIuY29tbWVudHMubm90aWZ5KG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub3RpZnkodXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGZsdXNoTm93T3JTb29uKCkge1xuICAgIGNvbnN0IHN0b3JhZ2VPcHMgPSBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucztcbiAgICBpZiAoc3RvcmFnZU9wcy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IG9wIG9mIHN0b3JhZ2VPcHMpIHtcbiAgICAgICAgY29udGV4dC51bmFja25vd2xlZGdlZE9wcy5zZXQobm4ob3Aub3BJZCksIG9wKTtcbiAgICAgIH1cbiAgICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICB9XG4gICAgaWYgKG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCkgIT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zID0gW107XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZWxhcHNlZE1pbGxpcyA9IG5vdyAtIGNvbnRleHQuYnVmZmVyLmxhc3RGbHVzaGVkQXQ7XG4gICAgaWYgKGVsYXBzZWRNaWxsaXMgPj0gY29uZmlnLnRocm90dGxlRGVsYXkpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzVG9GbHVzaCA9IHNlcmlhbGl6ZUJ1ZmZlcigpO1xuICAgICAgaWYgKG1lc3NhZ2VzVG9GbHVzaC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VuZE1lc3NhZ2VzKG1lc3NhZ2VzVG9GbHVzaCk7XG4gICAgICBjb250ZXh0LmJ1ZmZlciA9IHtcbiAgICAgICAgZmx1c2hUaW1lcklEOiB2b2lkIDAsXG4gICAgICAgIGxhc3RGbHVzaGVkQXQ6IG5vdyxcbiAgICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgICBzdG9yYWdlT3BlcmF0aW9uczogW10sXG4gICAgICAgIHByZXNlbmNlVXBkYXRlczogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCk7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5mbHVzaFRpbWVySUQgPSBzZXRUaW1lb3V0KFxuICAgICAgICBmbHVzaE5vd09yU29vbixcbiAgICAgICAgY29uZmlnLnRocm90dGxlRGVsYXkgLSBlbGFwc2VkTWlsbGlzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXJpYWxpemVCdWZmZXIoKSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBpZiAoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKFxuICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMudHlwZSA9PT0gXCJmdWxsXCIgPyB7XG4gICAgICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgICAgICAvLyBQb3B1bGF0aW5nIHRoZSBgdGFyZ2V0QWN0b3JgIGZpZWxkIHR1cm5zIHRoaXMgbWVzc2FnZSBpbnRvXG4gICAgICAgICAgLy8gYSBGdWxsIFByZXNlbmNl4oSiIHVwZGF0ZSBtZXNzYWdlIChub3QgYSBwYXRjaCksIHdoaWNoIHdpbGwgZ2V0XG4gICAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYnkgb3RoZXIgY2xpZW50cyBhcyBzdWNoLlxuICAgICAgICAgIHRhcmdldEFjdG9yOiAtMSxcbiAgICAgICAgICBkYXRhOiBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVxuICAgICAgICB9IDoge1xuICAgICAgICAgIHR5cGU6IDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi8sXG4gICAgICAgICAgZGF0YTogY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcykge1xuICAgICAgbWVzc2FnZXMucHVzaChldmVudCk7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogMjAxIC8qIFVQREFURV9TVE9SQUdFICovLFxuICAgICAgICBvcHM6IGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VzO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVlEb2ModXBkYXRlLCBndWlkKSB7XG4gICAgY29uc3QgY2xpZW50TXNnID0ge1xuICAgICAgdHlwZTogMzAxIC8qIFVQREFURV9ZRE9DICovLFxuICAgICAgdXBkYXRlLFxuICAgICAgZ3VpZFxuICAgIH07XG4gICAgY29udGV4dC5idWZmZXIubWVzc2FnZXMucHVzaChjbGllbnRNc2cpO1xuICAgIGV2ZW50SHViLnlkb2Mubm90aWZ5KGNsaWVudE1zZyk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBicm9hZGNhc3RFdmVudChldmVudCwgb3B0aW9uczIgPSB7XG4gICAgc2hvdWxkUXVldWVFdmVudElmTm90UmVhZHk6IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAobWFuYWdlZFNvY2tldC5nZXRTdGF0dXMoKSAhPT0gXCJjb25uZWN0ZWRcIiAmJiAhb3B0aW9uczIuc2hvdWxkUXVldWVFdmVudElmTm90UmVhZHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC5idWZmZXIubWVzc2FnZXMucHVzaCh7XG4gICAgICB0eXBlOiAxMDMgLyogQlJPQURDQVNUX0VWRU5UICovLFxuICAgICAgZXZlbnRcbiAgICB9KTtcbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIGRpc3BhdGNoT3BzKG9wcykge1xuICAgIGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zLnB1c2goLi4ub3BzKTtcbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGxldCBfZ2V0U3RvcmFnZSQgPSBudWxsO1xuICBsZXQgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZSA9IG51bGw7XG4gIGZ1bmN0aW9uIHByb2Nlc3NJbml0aWFsU3RvcmFnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgdW5hY2tub3dsZWRnZWRPcHMgPSBuZXcgTWFwKGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMpO1xuICAgIGNyZWF0ZU9yVXBkYXRlUm9vdEZyb21NZXNzYWdlKG1lc3NhZ2UsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICBhcHBseUFuZFNlbmRPcHModW5hY2tub3dsZWRnZWRPcHMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICBfcmVzb2x2ZVN0b3JhZ2VQcm9taXNlPy4oKTtcbiAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgZXZlbnRIdWIuc3RvcmFnZURpZExvYWQubm90aWZ5KCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3RyZWFtU3RvcmFnZSgpIHtcbiAgICBpZiAoIW1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0cmVhbUZldGNoKFxuICAgICAgbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIiA/IG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLnB1YmxpY0FwaUtleSA6IG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLnRva2VuLnJhdyxcbiAgICAgIGNvbmZpZy5yb29tSWRcbiAgICApO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgICBwcm9jZXNzSW5pdGlhbFN0b3JhZ2UoeyB0eXBlOiAyMDAgLyogSU5JVElBTF9TVE9SQUdFX1NUQVRFICovLCBpdGVtcyB9KTtcbiAgfVxuICBmdW5jdGlvbiByZWZyZXNoU3RvcmFnZShvcHRpb25zMikge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gY29udGV4dC5idWZmZXIubWVzc2FnZXM7XG4gICAgaWYgKGNvbmZpZy51bnN0YWJsZV9zdHJlYW1EYXRhKSB7XG4gICAgICB2b2lkIHN0cmVhbVN0b3JhZ2UoKTtcbiAgICB9IGVsc2UgaWYgKCFtZXNzYWdlcy5zb21lKChtc2cpID0+IG1zZy50eXBlID09PSAyMDAgLyogRkVUQ0hfU1RPUkFHRSAqLykpIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goeyB0eXBlOiAyMDAgLyogRkVUQ0hfU1RPUkFHRSAqLyB9KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMyLmZsdXNoKSB7XG4gICAgICBmbHVzaE5vd09yU29vbigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzdGFydExvYWRpbmdTdG9yYWdlKCkge1xuICAgIGlmIChfZ2V0U3RvcmFnZSQgPT09IG51bGwpIHtcbiAgICAgIHJlZnJlc2hTdG9yYWdlKHsgZmx1c2g6IHRydWUgfSk7XG4gICAgICBfZ2V0U3RvcmFnZSQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBfcmVzb2x2ZVN0b3JhZ2VQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuICAgICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIH1cbiAgICByZXR1cm4gX2dldFN0b3JhZ2UkO1xuICB9XG4gIGZ1bmN0aW9uIGdldFN0b3JhZ2VTbmFwc2hvdCgpIHtcbiAgICBjb25zdCByb290ID0gY29udGV4dC5yb290O1xuICAgIGlmIChyb290ICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiByb290O1xuICAgIH0gZWxzZSB7XG4gICAgICB2b2lkIHN0YXJ0TG9hZGluZ1N0b3JhZ2UoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRTdG9yYWdlKCkge1xuICAgIGlmIChjb250ZXh0LnJvb3QgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIHJvb3Q6IGNvbnRleHQucm9vdFxuICAgICAgfSk7XG4gICAgfVxuICAgIGF3YWl0IHN0YXJ0TG9hZGluZ1N0b3JhZ2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDogbm4oY29udGV4dC5yb290KVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZmV0Y2hZRG9jKHZlY3RvciwgZ3VpZCkge1xuICAgIGlmICghY29udGV4dC5idWZmZXIubWVzc2FnZXMuZmluZCgobSkgPT4ge1xuICAgICAgcmV0dXJuIG0udHlwZSA9PT0gMzAwIC8qIEZFVENIX1lET0MgKi8gJiYgbS52ZWN0b3IgPT09IHZlY3RvciAmJiBtLmd1aWQgPT09IGd1aWQ7XG4gICAgfSkpIHtcbiAgICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiAzMDAgLyogRkVUQ0hfWURPQyAqLyxcbiAgICAgICAgdmVjdG9yLFxuICAgICAgICBndWlkXG4gICAgICB9KTtcbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiB1bmRvKCkge1xuICAgIGlmIChjb250ZXh0LmFjdGl2ZUJhdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmRvIGlzIG5vdCBhbGxvd2VkIGR1cmluZyBhIGJhdGNoXCIpO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5T3BzID0gY29udGV4dC51bmRvU3RhY2sucG9wKCk7XG4gICAgaWYgKGhpc3RvcnlPcHMgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKGhpc3RvcnlPcHMsIHRydWUpO1xuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgIGNvbnRleHQucmVkb1N0YWNrLnB1c2gocmVzdWx0LnJldmVyc2UpO1xuICAgICAgb25IaXN0b3J5Q2hhbmdlKGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIHJlc3VsdC5vcHMpIHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIpIHtcbiAgICAgICAgY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVkbygpIHtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVkbyBpcyBub3QgYWxsb3dlZCBkdXJpbmcgYSBiYXRjaFwiKTtcbiAgICB9XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQucmVkb1N0YWNrLnBvcCgpO1xuICAgIGlmIChoaXN0b3J5T3BzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gbnVsbDtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhoaXN0b3J5T3BzLCB0cnVlKTtcbiAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICBjb250ZXh0LnVuZG9TdGFjay5wdXNoKHJlc3VsdC5yZXZlcnNlKTtcbiAgICAgIG9uSGlzdG9yeUNoYW5nZShkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBvcCBvZiByZXN1bHQub3BzKSB7XG4gICAgICBpZiAob3AudHlwZSAhPT0gXCJwcmVzZW5jZVwiKSB7XG4gICAgICAgIGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zLnB1c2gob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID0gMDtcbiAgfVxuICBmdW5jdGlvbiBiYXRjaChjYWxsYmFjaykge1xuICAgIGlmIChjb250ZXh0LmFjdGl2ZUJhdGNoKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgbGV0IHJldHVyblZhbHVlID0gdm9pZCAwO1xuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBjb250ZXh0LmFjdGl2ZUJhdGNoID0ge1xuICAgICAgICBvcHM6IFtdLFxuICAgICAgICB1cGRhdGVzOiB7XG4gICAgICAgICAgc3RvcmFnZVVwZGF0ZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICAgICAgcHJlc2VuY2U6IGZhbHNlLFxuICAgICAgICAgIG90aGVyczogW11cbiAgICAgICAgfSxcbiAgICAgICAgcmV2ZXJzZU9wczogW11cbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm5WYWx1ZSA9IGNhbGxiYWNrKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb25zdCBjdXJyZW50QmF0Y2ggPSBjb250ZXh0LmFjdGl2ZUJhdGNoO1xuICAgICAgICBjb250ZXh0LmFjdGl2ZUJhdGNoID0gbnVsbDtcbiAgICAgICAgaWYgKGN1cnJlbnRCYXRjaC5yZXZlcnNlT3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhZGRUb1VuZG9TdGFjayhjdXJyZW50QmF0Y2gucmV2ZXJzZU9wcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50QmF0Y2gub3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50QmF0Y2gub3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkaXNwYXRjaE9wcyhjdXJyZW50QmF0Y2gub3BzKTtcbiAgICAgICAgfVxuICAgICAgICBub3RpZnkoY3VycmVudEJhdGNoLnVwZGF0ZXMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gcGF1c2VIaXN0b3J5KCkge1xuICAgIGlmIChjb250ZXh0LnBhdXNlZEhpc3RvcnkgPT09IG51bGwpIHtcbiAgICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IFtdO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXN1bWVIaXN0b3J5KCkge1xuICAgIGNvbnN0IGhpc3RvcnlPcHMgPSBjb250ZXh0LnBhdXNlZEhpc3Rvcnk7XG4gICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gbnVsbDtcbiAgICBpZiAoaGlzdG9yeU9wcyAhPT0gbnVsbCAmJiBoaXN0b3J5T3BzLmxlbmd0aCA+IDApIHtcbiAgICAgIF9hZGRUb1JlYWxVbmRvU3RhY2soaGlzdG9yeU9wcywgYmF0Y2hVcGRhdGVzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RvcmFnZVN0YXR1cygpIHtcbiAgICBpZiAoY29udGV4dC5yb290ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBfZ2V0U3RvcmFnZSQgPT09IG51bGwgPyBcIm5vdC1sb2FkZWRcIiA6IFwibG9hZGluZ1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29udGV4dC51bmFja25vd2xlZGdlZE9wcy5zaXplID09PSAwID8gXCJzeW5jaHJvbml6ZWRcIiA6IFwic3luY2hyb25pemluZ1wiO1xuICAgIH1cbiAgfVxuICBsZXQgX2xhc3RTdG9yYWdlU3RhdHVzID0gZ2V0U3RvcmFnZVN0YXR1cygpO1xuICBmdW5jdGlvbiBub3RpZnlTdG9yYWdlU3RhdHVzKCkge1xuICAgIGNvbnN0IHN0b3JhZ2VTdGF0dXMgPSBnZXRTdG9yYWdlU3RhdHVzKCk7XG4gICAgaWYgKF9sYXN0U3RvcmFnZVN0YXR1cyAhPT0gc3RvcmFnZVN0YXR1cykge1xuICAgICAgX2xhc3RTdG9yYWdlU3RhdHVzID0gc3RvcmFnZVN0YXR1cztcbiAgICAgIGV2ZW50SHViLnN0b3JhZ2VTdGF0dXMubm90aWZ5KHN0b3JhZ2VTdGF0dXMpO1xuICAgIH1cbiAgfVxuICBjb25zdCBvdGhlcnNfZm9yRGV2VG9vbHMgPSBuZXcgRGVyaXZlZFJlZihcbiAgICBjb250ZXh0Lm90aGVycyxcbiAgICAob3RoZXJzKSA9PiBvdGhlcnMubWFwKChvdGhlciwgaW5kZXgpID0+IHVzZXJUb1RyZWVOb2RlKGBPdGhlciAke2luZGV4fWAsIG90aGVyKSlcbiAgKTtcbiAgY29uc3QgZXZlbnRzID0ge1xuICAgIHN0YXR1czogZXZlbnRIdWIuc3RhdHVzLm9ic2VydmFibGUsXG4gICAgbG9zdENvbm5lY3Rpb246IGV2ZW50SHViLmxvc3RDb25uZWN0aW9uLm9ic2VydmFibGUsXG4gICAgY3VzdG9tRXZlbnQ6IGV2ZW50SHViLmN1c3RvbUV2ZW50Lm9ic2VydmFibGUsXG4gICAgb3RoZXJzOiBldmVudEh1Yi5vdGhlcnMub2JzZXJ2YWJsZSxcbiAgICBzZWxmOiBldmVudEh1Yi5zZWxmLm9ic2VydmFibGUsXG4gICAgbXlQcmVzZW5jZTogZXZlbnRIdWIubXlQcmVzZW5jZS5vYnNlcnZhYmxlLFxuICAgIGVycm9yOiBldmVudEh1Yi5lcnJvci5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2U6IGV2ZW50SHViLnN0b3JhZ2Uub2JzZXJ2YWJsZSxcbiAgICBoaXN0b3J5OiBldmVudEh1Yi5oaXN0b3J5Lm9ic2VydmFibGUsXG4gICAgc3RvcmFnZURpZExvYWQ6IGV2ZW50SHViLnN0b3JhZ2VEaWRMb2FkLm9ic2VydmFibGUsXG4gICAgc3RvcmFnZVN0YXR1czogZXZlbnRIdWIuc3RvcmFnZVN0YXR1cy5vYnNlcnZhYmxlLFxuICAgIHlkb2M6IGV2ZW50SHViLnlkb2Mub2JzZXJ2YWJsZSxcbiAgICBjb21tZW50czogZXZlbnRIdWIuY29tbWVudHMub2JzZXJ2YWJsZVxuICB9O1xuICBjb25zdCBjb21tZW50c0FwaSA9IGNyZWF0ZUNvbW1lbnRzQXBpKGNvbmZpZy5yb29tSWQsIGRlbGVnYXRlcy5hdXRoZW50aWNhdGUsIHtcbiAgICBiYXNlVXJsOiBjb25maWcuYmFzZVVybFxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICB7XG4gICAgICAvKiBOT1RFOiBFeHBvc2luZyBfX2ludGVybmFsIGhlcmUgb25seSB0byBhbGxvdyB0ZXN0aW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgaW4gdW5pdCB0ZXN0cyAqL1xuICAgICAgX19pbnRlcm5hbDoge1xuICAgICAgICBnZXQgcHJlc2VuY2VCdWZmZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZXBDbG9uZShjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXM/LmRhdGEgPz8gbnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBnZXQgdW5kb1N0YWNrKCkge1xuICAgICAgICAgIHJldHVybiBkZWVwQ2xvbmUoY29udGV4dC51bmRvU3RhY2spO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgZ2V0IG5vZGVDb3VudCgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5ub2Rlcy5zaXplO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgLy8gU3VwcG9ydCBmb3IgdGhlIExpdmVibG9ja3MgYnJvd3NlciBleHRlbnNpb25cbiAgICAgICAgZ2V0U2VsZl9mb3JEZXZUb29sczogKCkgPT4gc2VsZkFzVHJlZU5vZGUuY3VycmVudCxcbiAgICAgICAgZ2V0T3RoZXJzX2ZvckRldlRvb2xzOiAoKSA9PiBvdGhlcnNfZm9yRGV2VG9vbHMuY3VycmVudCxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHNpbXVsYXRlOiB7XG4gICAgICAgICAgLy8gVGhlc2UgZXhpc3Qgb25seSBmb3Igb3VyIEUyRSB0ZXN0aW5nIGFwcFxuICAgICAgICAgIGV4cGxpY2l0Q2xvc2U6IChldmVudCkgPT4gbWFuYWdlZFNvY2tldC5fcHJpdmF0ZVNlbmRNYWNoaW5lRXZlbnQoeyB0eXBlOiBcIkVYUExJQ0lUX1NPQ0tFVF9DTE9TRVwiLCBldmVudCB9KSxcbiAgICAgICAgICByYXdTZW5kOiAoZGF0YSkgPT4gbWFuYWdlZFNvY2tldC5zZW5kKGRhdGEpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpZDogY29uZmlnLnJvb21JZCxcbiAgICAgIHN1YnNjcmliZTogbWFrZUNsYXNzaWNTdWJzY3JpYmVGbihldmVudHMpLFxuICAgICAgY29ubmVjdDogKCkgPT4gbWFuYWdlZFNvY2tldC5jb25uZWN0KCksXG4gICAgICByZWNvbm5lY3Q6ICgpID0+IG1hbmFnZWRTb2NrZXQucmVjb25uZWN0KCksXG4gICAgICBkaXNjb25uZWN0OiAoKSA9PiBtYW5hZ2VkU29ja2V0LmRpc2Nvbm5lY3QoKSxcbiAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgdW5pbnN0YWxsQmdUYWJTcHkoKTtcbiAgICAgICAgbWFuYWdlZFNvY2tldC5kZXN0cm95KCk7XG4gICAgICB9LFxuICAgICAgLy8gUHJlc2VuY2VcbiAgICAgIHVwZGF0ZVByZXNlbmNlLFxuICAgICAgdXBkYXRlWURvYyxcbiAgICAgIGJyb2FkY2FzdEV2ZW50LFxuICAgICAgLy8gU3RvcmFnZVxuICAgICAgYmF0Y2gsXG4gICAgICBoaXN0b3J5OiB7XG4gICAgICAgIHVuZG8sXG4gICAgICAgIHJlZG8sXG4gICAgICAgIGNhblVuZG8sXG4gICAgICAgIGNhblJlZG8sXG4gICAgICAgIGNsZWFyLFxuICAgICAgICBwYXVzZTogcGF1c2VIaXN0b3J5LFxuICAgICAgICByZXN1bWU6IHJlc3VtZUhpc3RvcnlcbiAgICAgIH0sXG4gICAgICBmZXRjaFlEb2MsXG4gICAgICBnZXRTdG9yYWdlLFxuICAgICAgZ2V0U3RvcmFnZVNuYXBzaG90LFxuICAgICAgZ2V0U3RvcmFnZVN0YXR1cyxcbiAgICAgIGV2ZW50cyxcbiAgICAgIC8vIENvcmVcbiAgICAgIGdldFN0YXR1czogKCkgPT4gbWFuYWdlZFNvY2tldC5nZXRTdGF0dXMoKSxcbiAgICAgIGdldENvbm5lY3Rpb25TdGF0ZTogKCkgPT4gbWFuYWdlZFNvY2tldC5nZXRMZWdhY3lTdGF0dXMoKSxcbiAgICAgIGdldFNlbGY6ICgpID0+IHNlbGYuY3VycmVudCxcbiAgICAgIC8vIFByZXNlbmNlXG4gICAgICBnZXRQcmVzZW5jZTogKCkgPT4gY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnQsXG4gICAgICBnZXRPdGhlcnM6ICgpID0+IGNvbnRleHQub3RoZXJzLmN1cnJlbnQsXG4gICAgICAuLi5jb21tZW50c0FwaVxuICAgIH0sXG4gICAgLy8gRXhwbGljdGx5IG1ha2UgdGhlIF9faW50ZXJuYWwgZmllbGQgbm9uLWVudW1lcmFibGUsIHRvIGF2b2lkIGFnZ3Jlc3NpdmVcbiAgICAvLyBmcmVlemluZyB3aGVuIHVzZWQgd2l0aCBJbW1lclxuICAgIFwiX19pbnRlcm5hbFwiLFxuICAgIHsgZW51bWVyYWJsZTogZmFsc2UgfVxuICApO1xufVxuZnVuY3Rpb24gbWFrZUNsYXNzaWNTdWJzY3JpYmVGbihldmVudHMpIHtcbiAgZnVuY3Rpb24gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlRGVlcGx5KG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlLnN1YnNjcmliZSgodXBkYXRlcykgPT4ge1xuICAgICAgY29uc3QgcmVsYXRlZFVwZGF0ZXMgPSB1cGRhdGVzLmZpbHRlcihcbiAgICAgICAgKHVwZGF0ZSkgPT4gaXNTYW1lTm9kZU9yQ2hpbGRPZih1cGRhdGUubm9kZSwgbm9kZSlcbiAgICAgICk7XG4gICAgICBpZiAocmVsYXRlZFVwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjYWxsYmFjayhyZWxhdGVkVXBkYXRlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlU2hhbGxvd2x5KG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlLnN1YnNjcmliZSgodXBkYXRlcykgPT4ge1xuICAgICAgZm9yIChjb25zdCB1cGRhdGUgb2YgdXBkYXRlcykge1xuICAgICAgICBpZiAodXBkYXRlLm5vZGUuX2lkID09PSBub2RlLl9pZCkge1xuICAgICAgICAgIGNhbGxiYWNrKHVwZGF0ZS5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShmaXJzdCwgc2Vjb25kLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJzdHJpbmdcIiAmJiBpc1Jvb21FdmVudE5hbWUoZmlyc3QpKSB7XG4gICAgICBpZiAodHlwZW9mIHNlY29uZCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgY2FsbGJhY2sgZnVuY3Rpb25cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBjYWxsYmFjayA9IHNlY29uZDtcbiAgICAgIHN3aXRjaCAoZmlyc3QpIHtcbiAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5jdXN0b21FdmVudC5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJteS1wcmVzZW5jZVwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMubXlQcmVzZW5jZS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwib3RoZXJzXCI6IHtcbiAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrO1xuICAgICAgICAgIHJldHVybiBldmVudHMub3RoZXJzLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3RoZXJzLCAuLi5pbnRlcm5hbEV2ZW50IH0gPSBldmVudDtcbiAgICAgICAgICAgIHJldHVybiBjYihvdGhlcnMsIGludGVybmFsRXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuZXJyb3Iuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcImNvbm5lY3Rpb25cIjoge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2s7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlKFxuICAgICAgICAgICAgKHN0YXR1cykgPT4gY2IobmV3VG9MZWdhY3lTdGF0dXMoc3RhdHVzKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzdGF0dXNcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwibG9zdC1jb25uZWN0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5sb3N0Q29ubmVjdGlvbi5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJoaXN0b3J5XCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5oaXN0b3J5LnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJzdG9yYWdlLXN0YXR1c1wiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuc3RvcmFnZVN0YXR1cy5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKFxuICAgICAgICAgICAgZmlyc3QsXG4gICAgICAgICAgICBgXCIke1N0cmluZyhmaXJzdCl9XCIgaXMgbm90IGEgdmFsaWQgZXZlbnQgbmFtZWBcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2Vjb25kID09PSB2b2lkIDAgfHwgdHlwZW9mIGZpcnN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgZmlyc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBzdG9yYWdlQ2FsbGJhY2sgPSBmaXJzdDtcbiAgICAgICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlLnN1YnNjcmliZShzdG9yYWdlQ2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHNwZWNpZnkgYSBsaXN0ZW5lciBjYWxsYmFja1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTGl2ZU5vZGUoZmlyc3QpKSB7XG4gICAgICBjb25zdCBub2RlID0gZmlyc3Q7XG4gICAgICBpZiAob3B0aW9ucz8uaXNEZWVwKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VDYWxsYmFjayA9IHNlY29uZDtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZURlZXBseShub2RlLCBzdG9yYWdlQ2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm9kZUNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlU2hhbGxvd2x5KG5vZGUsIG5vZGVDYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGAke1N0cmluZyhmaXJzdCl9IGlzIG5vdCBhIHZhbHVlIHRoYXQgY2FuIGJlIHN1YnNjcmliZWQgdG8uYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHN1YnNjcmliZTtcbn1cbmZ1bmN0aW9uIGlzUm9vbUV2ZW50TmFtZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IFwibXktcHJlc2VuY2VcIiB8fCB2YWx1ZSA9PT0gXCJvdGhlcnNcIiB8fCB2YWx1ZSA9PT0gXCJldmVudFwiIHx8IHZhbHVlID09PSBcImVycm9yXCIgfHwgdmFsdWUgPT09IFwiaGlzdG9yeVwiIHx8IHZhbHVlID09PSBcInN0YXR1c1wiIHx8IHZhbHVlID09PSBcInN0b3JhZ2Utc3RhdHVzXCIgfHwgdmFsdWUgPT09IFwibG9zdC1jb25uZWN0aW9uXCIgfHwgdmFsdWUgPT09IFwiY29ubmVjdGlvblwiO1xufVxuZnVuY3Rpb24gbWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBhdXRoTWFuYWdlcikge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoXCJyb29tOnJlYWRcIiwgcm9vbUlkKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VDcmVhdGVTb2NrZXREZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBiYXNlVXJsLCBXZWJTb2NrZXRQb2x5ZmlsbCkge1xuICByZXR1cm4gKGF1dGhWYWx1ZSkgPT4ge1xuICAgIGNvbnN0IHdzID0gV2ViU29ja2V0UG9seWZpbGwgPz8gKHR5cGVvZiBXZWJTb2NrZXQgPT09IFwidW5kZWZpbmVkXCIgPyB2b2lkIDAgOiBXZWJTb2NrZXQpO1xuICAgIGlmICh3cyA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKFxuICAgICAgICBcIlRvIHVzZSBMaXZlYmxvY2tzIGNsaWVudCBpbiBhIG5vbi1ET00gZW52aXJvbm1lbnQsIHlvdSBuZWVkIHRvIHByb3ZpZGUgYSBXZWJTb2NrZXQgcG9seWZpbGwuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgdXJsLnByb3RvY29sID0gdXJsLnByb3RvY29sID09PSBcImh0dHA6XCIgPyBcIndzXCIgOiBcIndzc1wiO1xuICAgIHVybC5wYXRobmFtZSA9IFwiL3Y3XCI7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJyb29tSWRcIiwgcm9vbUlkKTtcbiAgICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwic2VjcmV0XCIpIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwidG9rXCIsIGF1dGhWYWx1ZS50b2tlbi5yYXcpO1xuICAgIH0gZWxzZSBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwicHVibGljXCIpIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwicHVia2V5XCIsIGF1dGhWYWx1ZS5wdWJsaWNBcGlLZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIoYXV0aFZhbHVlLCBcIlVuaGFuZGxlZCBjYXNlXCIpO1xuICAgIH1cbiAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInZlcnNpb25cIiwgUEtHX1ZFUlNJT04gfHwgXCJkZXZcIik7XG4gICAgcmV0dXJuIG5ldyB3cyh1cmwudG9TdHJpbmcoKSk7XG4gIH07XG59XG5cbi8vIHNyYy9jbGllbnQudHNcbnZhciBNSU5fVEhST1RUTEUgPSAxNjtcbnZhciBNQVhfVEhST1RUTEUgPSAxZTM7XG52YXIgREVGQVVMVF9USFJPVFRMRSA9IDEwMDtcbnZhciBNSU5fQkFDS0dST1VORF9LRUVQX0FMSVZFX1RJTUVPVVQgPSAxNWUzO1xudmFyIE1JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDIwMDtcbnZhciBSRUNPTU1FTkRFRF9NSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAxZTM7XG52YXIgTUFYX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gM2U0O1xudmFyIERFRkFVTFRfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSA1ZTM7XG5mdW5jdGlvbiBnZXRCYXNlVXJsRnJvbUNsaWVudE9wdGlvbnMoY2xpZW50T3B0aW9ucykge1xuICBpZiAoXCJsaXZlYmxvY2tzU2VydmVyXCIgaW4gY2xpZW50T3B0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNsaWVudCBvcHRpb24gbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGNsaWVudE9wdGlvbnMuYmFzZVVybCA9PT0gXCJzdHJpbmdcIiAmJiBjbGllbnRPcHRpb25zLmJhc2VVcmwuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICByZXR1cm4gY2xpZW50T3B0aW9ucy5iYXNlVXJsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBERUZBVUxUX0JBU0VfVVJMO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnQob3B0aW9ucykge1xuICBjb25zdCBjbGllbnRPcHRpb25zID0gb3B0aW9ucztcbiAgY29uc3QgdGhyb3R0bGVEZWxheSA9IGdldFRocm90dGxlKGNsaWVudE9wdGlvbnMudGhyb3R0bGUgPz8gREVGQVVMVF9USFJPVFRMRSk7XG4gIGNvbnN0IGxvc3RDb25uZWN0aW9uVGltZW91dCA9IGdldExvc3RDb25uZWN0aW9uVGltZW91dChcbiAgICBjbGllbnRPcHRpb25zLmxvc3RDb25uZWN0aW9uVGltZW91dCA/PyBERUZBVUxUX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUXG4gICk7XG4gIGNvbnN0IGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0ID0gZ2V0QmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQoXG4gICAgY2xpZW50T3B0aW9ucy5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dFxuICApO1xuICBjb25zdCBhdXRoTWFuYWdlciA9IGNyZWF0ZUF1dGhNYW5hZ2VyKG9wdGlvbnMpO1xuICBjb25zdCByb29tc0J5SWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiB0ZWFyZG93blJvb20ocm9vbSkge1xuICAgIHVubGlua0RldlRvb2xzKHJvb20uaWQpO1xuICAgIHJvb21zQnlJZC5kZWxldGUocm9vbS5pZCk7XG4gICAgcm9vbS5kZXN0cm95KCk7XG4gIH1cbiAgZnVuY3Rpb24gbGVhc2VSb29tKGluZm8pIHtcbiAgICBjb25zdCBsZWF2ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGYgPSBsZWF2ZTtcbiAgICAgIGlmICghaW5mby51bnN1YnMuZGVsZXRlKHNlbGYpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJUaGlzIGxlYXZlIGZ1bmN0aW9uIHdhcyBhbHJlYWR5IGNhbGxlZC4gQ2FsbGluZyBpdCBtb3JlIHRoYW4gb25jZSBoYXMgbm8gZWZmZWN0LlwiXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5mby51bnN1YnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRlYXJkb3duUm9vbShpbmZvLnJvb20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpbmZvLnVuc3Vicy5hZGQobGVhdmUpO1xuICAgIHJldHVybiB7XG4gICAgICByb29tOiBpbmZvLnJvb20sXG4gICAgICBsZWF2ZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZW50ZXJSb29tKHJvb21JZCwgb3B0aW9uczIpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IHJvb21zQnlJZC5nZXQocm9vbUlkKTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxlYXNlUm9vbShleGlzdGluZyk7XG4gICAgfVxuICAgIGRlcHJlY2F0ZUlmKFxuICAgICAgb3B0aW9uczIuaW5pdGlhbFByZXNlbmNlID09PSBudWxsIHx8IG9wdGlvbnMyLmluaXRpYWxQcmVzZW5jZSA9PT0gdm9pZCAwLFxuICAgICAgXCJQbGVhc2UgcHJvdmlkZSBhbiBpbml0aWFsIHByZXNlbmNlIHZhbHVlIGZvciB0aGUgY3VycmVudCB1c2VyIHdoZW4gZW50ZXJpbmcgdGhlIHJvb20uXCJcbiAgICApO1xuICAgIGNvbnN0IGJhc2VVcmwgPSBnZXRCYXNlVXJsRnJvbUNsaWVudE9wdGlvbnMoY2xpZW50T3B0aW9ucyk7XG4gICAgY29uc3QgbmV3Um9vbSA9IGNyZWF0ZVJvb20oXG4gICAgICB7XG4gICAgICAgIGluaXRpYWxQcmVzZW5jZTogb3B0aW9uczIuaW5pdGlhbFByZXNlbmNlID8/IHt9LFxuICAgICAgICBpbml0aWFsU3RvcmFnZTogb3B0aW9uczIuaW5pdGlhbFN0b3JhZ2VcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJvb21JZCxcbiAgICAgICAgdGhyb3R0bGVEZWxheSxcbiAgICAgICAgbG9zdENvbm5lY3Rpb25UaW1lb3V0LFxuICAgICAgICBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCxcbiAgICAgICAgcG9seWZpbGxzOiBjbGllbnRPcHRpb25zLnBvbHlmaWxscyxcbiAgICAgICAgZGVsZWdhdGVzOiBjbGllbnRPcHRpb25zLm1vY2tlZERlbGVnYXRlcyA/PyB7XG4gICAgICAgICAgY3JlYXRlU29ja2V0OiBtYWtlQ3JlYXRlU29ja2V0RGVsZWdhdGVGb3JSb29tKFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgYmFzZVVybCxcbiAgICAgICAgICAgIGNsaWVudE9wdGlvbnMucG9seWZpbGxzPy5XZWJTb2NrZXRcbiAgICAgICAgICApLFxuICAgICAgICAgIGF1dGhlbnRpY2F0ZTogbWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBhdXRoTWFuYWdlcilcbiAgICAgICAgfSxcbiAgICAgICAgZW5hYmxlRGVidWdMb2dnaW5nOiBjbGllbnRPcHRpb25zLmVuYWJsZURlYnVnTG9nZ2luZyxcbiAgICAgICAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IG9wdGlvbnMyPy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyxcbiAgICAgICAgYmFzZVVybCxcbiAgICAgICAgdW5zdGFibGVfZmFsbGJhY2tUb0hUVFA6ICEhY2xpZW50T3B0aW9ucy51bnN0YWJsZV9mYWxsYmFja1RvSFRUUCxcbiAgICAgICAgdW5zdGFibGVfc3RyZWFtRGF0YTogISFjbGllbnRPcHRpb25zLnVuc3RhYmxlX3N0cmVhbURhdGFcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IG5ld1Jvb21JbmZvID0ge1xuICAgICAgcm9vbTogbmV3Um9vbSxcbiAgICAgIHVuc3ViczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgIH07XG4gICAgcm9vbXNCeUlkLnNldChyb29tSWQsIG5ld1Jvb21JbmZvKTtcbiAgICBzZXR1cERldlRvb2xzKCgpID0+IEFycmF5LmZyb20ocm9vbXNCeUlkLmtleXMoKSkpO1xuICAgIGxpbmtEZXZUb29scyhyb29tSWQsIG5ld1Jvb20pO1xuICAgIGNvbnN0IHNob3VsZENvbm5lY3QgPSBvcHRpb25zMi5hdXRvQ29ubmVjdCA/PyBvcHRpb25zMi5zaG91bGRJbml0aWFsbHlDb25uZWN0ID8/IHRydWU7XG4gICAgaWYgKHNob3VsZENvbm5lY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgYXRvYiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHM/LmF0b2IgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiWW91IG5lZWQgdG8gcG9seWZpbGwgYXRvYiB0byB1c2UgdGhlIGNsaWVudCBpbiB5b3VyIGVudmlyb25tZW50LiBQbGVhc2UgZm9sbG93IHRoZSBpbnN0cnVjdGlvbnMgYXQgaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2xpdmVibG9ja3MtY2xpZW50L2F0b2ItcG9seWZpbGxcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsLmF0b2IgPSBjbGllbnRPcHRpb25zLnBvbHlmaWxscy5hdG9iO1xuICAgICAgfVxuICAgICAgbmV3Um9vbS5jb25uZWN0KCk7XG4gICAgfVxuICAgIHJldHVybiBsZWFzZVJvb20obmV3Um9vbUluZm8pO1xuICB9XG4gIGZ1bmN0aW9uIGVudGVyKHJvb21JZCwgb3B0aW9uczIpIHtcbiAgICBjb25zdCB7IHJvb20sIGxlYXZlOiBfIH0gPSBlbnRlclJvb20ocm9vbUlkLCBvcHRpb25zMik7XG4gICAgcmV0dXJuIHJvb207XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Um9vbShyb29tSWQpIHtcbiAgICBjb25zdCByb29tID0gcm9vbXNCeUlkLmdldChyb29tSWQpPy5yb29tO1xuICAgIHJldHVybiByb29tID8gcm9vbSA6IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZm9yY2VMZWF2ZShyb29tSWQpIHtcbiAgICBjb25zdCB1bnN1YnMgPSByb29tc0J5SWQuZ2V0KHJvb21JZCk/LnVuc3VicyA/PyAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgdW5zdWIgb2YgdW5zdWJzKSB7XG4gICAgICB1bnN1YigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBsb2dvdXQoKSB7XG4gICAgYXV0aE1hbmFnZXIucmVzZXQoKTtcbiAgICBmb3IgKGNvbnN0IHsgcm9vbSB9IG9mIHJvb21zQnlJZC52YWx1ZXMoKSkge1xuICAgICAgaWYgKCFpc0lkbGUocm9vbS5nZXRTdGF0dXMoKSkpIHtcbiAgICAgICAgcm9vbS5yZWNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsb2dvdXQsXG4gICAgLy8gT2xkLCBkZXByZWNhdGVkIEFQSXNcbiAgICBlbnRlcixcbiAgICBnZXRSb29tLFxuICAgIGxlYXZlOiBmb3JjZUxlYXZlLFxuICAgIC8vIE5ldywgcHJlZmVycmVkIEFQSVxuICAgIGVudGVyUm9vbVxuICB9O1xufVxuZnVuY3Rpb24gY2hlY2tCb3VuZHMob3B0aW9uLCB2YWx1ZSwgbWluLCBtYXgsIHJlY29tbWVuZGVkTWluKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIgfHwgdmFsdWUgPCBtaW4gfHwgbWF4ICE9PSB2b2lkIDAgJiYgdmFsdWUgPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBtYXggIT09IHZvaWQgMCA/IGAke29wdGlvbn0gc2hvdWxkIGJlIGJldHdlZW4gJHtyZWNvbW1lbmRlZE1pbiA/PyBtaW59IGFuZCAke21heH0uYCA6IGAke29wdGlvbn0gc2hvdWxkIGJlIGF0IGxlYXN0ICR7cmVjb21tZW5kZWRNaW4gPz8gbWlufS5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHZvaWQgMClcbiAgICByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXG4gICAgXCJiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dFwiLFxuICAgIHZhbHVlLFxuICAgIE1JTl9CQUNLR1JPVU5EX0tFRVBfQUxJVkVfVElNRU9VVFxuICApO1xufVxuZnVuY3Rpb24gZ2V0VGhyb3R0bGUodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm91bmRzKFwidGhyb3R0bGVcIiwgdmFsdWUsIE1JTl9USFJPVFRMRSwgTUFYX1RIUk9UVExFKTtcbn1cbmZ1bmN0aW9uIGdldExvc3RDb25uZWN0aW9uVGltZW91dCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXG4gICAgXCJsb3N0Q29ubmVjdGlvblRpbWVvdXRcIixcbiAgICB2YWx1ZSxcbiAgICBNSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQsXG4gICAgTUFYX0xPU1RfQ09OTkVDVElPTl9USU1FT1VULFxuICAgIFJFQ09NTUVOREVEX01JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVFxuICApO1xufVxuXG4vLyBzcmMvY3JkdHMvdXRpbHMudHNcbmZ1bmN0aW9uIHRvUGxhaW5Mc29uKGxzb24pIHtcbiAgaWYgKGxzb24gaW5zdGFuY2VvZiBMaXZlT2JqZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdmVibG9ja3NUeXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgIGRhdGE6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMobHNvbi50b09iamVjdCgpKS5mbGF0TWFwKFxuICAgICAgICAgIChba2V5LCB2YWx1ZV0pID0+IHZhbHVlICE9PSB2b2lkIDAgPyBbW2tleSwgdG9QbGFpbkxzb24odmFsdWUpXV0gOiBbXVxuICAgICAgICApXG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZU1hcCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICBkYXRhOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIFsuLi5sc29uXS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW2tleSwgdG9QbGFpbkxzb24odmFsdWUpXSlcbiAgICAgIClcbiAgICB9O1xuICB9IGVsc2UgaWYgKGxzb24gaW5zdGFuY2VvZiBMaXZlTGlzdCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlTGlzdFwiLFxuICAgICAgZGF0YTogWy4uLmxzb25dLm1hcCgoaXRlbSkgPT4gdG9QbGFpbkxzb24oaXRlbSkpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbHNvbjtcbiAgfVxufVxuXG4vLyBzcmMvaW1tdXRhYmxlLnRzXG5mdW5jdGlvbiBsc29uT2JqZWN0VG9Kc29uKG9iaikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgY29uc3QgdmFsID0gb2JqW2tleV07XG4gICAgaWYgKHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGxzb25Ub0pzb24odmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxpdmVPYmplY3RUb0pzb24obGl2ZU9iamVjdCkge1xuICByZXR1cm4gbHNvbk9iamVjdFRvSnNvbihsaXZlT2JqZWN0LnRvT2JqZWN0KCkpO1xufVxuZnVuY3Rpb24gbGl2ZU1hcFRvSnNvbihtYXApIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcC5lbnRyaWVzKCkpIHtcbiAgICByZXN1bHRba2V5XSA9IGxzb25Ub0pzb24odmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsc29uTGlzdFRvSnNvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUubWFwKGxzb25Ub0pzb24pO1xufVxuZnVuY3Rpb24gbGl2ZUxpc3RUb0pzb24odmFsdWUpIHtcbiAgcmV0dXJuIGxzb25MaXN0VG9Kc29uKHZhbHVlLnRvQXJyYXkoKSk7XG59XG5mdW5jdGlvbiBsc29uVG9Kc29uKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4gbGl2ZU9iamVjdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlTGlzdCkge1xuICAgIHJldHVybiBsaXZlTGlzdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwKSB7XG4gICAgcmV0dXJuIGxpdmVNYXBUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyKSB7XG4gICAgcmV0dXJuIHZhbHVlLmRhdGE7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGxzb25MaXN0VG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBsc29uT2JqZWN0VG9Kc29uKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBkZWVwTGl2ZWlmeSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IExpdmVMaXN0KHZhbHVlLm1hcChkZWVwTGl2ZWlmeSkpO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgY29uc3QgaW5pdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICBjb25zdCB2YWwgPSB2YWx1ZVtrZXldO1xuICAgICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaW5pdFtrZXldID0gZGVlcExpdmVpZnkodmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMaXZlT2JqZWN0KGluaXQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hMaXZlTGlzdChsaXZlTGlzdCwgcHJldiwgbmV4dCkge1xuICBsZXQgaSA9IDA7XG4gIGxldCBwcmV2RW5kID0gcHJldi5sZW5ndGggLSAxO1xuICBsZXQgbmV4dEVuZCA9IG5leHQubGVuZ3RoIC0gMTtcbiAgbGV0IHByZXZOb2RlID0gcHJldlswXTtcbiAgbGV0IG5leHROb2RlID0gbmV4dFswXTtcbiAgb3V0ZXI6IHtcbiAgICB3aGlsZSAocHJldk5vZGUgPT09IG5leHROb2RlKSB7XG4gICAgICArK2k7XG4gICAgICBpZiAoaSA+IHByZXZFbmQgfHwgaSA+IG5leHRFbmQpIHtcbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9XG4gICAgICBwcmV2Tm9kZSA9IHByZXZbaV07XG4gICAgICBuZXh0Tm9kZSA9IG5leHRbaV07XG4gICAgfVxuICAgIHByZXZOb2RlID0gcHJldltwcmV2RW5kXTtcbiAgICBuZXh0Tm9kZSA9IG5leHRbbmV4dEVuZF07XG4gICAgd2hpbGUgKHByZXZOb2RlID09PSBuZXh0Tm9kZSkge1xuICAgICAgcHJldkVuZC0tO1xuICAgICAgbmV4dEVuZC0tO1xuICAgICAgaWYgKGkgPiBwcmV2RW5kIHx8IGkgPiBuZXh0RW5kKSB7XG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgcHJldk5vZGUgPSBwcmV2W3ByZXZFbmRdO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W25leHRFbmRdO1xuICAgIH1cbiAgfVxuICBpZiAoaSA+IHByZXZFbmQpIHtcbiAgICBpZiAoaSA8PSBuZXh0RW5kKSB7XG4gICAgICB3aGlsZSAoaSA8PSBuZXh0RW5kKSB7XG4gICAgICAgIGxpdmVMaXN0Lmluc2VydChkZWVwTGl2ZWlmeShuZXh0W2ldKSwgaSk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaSA+IG5leHRFbmQpIHtcbiAgICBsZXQgbG9jYWxJID0gaTtcbiAgICB3aGlsZSAobG9jYWxJIDw9IHByZXZFbmQpIHtcbiAgICAgIGxpdmVMaXN0LmRlbGV0ZShpKTtcbiAgICAgIGxvY2FsSSsrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoaSA8PSBwcmV2RW5kICYmIGkgPD0gbmV4dEVuZCkge1xuICAgICAgcHJldk5vZGUgPSBwcmV2W2ldO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W2ldO1xuICAgICAgY29uc3QgbGl2ZUxpc3ROb2RlID0gbGl2ZUxpc3QuZ2V0KGkpO1xuICAgICAgaWYgKGlzTGl2ZU9iamVjdChsaXZlTGlzdE5vZGUpICYmIGlzUGxhaW5PYmplY3QocHJldk5vZGUpICYmIGlzUGxhaW5PYmplY3QobmV4dE5vZGUpKSB7XG4gICAgICAgIHBhdGNoTGl2ZU9iamVjdChsaXZlTGlzdE5vZGUsIHByZXZOb2RlLCBuZXh0Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXZlTGlzdC5zZXQoaSwgZGVlcExpdmVpZnkobmV4dE5vZGUpKTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgd2hpbGUgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgbGl2ZUxpc3QuaW5zZXJ0KGRlZXBMaXZlaWZ5KG5leHRbaV0pLCBpKTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgbGV0IGxvY2FsSSA9IGk7XG4gICAgd2hpbGUgKGxvY2FsSSA8PSBwcmV2RW5kKSB7XG4gICAgICBsaXZlTGlzdC5kZWxldGUoaSk7XG4gICAgICBsb2NhbEkrKztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZU9iamVjdEtleShsaXZlT2JqZWN0LCBrZXksIHByZXYsIG5leHQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IG5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKG5leHQpO1xuICAgIGlmIChub25TZXJpYWxpemFibGVWYWx1ZSkge1xuICAgICAgZXJyb3IyKFxuICAgICAgICBgTmV3IHN0YXRlIHBhdGg6ICcke25vblNlcmlhbGl6YWJsZVZhbHVlLnBhdGh9JyB2YWx1ZTogJyR7U3RyaW5nKFxuICAgICAgICAgIG5vblNlcmlhbGl6YWJsZVZhbHVlLnZhbHVlXG4gICAgICAgICl9JyBpcyBub3Qgc2VyaWFsaXphYmxlLlxuT25seSBzZXJpYWxpemFibGUgdmFsdWUgY2FuIGJlIHN5bmNlZCB3aXRoIExpdmVibG9ja3MuYFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29uc3QgdmFsdWUgPSBsaXZlT2JqZWN0LmdldChrZXkpO1xuICBpZiAobmV4dCA9PT0gdm9pZCAwKSB7XG4gICAgbGl2ZU9iamVjdC5kZWxldGUoa2V5KTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgbGl2ZU9iamVjdC5zZXQoa2V5LCBkZWVwTGl2ZWlmeShuZXh0KSk7XG4gIH0gZWxzZSBpZiAocHJldiA9PT0gbmV4dCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChpc0xpdmVMaXN0KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHByZXYpICYmIEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICBwYXRjaExpdmVMaXN0KHZhbHVlLCBwcmV2LCBuZXh0KTtcbiAgfSBlbHNlIGlmIChpc0xpdmVPYmplY3QodmFsdWUpICYmIGlzUGxhaW5PYmplY3QocHJldikgJiYgaXNQbGFpbk9iamVjdChuZXh0KSkge1xuICAgIHBhdGNoTGl2ZU9iamVjdCh2YWx1ZSwgcHJldiwgbmV4dCk7XG4gIH0gZWxzZSB7XG4gICAgbGl2ZU9iamVjdC5zZXQoa2V5LCBkZWVwTGl2ZWlmeShuZXh0KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZU9iamVjdChyb290LCBwcmV2LCBuZXh0KSB7XG4gIGNvbnN0IHVwZGF0ZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuICAgIHBhdGNoTGl2ZU9iamVjdEtleShyb290LCBrZXksIHByZXZba2V5XSwgbmV4dFtrZXldKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgaWYgKG5leHRba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICByb290LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuICBpZiAoT2JqZWN0LmtleXModXBkYXRlcykubGVuZ3RoID4gMCkge1xuICAgIHJvb3QudXBkYXRlKHVwZGF0ZXMpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQYXJlbnRzUGF0aChub2RlKSB7XG4gIGNvbnN0IHBhdGggPSBbXTtcbiAgd2hpbGUgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICBpZiAoaXNMaXZlTGlzdChub2RlLnBhcmVudC5ub2RlKSkge1xuICAgICAgcGF0aC5wdXNoKG5vZGUucGFyZW50Lm5vZGUuX2luZGV4T2ZQb3NpdGlvbihub2RlLnBhcmVudC5rZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC5wdXNoKG5vZGUucGFyZW50LmtleSk7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudC5ub2RlO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0KHN0YXRlLCB1cGRhdGVzKSB7XG4gIHJldHVybiB1cGRhdGVzLnJlZHVjZShcbiAgICAoc3RhdGUyLCB1cGRhdGUpID0+IGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdFdpdGhVcGRhdGUoc3RhdGUyLCB1cGRhdGUpLFxuICAgIHN0YXRlXG4gICk7XG59XG5mdW5jdGlvbiBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3RXaXRoVXBkYXRlKHN0YXRlLCB1cGRhdGUpIHtcbiAgY29uc3QgcGF0aCA9IGdldFBhcmVudHNQYXRoKHVwZGF0ZS5ub2RlKTtcbiAgcmV0dXJuIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUoc3RhdGUsIHBhdGgsIHVwZGF0ZSk7XG59XG5mdW5jdGlvbiBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKHN0YXRlLCBwYXRoLCB1cGRhdGUpIHtcbiAgY29uc3QgcGF0aEl0ZW0gPSBwYXRoLnBvcCgpO1xuICBpZiAocGF0aEl0ZW0gPT09IHZvaWQgMCkge1xuICAgIHN3aXRjaCAodXBkYXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJMaXZlT2JqZWN0XCI6IHtcbiAgICAgICAgaWYgKCFpc0pzb25PYmplY3Qoc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbDogcmVjZWl2ZWQgdXBkYXRlIG9uIExpdmVPYmplY3QgYnV0IHN0YXRlIHdhcyBub3QgYW4gb2JqZWN0XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB1cGRhdGUudXBkYXRlcykge1xuICAgICAgICAgIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcInVwZGF0ZVwiKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSB1cGRhdGUubm9kZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gbHNvblRvSnNvbih2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgZGVsZXRlIG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJMaXZlTGlzdFwiOiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsOiByZWNlaXZlZCB1cGRhdGUgb24gTGl2ZUxpc3QgYnV0IHN0YXRlIHdhcyBub3QgYW4gYXJyYXlcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1N0YXRlID0gc3RhdGUubWFwKCh4KSA9PiB4KTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0VXBkYXRlIG9mIHVwZGF0ZS51cGRhdGVzKSB7XG4gICAgICAgICAgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJzZXRcIikge1xuICAgICAgICAgICAgbmV3U3RhdGUgPSBuZXdTdGF0ZS5tYXAoXG4gICAgICAgICAgICAgIChpdGVtLCBpbmRleCkgPT4gaW5kZXggPT09IGxpc3RVcGRhdGUuaW5kZXggPyBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSkgOiBpdGVtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcImluc2VydFwiKSB7XG4gICAgICAgICAgICBpZiAobGlzdFVwZGF0ZS5pbmRleCA9PT0gbmV3U3RhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlLnB1c2gobHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gW1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKDAsIGxpc3RVcGRhdGUuaW5kZXgpLFxuICAgICAgICAgICAgICAgIGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLmluZGV4KVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBuZXdTdGF0ZS5zcGxpY2UobGlzdFVwZGF0ZS5pbmRleCwgMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwibW92ZVwiKSB7XG4gICAgICAgICAgICBpZiAobGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4ID4gbGlzdFVwZGF0ZS5pbmRleCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZSgwLCBsaXN0VXBkYXRlLmluZGV4KSxcbiAgICAgICAgICAgICAgICBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5pbmRleCwgbGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4KSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXggKyAxKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoMCwgbGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4KSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShcbiAgICAgICAgICAgICAgICAgIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCArIDEsXG4gICAgICAgICAgICAgICAgICBsaXN0VXBkYXRlLmluZGV4ICsgMVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUuaW5kZXggKyAxKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTGl2ZU1hcFwiOiB7XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWw6IHJlY2VpdmVkIHVwZGF0ZSBvbiBMaXZlTWFwIGJ1dCBzdGF0ZSB3YXMgbm90IGFuIG9iamVjdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdXBkYXRlLnVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB1cGRhdGUubm9kZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlW2tleV0gPSBsc29uVG9Kc29uKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHN0YXRlKSkge1xuICAgIGNvbnN0IG5ld0FycmF5ID0gWy4uLnN0YXRlXTtcbiAgICBuZXdBcnJheVtwYXRoSXRlbV0gPSBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKFxuICAgICAgc3RhdGVbcGF0aEl0ZW1dLFxuICAgICAgcGF0aCxcbiAgICAgIHVwZGF0ZVxuICAgICk7XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9IGVsc2UgaWYgKGlzSnNvbk9iamVjdChzdGF0ZSkpIHtcbiAgICBjb25zdCBub2RlID0gc3RhdGVbcGF0aEl0ZW1dO1xuICAgIGlmIChub2RlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RhdGVBc09iaiA9IHN0YXRlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGVBc09iaixcbiAgICAgICAgW3BhdGhJdGVtXTogbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShub2RlLCBwYXRoLCB1cGRhdGUpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9zaGFsbG93LnRzXG5mdW5jdGlvbiBzaGFsbG93QXJyYXkoeHMsIHlzKSB7XG4gIGlmICh4cy5sZW5ndGggIT09IHlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFPYmplY3QuaXMoeHNbaV0sIHlzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dPYmoob2JqQSwgb2JqQikge1xuICBpZiAodHlwZW9mIG9iakEgIT09IFwib2JqZWN0XCIgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gXCJvYmplY3RcIiB8fCBvYmpCID09PSBudWxsIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmpBKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqQikgIT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqQikubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBrZXlzQS5ldmVyeShcbiAgICAoa2V5KSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5KSAmJiBPYmplY3QuaXMob2JqQVtrZXldLCBvYmpCW2tleV0pXG4gICk7XG59XG5mdW5jdGlvbiBzaGFsbG93KGEsIGIpIHtcbiAgaWYgKE9iamVjdC5pcyhhLCBiKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgY29uc3QgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICBpZiAoaXNBcnJheUEgfHwgaXNBcnJheUIpIHtcbiAgICBpZiAoIWlzQXJyYXlBIHx8ICFpc0FycmF5Qikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2hhbGxvd0FycmF5KGEsIGIpO1xuICB9XG4gIHJldHVybiBzaGFsbG93T2JqKGEsIGIpO1xufVxuXG4vLyBzcmMvbGliL0FzeW5jQ2FjaGUudHNcbnZhciBub29wID0gKCkgPT4ge1xufTtcbmZ1bmN0aW9uIGlzU2hhbGxvd0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEuaXNMb2FkaW5nICE9PSBiLmlzTG9hZGluZyB8fCBhLmRhdGEgPT09IHZvaWQgMCAhPT0gKGIuZGF0YSA9PT0gdm9pZCAwKSB8fCBhLmVycm9yID09PSB2b2lkIDAgIT09IChiLmVycm9yID09PSB2b2lkIDApKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzaGFsbG93KGEuZGF0YSwgYi5kYXRhKSAmJiBzaGFsbG93KGEuZXJyb3IsIGIuZXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZUl0ZW0oa2V5LCBhc3luY0Z1bmN0aW9uLCBvcHRpb25zKSB7XG4gIGNvbnN0ICRhc3luY0Z1bmN0aW9uID0gYXN5bmMgKCkgPT4gYXN5bmNGdW5jdGlvbihrZXkpO1xuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIGlzSW52YWxpZDogdHJ1ZVxuICB9O1xuICBsZXQgc3RhdGUgPSB7IGlzTG9hZGluZzogZmFsc2UgfTtcbiAgbGV0IHByZXZpb3VzU3RhdGUgPSB7IGlzTG9hZGluZzogZmFsc2UgfTtcbiAgY29uc3QgZXZlbnRTb3VyY2UyID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICBjb25zdCBpc0VxdWFsID0gb3B0aW9ucz8uaXNTdGF0ZUVxdWFsID8/IGlzU2hhbGxvd0VxdWFsO1xuICAgIGlmICghaXNFcXVhbChwcmV2aW91c1N0YXRlLCBzdGF0ZSkpIHtcbiAgICAgIHByZXZpb3VzU3RhdGUgPSBzdGF0ZTtcbiAgICAgIGV2ZW50U291cmNlMi5ub3RpZnkoc3RhdGUpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIGlmICghY29udGV4dC5wcm9taXNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgY29udGV4dC5wcm9taXNlO1xuICAgICAgY29udGV4dC5pc0ludmFsaWQgPSBmYWxzZTtcbiAgICAgIHN0YXRlID0ge1xuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBkYXRhXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yMykge1xuICAgICAgc3RhdGUgPSB7XG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGRhdGE6IHN0YXRlLmRhdGEsXG4gICAgICAgIGVycm9yOiBlcnJvcjNcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnRleHQucHJvbWlzZSA9IHZvaWQgMDtcbiAgICBub3RpZnkoKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZXZhbGlkYXRlKCkge1xuICAgIGNvbnRleHQuaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICByZXR1cm4gZ2V0KCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmIChjb250ZXh0LmlzSW52YWxpZCkge1xuICAgICAgaWYgKCFjb250ZXh0LnByb21pc2UpIHtcbiAgICAgICAgY29udGV4dC5pc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICBjb250ZXh0LnByb21pc2UgPSAkYXN5bmNGdW5jdGlvbigpO1xuICAgICAgICBzdGF0ZSA9IHsgaXNMb2FkaW5nOiB0cnVlLCBkYXRhOiBzdGF0ZS5kYXRhIH07XG4gICAgICAgIG5vdGlmeSgpO1xuICAgICAgfVxuICAgICAgYXdhaXQgcmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0U3RhdGUoKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5ldmVudFNvdXJjZTIub2JzZXJ2YWJsZSxcbiAgICBnZXQsXG4gICAgZ2V0U3RhdGUsXG4gICAgcmV2YWxpZGF0ZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQXN5bmNDYWNoZShhc3luY0Z1bmN0aW9uLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZnVuY3Rpb24gY3JlYXRlKGtleSkge1xuICAgIGxldCBjYWNoZUl0ZW0gPSBjYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoY2FjaGVJdGVtKSB7XG4gICAgICByZXR1cm4gY2FjaGVJdGVtO1xuICAgIH1cbiAgICBjYWNoZUl0ZW0gPSBjcmVhdGVDYWNoZUl0ZW0oa2V5LCBhc3luY0Z1bmN0aW9uLCBvcHRpb25zKTtcbiAgICBjYWNoZS5zZXQoa2V5LCBjYWNoZUl0ZW0pO1xuICAgIHJldHVybiBjYWNoZUl0ZW07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHJldHVybiBjcmVhdGUoa2V5KS5nZXQoKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRTdGF0ZShrZXkpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk/LmdldFN0YXRlKCk7XG4gIH1cbiAgZnVuY3Rpb24gcmV2YWxpZGF0ZShrZXkpIHtcbiAgICByZXR1cm4gY3JlYXRlKGtleSkucmV2YWxpZGF0ZSgpO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShrZXksIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGNyZWF0ZShrZXkpLnN1YnNjcmliZShjYWxsYmFjaykgPz8gbm9vcDtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmVPbmNlKGtleSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gY3JlYXRlKGtleSkuc3Vic2NyaWJlT25jZShjYWxsYmFjaykgPz8gbm9vcDtcbiAgfVxuICBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGNhY2hlLmNsZWFyKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGUsXG4gICAgZ2V0LFxuICAgIGdldFN0YXRlLFxuICAgIHJldmFsaWRhdGUsXG4gICAgc3Vic2NyaWJlLFxuICAgIHN1YnNjcmliZU9uY2UsXG4gICAgaGFzLFxuICAgIGNsZWFyXG4gIH07XG59XG5cbi8vIHNyYy9saWIvUG9sbGVyLnRzXG5mdW5jdGlvbiBtYWtlUG9sbGVyKGNhbGxiYWNrKSB7XG4gIGxldCBjb250ZXh0ID0ge1xuICAgIHN0YXRlOiBcInN0b3BwZWRcIixcbiAgICB0aW1lb3V0SGFuZGxlOiBudWxsLFxuICAgIGludGVydmFsOiBudWxsLFxuICAgIGxhc3RTY2hlZHVsZWRBdDogbnVsbCxcbiAgICByZW1haW5pbmdJbnRlcnZhbDogbnVsbFxuICB9O1xuICBmdW5jdGlvbiBwb2xsKCkge1xuICAgIGlmIChjb250ZXh0LnN0YXRlID09PSBcInJ1bm5pbmdcIikge1xuICAgICAgc2NoZWR1bGUoY29udGV4dC5pbnRlcnZhbCk7XG4gICAgfVxuICAgIHZvaWQgY2FsbGJhY2soKTtcbiAgfVxuICBmdW5jdGlvbiBzY2hlZHVsZShpbnRlcnZhbCkge1xuICAgIGNvbnRleHQgPSB7XG4gICAgICBzdGF0ZTogXCJydW5uaW5nXCIsXG4gICAgICBpbnRlcnZhbDogY29udGV4dC5zdGF0ZSAhPT0gXCJzdG9wcGVkXCIgPyBjb250ZXh0LmludGVydmFsIDogaW50ZXJ2YWwsXG4gICAgICBsYXN0U2NoZWR1bGVkQXQ6IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgdGltZW91dEhhbmRsZTogc2V0VGltZW91dChwb2xsLCBpbnRlcnZhbCksXG4gICAgICByZW1haW5pbmdJbnRlcnZhbDogbnVsbFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc2NoZWR1bGVSZW1haW5pbmcocmVtYWluaW5nKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgIT09IFwicGF1c2VkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dCA9IHtcbiAgICAgIHN0YXRlOiBcInJ1bm5pbmdcIixcbiAgICAgIGludGVydmFsOiBjb250ZXh0LmludGVydmFsLFxuICAgICAgbGFzdFNjaGVkdWxlZEF0OiBjb250ZXh0Lmxhc3RTY2hlZHVsZWRBdCxcbiAgICAgIHRpbWVvdXRIYW5kbGU6IHNldFRpbWVvdXQocG9sbCwgcmVtYWluaW5nKSxcbiAgICAgIHJlbWFpbmluZ0ludGVydmFsOiBudWxsXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzdGFydChpbnRlcnZhbCkge1xuICAgIGlmIChjb250ZXh0LnN0YXRlID09PSBcInJ1bm5pbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzY2hlZHVsZShpbnRlcnZhbCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVzdGFydChpbnRlcnZhbCkge1xuICAgIHN0b3AoKTtcbiAgICBzdGFydChpbnRlcnZhbCk7XG4gIH1cbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgIT09IFwicnVubmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyVGltZW91dChjb250ZXh0LnRpbWVvdXRIYW5kbGUpO1xuICAgIGNvbnRleHQgPSB7XG4gICAgICBzdGF0ZTogXCJwYXVzZWRcIixcbiAgICAgIGludGVydmFsOiBjb250ZXh0LmludGVydmFsLFxuICAgICAgbGFzdFNjaGVkdWxlZEF0OiBjb250ZXh0Lmxhc3RTY2hlZHVsZWRBdCxcbiAgICAgIHRpbWVvdXRIYW5kbGU6IG51bGwsXG4gICAgICByZW1haW5pbmdJbnRlcnZhbDogY29udGV4dC5pbnRlcnZhbCAtIChwZXJmb3JtYW5jZS5ub3coKSAtIGNvbnRleHQubGFzdFNjaGVkdWxlZEF0KVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgIGlmIChjb250ZXh0LnN0YXRlICE9PSBcInBhdXNlZFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlUmVtYWluaW5nKGNvbnRleHQucmVtYWluaW5nSW50ZXJ2YWwpO1xuICB9XG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgPT09IFwic3RvcHBlZFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb250ZXh0LnRpbWVvdXRIYW5kbGUpIHtcbiAgICAgIGNsZWFyVGltZW91dChjb250ZXh0LnRpbWVvdXRIYW5kbGUpO1xuICAgIH1cbiAgICBjb250ZXh0ID0ge1xuICAgICAgc3RhdGU6IFwic3RvcHBlZFwiLFxuICAgICAgaW50ZXJ2YWw6IG51bGwsXG4gICAgICBsYXN0U2NoZWR1bGVkQXQ6IG51bGwsXG4gICAgICB0aW1lb3V0SGFuZGxlOiBudWxsLFxuICAgICAgcmVtYWluaW5nSW50ZXJ2YWw6IG51bGxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RhcnQsXG4gICAgcmVzdGFydCxcbiAgICBwYXVzZSxcbiAgICByZXN1bWUsXG4gICAgc3RvcFxuICB9O1xufVxuXG4vLyBzcmMvbGliL3N0cmluZ2lmeS50c1xuZnVuY3Rpb24gc3RyaW5naWZ5KG9iamVjdCwgLi4uYXJncykge1xuICBpZiAodHlwZW9mIG9iamVjdCAhPT0gXCJvYmplY3RcIiB8fCBvYmplY3QgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iamVjdCwgLi4uYXJncyk7XG4gIH1cbiAgY29uc3Qgc29ydGVkT2JqZWN0ID0gT2JqZWN0LmtleXMob2JqZWN0KS5zb3J0KCkucmVkdWNlKFxuICAgIChzb3J0ZWRPYmplY3QyLCBrZXkpID0+IHtcbiAgICAgIHNvcnRlZE9iamVjdDJba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgcmV0dXJuIHNvcnRlZE9iamVjdDI7XG4gICAgfSxcbiAgICB7fVxuICApO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc29ydGVkT2JqZWN0LCAuLi5hcmdzKTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5kZXRlY3REdXBlcyhQS0dfTkFNRSwgUEtHX1ZFUlNJT04sIFBLR19GT1JNQVQpO1xuZXhwb3J0IHtcbiAgQ2xpZW50TXNnQ29kZSxcbiAgQ29tbWVudHNBcGlFcnJvcixcbiAgQ3JkdFR5cGUsXG4gIExpdmVMaXN0LFxuICBMaXZlTWFwLFxuICBMaXZlT2JqZWN0LFxuICBPcENvZGUsXG4gIFNlcnZlck1zZ0NvZGUsXG4gIFdlYnNvY2tldENsb3NlQ29kZXMsXG4gIGFja09wLFxuICBhc1BvcyxcbiAgYXNzZXJ0LFxuICBhc3NlcnROZXZlcixcbiAgYjY0ZGVjb2RlLFxuICBjbG9uZUxzb24sXG4gIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyBhcyBjb25zb2xlLFxuICBjb252ZXJ0VG9Db21tZW50RGF0YSxcbiAgY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbixcbiAgY29udmVydFRvVGhyZWFkRGF0YSxcbiAgY3JlYXRlQXN5bmNDYWNoZSxcbiAgY3JlYXRlQ2xpZW50LFxuICBjcmVhdGVDb21tZW50c0FwaSxcbiAgZGVwcmVjYXRlLFxuICBkZXByZWNhdGVJZixcbiAgZGV0ZWN0RHVwZXMsXG4gIGVycm9ySWYsXG4gIGZyZWV6ZSxcbiAgZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5LFxuICBpc0NoaWxkQ3JkdCxcbiAgaXNKc29uQXJyYXksXG4gIGlzSnNvbk9iamVjdCxcbiAgaXNKc29uU2NhbGFyLFxuICBpc0xpdmVOb2RlLFxuICBpc1BsYWluT2JqZWN0LFxuICBpc1Jvb3RDcmR0LFxuICBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3QsXG4gIGxzb25Ub0pzb24sXG4gIG1ha2VFdmVudFNvdXJjZSxcbiAgbWFrZVBvbGxlcixcbiAgbWFrZVBvc2l0aW9uLFxuICBubixcbiAgcGF0Y2hMaXZlT2JqZWN0S2V5LFxuICByYWlzZSxcbiAgc2hhbGxvdyxcbiAgc3RyaW5naWZ5LFxuICBzdHJpbmdpZnlDb21tZW50Qm9keSxcbiAgdGhyb3dVc2FnZUVycm9yLFxuICB0b1BsYWluTHNvbixcbiAgdHJ5UGFyc2VKc29uLFxuICB3aXRoVGltZW91dFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJnZXQiLCJlbnVtZXJhYmxlIiwiUEtHX05BTUUiLCJQS0dfVkVSU0lPTiIsIlBLR19GT1JNQVQiLCJnIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsImdsb2JhbCIsImNyb3NzTGlua2VkRG9jcyIsImR1cGVzRG9jcyIsIlNQQUNFIiwiZXJyb3IiLCJtc2ciLCJwcm9jZXNzIiwiY29uc29sZSIsIkVycm9yIiwiZGV0ZWN0RHVwZXMiLCJwa2dOYW1lIiwicGtnVmVyc2lvbiIsInBrZ0Zvcm1hdCIsInBrZ0lkIiwiU3ltYm9sIiwiZm9yIiwicGtnQnVpbGRJbmZvIiwiam9pbiIsImFzc2VydE5ldmVyIiwiX3ZhbHVlIiwiZXJybXNnIiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwiZXJyIiwibm4iLCJ2YWx1ZSIsImNvbnRyb2xsZWRQcm9taXNlIiwiZmxhZ2dlciIsInByb21pc2UiLCJQcm9taXNlIiwicmVzIiwibWFrZUV2ZW50U291cmNlIiwiX29uZXRpbWVPYnNlcnZlcnMiLCJTZXQiLCJfb2JzZXJ2ZXJzIiwiX2J1ZmZlciIsInBhdXNlIiwidW5wYXVzZSIsImV2ZW50Iiwibm90aWZ5Iiwic3Vic2NyaWJlIiwiY2FsbGJhY2siLCJhZGQiLCJkZWxldGUiLCJzdWJzY3JpYmVPbmNlIiwid2FpdFVudGlsIiwicHJlZGljYXRlIiwidW5zdWIiLCJmaW5hbGx5Iiwibm90aWZ5T3JCdWZmZXIiLCJwdXNoIiwiZm9yRWFjaCIsImNsZWFyIiwiY291bnQiLCJzaXplIiwib2JzZXJ2YWJsZSIsImZhbmN5X2NvbnNvbGVfZXhwb3J0cyIsImVycm9yMiIsImVycm9yV2l0aFRpdGxlIiwid2FybiIsIndhcm5XaXRoVGl0bGUiLCJiYWRnZSIsImJvbGQiLCJ3cmFwIiwibWV0aG9kIiwibWVzc2FnZSIsImFyZ3MiLCJ3cmFwV2l0aFRpdGxlIiwidGl0bGUiLCJkaXN0YW5jZSIsInN0YXRlMSIsInN0YXRlMiIsImNodW5rczEiLCJzcGxpdCIsImNodW5rczIiLCJtaW5MZW4iLCJNYXRoIiwibWluIiwibGVuZ3RoIiwic2hhcmVkIiwidXAiLCJkb3duIiwicGF0dGVybnMiLCJ0YXJnZXRTdGF0ZSIsImxldmVscyIsInBhcnRzIiwicmVzdWx0IiwiaSIsInNsaWNlIiwiU2FmZUNvbnRleHQiLCJjdXJyZW50IiwiY3VyciIsImFsbG93UGF0Y2hpbmciLCJzZWxmIiwiYWxsb3dlZCIsInBhdGNoYWJsZUNvbnRleHQiLCJwYXRjaCIsImFzc2lnbiIsInBhaXIiLCJlbnRyaWVzIiwia2V5IiwiY29uc3RydWN0b3IiLCJpbml0aWFsQ29udGV4dCIsIm5leHRJZCIsIkZTTSIsImluaXRpYWxTdGF0ZSIsInN0YXRlcyIsInZhbHVlcyIsIml0ZXJhdG9yIiwibmV4dCIsImRvbmUiLCJjdXJyZW50U3RhdGUiLCJjdXJyZW50U3RhdGVPck51bGwiLCJydW5uaW5nU3RhdGUiLCJzdGFydCIsImVudGVyIiwic3RvcCIsImV4aXQiLCJjb250ZXh0IiwiY3VycmVudENvbnRleHQiLCJhZGRTdGF0ZSIsInN0YXRlIiwib25FbnRlciIsIm5hbWVPclBhdHRlcm4iLCJlbnRlckZuIiwiZW50ZXJGbnMiLCJoYXMiLCJzZXQiLCJvbkVudGVyQXN5bmMiLCJwcm9taXNlRm4iLCJvbk9LIiwib25FcnJvciIsImNhbmNlbGxlZCIsInRoZW4iLCJkYXRhIiwidHJhbnNpdGlvbiIsInR5cGUiLCJyZWFzb24iLCJnZXRTdGF0ZXNNYXRjaGluZyIsIm1hdGNoZXMiLCJlbmRzV2l0aCIsInByZWZpeCIsInN0YXJ0c1dpdGgiLCJKU09OIiwic3RyaW5naWZ5IiwiYWRkVHJhbnNpdGlvbnMiLCJtYXBwaW5nIiwic3JjU3RhdGUiLCJtYXAiLCJhbGxvd2VkVHJhbnNpdGlvbnMiLCJNYXAiLCJ0YXJnZXRfIiwia25vd25FdmVudFR5cGVzIiwidGFyZ2V0Rm4iLCJhZGRUaW1lZFRyYW5zaXRpb24iLCJzdGF0ZU9yUGF0dGVybiIsImFmdGVyMiIsIm1zIiwidGltZW91dElEIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsImdldFRhcmdldEZuIiwiZXZlbnROYW1lIiwiZXZlbnRIdWIiLCJ3aWxsRXhpdFN0YXRlIiwiY2xlYW51cFN0YWNrIiwicG9wIiwiZW50ZXJQYXR0ZXJucyIsInBhdHRlcm4iLCJjbGVhbnVwRm4iLCJkaWRFbnRlclN0YXRlIiwic2VuZCIsImRpZElnbm9yZUV2ZW50IiwiZGlkUmVjZWl2ZUV2ZW50Iiwib2xkU3RhdGUiLCJuZXh0VGFyZ2V0IiwibmV4dFN0YXRlIiwiZWZmZWN0cyIsIkFycmF5IiwiaXNBcnJheSIsImVmZmVjdCIsIndpbGxUcmFuc2l0aW9uIiwiZnJvbSIsInRvIiwiZWZmZWN0c1RvUnVuIiwiaWQiLCJldmVudHMiLCJyYWlzZSIsImlzUGxhaW5PYmplY3QiLCJibG9iIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwib2JqIiwidHJ5UGFyc2VKc29uIiwicmF3TWVzc2FnZSIsInBhcnNlIiwiZSIsImRlZXBDbG9uZSIsImI2NGRlY29kZSIsImI2NHZhbHVlIiwiZm9ybWF0dGVkVmFsdWUiLCJyZXBsYWNlIiwiZGVjb2RlZFZhbHVlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiYXRvYiIsImMiLCJjaGFyQ29kZUF0IiwiY29tcGFjdCIsIml0ZW1zIiwiZmlsdGVyIiwiaXRlbSIsImNvbXBhY3RPYmplY3QiLCJuZXdPYmoiLCJrZXlzIiwiayIsIndpdGhUaW1lb3V0IiwibWlsbGlzIiwidGltZXJJRCIsInRpbWVyJCIsIl8iLCJyZWplY3QiLCJyYWNlIiwiU2VydmVyTXNnQ29kZSIsIlNlcnZlck1zZ0NvZGUyIiwiV2Vic29ja2V0Q2xvc2VDb2RlcyIsIldlYnNvY2tldENsb3NlQ29kZXMyIiwic2hvdWxkRGlzY29ubmVjdCIsImNvZGUiLCJzaG91bGRSZWF1dGgiLCJzaG91bGRSZXRyeVdpdGhvdXRSZWF1dGgiLCJpc0lkbGUiLCJzdGF0dXMiLCJuZXdUb0xlZ2FjeVN0YXR1cyIsInRvTmV3Q29ubmVjdGlvblN0YXR1cyIsIm1hY2hpbmUiLCJzdWNjZXNzQ291bnQiLCJCQUNLT0ZGX0RFTEFZUyIsIlJFU0VUX0RFTEFZIiwiQkFDS09GRl9ERUxBWVNfU0xPVyIsIkhFQVJUQkVBVF9JTlRFUlZBTCIsIlBPTkdfVElNRU9VVCIsIkFVVEhfVElNRU9VVCIsIlNPQ0tFVF9DT05ORUNUX1RJTUVPVVQiLCJTdG9wUmV0cnlpbmciLCJMaXZlYmxvY2tzRXJyb3IiLCJuZXh0QmFja29mZkRlbGF5IiwiY3VycmVudERlbGF5IiwiZGVsYXlzIiwiZmluZCIsImRlbGF5IiwiaW5jcmVhc2VCYWNrb2ZmRGVsYXkiLCJiYWNrb2ZmRGVsYXkiLCJpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseSIsInJlc2V0U3VjY2Vzc0NvdW50IiwibG9nIiwibGV2ZWwiLCJsb2dnZXIiLCJsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudCIsImNvbm4iLCJjdHgiLCJTdHJpbmciLCJpc0Nsb3NlRXZlbnQiLCJsb2dDbG9zZUV2ZW50IiwibG9nUGVybWFuZW50Q2xvc2UiLCJlcnJvcjMiLCJlbmFibGVUcmFjaW5nIiwiRGF0ZSIsImdldFRpbWUiLCJsb2cyIiwidG9GaXhlZCIsInVuc3VicyIsImRlZmluZUNvbm5lY3Rpdml0eUV2ZW50cyIsInN0YXR1c0RpZENoYW5nZSIsImRpZENvbm5lY3QiLCJkaWREaXNjb25uZWN0IiwibGFzdFN0YXR1cyIsInVuc3Vic2NyaWJlIiwiY3VyclN0YXR1cyIsImNyZWF0ZUNvbm5lY3Rpb25TdGF0ZU1hY2hpbmUiLCJkZWxlZ2F0ZXMiLCJvcHRpb25zIiwib25NZXNzYWdlIiwib25MaXZlYmxvY2tzRXJyb3IiLCJmaXJlRXJyb3JFdmVudCIsImVycmNvZGUiLCJhdXRoVmFsdWUiLCJzb2NrZXQiLCJSRUNPTk5FQ1QiLCJESVNDT05ORUNUIiwiQ09OTkVDVCIsIk5BVklHQVRPUl9PTkxJTkUiLCJhdXRoZW50aWNhdGUiLCJva0V2ZW50IiwiZmFpbGVkRXZlbnQiLCJvblNvY2tldEVycm9yIiwib25Tb2NrZXRDbG9zZSIsIm9uU29ja2V0TWVzc2FnZSIsInRlYXJkb3duU29ja2V0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsb3NlIiwiY2FwdHVyZWRQcmVtYXR1cmVFdmVudCIsImNvbm5lY3QkIiwicmVzb2x2ZSIsInJlaiIsImNyZWF0ZVNvY2tldCIsImFjdG9yJCIsImRpZFJlY2VpdmVBY3RvciIsIndhaXRGb3JBY3RvcklkIiwic2VydmVyTXNnIiwiYWRkRXZlbnRMaXN0ZW5lciIsImZhaWx1cmUiLCJzZW5kSGVhcnRiZWF0IiwibWF5YmVIZWFydGJlYXQiLCJkb2MiLCJkb2N1bWVudCIsImNhblpvbWJpZSIsInZpc2liaWxpdHlTdGF0ZSIsIk5BVklHQVRPUl9PRkZMSU5FIiwiV0lORE9XX0dPVF9GT0NVUyIsImN0eDIiLCJQT05HIiwiRVhQTElDSVRfU09DS0VUX0VSUk9SIiwicmVhZHlTdGF0ZSIsIkVYUExJQ0lUX1NPQ0tFVF9DTE9TRSIsIndpbiIsInJvb3QiLCJvbk5ldHdvcmtPZmZsaW5lIiwib25OZXR3b3JrQmFja09ubGluZSIsIm9uVmlzaWJpbGl0eUNoYW5nZSIsImNsZWFudXBzIiwiZW5hYmxlRGVidWdMb2dnaW5nIiwiTWFuYWdlZFNvY2tldCIsImdldExlZ2FjeVN0YXR1cyIsImdldFN0YXR1cyIsImNvbm5lY3QiLCJyZWNvbm5lY3QiLCJkaXNjb25uZWN0IiwiZGVzdHJveSIsImNsZWFudXAiLCJfcHJpdmF0ZVNlbmRNYWNoaW5lRXZlbnQiLCJjYW5Xcml0ZVN0b3JhZ2UiLCJzY29wZXMiLCJpbmNsdWRlcyIsImNhbkNvbW1lbnQiLCJpc1ZhbGlkQXV0aFRva2VuUGF5bG9hZCIsInBhcnNlQXV0aFRva2VuIiwicmF3VG9rZW5TdHJpbmciLCJ0b2tlblBhcnRzIiwicGF5bG9hZCIsInJhdyIsInBhcnNlZCIsImNyZWF0ZUF1dGhNYW5hZ2VyIiwiYXV0aE9wdGlvbnMiLCJhdXRoZW50aWNhdGlvbiIsInByZXBhcmVBdXRoZW50aWNhdGlvbiIsInNlZW5Ub2tlbnMiLCJ0b2tlbnMiLCJleHBpcnlUaW1lcyIsInJlcXVlc3RQcm9taXNlcyIsInJlc2V0IiwiaGFzQ29ycmVzcG9uZGluZ1Njb3BlcyIsInJlcXVlc3RlZFNjb3BlIiwiZ2V0Q2FjaGVkVG9rZW4iLCJyb29tSWQiLCJub3ciLCJjZWlsIiwidG9rZW4iLCJleHBpcmVzQXQiLCJzcGxpY2UiLCJyZXNvdXJjZSIsInBlcm1zIiwibWFrZUF1dGhSZXF1ZXN0IiwiZmV0Y2hlciIsInBvbHlmaWxscyIsImZldGNoIiwicmVzcG9uc2UiLCJmZXRjaEF1dGhFbmRwb2ludCIsInVybCIsInJvb20iLCJnZXRBdXRoVmFsdWUiLCJwdWJsaWNBcGlLZXkiLCJjYWNoZWRUb2tlbiIsImN1cnJlbnRQcm9taXNlIiwiQlVGRkVSIiwiZmxvb3IiLCJleHAiLCJpYXQiLCJhdXRoRW5kcG9pbnQiLCJmZXRjaDIiLCJlbmRwb2ludCIsImJvZHkiLCJoZWFkZXJzIiwib2siLCJ0ZXh0IiwidHJpbSIsImpzb24iLCJlciIsIkRFRkFVTFRfQkFTRV9VUkwiLCJfYnJpZGdlQWN0aXZlIiwiYWN0aXZhdGVCcmlkZ2UiLCJzZW5kVG9QYW5lbCIsImZ1bGxNc2ciLCJzb3VyY2UiLCJmb3JjZSIsInBvc3RNZXNzYWdlIiwiZXZlbnRTb3VyY2UiLCJvbk1lc3NhZ2VGcm9tUGFuZWwiLCJWRVJTSU9OIiwiX2RldnRvb2xzU2V0dXBIYXNSdW4iLCJzZXR1cERldlRvb2xzIiwiZ2V0QWxsUm9vbXMiLCJjbGllbnRWZXJzaW9uIiwidW5zdWJzQnlSb29tSWQiLCJzdG9wU3luY1N0cmVhbSIsInN0YXJ0U3luY1N0cmVhbSIsImZ1bGxTeW5jIiwicGFydGlhbFN5bmNDb25uZWN0aW9uIiwic3RvcmFnZURpZExvYWQiLCJwYXJ0aWFsU3luY1N0b3JhZ2UiLCJzdG9yYWdlIiwicGFydGlhbFN5bmNNZSIsIm90aGVycyIsInBhcnRpYWxTeW5jT3RoZXJzIiwieWRvYyIsInVwZGF0ZSIsInN5bmNZZG9jVXBkYXRlIiwiY3VzdG9tRXZlbnQiLCJldmVudERhdGEiLCJmb3J3YXJkRXZlbnQiLCJsb2FkZWRBdCIsImV2ZW50Q291bnRlciIsIm5leHRFdmVudElkIiwiY29ubmVjdGlvbklkIiwiZ2V0U3RvcmFnZVNuYXBzaG90IiwidG9UcmVlTm9kZSIsIm1lIiwiX19pbnRlcm5hbCIsImdldFNlbGZfZm9yRGV2VG9vbHMiLCJnZXRPdGhlcnNfZm9yRGV2VG9vbHMiLCJmZXRjaFlEb2MiLCJyb29tQ2hhbm5lbExpc3RlbmVycyIsInN0b3BSb29tQ2hhbm5lbExpc3RlbmVyIiwibGlzdGVuZXIiLCJsaW5rRGV2VG9vbHMiLCJ1bmxpbmtEZXZUb29scyIsIl9lbWl0dGVkRGVwcmVjYXRpb25XYXJuaW5ncyIsImRlcHJlY2F0ZSIsImRlcHJlY2F0ZUlmIiwidGhyb3dVc2FnZUVycm9yIiwidXNhZ2VFcnJvciIsImVycm9ySWYiLCJpc0NvbW1lbnRCb2R5UGFyYWdyYXBoIiwiZWxlbWVudCIsImlzQ29tbWVudEJvZHlUZXh0IiwiaXNDb21tZW50Qm9keU1lbnRpb24iLCJpc0NvbW1lbnRCb2R5TGluayIsImNvbW1lbnRCb2R5RWxlbWVudHNHdWFyZHMiLCJwYXJhZ3JhcGgiLCJsaW5rIiwibWVudGlvbiIsImNvbW1lbnRCb2R5RWxlbWVudHNUeXBlcyIsInRyYXZlcnNlQ29tbWVudEJvZHkiLCJlbGVtZW50T3JWaXNpdG9yIiwicG9zc2libHlWaXNpdG9yIiwiY29udGVudCIsImd1YXJkIiwidmlzaXRvciIsImJsb2NrIiwiaW5saW5lIiwiY2hpbGRyZW4iLCJnZXRNZW50aW9uZWRJZHNGcm9tQ29tbWVudEJvZHkiLCJtZW50aW9uZWRJZHMiLCJyZXNvbHZlVXNlcnNJbkNvbW1lbnRCb2R5IiwicmVzb2x2ZVVzZXJzIiwicmVzb2x2ZWRVc2VycyIsInVzZXJJZHMiLCJ1c2VycyIsImluZGV4IiwidXNlcklkIiwidXNlciIsImh0bWxFc2NhcGFibGVzIiwiaHRtbEVzY2FwYWJsZXNSZWdleCIsIlJlZ0V4cCIsImVudGl0eSIsImh0bWxTYWZlIiwiSHRtbFNhZmVTdHJpbmciLCJqb2luSHRtbCIsInN0cmluZ3MiLCJmaWxsIiwiZXNjYXBlSHRtbCIsImNoYXJhY3RlciIsIl9zdHJpbmdzIiwicmVkdWNlIiwic3RyIiwiX3ZhbHVlcyIsImh0bWwiLCJtYXJrZG93bkVzY2FwYWJsZXMiLCJtYXJrZG93bkVzY2FwYWJsZXNSZWdleCIsImpvaW5NYXJrZG93biIsIk1hcmtkb3duU2FmZVN0cmluZyIsImVzY2FwZU1hcmtkb3duIiwibWFya2Rvd24iLCJ0b0Fic29sdXRlVXJsIiwic3RyaW5naWZ5Q29tbWVudEJvZHlQbGFpbkVsZW1lbnRzIiwic3RyaW5naWZ5Q29tbWVudEJvZHlIdG1sRWxlbWVudHMiLCJpdGFsaWMiLCJzdHJpa2V0aHJvdWdoIiwiaHJlZiIsInN0cmluZ2lmeUNvbW1lbnRCb2R5TWFya2Rvd25FbGVtZW50cyIsInN0cmluZ2lmeUNvbW1lbnRCb2R5IiwiZm9ybWF0Iiwic2VwYXJhdG9yIiwiZWxlbWVudHMiLCJibG9ja3MiLCJmbGF0TWFwIiwiYmxvY2tJbmRleCIsImlubGluZXMiLCJpbmxpbmVJbmRleCIsImNvbnZlcnRUb0NvbW1lbnREYXRhIiwiZWRpdGVkQXQiLCJjcmVhdGVkQXQiLCJyZWFjdGlvbnMiLCJyZWFjdGlvbiIsImRlbGV0ZWRBdCIsImNvbnZlcnRUb1RocmVhZERhdGEiLCJ1cGRhdGVkQXQiLCJjb21tZW50cyIsImNvbW1lbnQiLCJjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uIiwiZ2V0QXV0aEJlYXJlckhlYWRlckZyb21BdXRoVmFsdWUiLCJDb21tZW50c0FwaUVycm9yIiwiZGV0YWlscyIsImNyZWF0ZUNvbW1lbnRzQXBpIiwiY29uZmlnIiwiZmV0Y2hKc29uIiwiZmV0Y2hBcGkiLCJlcnJvckJvZHkiLCJzdGF0dXNUZXh0Iiwicm9vbUlkMiIsIlVSTCIsImVuY29kZVVSSUNvbXBvbmVudCIsImJhc2VVcmwiLCJBdXRob3JpemF0aW9uIiwiZ2V0VGhyZWFkcyIsInF1ZXJ5IiwibWV0YWRhdGEiLCJ0aHJlYWQiLCJjcmVhdGVUaHJlYWQiLCJjb21tZW50SWQiLCJ0aHJlYWRJZCIsImVkaXRUaHJlYWRNZXRhZGF0YSIsImNyZWF0ZUNvbW1lbnQiLCJlZGl0Q29tbWVudCIsImRlbGV0ZUNvbW1lbnQiLCJhZGRSZWFjdGlvbiIsImVtb2ppIiwicmVtb3ZlUmVhY3Rpb24iLCJNSU5fQ09ERSIsIk1BWF9DT0RFIiwiTlVNX0RJR0lUUyIsIlpFUk8iLCJudGhEaWdpdCIsIk9ORSIsIlpFUk9fTklORSIsIm4iLCJmcm9tQ2hhckNvZGUiLCJtYWtlUG9zaXRpb24iLCJ4IiwieSIsImJldHdlZW4iLCJhZnRlciIsImJlZm9yZSIsInBvcyIsImxhc3RJbmRleCIsInN1YnN0cmluZyIsImxvIiwiaGkiLCJfYmV0d2VlbiIsImxvTGVuIiwiaGlMZW4iLCJsb0NvZGUiLCJoaUNvZGUiLCJyZXBlYXQiLCJzdWZmaXgiLCJuaW5lcyIsInRha2VOIiwiTUlOX05PTl9aRVJPX0NPREUiLCJpc1BvcyIsImxhc3RJZHgiLCJsYXN0IiwiY29udmVydFRvUG9zIiwiY29kZXMiLCJhc1BvcyIsIk9wQ29kZSIsIk9wQ29kZTIiLCJhY2tPcCIsIm9wSWQiLCJpc0Fja09wIiwib3AiLCJjcmR0QXNMaXZlTm9kZSIsIkhhc1BhcmVudCIsIm5vZGUiLCJmcmVlemUiLCJOb1BhcmVudCIsIk9ycGhhbmVkIiwib2xkS2V5Iiwib2xkUG9zIiwiQWJzdHJhY3RDcmR0IiwiX2dldFBhcmVudEtleU9yVGhyb3ciLCJwYXJlbnQiLCJfcGFyZW50UG9zIiwiX3Bvb2wiLCJfX3Bvb2wiLCJfaWQiLCJfX2lkIiwiX3BhcmVudCIsIl9wYXJlbnRLZXkiLCJfYXBwbHkiLCJfaXNMb2NhbCIsIl9kZXRhY2hDaGlsZCIsIm1vZGlmaWVkIiwiX3NldFBhcmVudExpbmsiLCJuZXdQYXJlbnROb2RlIiwibmV3UGFyZW50S2V5IiwiX2F0dGFjaCIsInBvb2wiLCJhZGROb2RlIiwiX2RldGFjaCIsImRlbGV0ZU5vZGUiLCJpbnZhbGlkYXRlIiwiX2NhY2hlZEltbXV0YWJsZSIsIl9jYWNoZWRUcmVlTm9kZSIsIl9jYWNoZWRUcmVlTm9kZUtleSIsIl90b1RyZWVOb2RlIiwidG9JbW11dGFibGUiLCJfdG9JbW11dGFibGUiLCJDcmR0VHlwZSIsIkNyZHRUeXBlMiIsImlzUm9vdENyZHQiLCJjcmR0IiwiaXNDaGlsZENyZHQiLCJwYXJlbnRJZCIsInBhcmVudEtleSIsIm5hbm9pZCIsImFscGhhYmV0IiwibGVuIiwiY2hhckF0IiwicmFuZG9tIiwiTGl2ZVJlZ2lzdGVyIiwiX0xpdmVSZWdpc3RlciIsIl9kYXRhIiwiX2Rlc2VyaWFsaXplIiwiX3BhcmVudFRvQ2hpbGRyZW4iLCJyZWdpc3RlciIsIl90b09wcyIsImdlbmVyYXRlT3BJZCIsIl9zZXJpYWxpemUiLCJfYXR0YWNoQ2hpbGQiLCJfb3AiLCJfY3JkdCIsImlzTG9jYWwiLCJjbG9uZSIsImNvbXBhcmVOb2RlUG9zaXRpb24iLCJpdGVtQSIsIml0ZW1CIiwicG9zQSIsInBvc0IiLCJMaXZlTGlzdCIsIl9MaXZlTGlzdCIsInBhcmVudFRvQ2hpbGRyZW4iLCJsaXN0IiwiaWQyIiwiY2hpbGQiLCJkZXNlcmlhbGl6ZSIsIl9pbnNlcnRBbmRTb3J0Iiwib3BzIiwiX2l0ZW1zIiwicGFyZW50S2V5MiIsImNoaWxkT3BzIiwiSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbiIsImNoaWxkT3BJZCIsIl91bmFja25vd2xlZGdlZFNldHMiLCJfc29ydEl0ZW1zIiwic29ydCIsIl9pbmRleE9mUG9zaXRpb24iLCJwb3NpdGlvbiIsImZpbmRJbmRleCIsImdlbmVyYXRlSWQiLCJfYXBwbHlTZXRSZW1vdGUiLCJjcmVhdGlvbk9wVG9MaXZlTm9kZSIsImRlbGV0ZWRJZCIsImluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiIsIml0ZW1XaXRoU2FtZVBvc2l0aW9uIiwibWFrZVVwZGF0ZSIsInNldERlbHRhIiwicmV2ZXJzZSIsIl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zIiwiZGVsdGEiLCJkZWxldGVEZWx0YTIiLCJfZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbiIsInVwZGF0ZXMiLCJpbnNlcnREZWx0YSIsIl9hcHBseVNldEFjayIsImRlbGV0ZWREZWx0YSIsInVuYWNrbm93bGVkZ2VkT3BJZCIsImV4aXN0aW5nSXRlbSIsImRlbGV0ZURlbHRhIiwicHJldmlvdXNJbmRleCIsImluZGV4T2YiLCJuZXdJbmRleCIsIm1vdmVEZWx0YSIsIm9ycGhhbiIsImdldE5vZGUiLCJyZWNyZWF0ZWRJdGVtSW5kZXgiLCJuZXdJdGVtIiwiX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0IiwiZGVsZXRlZEl0ZW0iLCJfYXBwbHlSZW1vdGVJbnNlcnQiLCJleGlzdGluZ0l0ZW1JbmRleCIsIl9zaGlmdEl0ZW1Qb3NpdGlvbiIsIl9hcHBseUluc2VydEFjayIsIml0ZW1JbmRleEF0UG9zaXRpb24iLCJvbGRQb3NpdGlvbkluZGV4IiwiX2FwcGx5SW5zZXJ0VW5kb1JlZG8iLCJuZXdLZXkiLCJiZWZvcmUyIiwiX2FwcGx5U2V0VW5kb1JlZG8iLCJpbmRleE9mSXRlbVdpdGhTYW1lS2V5IiwiaW50ZW50IiwiaW5kZXhUb0RlbGV0ZSIsIl9hcHBseVNldENoaWxkS2V5UmVtb3RlIiwicHJldmlvdXNLZXkiLCJfYXBwbHlTZXRDaGlsZEtleUFjayIsIl9hcHBseVNldENoaWxkS2V5VW5kb1JlZG8iLCJfc2V0Q2hpbGRLZXkiLCJhc3NlcnRTdG9yYWdlSXNXcml0YWJsZSIsImluc2VydCIsImxzb25Ub0xpdmVOb2RlIiwiZGlzcGF0Y2giLCJtb3ZlIiwidGFyZ2V0SW5kZXgiLCJiZWZvcmVQb3NpdGlvbiIsImFmdGVyUG9zaXRpb24iLCJwcmV2aW91c1Bvc2l0aW9uIiwic3RvcmFnZVVwZGF0ZXMiLCJjaGlsZFJlY29yZElkIiwicmV2ZXJzZU9wcyIsInVwZGF0ZURlbHRhIiwiY2hpbGRJZCIsImV4aXN0aW5nSWQiLCJ0b0FycmF5IiwiZW50cnkiLCJsaXZlTm9kZVRvTHNvbiIsImV2ZXJ5IiwiY2FsbGJhY2tmbiIsInNlYXJjaEVsZW1lbnQiLCJmcm9tSW5kZXgiLCJsYXN0SW5kZXhPZiIsInNvbWUiLCJMaXZlTGlzdEl0ZXJhdG9yIiwic2hpZnRlZFBvc2l0aW9uIiwiV2Vha1NldCIsIm5ld1Bvc2l0aW9uIiwiX2lubmVySXRlcmF0b3IiLCJsaXZlTGlzdCIsImRlbHRhVXBkYXRlcyIsImZpcnN0T3AiLCJMaXZlTWFwIiwiX0xpdmVNYXAiLCJfbWFwIiwiX2l0ZW0iLCJfa2V5IiwiaXNMaXZlTm9kZSIsImxhc3RVcGRhdGVPcElkIiwidW5hY2tub3dsZWRnZWRTZXQiLCJwcmV2aW91c1ZhbHVlIiwidGhpc0lkIiwic3RvcmFnZVVwZGF0ZSIsIm9sZFZhbHVlIiwiaW5uZXJJdGVyYXRvciIsIml0ZXJhdG9yVmFsdWUiLCJrZXkyIiwidmFsIiwiZW50cmllczIiLCJtYXBwZWRFbnRyaWVzIiwiTGl2ZU9iamVjdCIsIl9MaXZlT2JqZWN0IiwiX2J1aWxkUm9vdEFuZFBhcmVudFRvQ2hpbGRyZW4iLCJ0dXBsZSIsIl9mcm9tSXRlbXMiLCJsaXZlT2JqIiwiX2Rlc2VyaWFsaXplQ2hpbGRyZW4iLCJkZXNlcmlhbGl6ZVRvTHNvbiIsImlzTGl2ZVN0cnVjdHVyZSIsImNyZWF0aW9uT3BUb0xzb24iLCJfcHJvcFRvTGFzdFVwZGF0ZSIsIl9hcHBseVVwZGF0ZSIsIl9hcHBseURlbGV0ZU9iamVjdEtleSIsImlzTW9kaWZpZWQiLCJyZXZlcnNlVXBkYXRlIiwidW5zaGlmdCIsInRvT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJrZXlBc1N0cmluZyIsIm5ld1ZhbHVlIiwidXBkYXRlZFByb3BzIiwicmV2ZXJzZVVwZGF0ZU9wIiwibmV3QXR0YWNoQ2hpbGRPcHMiLCJjcmVhdGVDcmR0T3AiLCJub2RlSWQiLCJpc1NhbWVOb2RlT3JDaGlsZE9mIiwiaXNMaXZlTGlzdCIsImlzTGl2ZU1hcCIsImlzTGl2ZU9iamVjdCIsImlzTGl2ZVJlZ2lzdGVyIiwiY2xvbmVMc29uIiwiZ2V0VHJlZXNEaWZmT3BlcmF0aW9ucyIsImN1cnJlbnRJdGVtcyIsIm5ld0l0ZW1zIiwiY3VycmVudENyZHQiLCJtZXJnZU9iamVjdFN0b3JhZ2VVcGRhdGVzIiwiZmlyc3QiLCJzZWNvbmQiLCJtZXJnZU1hcFN0b3JhZ2VVcGRhdGVzIiwibWVyZ2VMaXN0U3RvcmFnZVVwZGF0ZXMiLCJjb25jYXQiLCJtZXJnZVN0b3JhZ2VVcGRhdGVzIiwiaXNQbGFpbiIsImZpbmROb25TZXJpYWxpemFibGVWYWx1ZSIsInBhdGgiLCJuZXN0ZWRWYWx1ZSIsIm5lc3RlZFBhdGgiLCJub25TZXJpYWxpemFibGVOZXN0ZWRWYWx1ZSIsImNhcHR1cmVTdGFja1RyYWNlIiwidHJhY2VSb290IiwiZXJyb3JMaWtlIiwic3RhY2siLCJpc0pzb25TY2FsYXIiLCJpc0pzb25BcnJheSIsImlzSnNvbk9iamVjdCIsIkNsaWVudE1zZ0NvZGUiLCJDbGllbnRNc2dDb2RlMiIsIm1lcmdlIiwidXBkYXRlZCIsIkltbXV0YWJsZVJlZiIsImRpZEludmFsaWRhdGUiLCJfZXYiLCJfY2FjaGUiLCJtYWtlVXNlciIsInByZXNlbmNlIiwiaW5mbyIsImNhbldyaXRlIiwiaXNSZWFkT25seSIsIk90aGVyc1JlZiIsImNvbm5lY3Rpb25JZHMiLCJfY29ubmVjdGlvbnMiLCJfcHJlc2VuY2VzIiwiZ2V0VXNlciIsIk51bWJlciIsImNsZWFyT3RoZXJzIiwiX3VzZXJzIiwiX2dldFVzZXIiLCJjYWNoZWRVc2VyIiwiY29tcHV0ZWRVc2VyIiwiX2ludmFsaWRhdGVVc2VyIiwic2V0Q29ubmVjdGlvbiIsIm1ldGFVc2VySWQiLCJtZXRhVXNlckluZm8iLCJyZW1vdmVDb25uZWN0aW9uIiwic2V0T3RoZXIiLCJwYXRjaE90aGVyIiwib2xkUHJlc2VuY2UiLCJuZXdQcmVzZW5jZSIsIlBhdGNoYWJsZVJlZiIsIm9sZERhdGEiLCJuZXdEYXRhIiwiVmFsdWVSZWYiLCJpbml0aWFsVmFsdWUiLCJEZXJpdmVkUmVmIiwiX3RyYW5zZm9ybSIsIl9yZWZzIiwicmVmIiwidHJhbnNmb3JtRm4iLCJvdGhlclJlZnMiLCJNQVhfU09DS0VUX01FU1NBR0VfU0laRSIsIm1ha2VJZEZhY3RvcnkiLCJ1c2VyVG9UcmVlTm9kZSIsImluc3RhbGxCYWNrZ3JvdW5kVGFiU3B5IiwiaW5CYWNrZ3JvdW5kU2luY2UiLCJjcmVhdGVSb29tIiwiaW5pdGlhbFByZXNlbmNlIiwiaW5pdGlhbFN0b3JhZ2UiLCJ1bmluc3RhbGxCZ1RhYlNweSIsImJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0IiwiZ2V0U3RvcmFnZVN0YXR1cyIsIm1hbmFnZWRTb2NrZXQiLCJidWZmZXIiLCJmbHVzaFRpbWVySUQiLCJsYXN0Rmx1c2hlZEF0IiwicHJlc2VuY2VVcGRhdGVzIiwibWVzc2FnZXMiLCJzdG9yYWdlT3BlcmF0aW9ucyIsInN0YXRpY1Nlc3Npb25JbmZvIiwiZHluYW1pY1Nlc3Npb25JbmZvIiwibXlQcmVzZW5jZSIsImlkRmFjdG9yeSIsImNsb2NrIiwib3BDbG9jayIsIm5vZGVzIiwidW5kb1N0YWNrIiwicmVkb1N0YWNrIiwicGF1c2VkSGlzdG9yeSIsImFjdGl2ZUJhdGNoIiwidW5hY2tub3dsZWRnZWRPcHMiLCJvcFN0YWNrVHJhY2VzIiwiZG9Ob3RCYXRjaFVwZGF0ZXMiLCJjYiIsImJhdGNoVXBkYXRlcyIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwibGFzdFRva2VuS2V5Iiwib25TdGF0dXNEaWRDaGFuZ2UiLCJuZXdTdGF0dXMiLCJ0b2tlbktleSIsInVpZCIsInVzZXJJbmZvIiwidWkiLCJub3RpZnlTZWxmQ2hhbmdlZCIsIl9jb25uZWN0aW9uTG9zc1RpbWVySWQiLCJfaGFzTG9zdENvbm5lY3Rpb24iLCJoYW5kbGVDb25uZWN0aW9uTG9zc0V2ZW50IiwibG9zdENvbm5lY3Rpb24iLCJsb3N0Q29ubmVjdGlvblRpbWVvdXQiLCJvbkRpZENvbm5lY3QiLCJfZ2V0U3RvcmFnZSQiLCJyZWZyZXNoU3RvcmFnZSIsImZsdXNoIiwiZmx1c2hOb3dPclNvb24iLCJvbkRpZERpc2Nvbm5lY3QiLCJoYW5kbGVTZXJ2ZXJNZXNzYWdlIiwiZ2V0Q29ubmVjdGlvbklkIiwic3RhY2tUcmFjZSIsImFkZFRvVW5kb1N0YWNrIiwiZGlzcGF0Y2hPcHMiLCJjb25uZWN0aW9uIiwiaGlzdG9yeSIsInN0b3JhZ2VTdGF0dXMiLCJzdHJlYW1GZXRjaCIsImF1dGhUb2tlbk9yUHVibGljQXBpS2V5IiwiaHR0cFBvc3RUb1Jvb20iLCJzZW5kTWVzc2FnZXMiLCJzZXJpYWxpemVkUGF5bG9hZCIsIm5vbmNlIiwidW5zdGFibGVfZmFsbGJhY2tUb0hUVFAiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsInJlc3AiLCJzdGF0aWNTZXNzaW9uIiwiZHluYW1pY1Nlc3Npb24iLCJhY3RvciIsIl9sYXN0U2VsZiIsImJhdGNoZWRVcGRhdGVzV3JhcHBlciIsImN1cnJTZWxmIiwic2VsZkFzVHJlZU5vZGUiLCJjcmVhdGVPclVwZGF0ZVJvb3RGcm9tTWVzc2FnZSIsInVwZGF0ZVJvb3QiLCJzdGFja1NpemVCZWZvcmUiLCJhcHBseU9wcyIsIl9hZGRUb1JlYWxVbmRvU3RhY2siLCJoaXN0b3J5T3BzIiwic2hpZnQiLCJvbkhpc3RvcnlDaGFuZ2UiLCJvdGhlcnNVcGRhdGVzIiwidXBkYXRlczIiLCJub3RpZnlTdG9yYWdlU3RhdHVzIiwicmF3T3BzIiwib3V0cHV0IiwiY3JlYXRlZE5vZGVJZHMiLCJkZWxldGVkIiwiYXBwbHlPcFJlc3VsdCIsImFwcGx5T3AiLCJwYXJlbnROb2RlIiwidXBkYXRlUHJlc2VuY2UiLCJvcHRpb25zMiIsIm9sZFZhbHVlcyIsIm92ZXJyaWRlVmFsdWUiLCJhZGRUb0hpc3RvcnkiLCJvblVwZGF0ZVByZXNlbmNlTWVzc2FnZSIsInRhcmdldEFjdG9yIiwib2xkVXNlciIsIm5ld1VzZXIiLCJvblVzZXJMZWZ0TWVzc2FnZSIsIm9uUm9vbVN0YXRlTWVzc2FnZSIsImNhblVuZG8iLCJjYW5SZWRvIiwib25Vc2VySm9pbmVkTWVzc2FnZSIsInBhcnNlU2VydmVyTWVzc2FnZSIsInBhcnNlU2VydmVyTWVzc2FnZXMiLCJhcHBseUFuZFNlbmRPcHMiLCJvZmZsaW5lT3BzIiwidXNlckpvaW5lZFVwZGF0ZSIsIm90aGVyc1ByZXNlbmNlVXBkYXRlIiwidSIsImV2ZW50MiIsInByb2Nlc3NJbml0aWFsU3RvcmFnZSIsImFwcGx5UmVzdWx0IiwidHJhY2VzIiwib3BJZHMiLCJ0cmFjZSIsInN0b3JhZ2VPcHMiLCJlbGFwc2VkTWlsbGlzIiwidGhyb3R0bGVEZWxheSIsIm1lc3NhZ2VzVG9GbHVzaCIsInNlcmlhbGl6ZUJ1ZmZlciIsInVwZGF0ZVlEb2MiLCJndWlkIiwiY2xpZW50TXNnIiwiYnJvYWRjYXN0RXZlbnQiLCJzaG91bGRRdWV1ZUV2ZW50SWZOb3RSZWFkeSIsIl9yZXNvbHZlU3RvcmFnZVByb21pc2UiLCJzdHJlYW1TdG9yYWdlIiwidW5zdGFibGVfc3RyZWFtRGF0YSIsInN0YXJ0TG9hZGluZ1N0b3JhZ2UiLCJnZXRTdG9yYWdlIiwidmVjdG9yIiwibSIsInVuZG8iLCJyZWRvIiwiYmF0Y2giLCJyZXR1cm5WYWx1ZSIsImN1cnJlbnRCYXRjaCIsInBhdXNlSGlzdG9yeSIsInJlc3VtZUhpc3RvcnkiLCJfbGFzdFN0b3JhZ2VTdGF0dXMiLCJvdGhlcnNfZm9yRGV2VG9vbHMiLCJvdGhlciIsImNvbW1lbnRzQXBpIiwicHJlc2VuY2VCdWZmZXIiLCJub2RlQ291bnQiLCJzaW11bGF0ZSIsImV4cGxpY2l0Q2xvc2UiLCJyYXdTZW5kIiwibWFrZUNsYXNzaWNTdWJzY3JpYmVGbiIsInJlc3VtZSIsImdldENvbm5lY3Rpb25TdGF0ZSIsImdldFNlbGYiLCJnZXRQcmVzZW5jZSIsImdldE90aGVycyIsInN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZURlZXBseSIsInJlbGF0ZWRVcGRhdGVzIiwic3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlU2hhbGxvd2x5IiwiaXNSb29tRXZlbnROYW1lIiwiaW50ZXJuYWxFdmVudCIsInN0b3JhZ2VDYWxsYmFjayIsImlzRGVlcCIsIm5vZGVDYWxsYmFjayIsIm1ha2VBdXRoRGVsZWdhdGVGb3JSb29tIiwiYXV0aE1hbmFnZXIiLCJtYWtlQ3JlYXRlU29ja2V0RGVsZWdhdGVGb3JSb29tIiwiV2ViU29ja2V0UG9seWZpbGwiLCJ3cyIsIldlYlNvY2tldCIsInByb3RvY29sIiwicGF0aG5hbWUiLCJzZWFyY2hQYXJhbXMiLCJNSU5fVEhST1RUTEUiLCJNQVhfVEhST1RUTEUiLCJERUZBVUxUX1RIUk9UVExFIiwiTUlOX0JBQ0tHUk9VTkRfS0VFUF9BTElWRV9USU1FT1VUIiwiTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUIiwiUkVDT01NRU5ERURfTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUIiwiTUFYX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUIiwiREVGQVVMVF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCIsImdldEJhc2VVcmxGcm9tQ2xpZW50T3B0aW9ucyIsImNsaWVudE9wdGlvbnMiLCJjcmVhdGVDbGllbnQiLCJnZXRUaHJvdHRsZSIsInRocm90dGxlIiwiZ2V0TG9zdENvbm5lY3Rpb25UaW1lb3V0IiwiZ2V0QmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQiLCJyb29tc0J5SWQiLCJ0ZWFyZG93blJvb20iLCJsZWFzZVJvb20iLCJsZWF2ZSIsImVudGVyUm9vbSIsImV4aXN0aW5nIiwibmV3Um9vbSIsIm1vY2tlZERlbGVnYXRlcyIsIm5ld1Jvb21JbmZvIiwic2hvdWxkQ29ubmVjdCIsImF1dG9Db25uZWN0Iiwic2hvdWxkSW5pdGlhbGx5Q29ubmVjdCIsImdldFJvb20iLCJmb3JjZUxlYXZlIiwibG9nb3V0IiwiY2hlY2tCb3VuZHMiLCJvcHRpb24iLCJtYXgiLCJyZWNvbW1lbmRlZE1pbiIsInRvUGxhaW5Mc29uIiwibHNvbiIsImxpdmVibG9ja3NUeXBlIiwibHNvbk9iamVjdFRvSnNvbiIsImxzb25Ub0pzb24iLCJsaXZlT2JqZWN0VG9Kc29uIiwibGl2ZU9iamVjdCIsImxpdmVNYXBUb0pzb24iLCJsc29uTGlzdFRvSnNvbiIsImxpdmVMaXN0VG9Kc29uIiwiZGVlcExpdmVpZnkiLCJpbml0IiwicGF0Y2hMaXZlTGlzdCIsInByZXYiLCJwcmV2RW5kIiwibmV4dEVuZCIsInByZXZOb2RlIiwibmV4dE5vZGUiLCJvdXRlciIsImxvY2FsSSIsImxpdmVMaXN0Tm9kZSIsInBhdGNoTGl2ZU9iamVjdCIsInBhdGNoTGl2ZU9iamVjdEtleSIsIm5vblNlcmlhbGl6YWJsZVZhbHVlIiwiZ2V0UGFyZW50c1BhdGgiLCJsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3QiLCJsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3RXaXRoVXBkYXRlIiwibGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZSIsInBhdGhJdGVtIiwibmV3U3RhdGUiLCJsaXN0VXBkYXRlIiwibmV3QXJyYXkiLCJzdGF0ZUFzT2JqIiwic2hhbGxvd0FycmF5IiwieHMiLCJ5cyIsImlzIiwic2hhbGxvd09iaiIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJoYXNPd25Qcm9wZXJ0eSIsInNoYWxsb3ciLCJhIiwiYiIsImlzQXJyYXlBIiwiaXNBcnJheUIiLCJub29wIiwiaXNTaGFsbG93RXF1YWwiLCJpc0xvYWRpbmciLCJjcmVhdGVDYWNoZUl0ZW0iLCJhc3luY0Z1bmN0aW9uIiwiJGFzeW5jRnVuY3Rpb24iLCJpc0ludmFsaWQiLCJwcmV2aW91c1N0YXRlIiwiZXZlbnRTb3VyY2UyIiwiaXNFcXVhbCIsImlzU3RhdGVFcXVhbCIsInJldmFsaWRhdGUiLCJnZXRTdGF0ZSIsImNyZWF0ZUFzeW5jQ2FjaGUiLCJjYWNoZSIsImNyZWF0ZSIsImNhY2hlSXRlbSIsIm1ha2VQb2xsZXIiLCJ0aW1lb3V0SGFuZGxlIiwiaW50ZXJ2YWwiLCJsYXN0U2NoZWR1bGVkQXQiLCJyZW1haW5pbmdJbnRlcnZhbCIsInBvbGwiLCJzY2hlZHVsZSIsInBlcmZvcm1hbmNlIiwic2NoZWR1bGVSZW1haW5pbmciLCJyZW1haW5pbmciLCJyZXN0YXJ0Iiwib2JqZWN0Iiwic29ydGVkT2JqZWN0Iiwic29ydGVkT2JqZWN0MiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@liveblocks/core/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@liveblocks/react/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@liveblocks/react/dist/index.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientSideSuspense: function() { return /* binding */ ClientSideSuspense; },\n/* harmony export */   createRoomContext: function() { return /* binding */ createRoomContext; },\n/* harmony export */   shallow: function() { return /* reexport safe */ _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow; },\n/* harmony export */   useRoomContextBundle: function() { return /* binding */ useRoomContextBundle; }\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liveblocks/client */ \"(app-pages-browser)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! nanoid */ \"(app-pages-browser)/./node_modules/nanoid/index.browser.js\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\");\n/* __next_internal_client_entry_do_not_use__ ClientSideSuspense,createRoomContext,shallow,useRoomContextBundle auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$(), _s9 = $RefreshSig$(), _s10 = $RefreshSig$(), _s11 = $RefreshSig$();\n// src/index.ts\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/react\";\nvar PKG_VERSION = \"1.9.7\";\nvar PKG_FORMAT = \"esm\";\n// src/ClientSideSuspense.tsx\n\nfunction ClientSideSuspense(props) {\n    _s();\n    const [mounted, setMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        setMounted(true);\n    }, []);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n        fallback: props.fallback\n    }, mounted ? props.children() : props.fallback);\n}\n_s(ClientSideSuspense, \"LrrVfNW3d1raFE0BNzCTILYmIfo=\");\n_c = ClientSideSuspense;\n// src/factory.tsx\n\n\n\n\n// src/comments/CommentsRoom.tsx\n\n\n\n\n// src/comments/errors.ts\nvar CreateThreadError = class extends Error {\n    constructor(cause, context){\n        super(\"Create thread failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"CreateThreadError\";\n    }\n};\nvar EditThreadMetadataError = class extends Error {\n    constructor(cause, context){\n        super(\"Edit thread metadata failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"EditThreadMetadataError\";\n    }\n};\nvar CreateCommentError = class extends Error {\n    constructor(cause, context){\n        super(\"Create comment failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"CreateCommentError\";\n    }\n};\nvar EditCommentError = class extends Error {\n    constructor(cause, context){\n        super(\"Edit comment failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"EditCommentError\";\n    }\n};\nvar DeleteCommentError = class extends Error {\n    constructor(cause, context){\n        super(\"Delete comment failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"DeleteCommentError\";\n    }\n};\nvar AddReactionError = class extends Error {\n    constructor(cause, context){\n        super(\"Add reaction failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"AddReactionError\";\n    }\n};\nvar RemoveReactionError = class extends Error {\n    constructor(cause, context){\n        super(\"Remove reaction failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"RemoveReactionError\";\n    }\n};\n// src/comments/lib/revalidation.ts\n\n// src/comments/lib/use-is-document-visible.ts\n\nfunction useIsDocumentVisible() {\n    _s1();\n    const isVisible = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(subscribe, getSnapshot, getSnapshot);\n    return isVisible;\n}\n_s1(useIsDocumentVisible, \"Rfb9M/gV82sh12lehq3N1/jJzfk=\", false, function() {\n    return [\n        use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore\n    ];\n});\nfunction subscribe(onStoreChange) {\n    document.addEventListener(\"visibilitychange\", onStoreChange);\n    return ()=>{\n        document.removeEventListener(\"visibilitychange\", onStoreChange);\n    };\n}\nfunction getSnapshot() {\n    const isDocumentDefined = typeof document !== \"undefined\";\n    return isDocumentDefined ? document.visibilityState === \"visible\" : true;\n}\n// src/comments/lib/use-is-online.ts\n\n\nfunction useIsOnline() {\n    _s2();\n    const isOnlineRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const subscribe2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((onStoreChange)=>{\n        function handleIsOnline() {\n            isOnlineRef.current = true;\n            onStoreChange();\n        }\n        function handleIsOffline() {\n            isOnlineRef.current = false;\n            onStoreChange();\n        }\n        window.addEventListener(\"online\", handleIsOnline);\n        window.addEventListener(\"offline\", handleIsOffline);\n        return ()=>{\n            window.removeEventListener(\"online\", handleIsOnline);\n            window.removeEventListener(\"offline\", handleIsOffline);\n        };\n    }, []);\n    const getSnapshot2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        return isOnlineRef.current;\n    }, []);\n    const isOnline = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(subscribe2, getSnapshot2, getSnapshot2);\n    return isOnline;\n}\n_s2(useIsOnline, \"ruyyaaZMOyQYz7MS88fsorhsFMw=\", false, function() {\n    return [\n        use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore\n    ];\n});\n// src/comments/lib/revalidation.ts\nvar DEFAULT_ERROR_RETRY_INTERVAL = 5e3;\nvar DEFAULT_MAX_ERROR_RETRY_COUNT = 5;\nvar DEFAULT_DEDUPING_INTERVAL = 2e3;\nvar timestamp = 0;\nfunction useRevalidateCache(manager, fetcher) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    _s3();\n    const isOnlineRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const { dedupingInterval = DEFAULT_DEDUPING_INTERVAL, errorRetryInterval = DEFAULT_ERROR_RETRY_INTERVAL, errorRetryCount = DEFAULT_MAX_ERROR_RETRY_COUNT } = options;\n    const _revalidateCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (param)=>{\n        let { shouldDedupe, retryCount = 0 } = param;\n        let startAt;\n        const shouldStartRequest = !manager.getRequest() || !shouldDedupe;\n        function deleteActiveRequest() {\n            const activeRequest = manager.getRequest();\n            if (!activeRequest) return;\n            if (activeRequest.timestamp !== startAt) return;\n            manager.setRequest(void 0);\n        }\n        function handleError() {\n            const timeout = ~~((Math.random() + 0.5) * (1 << (retryCount < 8 ? retryCount : 8))) * errorRetryInterval;\n            if (retryCount > errorRetryCount) return;\n            setTimeout(()=>{\n                void _revalidateCache({\n                    shouldDedupe: false,\n                    retryCount: retryCount + 1\n                });\n            }, timeout);\n        }\n        if (shouldStartRequest) {\n            manager.setRequest({\n                fetcher: fetcher(),\n                timestamp: ++timestamp\n            });\n        }\n        try {\n            let activeRequest = manager.getRequest();\n            if (!activeRequest) return;\n            startAt = activeRequest.timestamp;\n            const newData = await activeRequest.fetcher;\n            if (shouldStartRequest) {\n                setTimeout(deleteActiveRequest, dedupingInterval);\n            }\n            activeRequest = manager.getRequest();\n            if (!activeRequest || activeRequest.timestamp !== startAt) return;\n            const activeMutation = manager.getMutation();\n            if (activeMutation && (activeMutation.startTime > startAt || activeMutation.endTime > startAt || activeMutation.endTime === 0)) {\n                return;\n            }\n            manager.setCache(newData);\n        } catch (err) {\n            deleteActiveRequest();\n            const isVisible = document.visibilityState === \"visible\";\n            const isOnline = isOnlineRef.current;\n            if (shouldStartRequest && isVisible && isOnline) handleError();\n            manager.setError(err);\n        }\n        return;\n    }, [\n        manager,\n        fetcher,\n        dedupingInterval,\n        errorRetryInterval,\n        errorRetryCount\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        function handleIsOnline() {\n            isOnlineRef.current = true;\n        }\n        function handleIsOffline() {\n            isOnlineRef.current = false;\n        }\n        window.addEventListener(\"online\", handleIsOnline);\n        window.addEventListener(\"offline\", handleIsOffline);\n        return ()=>{\n            window.removeEventListener(\"online\", handleIsOnline);\n            window.removeEventListener(\"offline\", handleIsOffline);\n        };\n    }, []);\n    const revalidateCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((param)=>{\n        let { shouldDedupe } = param;\n        return _revalidateCache({\n            shouldDedupe,\n            retryCount: 0\n        });\n    }, [\n        _revalidateCache\n    ]);\n    return revalidateCache;\n}\n_s3(useRevalidateCache, \"lMNPttQEfRNxLAEZrsx5FJJ9F2o=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useRef,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback\n    ];\n});\nfunction useMutate(manager, revalidateCache) {\n    _s4();\n    const mutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (data, options)=>{\n        const beforeMutationTimestamp = ++timestamp;\n        manager.setMutation({\n            startTime: beforeMutationTimestamp,\n            endTime: 0\n        });\n        const currentCache = manager.getCache();\n        manager.setCache(options.optimisticData);\n        let error;\n        try {\n            await data;\n        } catch (err) {\n            error = err;\n        }\n        const activeMutation = manager.getMutation();\n        if (activeMutation && beforeMutationTimestamp !== activeMutation.startTime) {\n            if (error) throw error;\n            return;\n        }\n        if (error) {\n            manager.setCache(currentCache);\n        }\n        manager.setMutation({\n            startTime: beforeMutationTimestamp,\n            endTime: ++timestamp\n        });\n        manager.setRequest(void 0);\n        void revalidateCache({\n            shouldDedupe: false\n        });\n        if (error) throw error;\n    }, [\n        manager,\n        revalidateCache\n    ]);\n    return mutate;\n}\n_s4(useMutate, \"4GWwu+i+RydOvroFphJ3Xw0B5Rk=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback\n    ];\n});\n// src/comments/CommentsRoom.tsx\nvar THREAD_ID_PREFIX = \"th\";\nvar COMMENT_ID_PREFIX = \"cm\";\nvar POLLING_INTERVAL_REALTIME = 3e4;\nvar POLLING_INTERVAL = 5e3;\nfunction createCommentsRoom(errorEventSource) {\n    var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$(), _s9 = $RefreshSig$(), _s10 = $RefreshSig$(), _s11 = $RefreshSig$(), _s12 = $RefreshSig$();\n    const store = createClientCacheStore();\n    const FetcherContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\n    const RoomManagerContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\n    function getThreads(manager) {\n        const threads = manager.getCache();\n        if (!threads) {\n            throw new Error(\"Cannot update threads or comments before they are loaded.\");\n        }\n        return threads;\n    }\n    function CommentsRoomProvider(param) {\n        let { room, children } = param;\n        _s();\n        const manager = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n            return createRoomRevalidationManager(room.id, {\n                getCache: store.getThreads,\n                setCache: store.setThreads\n            });\n        }, [\n            room.id\n        ]);\n        const fetcher = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async ()=>{\n            const options = manager.getRevalidationManagers().filter((param)=>{\n                let [key] = param;\n                return manager.getReferenceCount(key) > 0;\n            }).map((param)=>{\n                let [_, manager2] = param;\n                return manager2.getOptions();\n            });\n            const responses = await Promise.all(options.map(async (option)=>{\n                return await room.getThreads(option);\n            }));\n            const threads = Array.from(new Map(responses.flat().map((thread)=>[\n                    thread.id,\n                    thread\n                ])).values());\n            return threads;\n        }, [\n            room,\n            manager\n        ]);\n        const revalidateCache = useRevalidateCache(manager, fetcher);\n        const status = useSyncExternalStore3(room.events.status.subscribe, room.getStatus, room.getStatus);\n        const isOnline = useIsOnline();\n        const isDocumentVisible = useIsDocumentVisible();\n        const refreshInterval = getPollingInterval(isOnline, isDocumentVisible, status === \"connected\");\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            let revalidationTimerId;\n            function scheduleRevalidation() {\n                if (refreshInterval === 0) return;\n                revalidationTimerId = window.setTimeout(()=>{\n                    if (isOnline && isDocumentVisible && !manager.getError() && manager.getTotalReferenceCount() > 0) {\n                        void revalidateCache({\n                            shouldDedupe: true\n                        }).then(scheduleRevalidation);\n                        return;\n                    }\n                    scheduleRevalidation();\n                }, refreshInterval);\n            }\n            scheduleRevalidation();\n            return ()=>{\n                window.clearTimeout(revalidationTimerId);\n            };\n        }, [\n            revalidateCache,\n            refreshInterval,\n            isOnline,\n            isDocumentVisible,\n            manager\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            function handleIsOnline() {\n                if (isDocumentVisible) {\n                    void revalidateCache({\n                        shouldDedupe: true\n                    });\n                }\n            }\n            window.addEventListener(\"online\", handleIsOnline);\n            return ()=>{\n                window.removeEventListener(\"online\", handleIsOnline);\n            };\n        }, [\n            revalidateCache,\n            isDocumentVisible\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            function handleVisibilityChange() {\n                const isVisible = document.visibilityState === \"visible\";\n                if (isVisible && isOnline) {\n                    void revalidateCache({\n                        shouldDedupe: true\n                    });\n                }\n            }\n            document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n            return ()=>{\n                document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n            };\n        }, [\n            revalidateCache,\n            isOnline\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            const unsubscribe = room.events.comments.subscribe(()=>{\n                void revalidateCache({\n                    shouldDedupe: false\n                });\n            });\n            return ()=>{\n                unsubscribe();\n            };\n        }, [\n            room,\n            revalidateCache\n        ]);\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetcherContext.Provider, {\n            value: fetcher\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomManagerContext.Provider, {\n            value: manager\n        }, children));\n    }\n    _s(CommentsRoomProvider, \"UDEYKETTioU94ezH6LjOzlyGtlQ=\", false, function() {\n        return [\n            useRevalidateCache,\n            useSyncExternalStore3,\n            useIsOnline,\n            useIsDocumentVisible,\n            react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n            react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n            react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n            react__WEBPACK_IMPORTED_MODULE_0__.useEffect\n        ];\n    });\n    function useRoomManager() {\n        _s1();\n        const manager = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RoomManagerContext);\n        if (manager === null) {\n            throw new Error(\"CommentsRoomProvider is missing from the React tree.\");\n        }\n        return manager;\n    }\n    _s1(useRoomManager, \"YBMkunL3KLAD6ckxMh6EOjAVXwM=\");\n    function getUseThreadsRevalidationManager(options, roomManager) {\n        const key = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(options);\n        const revalidationManager = roomManager.getRevalidationManager(key);\n        if (!revalidationManager) {\n            const useThreadsRevalidationManager = createUseThreadsRevalidationManager(options, roomManager);\n            roomManager.setRevalidationmanager(key, useThreadsRevalidationManager);\n            return useThreadsRevalidationManager;\n        }\n        return revalidationManager;\n    }\n    function useThreadsFetcher() {\n        _s2();\n        const fetcher = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FetcherContext);\n        if (fetcher === null) {\n            throw new Error(\"CommentsRoomProvider is missing from the React tree.\");\n        }\n        return fetcher;\n    }\n    _s2(useThreadsFetcher, \"rmppyt6+hzDu/n/ePy8H7MRnOXI=\");\n    function useThreads(room) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n            query: {\n                metadata: {}\n            }\n        };\n        _s3();\n        const key = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(options), [\n            options\n        ]);\n        const manager = useRoomManager();\n        const useThreadsRevalidationManager = getUseThreadsRevalidationManager(options, manager);\n        const fetcher = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n            return room.getThreads(options);\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps -- The missing dependency is `options` but `key` and `normalized` are analogous, so we only include `key` as dependency. This helps minimize the number of re-renders as `options` can change on each render\n        [\n            key,\n            room\n        ]);\n        const revalidateCache = useRevalidateCache(useThreadsRevalidationManager, fetcher);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            void revalidateCache({\n                shouldDedupe: true\n            });\n        }, [\n            revalidateCache\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            manager.incrementReferenceCount(key);\n            return ()=>{\n                manager.decrementReferenceCount(key);\n            };\n        }, [\n            manager,\n            key\n        ]);\n        const cache = _useThreads(room, options);\n        return cache;\n    }\n    _s3(useThreads, \"G41xSiiE7YXsvC/mH5aKH0ev1Uc=\", false, function() {\n        return [\n            useRoomManager,\n            useRevalidateCache,\n            react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n            react__WEBPACK_IMPORTED_MODULE_0__.useEffect\n        ];\n    });\n    function useThreadsSuspense(room) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n            query: {\n                metadata: {}\n            }\n        };\n        _s4();\n        const key = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(options), [\n            options\n        ]);\n        const manager = useRoomManager();\n        const useThreadsRevalidationManager = getUseThreadsRevalidationManager(options, manager);\n        const fetcher = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n            return room.getThreads(options);\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps -- The missing dependency is `options` but `key` and `normalized` are analogous, so we only include `key` as dependency. This helps minimize the number of re-renders as `options` can change on each render\n        [\n            key,\n            room\n        ]);\n        const revalidateCache = useRevalidateCache(useThreadsRevalidationManager, fetcher);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            void revalidateCache({\n                shouldDedupe: true\n            });\n        }, [\n            revalidateCache\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            manager.incrementReferenceCount(key);\n            return ()=>{\n                manager.decrementReferenceCount(key);\n            };\n        }, [\n            manager,\n            key\n        ]);\n        const cache = _useThreads(room, options);\n        if (cache.error) {\n            throw cache.error;\n        }\n        if (cache.isLoading || !cache.threads) {\n            throw revalidateCache({\n                shouldDedupe: true\n            });\n        }\n        return {\n            isLoading: false,\n            threads: cache.threads,\n            error: cache.error\n        };\n    }\n    _s4(useThreadsSuspense, \"G41xSiiE7YXsvC/mH5aKH0ev1Uc=\", false, function() {\n        return [\n            useRoomManager,\n            useRevalidateCache,\n            react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n            react__WEBPACK_IMPORTED_MODULE_0__.useEffect\n        ];\n    });\n    function _useThreads(room, options) {\n        _s5();\n        const manager = useRoomManager();\n        const useThreadsRevalidationManager = getUseThreadsRevalidationManager(options, manager);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(store.subscribe, ()=>store.getThreads(), ()=>store.getThreads(), (state)=>{\n            const isLoading = useThreadsRevalidationManager.getIsLoading();\n            if (isLoading) {\n                return {\n                    isLoading: true\n                };\n            }\n            const options2 = useThreadsRevalidationManager.getOptions();\n            const error = useThreadsRevalidationManager.getError();\n            const filtered = state.filter((thread)=>{\n                if (thread.roomId !== room.id) return false;\n                var _options2_query;\n                const query = (_options2_query = options2.query) !== null && _options2_query !== void 0 ? _options2_query : {};\n                for(const key in query.metadata){\n                    if (thread.metadata[key] !== query.metadata[key]) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n            return {\n                isLoading: false,\n                threads: filtered,\n                error\n            };\n        });\n    }\n    _s5(_useThreads, \"fYtPnUVDukHzP43N6vRbVkmZwdQ=\", false, function() {\n        return [\n            useRoomManager,\n            use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector\n        ];\n    });\n    function useEditThreadMetadata(room) {\n        _s6();\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const editThreadMetadata = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((options)=>{\n            const threadId = options.threadId;\n            const metadata = \"metadata\" in options ? options.metadata : {};\n            const threads = getThreads(manager);\n            const optimisticData = threads.map((thread)=>thread.id === threadId ? {\n                    ...thread,\n                    metadata: {\n                        ...thread.metadata,\n                        ...metadata\n                    }\n                } : thread);\n            mutate(room.editThreadMetadata({\n                metadata,\n                threadId\n            }), {\n                optimisticData\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new EditThreadMetadataError(error, {\n                    roomId: room.id,\n                    threadId,\n                    metadata\n                }));\n            });\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return editThreadMetadata;\n    }\n    _s6(useEditThreadMetadata, \"OTibWRzERC/aaFxWh9IriAzROa4=\", false, function() {\n        return [\n            useRoomManager,\n            useThreadsFetcher,\n            useRevalidateCache,\n            useMutate,\n            react__WEBPACK_IMPORTED_MODULE_0__.useCallback\n        ];\n    });\n    function useCreateThread(room) {\n        _s7();\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const createThread = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((options)=>{\n            const body = options.body;\n            const metadata = \"metadata\" in options ? options.metadata : {};\n            const threads = getThreads(manager);\n            const threadId = createThreadId();\n            const commentId = createCommentId();\n            const now = /* @__PURE__ */ new Date();\n            const newComment = {\n                id: commentId,\n                threadId,\n                roomId: room.id,\n                createdAt: now,\n                type: \"comment\",\n                userId: getCurrentUserId(room),\n                body,\n                reactions: []\n            };\n            const newThread = {\n                id: threadId,\n                type: \"thread\",\n                createdAt: now,\n                roomId: room.id,\n                metadata,\n                comments: [\n                    newComment\n                ]\n            };\n            mutate(room.createThread({\n                threadId,\n                commentId,\n                body,\n                metadata\n            }), {\n                optimisticData: [\n                    ...threads,\n                    newThread\n                ]\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new CreateThreadError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    body,\n                    metadata\n                }));\n            });\n            return newThread;\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return createThread;\n    }\n    _s7(useCreateThread, \"cFAAr8QWtvOaZxi3CDsu9MpXcFc=\", false, function() {\n        return [\n            useRoomManager,\n            useThreadsFetcher,\n            useRevalidateCache,\n            useMutate,\n            react__WEBPACK_IMPORTED_MODULE_0__.useCallback\n        ];\n    });\n    function useCreateComment(room) {\n        _s8();\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const createComment = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((param)=>{\n            let { threadId, body } = param;\n            const threads = getThreads(manager);\n            const commentId = createCommentId();\n            const now = /* @__PURE__ */ new Date();\n            const comment = {\n                id: commentId,\n                threadId,\n                roomId: room.id,\n                type: \"comment\",\n                createdAt: now,\n                userId: getCurrentUserId(room),\n                body,\n                reactions: []\n            };\n            const optimisticData = threads.map((thread)=>thread.id === threadId ? {\n                    ...thread,\n                    comments: [\n                        ...thread.comments,\n                        comment\n                    ]\n                } : thread);\n            mutate(room.createComment({\n                threadId,\n                commentId,\n                body\n            }), {\n                optimisticData\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new CreateCommentError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    body\n                }));\n            });\n            return comment;\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return createComment;\n    }\n    _s8(useCreateComment, \"diY0sNox4pLo+Ywt2rmHeK4TUpU=\", false, function() {\n        return [\n            useRoomManager,\n            useThreadsFetcher,\n            useRevalidateCache,\n            useMutate,\n            react__WEBPACK_IMPORTED_MODULE_0__.useCallback\n        ];\n    });\n    function useEditComment(room) {\n        _s9();\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const editComment = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((param)=>{\n            let { threadId, commentId, body } = param;\n            const threads = getThreads(manager);\n            const now = /* @__PURE__ */ new Date();\n            const optimisticData = threads.map((thread)=>thread.id === threadId ? {\n                    ...thread,\n                    comments: thread.comments.map((comment)=>comment.id === commentId ? {\n                            ...comment,\n                            editedAt: now,\n                            body\n                        } : comment)\n                } : thread);\n            mutate(room.editComment({\n                threadId,\n                commentId,\n                body\n            }), {\n                optimisticData\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new EditCommentError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    body\n                }));\n            });\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return editComment;\n    }\n    _s9(useEditComment, \"QK00uEbTM5dHsNcP2FETFj4XbnQ=\", false, function() {\n        return [\n            useRoomManager,\n            useThreadsFetcher,\n            useRevalidateCache,\n            useMutate,\n            react__WEBPACK_IMPORTED_MODULE_0__.useCallback\n        ];\n    });\n    function useDeleteComment(room) {\n        _s10();\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const deleteComment = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((param)=>{\n            let { threadId, commentId } = param;\n            const threads = getThreads(manager);\n            const now = /* @__PURE__ */ new Date();\n            const newThreads = [];\n            for (const thread of threads){\n                if (thread.id === threadId) {\n                    const newThread = {\n                        ...thread,\n                        comments: thread.comments.map((comment)=>comment.id === commentId ? {\n                                ...comment,\n                                deletedAt: now,\n                                body: void 0\n                            } : comment)\n                    };\n                    if (newThread.comments.some((comment)=>comment.deletedAt === void 0)) {\n                        newThreads.push(newThread);\n                    }\n                } else {\n                    newThreads.push(thread);\n                }\n            }\n            mutate(room.deleteComment({\n                threadId,\n                commentId\n            }), {\n                optimisticData: newThreads\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new DeleteCommentError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId\n                }));\n            });\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return deleteComment;\n    }\n    _s10(useDeleteComment, \"miNcxkiLHm5okrI+HpEMw0InqWY=\", false, function() {\n        return [\n            useRoomManager,\n            useThreadsFetcher,\n            useRevalidateCache,\n            useMutate,\n            react__WEBPACK_IMPORTED_MODULE_0__.useCallback\n        ];\n    });\n    function useAddReaction(room) {\n        _s11();\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const createComment = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((param)=>{\n            let { threadId, commentId, emoji } = param;\n            const threads = getThreads(manager);\n            const now = /* @__PURE__ */ new Date();\n            const userId = getCurrentUserId(room);\n            const optimisticData = threads.map((thread)=>thread.id === threadId ? {\n                    ...thread,\n                    comments: thread.comments.map((comment)=>{\n                        if (comment.id !== commentId) {\n                            return comment;\n                        }\n                        let reactions;\n                        if (comment.reactions.some((reaction)=>reaction.emoji === emoji)) {\n                            reactions = comment.reactions.map((reaction)=>reaction.emoji === emoji ? {\n                                    ...reaction,\n                                    users: [\n                                        ...reaction.users,\n                                        {\n                                            id: userId\n                                        }\n                                    ]\n                                } : reaction);\n                        } else {\n                            reactions = [\n                                ...comment.reactions,\n                                {\n                                    emoji,\n                                    createdAt: now,\n                                    users: [\n                                        {\n                                            id: userId\n                                        }\n                                    ]\n                                }\n                            ];\n                        }\n                        return {\n                            ...comment,\n                            reactions\n                        };\n                    })\n                } : thread);\n            mutate(room.addReaction({\n                threadId,\n                commentId,\n                emoji\n            }), {\n                optimisticData\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new AddReactionError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    emoji\n                }));\n            });\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return createComment;\n    }\n    _s11(useAddReaction, \"diY0sNox4pLo+Ywt2rmHeK4TUpU=\", false, function() {\n        return [\n            useRoomManager,\n            useThreadsFetcher,\n            useRevalidateCache,\n            useMutate,\n            react__WEBPACK_IMPORTED_MODULE_0__.useCallback\n        ];\n    });\n    function useRemoveReaction(room) {\n        _s12();\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const createComment = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((param)=>{\n            let { threadId, commentId, emoji } = param;\n            const threads = getThreads(manager);\n            const userId = getCurrentUserId(room);\n            const optimisticData = threads.map((thread)=>thread.id === threadId ? {\n                    ...thread,\n                    comments: thread.comments.map((comment)=>{\n                        if (comment.id !== commentId) {\n                            return comment;\n                        }\n                        const reactionIndex = comment.reactions.findIndex((reaction)=>reaction.emoji === emoji);\n                        let reactions = comment.reactions;\n                        if (reactionIndex >= 0 && comment.reactions[reactionIndex].users.some((user)=>user.id === userId)) {\n                            if (comment.reactions[reactionIndex].users.length <= 1) {\n                                reactions = [\n                                    ...comment.reactions\n                                ];\n                                reactions.splice(reactionIndex, 1);\n                            } else {\n                                reactions[reactionIndex] = {\n                                    ...reactions[reactionIndex],\n                                    users: reactions[reactionIndex].users.filter((user)=>user.id !== userId)\n                                };\n                            }\n                        }\n                        return {\n                            ...comment,\n                            reactions\n                        };\n                    })\n                } : thread);\n            mutate(room.removeReaction({\n                threadId,\n                commentId,\n                emoji\n            }), {\n                optimisticData\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new RemoveReactionError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    emoji\n                }));\n            });\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return createComment;\n    }\n    _s12(useRemoveReaction, \"diY0sNox4pLo+Ywt2rmHeK4TUpU=\", false, function() {\n        return [\n            useRoomManager,\n            useThreadsFetcher,\n            useRevalidateCache,\n            useMutate,\n            react__WEBPACK_IMPORTED_MODULE_0__.useCallback\n        ];\n    });\n    return {\n        CommentsRoomProvider,\n        useThreads,\n        useThreadsSuspense,\n        useEditThreadMetadata,\n        useCreateThread,\n        useCreateComment,\n        useEditComment,\n        useDeleteComment,\n        useAddReaction,\n        useRemoveReaction\n    };\n}\nfunction createOptimisticId(prefix) {\n    return \"\".concat(prefix, \"_\").concat((0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)());\n}\nfunction createThreadId() {\n    return createOptimisticId(THREAD_ID_PREFIX);\n}\nfunction createCommentId() {\n    return createOptimisticId(COMMENT_ID_PREFIX);\n}\nfunction getCurrentUserId(room) {\n    const self = room.getSelf();\n    if (self === null || self.id === void 0) {\n        return \"anonymous\";\n    } else {\n        return self.id;\n    }\n}\nfunction handleCommentsApiError(err) {\n    var _err_details;\n    const message = \"Request failed with status \".concat(err.status, \": \").concat(err.message);\n    if (((_err_details = err.details) === null || _err_details === void 0 ? void 0 : _err_details.error) === \"FORBIDDEN\") {\n        const detailedMessage = [\n            message,\n            err.details.suggestion,\n            err.details.docs\n        ].filter(Boolean).join(\"\\n\");\n        console.error(detailedMessage);\n    }\n    return new Error(message);\n}\nfunction createRoomRevalidationManager(roomId, param) {\n    let { getCache, setCache } = param;\n    let request;\n    let error;\n    let mutation;\n    const revalidationManagerByOptions = /* @__PURE__ */ new Map();\n    const referenceCountByOptions = /* @__PURE__ */ new Map();\n    return {\n        // Cache\n        getCache () {\n            const threads = getCache();\n            const filtered = threads.filter((thread)=>thread.roomId === roomId);\n            return filtered;\n        },\n        setCache (value) {\n            for (const key of revalidationManagerByOptions.keys()){\n                if (referenceCountByOptions.get(key) === 0) {\n                    revalidationManagerByOptions.delete(key);\n                    referenceCountByOptions.delete(key);\n                }\n            }\n            const sorted = value.sort((a, b)=>new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n            const threads = getCache();\n            const newThreads = threads.filter((thread)=>thread.roomId !== roomId).concat(sorted);\n            setCache(newThreads);\n        },\n        // Request\n        getRequest () {\n            return request;\n        },\n        setRequest (value) {\n            request = value;\n        },\n        // Error\n        getError () {\n            return error;\n        },\n        setError (err) {\n            error = err;\n        },\n        // Mutation\n        getMutation () {\n            return mutation;\n        },\n        setMutation (info) {\n            mutation = info;\n        },\n        getRevalidationManagers () {\n            return Array.from(revalidationManagerByOptions.entries());\n        },\n        getRevalidationManager (key) {\n            return revalidationManagerByOptions.get(key);\n        },\n        setRevalidationmanager (key, manager) {\n            revalidationManagerByOptions.set(key, manager);\n        },\n        getTotalReferenceCount () {\n            return Array.from(referenceCountByOptions.values()).reduce((acc, count)=>acc + count, 0);\n        },\n        incrementReferenceCount (key) {\n            var _referenceCountByOptions_get;\n            const count = (_referenceCountByOptions_get = referenceCountByOptions.get(key)) !== null && _referenceCountByOptions_get !== void 0 ? _referenceCountByOptions_get : 0;\n            referenceCountByOptions.set(key, count + 1);\n        },\n        decrementReferenceCount (key) {\n            var _referenceCountByOptions_get;\n            const count = (_referenceCountByOptions_get = referenceCountByOptions.get(key)) !== null && _referenceCountByOptions_get !== void 0 ? _referenceCountByOptions_get : 0;\n            referenceCountByOptions.set(key, count - 1);\n        },\n        getReferenceCount (key) {\n            var _referenceCountByOptions_get;\n            return (_referenceCountByOptions_get = referenceCountByOptions.get(key)) !== null && _referenceCountByOptions_get !== void 0 ? _referenceCountByOptions_get : 0;\n        }\n    };\n}\nfunction createClientCacheStore() {\n    let threads = [];\n    const threadsEventSource = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makeEventSource)();\n    return {\n        getThreads () {\n            return threads;\n        },\n        setThreads (value) {\n            threads = value;\n            threadsEventSource.notify(threads);\n        },\n        subscribe (callback) {\n            return threadsEventSource.subscribe(callback);\n        }\n    };\n}\nfunction createUseThreadsRevalidationManager(options, manager) {\n    let isLoading = true;\n    let request;\n    let error;\n    return {\n        // Cache\n        getCache () {\n            return void 0;\n        },\n        setCache (value) {\n            var _manager_getCache;\n            const cache = new Map(((_manager_getCache = manager.getCache()) !== null && _manager_getCache !== void 0 ? _manager_getCache : []).map((thread)=>[\n                    thread.id,\n                    thread\n                ]));\n            for (const thread of value){\n                cache.set(thread.id, thread);\n            }\n            manager.setCache(Array.from(cache.values()));\n            isLoading = false;\n        },\n        // Request\n        getRequest () {\n            return request;\n        },\n        setRequest (value) {\n            request = value;\n        },\n        // Error\n        getError () {\n            return error;\n        },\n        setError (err) {\n            error = err;\n            isLoading = false;\n            const cache = manager.getCache();\n            manager.setCache(cache);\n        },\n        // Mutation\n        getMutation () {\n            return void 0;\n        },\n        setMutation (_) {\n            return;\n        },\n        getOptions () {\n            return options;\n        },\n        getIsLoading () {\n            return isLoading;\n        },\n        setIsLoading (value) {\n            isLoading = value;\n        }\n    };\n}\nfunction getPollingInterval(isBrowserOnline, isDocumentVisible, isRoomConnected) {\n    if (!isBrowserOnline || !isDocumentVisible) return;\n    if (isRoomConnected) return POLLING_INTERVAL_REALTIME;\n    return POLLING_INTERVAL;\n}\n// src/comments/lib/use-debounce.ts\n\nvar DEFAULT_DELAY = 500;\nfunction useDebounce(value) {\n    let delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_DELAY;\n    _s5();\n    const timeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const [debouncedValue, setDebouncedValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(value);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (delay === false) {\n            return;\n        }\n        if (timeout.current === void 0) {\n            setDebouncedValue(value);\n        }\n        timeout.current = window.setTimeout(()=>{\n            setDebouncedValue(value);\n            timeout.current = void 0;\n        }, delay);\n        return ()=>{\n            window.clearTimeout(timeout.current);\n        };\n    }, [\n        value,\n        delay\n    ]);\n    return debouncedValue;\n}\n_s5(useDebounce, \"HV5qOmXe5kf4no9PIWBDax5o1Kk=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useRef,\n        react__WEBPACK_IMPORTED_MODULE_0__.useState,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect\n    ];\n});\n// src/lib/use-async-cache.ts\n\n\n// src/lib/use-initial.ts\n\nfunction useInitial(value) {\n    _s6();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(value)[0];\n}\n_s6(useInitial, \"Lq3SgvX34KPAnoNPTsuIpUz33b8=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useState\n    ];\n});\n// src/lib/use-async-cache.ts\nvar INITIAL_ASYNC_STATE = {\n    isLoading: false,\n    data: void 0,\n    error: void 0\n};\nvar noop = ()=>{};\nfunction useAsyncCache(cache, key, options) {\n    var _previousData_current, _previousData_current1;\n    _s7();\n    const frozenOptions = useInitial(options);\n    const cacheItem = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (key === null || !cache) {\n            return null;\n        }\n        const cacheItem2 = cache.create(key);\n        void cacheItem2.get();\n        return cacheItem2;\n    }, [\n        cache,\n        key\n    ]);\n    const subscribe2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback)=>{\n        var _cacheItem_subscribe;\n        return (_cacheItem_subscribe = cacheItem === null || cacheItem === void 0 ? void 0 : cacheItem.subscribe(callback)) !== null && _cacheItem_subscribe !== void 0 ? _cacheItem_subscribe : noop;\n    }, [\n        cacheItem\n    ]);\n    const getState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        var _cacheItem_getState;\n        return (_cacheItem_getState = cacheItem === null || cacheItem === void 0 ? void 0 : cacheItem.getState()) !== null && _cacheItem_getState !== void 0 ? _cacheItem_getState : INITIAL_ASYNC_STATE;\n    }, [\n        cacheItem\n    ]);\n    const revalidate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>cacheItem === null || cacheItem === void 0 ? void 0 : cacheItem.revalidate(), [\n        cacheItem\n    ]);\n    const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(subscribe2, getState, getState);\n    const previousData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    let data = state.data;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        previousData.current = {\n            key,\n            data: state.data\n        };\n    }, [\n        key,\n        state.data\n    ]);\n    if (!cacheItem) {\n        return {\n            isLoading: false,\n            data: void 0,\n            error: void 0,\n            getState,\n            revalidate\n        };\n    }\n    if (frozenOptions === null || frozenOptions === void 0 ? void 0 : frozenOptions.suspense) {\n        const error = getState().error;\n        if (error) {\n            throw error;\n        } else if (getState().isLoading) {\n            throw new Promise((resolve)=>{\n                cacheItem.subscribeOnce((state2)=>{\n                    if (!state2.isLoading) {\n                        resolve();\n                    }\n                });\n            });\n        }\n    }\n    if (state.isLoading && (frozenOptions === null || frozenOptions === void 0 ? void 0 : frozenOptions.keepPreviousDataWhileLoading) && typeof state.data === \"undefined\" && ((_previousData_current = previousData.current) === null || _previousData_current === void 0 ? void 0 : _previousData_current.key) !== key && typeof ((_previousData_current1 = previousData.current) === null || _previousData_current1 === void 0 ? void 0 : _previousData_current1.data) !== \"undefined\") {\n        data = previousData.current.data;\n    }\n    return {\n        isLoading: state.isLoading,\n        data,\n        error: state.error,\n        getState,\n        revalidate\n    };\n}\n_s7(useAsyncCache, \"zUQ6EZUfCzh2QcdK6ZowCEtVZng=\", false, function() {\n    return [\n        useInitial,\n        react__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore,\n        react__WEBPACK_IMPORTED_MODULE_0__.useRef,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect\n    ];\n});\n// src/lib/use-latest.ts\n\nfunction useLatest(value) {\n    _s8();\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = value;\n    }, [\n        value\n    ]);\n    return ref;\n}\n_s8(useLatest, \"a1mvwK9yaYb3uQIJX0cV7QRdeVM=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useRef,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect\n    ];\n});\n// src/lib/use-rerender.ts\n\nfunction useRerender() {\n    _s9();\n    const [, update] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(// This implementation works by incrementing a hidden counter value that is\n    // never consumed. Simply incrementing the counter changes the component's\n    // state and, thus, trigger a re-render.\n    (x)=>x + 1, 0);\n    return update;\n}\n_s9(useRerender, \"OhrQOAn1W/INSRhOrgETZKuOhVA=\");\n// src/factory.tsx\nvar noop2 = ()=>{};\nvar identity = (x)=>x;\nvar missing_unstable_batchedUpdates = (reactVersion, roomId)=>\"We noticed youre using React \".concat(reactVersion, '. Please pass unstable_batchedUpdates at the RoomProvider level until youre ready to upgrade to React 18:\\n\\n    import { unstable_batchedUpdates } from \"react-dom\";  // or \"react-native\"\\n\\n    <RoomProvider id=').concat(JSON.stringify(roomId), \" ... unstable_batchedUpdates={unstable_batchedUpdates}>\\n      ...\\n    </RoomProvider>\\n\\nWhy? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information\");\nvar superfluous_unstable_batchedUpdates = \"You dont need to pass unstable_batchedUpdates to RoomProvider anymore, since youre on React 18+ already.\";\nfunction useSyncExternalStore3(s, gs, gss) {\n    _s10();\n    return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(s, gs, gss, identity);\n}\n_s10(useSyncExternalStore3, \"EC1G8rw5KMYMXttGdodq1Hr7j5k=\", false, function() {\n    return [\n        use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector\n    ];\n});\nvar STABLE_EMPTY_LIST = Object.freeze([]);\nfunction alwaysEmptyList() {\n    return STABLE_EMPTY_LIST;\n}\nfunction alwaysNull() {\n    return null;\n}\nfunction makeMutationContext(room) {\n    const errmsg = \"This mutation cannot be used until connected to the Liveblocks room\";\n    return {\n        get storage () {\n            const mutableRoot = room.getStorageSnapshot();\n            if (mutableRoot === null) {\n                throw new Error(errmsg);\n            }\n            return mutableRoot;\n        },\n        get self () {\n            const self = room.getSelf();\n            if (self === null) {\n                throw new Error(errmsg);\n            }\n            return self;\n        },\n        get others () {\n            const others = room.getOthers();\n            if (room.getSelf() === null) {\n                throw new Error(errmsg);\n            }\n            return others;\n        },\n        setMyPresence: room.updatePresence\n    };\n}\nvar hasWarnedIfNoResolveUsers = false;\nfunction warnIfNoResolveUsers(usersCache) {\n    if (!hasWarnedIfNoResolveUsers && !usersCache && \"development\" !== \"production\") {\n        console.warn(\"Set the resolveUsers option in createRoomContext to specify user info.\");\n        hasWarnedIfNoResolveUsers = true;\n    }\n}\nvar ContextBundle = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction useRoomContextBundle() {\n    _s11();\n    const bundle = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ContextBundle);\n    if (bundle === null) {\n        throw new Error(\"RoomProvider is missing from the React tree.\");\n    }\n    return bundle;\n}\n_s11(useRoomContextBundle, \"/Yt2TBLkiK+BQAGeiF3IxG9eCZY=\");\nfunction createRoomContext(client, options) {\n    var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$(), _s9 = $RefreshSig$(), _s10 = $RefreshSig$(), _s11 = $RefreshSig$(), _s12 = $RefreshSig$(), _s13 = $RefreshSig$(), _s14 = $RefreshSig$(), _s15 = $RefreshSig$(), _s16 = $RefreshSig$(), _s17 = $RefreshSig$(), _s18 = $RefreshSig$(), _s19 = $RefreshSig$(), _s20 = $RefreshSig$(), _s21 = $RefreshSig$(), _s22 = $RefreshSig$(), _s23 = $RefreshSig$(), _s24 = $RefreshSig$(), _s25 = $RefreshSig$(), _s26 = $RefreshSig$(), _s27 = $RefreshSig$(), _s28 = $RefreshSig$(), _s29 = $RefreshSig$(), _s30 = $RefreshSig$(), _s31 = $RefreshSig$(), _s32 = $RefreshSig$(), _s33 = $RefreshSig$(), _s34 = $RefreshSig$(), _s35 = $RefreshSig$(), _s36 = $RefreshSig$(), _s37 = $RefreshSig$(), _s38 = $RefreshSig$(), _s39 = $RefreshSig$(), _s40 = $RefreshSig$(), _s41 = $RefreshSig$(), _s42 = $RefreshSig$(), _s43 = $RefreshSig$(), _s44 = $RefreshSig$(), _s45 = $RefreshSig$(), _s46 = $RefreshSig$(), _s47 = $RefreshSig$();\n    const RoomContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n    const commentsErrorEventSource = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makeEventSource)();\n    const { CommentsRoomProvider, ...commentsRoom } = createCommentsRoom(commentsErrorEventSource);\n    function RoomProviderOuter(props) {\n        _s();\n        const [cache] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>/* @__PURE__ */ new Map());\n        const stableEnterRoom = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((roomId, options2)=>{\n            const cached = cache.get(roomId);\n            if (cached) return cached;\n            const rv = client.enterRoom(roomId, options2);\n            const origLeave = rv.leave;\n            rv.leave = ()=>{\n                origLeave();\n                cache.delete(roomId);\n            };\n            cache.set(roomId, rv);\n            return rv;\n        }, [\n            cache\n        ]);\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomProviderInner, {\n            ...props,\n            stableEnterRoom\n        });\n    }\n    _s(RoomProviderOuter, \"mKddi/3p7+2yJai7e/U3hcSmznE=\");\n    function RoomProviderInner(props) {\n        _s1();\n        const { id: roomId, stableEnterRoom } = props;\n        if (true) {\n            if (!roomId) {\n                throw new Error(\"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\");\n            }\n            if (typeof roomId !== \"string\") {\n                throw new Error(\"RoomProvider id property should be a string.\");\n            }\n            const majorReactVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version) || 1;\n            const oldReactVersion = majorReactVersion < 18;\n            (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.errorIf)(oldReactVersion && props.unstable_batchedUpdates === void 0, missing_unstable_batchedUpdates(majorReactVersion, roomId));\n            (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.deprecateIf)(!oldReactVersion && props.unstable_batchedUpdates !== void 0, superfluous_unstable_batchedUpdates);\n        }\n        var _props_autoConnect, _ref;\n        const frozenProps = useInitial({\n            initialPresence: props.initialPresence,\n            initialStorage: props.initialStorage,\n            unstable_batchedUpdates: props.unstable_batchedUpdates,\n            autoConnect: (_ref = (_props_autoConnect = props.autoConnect) !== null && _props_autoConnect !== void 0 ? _props_autoConnect : props.shouldInitiallyConnect) !== null && _ref !== void 0 ? _ref : \"object\" !== \"undefined\"\n        });\n        const [{ room }, setRoomLeavePair] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>stableEnterRoom(roomId, {\n                ...frozenProps,\n                autoConnect: false\n            }));\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            const pair = stableEnterRoom(roomId, frozenProps);\n            setRoomLeavePair(pair);\n            const { room: room2, leave } = pair;\n            if (frozenProps.autoConnect) {\n                room2.connect();\n            }\n            return ()=>{\n                leave();\n            };\n        }, [\n            roomId,\n            frozenProps,\n            stableEnterRoom\n        ]);\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomContext.Provider, {\n            value: room\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CommentsRoomProvider, {\n            room\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextBundle.Provider, {\n            value: internalBundle\n        }, props.children)));\n    }\n    _s1(RoomProviderInner, \"kmyFNYfVjxEECzhCpNH4Ewq/iwo=\", false, function() {\n        return [\n            useInitial\n        ];\n    });\n    function connectionIdSelector(others) {\n        return others.map((user)=>user.connectionId);\n    }\n    function useRoom() {\n        _s2();\n        const room = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RoomContext);\n        if (room === null) {\n            throw new Error(\"RoomProvider is missing from the React tree.\");\n        }\n        return room;\n    }\n    _s2(useRoom, \"8pzZl8Wn+Ru3GugNYlOVJR39oTA=\");\n    function useStatus() {\n        _s3();\n        const room = useRoom();\n        const subscribe2 = room.events.status.subscribe;\n        const getSnapshot2 = room.getStatus;\n        const getServerSnapshot = room.getStatus;\n        return useSyncExternalStore3(subscribe2, getSnapshot2, getServerSnapshot);\n    }\n    _s3(useStatus, \"OdNXbdzQRLrJA+fG9mgW2ld2gGc=\", false, function() {\n        return [\n            useRoom,\n            useSyncExternalStore3\n        ];\n    });\n    function useMyPresence() {\n        _s4();\n        const room = useRoom();\n        const subscribe2 = room.events.myPresence.subscribe;\n        const getSnapshot2 = room.getPresence;\n        const presence = useSyncExternalStore3(subscribe2, getSnapshot2, getSnapshot2);\n        const setPresence = room.updatePresence;\n        return [\n            presence,\n            setPresence\n        ];\n    }\n    _s4(useMyPresence, \"4ZrYwbtaxyk9SI5C92C78vRsNdU=\", false, function() {\n        return [\n            useRoom,\n            useSyncExternalStore3\n        ];\n    });\n    function useUpdateMyPresence() {\n        _s5();\n        return useRoom().updatePresence;\n    }\n    _s5(useUpdateMyPresence, \"FxiKrJOMJJNhaRQQz0EOlEBhEog=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useOthers(selector, isEqual) {\n        _s6();\n        const room = useRoom();\n        const subscribe2 = room.events.others.subscribe;\n        const getSnapshot2 = room.getOthers;\n        const getServerSnapshot = alwaysEmptyList;\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(subscribe2, getSnapshot2, getServerSnapshot, selector !== null && selector !== void 0 ? selector : identity, isEqual);\n    }\n    _s6(useOthers, \"wzDTGbE0RFy0tOTusrlT61JxYmA=\", false, function() {\n        return [\n            useRoom,\n            use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector\n        ];\n    });\n    function useOthersConnectionIds() {\n        _s7();\n        return useOthers(connectionIdSelector, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow);\n    }\n    _s7(useOthersConnectionIds, \"6jB4CmiADvy0x5yMLb1ArTc/siU=\", false, function() {\n        return [\n            useOthers\n        ];\n    });\n    function useOthersMapped(itemSelector, itemIsEqual) {\n        _s8();\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((others)=>others.map((other)=>[\n                    other.connectionId,\n                    itemSelector(other)\n                ]), [\n            itemSelector\n        ]);\n        const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((a, b)=>{\n            const eq = itemIsEqual !== null && itemIsEqual !== void 0 ? itemIsEqual : Object.is;\n            return a.length === b.length && a.every((atuple, index)=>{\n                const btuple = b[index];\n                return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n            });\n        }, [\n            itemIsEqual\n        ]);\n        return useOthers(wrappedSelector, wrappedIsEqual);\n    }\n    _s8(useOthersMapped, \"QVo/xWftrYyzYLUmcqVZUiiRPdw=\", false, function() {\n        return [\n            useOthers\n        ];\n    });\n    const NOT_FOUND = Symbol();\n    function useOther(connectionId, selector, isEqual) {\n        _s9();\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((others)=>{\n            const other2 = others.find((other3)=>other3.connectionId === connectionId);\n            return other2 !== void 0 ? selector(other2) : NOT_FOUND;\n        }, [\n            connectionId,\n            selector\n        ]);\n        const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((prev, curr)=>{\n            if (prev === NOT_FOUND || curr === NOT_FOUND) {\n                return prev === curr;\n            }\n            const eq = isEqual !== null && isEqual !== void 0 ? isEqual : Object.is;\n            return eq(prev, curr);\n        }, [\n            isEqual\n        ]);\n        const other = useOthers(wrappedSelector, wrappedIsEqual);\n        if (other === NOT_FOUND) {\n            throw new Error(\"No such other user with connection id \".concat(connectionId, \" exists\"));\n        }\n        return other;\n    }\n    _s9(useOther, \"9iZgjSXiCys5UFZauLNwjMbsrjo=\", false, function() {\n        return [\n            useOthers\n        ];\n    });\n    function useBroadcastEvent() {\n        _s10();\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(event) {\n            let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n                shouldQueueEventIfNotReady: false\n            };\n            room.broadcastEvent(event, options2);\n        }, [\n            room\n        ]);\n    }\n    _s10(useBroadcastEvent, \"mRjfZCZLIOt9iOyXufGWtKsUM38=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useOthersListener(callback) {\n        _s11();\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>room.events.others.subscribe((event)=>savedCallback.current(event)), [\n            room,\n            savedCallback\n        ]);\n    }\n    _s11(useOthersListener, \"pVgeNp/NR8vr1KFBM1x9XIErS1Y=\", false, function() {\n        return [\n            useRoom,\n            useLatest\n        ];\n    });\n    function useLostConnectionListener(callback) {\n        _s12();\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>room.events.lostConnection.subscribe((event)=>savedCallback.current(event)), [\n            room,\n            savedCallback\n        ]);\n    }\n    _s12(useLostConnectionListener, \"pVgeNp/NR8vr1KFBM1x9XIErS1Y=\", false, function() {\n        return [\n            useRoom,\n            useLatest\n        ];\n    });\n    function useErrorListener(callback) {\n        _s13();\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>room.events.error.subscribe((e)=>savedCallback.current(e)), [\n            room,\n            savedCallback\n        ]);\n    }\n    _s13(useErrorListener, \"pVgeNp/NR8vr1KFBM1x9XIErS1Y=\", false, function() {\n        return [\n            useRoom,\n            useLatest\n        ];\n    });\n    function useEventListener(callback) {\n        _s14();\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            const listener = (eventData)=>{\n                savedCallback.current(eventData);\n            };\n            return room.events.customEvent.subscribe(listener);\n        }, [\n            room,\n            savedCallback\n        ]);\n    }\n    _s14(useEventListener, \"pVgeNp/NR8vr1KFBM1x9XIErS1Y=\", false, function() {\n        return [\n            useRoom,\n            useLatest\n        ];\n    });\n    function useSelf(maybeSelector, isEqual) {\n        _s15();\n        const room = useRoom();\n        const subscribe2 = room.events.self.subscribe;\n        const getSnapshot2 = room.getSelf;\n        const selector = maybeSelector !== null && maybeSelector !== void 0 ? maybeSelector : identity;\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((me)=>me !== null ? selector(me) : null, [\n            selector\n        ]);\n        const getServerSnapshot = alwaysNull;\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(subscribe2, getSnapshot2, getServerSnapshot, wrappedSelector, isEqual);\n    }\n    _s15(useSelf, \"f6H1LHeDifHCBxYaDVND0KejjWE=\", false, function() {\n        return [\n            useRoom,\n            use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector\n        ];\n    });\n    function useMutableStorageRoot() {\n        _s16();\n        const room = useRoom();\n        const subscribe2 = room.events.storageDidLoad.subscribeOnce;\n        const getSnapshot2 = room.getStorageSnapshot;\n        const getServerSnapshot = alwaysNull;\n        return useSyncExternalStore3(subscribe2, getSnapshot2, getServerSnapshot);\n    }\n    _s16(useMutableStorageRoot, \"OdNXbdzQRLrJA+fG9mgW2ld2gGc=\", false, function() {\n        return [\n            useRoom,\n            useSyncExternalStore3\n        ];\n    });\n    function useStorageRoot() {\n        _s17();\n        return [\n            useMutableStorageRoot()\n        ];\n    }\n    _s17(useStorageRoot, \"ScjpHkLIwcJwYDu1t5uCS240Fs8=\", false, function() {\n        return [\n            useMutableStorageRoot\n        ];\n    });\n    function useHistory() {\n        _s18();\n        return useRoom().history;\n    }\n    _s18(useHistory, \"FxiKrJOMJJNhaRQQz0EOlEBhEog=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useUndo() {\n        _s19();\n        return useHistory().undo;\n    }\n    _s19(useUndo, \"ebO9cvF3Ou0GZnyLIaifBK5vWck=\", false, function() {\n        return [\n            useHistory\n        ];\n    });\n    function useRedo() {\n        _s20();\n        return useHistory().redo;\n    }\n    _s20(useRedo, \"ebO9cvF3Ou0GZnyLIaifBK5vWck=\", false, function() {\n        return [\n            useHistory\n        ];\n    });\n    function useCanUndo() {\n        _s21();\n        const room = useRoom();\n        const subscribe2 = room.events.history.subscribe;\n        const canUndo = room.history.canUndo;\n        return useSyncExternalStore3(subscribe2, canUndo, canUndo);\n    }\n    _s21(useCanUndo, \"OdNXbdzQRLrJA+fG9mgW2ld2gGc=\", false, function() {\n        return [\n            useRoom,\n            useSyncExternalStore3\n        ];\n    });\n    function useCanRedo() {\n        _s22();\n        const room = useRoom();\n        const subscribe2 = room.events.history.subscribe;\n        const canRedo = room.history.canRedo;\n        return useSyncExternalStore3(subscribe2, canRedo, canRedo);\n    }\n    _s22(useCanRedo, \"OdNXbdzQRLrJA+fG9mgW2ld2gGc=\", false, function() {\n        return [\n            useRoom,\n            useSyncExternalStore3\n        ];\n    });\n    function useBatch() {\n        _s23();\n        return useRoom().batch;\n    }\n    _s23(useBatch, \"FxiKrJOMJJNhaRQQz0EOlEBhEog=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useLegacyKey(key) {\n        _s24();\n        const room = useRoom();\n        const rootOrNull = useMutableStorageRoot();\n        const rerender = useRerender();\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            if (rootOrNull === null) {\n                return;\n            }\n            const root = rootOrNull;\n            let unsubCurr;\n            let curr = root.get(key);\n            function subscribeToCurr() {\n                unsubCurr = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.isLiveNode)(curr) ? room.subscribe(curr, rerender) : void 0;\n            }\n            function onRootChange() {\n                const newValue = root.get(key);\n                if (newValue !== curr) {\n                    unsubCurr === null || unsubCurr === void 0 ? void 0 : unsubCurr();\n                    curr = newValue;\n                    subscribeToCurr();\n                    rerender();\n                }\n            }\n            subscribeToCurr();\n            rerender();\n            const unsubscribeRoot = room.subscribe(root, onRootChange);\n            return ()=>{\n                unsubscribeRoot();\n                unsubCurr === null || unsubCurr === void 0 ? void 0 : unsubCurr();\n            };\n        }, [\n            rootOrNull,\n            room,\n            key,\n            rerender\n        ]);\n        if (rootOrNull === null) {\n            return null;\n        } else {\n            return rootOrNull.get(key);\n        }\n    }\n    _s24(useLegacyKey, \"Jcr1Y5ArKo4MfMC3Yie4xsFig0A=\", false, function() {\n        return [\n            useRoom,\n            useMutableStorageRoot,\n            useRerender\n        ];\n    });\n    function useStorage(selector, isEqual) {\n        _s25();\n        const room = useRoom();\n        const rootOrNull = useMutableStorageRoot();\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((rootOrNull2)=>rootOrNull2 !== null ? selector(rootOrNull2) : null, [\n            selector\n        ]);\n        const subscribe2 = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((onStoreChange)=>rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, {\n                isDeep: true\n            }) : noop2, [\n            room,\n            rootOrNull\n        ]);\n        const getSnapshot2 = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n            if (rootOrNull === null) {\n                return null;\n            } else {\n                const root = rootOrNull;\n                const imm = root.toImmutable();\n                return imm;\n            }\n        }, [\n            rootOrNull\n        ]);\n        const getServerSnapshot = alwaysNull;\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(subscribe2, getSnapshot2, getServerSnapshot, wrappedSelector, isEqual);\n    }\n    _s25(useStorage, \"IN17QOwcHbvLZJFho2jFscicPEU=\", false, function() {\n        return [\n            useRoom,\n            useMutableStorageRoot,\n            use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector\n        ];\n    });\n    function ensureNotServerSide() {\n        if (false) {}\n    }\n    function useSuspendUntilStorageLoaded() {\n        _s26();\n        const room = useRoom();\n        if (room.getStorageSnapshot() !== null) {\n            return;\n        }\n        ensureNotServerSide();\n        throw new Promise((res)=>{\n            room.events.storageDidLoad.subscribeOnce(()=>res());\n        });\n    }\n    _s26(useSuspendUntilStorageLoaded, \"5S+JyCCayKN2MtiKPOSRKS71F0s=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useSuspendUntilPresenceLoaded() {\n        _s27();\n        const room = useRoom();\n        if (room.getSelf() !== null) {\n            return;\n        }\n        ensureNotServerSide();\n        throw new Promise((res)=>{\n            room.events.self.subscribeOnce(()=>res());\n            room.events.status.subscribeOnce(()=>res());\n        });\n    }\n    _s27(useSuspendUntilPresenceLoaded, \"5S+JyCCayKN2MtiKPOSRKS71F0s=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useMutation(callback, deps) {\n        _s28();\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n            return function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                return(// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                room.batch(()=>// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    callback(makeMutationContext(room), ...args)));\n            };\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            room,\n            ...deps\n        ]);\n    }\n    _s28(useMutation, \"UIS+w5CDyOyk6Qsa0iFAjGNrJxA=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useStorageSuspense(selector, isEqual) {\n        _s29();\n        useSuspendUntilStorageLoaded();\n        return useStorage(selector, isEqual);\n    }\n    _s29(useStorageSuspense, \"ufHq6RVDBh54qc/BvISf00FLxV0=\", false, function() {\n        return [\n            useSuspendUntilStorageLoaded,\n            useStorage\n        ];\n    });\n    function useSelfSuspense(selector, isEqual) {\n        _s30();\n        useSuspendUntilPresenceLoaded();\n        return useSelf(selector, isEqual);\n    }\n    _s30(useSelfSuspense, \"BgLte48ji+6JvKhVuqCKetBzjDw=\", false, function() {\n        return [\n            useSuspendUntilPresenceLoaded,\n            useSelf\n        ];\n    });\n    function useOthersSuspense(selector, isEqual) {\n        _s31();\n        useSuspendUntilPresenceLoaded();\n        return useOthers(selector, isEqual);\n    }\n    _s31(useOthersSuspense, \"tgwOdB3IIxS+X2oeFCV6cWMZDcg=\", false, function() {\n        return [\n            useSuspendUntilPresenceLoaded,\n            useOthers\n        ];\n    });\n    function useOthersConnectionIdsSuspense() {\n        _s32();\n        useSuspendUntilPresenceLoaded();\n        return useOthersConnectionIds();\n    }\n    _s32(useOthersConnectionIdsSuspense, \"BffsyqAH7fc+aZC9vagFs5jiTu4=\", false, function() {\n        return [\n            useSuspendUntilPresenceLoaded,\n            useOthersConnectionIds\n        ];\n    });\n    function useOthersMappedSuspense(itemSelector, itemIsEqual) {\n        _s33();\n        useSuspendUntilPresenceLoaded();\n        return useOthersMapped(itemSelector, itemIsEqual);\n    }\n    _s33(useOthersMappedSuspense, \"J+5f7Iz6l6KRz7hpbMcA7i42zPc=\", false, function() {\n        return [\n            useSuspendUntilPresenceLoaded,\n            useOthersMapped\n        ];\n    });\n    function useOtherSuspense(connectionId, selector, isEqual) {\n        _s34();\n        useSuspendUntilPresenceLoaded();\n        return useOther(connectionId, selector, isEqual);\n    }\n    _s34(useOtherSuspense, \"sSBwliR/JAo6HptIb+i+vJMr9hk=\", false, function() {\n        return [\n            useSuspendUntilPresenceLoaded,\n            useOther\n        ];\n    });\n    function useLegacyKeySuspense(key) {\n        _s35();\n        useSuspendUntilStorageLoaded();\n        return useLegacyKey(key);\n    }\n    _s35(useLegacyKeySuspense, \"yueVrdGi24iMN//WrvZxeaFAsDg=\", false, function() {\n        return [\n            useSuspendUntilStorageLoaded,\n            useLegacyKey\n        ];\n    });\n    function useThreads(options2) {\n        _s36();\n        const room = useRoom();\n        return commentsRoom.useThreads(room, options2);\n    }\n    _s36(useThreads, \"o+WFlB5hSuYG/PHlCbTY/mx/TJw=\", false, function() {\n        return [\n            useRoom,\n            commentsRoom.useThreads\n        ];\n    });\n    function useThreadsSuspense(options2) {\n        _s37();\n        const room = useRoom();\n        return commentsRoom.useThreadsSuspense(room, options2);\n    }\n    _s37(useThreadsSuspense, \"STT/yFUxKr4r1muYxSpwQAHys8s=\", false, function() {\n        return [\n            useRoom,\n            commentsRoom.useThreadsSuspense\n        ];\n    });\n    function useCreateThread() {\n        _s38();\n        const room = useRoom();\n        return commentsRoom.useCreateThread(room);\n    }\n    _s38(useCreateThread, \"2iPVHh8qy0aDUrmToyuLR21t03M=\", false, function() {\n        return [\n            useRoom,\n            commentsRoom.useCreateThread\n        ];\n    });\n    function useEditThreadMetadata() {\n        _s39();\n        const room = useRoom();\n        return commentsRoom.useEditThreadMetadata(room);\n    }\n    _s39(useEditThreadMetadata, \"2mGozCN26yJEcdaWATs/tKHqZro=\", false, function() {\n        return [\n            useRoom,\n            commentsRoom.useEditThreadMetadata\n        ];\n    });\n    function useAddReaction() {\n        _s40();\n        const room = useRoom();\n        return commentsRoom.useAddReaction(room);\n    }\n    _s40(useAddReaction, \"F7SF14gXcfzSmD8Gzr1LqgKAUJk=\", false, function() {\n        return [\n            useRoom,\n            commentsRoom.useAddReaction\n        ];\n    });\n    function useRemoveReaction() {\n        _s41();\n        const room = useRoom();\n        return commentsRoom.useRemoveReaction(room);\n    }\n    _s41(useRemoveReaction, \"M93dOr7m4KfFcayxIUneQE0lTdM=\", false, function() {\n        return [\n            useRoom,\n            commentsRoom.useRemoveReaction\n        ];\n    });\n    function useCreateComment() {\n        _s42();\n        const room = useRoom();\n        return commentsRoom.useCreateComment(room);\n    }\n    _s42(useCreateComment, \"8trAUQ2X3TtYFUPxQ48hgUgzFY4=\", false, function() {\n        return [\n            useRoom,\n            commentsRoom.useCreateComment\n        ];\n    });\n    function useEditComment() {\n        _s43();\n        const room = useRoom();\n        return commentsRoom.useEditComment(room);\n    }\n    _s43(useEditComment, \"qzpraICj4araHhBfu/Y5GiNNajU=\", false, function() {\n        return [\n            useRoom,\n            commentsRoom.useEditComment\n        ];\n    });\n    function useDeleteComment() {\n        _s44();\n        const room = useRoom();\n        return commentsRoom.useDeleteComment(room);\n    }\n    _s44(useDeleteComment, \"UvRBKjJcTCcGC5h+mF2Ag6Xvn7w=\", false, function() {\n        return [\n            useRoom,\n            commentsRoom.useDeleteComment\n        ];\n    });\n    const { resolveUsers, resolveMentionSuggestions } = options !== null && options !== void 0 ? options : {};\n    const usersCache = resolveUsers ? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.createAsyncCache)(async (stringifiedOptions)=>{\n        const users = await resolveUsers(JSON.parse(stringifiedOptions));\n        return users === null || users === void 0 ? void 0 : users[0];\n    }) : void 0;\n    function useUser(userId) {\n        _s45();\n        const room = useRoom();\n        const resolverKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)({\n                userIds: [\n                    userId\n                ],\n                roomId: room.id\n            }), [\n            userId,\n            room.id\n        ]);\n        const state = useAsyncCache(usersCache, resolverKey);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>warnIfNoResolveUsers(usersCache), []);\n        if (state.isLoading) {\n            return {\n                isLoading: true\n            };\n        } else {\n            return {\n                user: state.data,\n                error: state.error,\n                isLoading: false\n            };\n        }\n    }\n    _s45(useUser, \"rJ/lBuWLnN7/xOnx6ttTQqx+560=\", false, function() {\n        return [\n            useRoom,\n            useAsyncCache\n        ];\n    });\n    function useUserSuspense(userId) {\n        _s46();\n        const room = useRoom();\n        const resolverKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)({\n                userIds: [\n                    userId\n                ],\n                roomId: room.id\n            }), [\n            userId,\n            room.id\n        ]);\n        const state = useAsyncCache(usersCache, resolverKey, {\n            suspense: true\n        });\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>warnIfNoResolveUsers(usersCache), []);\n        return {\n            user: state.data,\n            isLoading: false\n        };\n    }\n    _s46(useUserSuspense, \"rJ/lBuWLnN7/xOnx6ttTQqx+560=\", false, function() {\n        return [\n            useRoom,\n            useAsyncCache\n        ];\n    });\n    const mentionSuggestionsCache = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.createAsyncCache)(resolveMentionSuggestions ? (stringifiedOptions)=>{\n        return resolveMentionSuggestions(JSON.parse(stringifiedOptions));\n    } : ()=>Promise.resolve([]));\n    function useMentionSuggestions(search) {\n        _s47();\n        const room = useRoom();\n        const debouncedSearch = useDebounce(search, 500);\n        const resolverKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>debouncedSearch !== void 0 ? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)({\n                text: debouncedSearch,\n                roomId: room.id\n            }) : null, [\n            debouncedSearch,\n            room.id\n        ]);\n        const { data } = useAsyncCache(mentionSuggestionsCache, resolverKey, {\n            keepPreviousDataWhileLoading: true\n        });\n        return data;\n    }\n    _s47(useMentionSuggestions, \"unluCUgg5gW3RfiuGuQwUOY6mnU=\", false, function() {\n        return [\n            useRoom,\n            useDebounce,\n            useAsyncCache\n        ];\n    });\n    const bundle = {\n        RoomContext,\n        RoomProvider: RoomProviderOuter,\n        useRoom,\n        useStatus,\n        useBatch,\n        useBroadcastEvent,\n        useOthersListener,\n        useLostConnectionListener,\n        useErrorListener,\n        useEventListener,\n        useHistory,\n        useUndo,\n        useRedo,\n        useCanRedo,\n        useCanUndo,\n        // These are just aliases. The passed-in key will define their return values.\n        useList: useLegacyKey,\n        useMap: useLegacyKey,\n        useObject: useLegacyKey,\n        useStorageRoot,\n        useStorage,\n        useSelf,\n        useMyPresence,\n        useUpdateMyPresence,\n        useOthers,\n        useOthersMapped,\n        useOthersConnectionIds,\n        useOther,\n        useMutation,\n        useThreads,\n        useUser,\n        useCreateThread,\n        useEditThreadMetadata,\n        useCreateComment,\n        useEditComment,\n        useDeleteComment,\n        useAddReaction,\n        useRemoveReaction,\n        suspense: {\n            RoomContext,\n            RoomProvider: RoomProviderOuter,\n            useRoom,\n            useStatus,\n            useBatch,\n            useBroadcastEvent,\n            useOthersListener,\n            useLostConnectionListener,\n            useErrorListener,\n            useEventListener,\n            useHistory,\n            useUndo,\n            useRedo,\n            useCanRedo,\n            useCanUndo,\n            // Legacy hooks\n            useList: useLegacyKeySuspense,\n            useMap: useLegacyKeySuspense,\n            useObject: useLegacyKeySuspense,\n            useStorageRoot,\n            useStorage: useStorageSuspense,\n            useSelf: useSelfSuspense,\n            useMyPresence,\n            useUpdateMyPresence,\n            useOthers: useOthersSuspense,\n            useOthersMapped: useOthersMappedSuspense,\n            useOthersConnectionIds: useOthersConnectionIdsSuspense,\n            useOther: useOtherSuspense,\n            useMutation,\n            useThreads: useThreadsSuspense,\n            useUser: useUserSuspense,\n            useCreateThread,\n            useEditThreadMetadata,\n            useCreateComment,\n            useEditComment,\n            useDeleteComment,\n            useAddReaction,\n            useRemoveReaction\n        }\n    };\n    const internalBundle = {\n        ...bundle,\n        hasResolveMentionSuggestions: resolveMentionSuggestions !== void 0,\n        useMentionSuggestions\n    };\n    return bundle;\n}\n// src/index.ts\n\n(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.detectDupes)(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n //# sourceMappingURL=index.mjs.map\nvar _c;\n$RefreshReg$(_c, \"ClientSideSuspense\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBRUEsZUFBZTtBQUNnQztBQUUvQyxpQkFBaUI7QUFDakIsSUFBSUMsV0FBVztBQUNmLElBQUlDLGNBQWM7QUFDbEIsSUFBSUMsYUFBYTtBQUVqQiw2QkFBNkI7QUFDRTtBQUMvQixTQUFTRSxtQkFBbUJDLEtBQUs7O0lBQy9CLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHSiwyQ0FBYyxDQUFDO0lBQzdDQSw0Q0FBZSxDQUFDO1FBQ2RJLFdBQVc7SUFDYixHQUFHLEVBQUU7SUFDTCxPQUFPLGFBQWEsaUJBQUdKLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFO1FBQUVTLFVBQVVQLE1BQU1PLFFBQVE7SUFBQyxHQUFHTixVQUFVRCxNQUFNUSxRQUFRLEtBQUtSLE1BQU1PLFFBQVE7QUFDdEk7R0FOU1I7S0FBQUE7QUFRVCxrQkFBa0I7QUFDMkI7QUFRbkI7QUFDTTtBQUNzRztBQUV0SSxnQ0FBZ0M7QUFDZ0Q7QUFDaEQ7QUFPakI7QUFDa0Y7QUFFakcseUJBQXlCO0FBQ3pCLElBQUkrQixvQkFBb0IsY0FBY0M7SUFDcENDLFlBQVlDLEtBQUssRUFBRUMsT0FBTyxDQUFFO1FBQzFCLEtBQUssQ0FBQztRQUNOLElBQUksQ0FBQ0QsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUNBLElBQUlDLDBCQUEwQixjQUFjTDtJQUMxQ0MsWUFBWUMsS0FBSyxFQUFFQyxPQUFPLENBQUU7UUFDMUIsS0FBSyxDQUFDO1FBQ04sSUFBSSxDQUFDRCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBQ0EsSUFBSUUscUJBQXFCLGNBQWNOO0lB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WUFDQUM7WUFDQThEO1lBQ0E5QjtZQUNBSTtZQUNBRTtZQUNBRTtZQUNBRTtZQUNBVTtZQUNBRTtZQUNBRTtZQUNBSTtZQUNBRjtZQUNBLGVBQWU7WUFDZmdELFNBQVNmO1lBQ1RnQixRQUFRaEI7WUFDUmlCLFdBQVdqQjtZQUNYeEM7WUFDQXNCLFlBQVlZO1lBQ1p2QyxTQUFTd0M7WUFDVHBGO1lBQ0FLO1lBQ0FDLFdBQVcrRTtZQUNYM0UsaUJBQWlCNkU7WUFDakI5RSx3QkFBd0I2RTtZQUN4QjlELFVBQVVnRTtZQUNWUjtZQUNBclIsWUFBWU87WUFDWjRSLFNBQVNHO1lBQ1RqUjtZQUNBUDtZQUNBc0I7WUFDQUc7WUFDQUc7WUFDQU07WUFDQUs7UUFDRjtJQUNGO0lBQ0EsTUFBTTBJLGlCQUFpQjtRQUNyQixHQUFHNUIsTUFBTTtRQUNUNkksOEJBQThCaEIsOEJBQThCLEtBQUs7UUFDakVRO0lBQ0Y7SUFDQSxPQUFPckk7QUFDVDtBQUVBLGVBQWU7QUFDMEM7QUFDekRyViw2REFBV0EsQ0FBQ0MsVUFBVUMsYUFBYUM7QUFNakMsQ0FDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0L2Rpc3QvaW5kZXgubWpzP2NkMzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgZGV0ZWN0RHVwZXMgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuXG4vLyBzcmMvdmVyc2lvbi50c1xudmFyIFBLR19OQU1FID0gXCJAbGl2ZWJsb2Nrcy9yZWFjdFwiO1xudmFyIFBLR19WRVJTSU9OID0gXCIxLjkuN1wiO1xudmFyIFBLR19GT1JNQVQgPSBcImVzbVwiO1xuXG4vLyBzcmMvQ2xpZW50U2lkZVN1c3BlbnNlLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBDbGllbnRTaWRlU3VzcGVuc2UocHJvcHMpIHtcbiAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldE1vdW50ZWQodHJ1ZSk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LlN1c3BlbnNlLCB7IGZhbGxiYWNrOiBwcm9wcy5mYWxsYmFjayB9LCBtb3VudGVkID8gcHJvcHMuY2hpbGRyZW4oKSA6IHByb3BzLmZhbGxiYWNrKTtcbn1cblxuLy8gc3JjL2ZhY3RvcnkudHN4XG5pbXBvcnQgeyBzaGFsbG93IH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NsaWVudFwiO1xuaW1wb3J0IHtcbiAgY3JlYXRlQXN5bmNDYWNoZSxcbiAgZGVwcmVjYXRlSWYsXG4gIGVycm9ySWYsXG4gIGlzTGl2ZU5vZGUsXG4gIG1ha2VFdmVudFNvdXJjZSBhcyBtYWtlRXZlbnRTb3VyY2UyLFxuICBzdHJpbmdpZnkgYXMgc3RyaW5naWZ5MlxufSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuaW1wb3J0ICogYXMgUmVhY3QzIGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgYXMgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyIH0gZnJvbSBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vd2l0aC1zZWxlY3Rvci5qc1wiO1xuXG4vLyBzcmMvY29tbWVudHMvQ29tbWVudHNSb29tLnRzeFxuaW1wb3J0IHsgQ29tbWVudHNBcGlFcnJvciwgbWFrZUV2ZW50U291cmNlLCBzdHJpbmdpZnkgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuaW1wb3J0IHsgbmFub2lkIH0gZnJvbSBcIm5hbm9pZFwiO1xuaW1wb3J0IFJlYWN0Miwge1xuICBjcmVhdGVDb250ZXh0LFxuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazMsXG4gIHVzZUNvbnRleHQsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QzLFxuICB1c2VNZW1vXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzXCI7XG5cbi8vIHNyYy9jb21tZW50cy9lcnJvcnMudHNcbnZhciBDcmVhdGVUaHJlYWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiQ3JlYXRlIHRocmVhZCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiQ3JlYXRlVGhyZWFkRXJyb3JcIjtcbiAgfVxufTtcbnZhciBFZGl0VGhyZWFkTWV0YWRhdGFFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiRWRpdCB0aHJlYWQgbWV0YWRhdGEgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIkVkaXRUaHJlYWRNZXRhZGF0YUVycm9yXCI7XG4gIH1cbn07XG52YXIgQ3JlYXRlQ29tbWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJDcmVhdGUgY29tbWVudCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiQ3JlYXRlQ29tbWVudEVycm9yXCI7XG4gIH1cbn07XG52YXIgRWRpdENvbW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiRWRpdCBjb21tZW50IGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJFZGl0Q29tbWVudEVycm9yXCI7XG4gIH1cbn07XG52YXIgRGVsZXRlQ29tbWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJEZWxldGUgY29tbWVudCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiRGVsZXRlQ29tbWVudEVycm9yXCI7XG4gIH1cbn07XG52YXIgQWRkUmVhY3Rpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiQWRkIHJlYWN0aW9uIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJBZGRSZWFjdGlvbkVycm9yXCI7XG4gIH1cbn07XG52YXIgUmVtb3ZlUmVhY3Rpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiUmVtb3ZlIHJlYWN0aW9uIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJSZW1vdmVSZWFjdGlvbkVycm9yXCI7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tZW50cy9saWIvcmV2YWxpZGF0aW9uLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyLCB1c2VSZWYgYXMgdXNlUmVmMiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvY29tbWVudHMvbGliL3VzZS1pcy1kb2N1bWVudC12aXNpYmxlLnRzXG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzXCI7XG5mdW5jdGlvbiB1c2VJc0RvY3VtZW50VmlzaWJsZSgpIHtcbiAgY29uc3QgaXNWaXNpYmxlID0gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U25hcHNob3QpO1xuICByZXR1cm4gaXNWaXNpYmxlO1xufVxuZnVuY3Rpb24gc3Vic2NyaWJlKG9uU3RvcmVDaGFuZ2UpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25TdG9yZUNoYW5nZSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25TdG9yZUNoYW5nZSk7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRTbmFwc2hvdCgpIHtcbiAgY29uc3QgaXNEb2N1bWVudERlZmluZWQgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG4gIHJldHVybiBpc0RvY3VtZW50RGVmaW5lZCA/IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJ2aXNpYmxlXCIgOiB0cnVlO1xufVxuXG4vLyBzcmMvY29tbWVudHMvbGliL3VzZS1pcy1vbmxpbmUudHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlMiB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzXCI7XG5mdW5jdGlvbiB1c2VJc09ubGluZSgpIHtcbiAgY29uc3QgaXNPbmxpbmVSZWYgPSB1c2VSZWYodHJ1ZSk7XG4gIGNvbnN0IHN1YnNjcmliZTIgPSB1c2VDYWxsYmFjaygob25TdG9yZUNoYW5nZSkgPT4ge1xuICAgIGZ1bmN0aW9uIGhhbmRsZUlzT25saW5lKCkge1xuICAgICAgaXNPbmxpbmVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICBvblN0b3JlQ2hhbmdlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUlzT2ZmbGluZSgpIHtcbiAgICAgIGlzT25saW5lUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIG9uU3RvcmVDaGFuZ2UoKTtcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgaGFuZGxlSXNPbmxpbmUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBoYW5kbGVJc09mZmxpbmUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBoYW5kbGVJc09ubGluZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgaGFuZGxlSXNPZmZsaW5lKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IGdldFNuYXBzaG90MiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByZXR1cm4gaXNPbmxpbmVSZWYuY3VycmVudDtcbiAgfSwgW10pO1xuICBjb25zdCBpc09ubGluZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlMihzdWJzY3JpYmUyLCBnZXRTbmFwc2hvdDIsIGdldFNuYXBzaG90Mik7XG4gIHJldHVybiBpc09ubGluZTtcbn1cblxuLy8gc3JjL2NvbW1lbnRzL2xpYi9yZXZhbGlkYXRpb24udHNcbnZhciBERUZBVUxUX0VSUk9SX1JFVFJZX0lOVEVSVkFMID0gNWUzO1xudmFyIERFRkFVTFRfTUFYX0VSUk9SX1JFVFJZX0NPVU5UID0gNTtcbnZhciBERUZBVUxUX0RFRFVQSU5HX0lOVEVSVkFMID0gMmUzO1xudmFyIHRpbWVzdGFtcCA9IDA7XG5mdW5jdGlvbiB1c2VSZXZhbGlkYXRlQ2FjaGUobWFuYWdlciwgZmV0Y2hlciwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGlzT25saW5lUmVmID0gdXNlUmVmMih0cnVlKTtcbiAgY29uc3Qge1xuICAgIGRlZHVwaW5nSW50ZXJ2YWwgPSBERUZBVUxUX0RFRFVQSU5HX0lOVEVSVkFMLFxuICAgIGVycm9yUmV0cnlJbnRlcnZhbCA9IERFRkFVTFRfRVJST1JfUkVUUllfSU5URVJWQUwsXG4gICAgZXJyb3JSZXRyeUNvdW50ID0gREVGQVVMVF9NQVhfRVJST1JfUkVUUllfQ09VTlRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IF9yZXZhbGlkYXRlQ2FjaGUgPSB1c2VDYWxsYmFjazIoXG4gICAgYXN5bmMgKHtcbiAgICAgIHNob3VsZERlZHVwZSxcbiAgICAgIHJldHJ5Q291bnQgPSAwXG4gICAgfSkgPT4ge1xuICAgICAgbGV0IHN0YXJ0QXQ7XG4gICAgICBjb25zdCBzaG91bGRTdGFydFJlcXVlc3QgPSAhbWFuYWdlci5nZXRSZXF1ZXN0KCkgfHwgIXNob3VsZERlZHVwZTtcbiAgICAgIGZ1bmN0aW9uIGRlbGV0ZUFjdGl2ZVJlcXVlc3QoKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVJlcXVlc3QgPSBtYW5hZ2VyLmdldFJlcXVlc3QoKTtcbiAgICAgICAgaWYgKCFhY3RpdmVSZXF1ZXN0KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGFjdGl2ZVJlcXVlc3QudGltZXN0YW1wICE9PSBzdGFydEF0KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbWFuYWdlci5zZXRSZXF1ZXN0KHZvaWQgMCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IH5+KChNYXRoLnJhbmRvbSgpICsgMC41KSAqICgxIDw8IChyZXRyeUNvdW50IDwgOCA/IHJldHJ5Q291bnQgOiA4KSkpICogZXJyb3JSZXRyeUludGVydmFsO1xuICAgICAgICBpZiAocmV0cnlDb3VudCA+IGVycm9yUmV0cnlDb3VudClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHZvaWQgX3JldmFsaWRhdGVDYWNoZSh7XG4gICAgICAgICAgICBzaG91bGREZWR1cGU6IGZhbHNlLFxuICAgICAgICAgICAgcmV0cnlDb3VudDogcmV0cnlDb3VudCArIDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkU3RhcnRSZXF1ZXN0KSB7XG4gICAgICAgIG1hbmFnZXIuc2V0UmVxdWVzdCh7XG4gICAgICAgICAgZmV0Y2hlcjogZmV0Y2hlcigpLFxuICAgICAgICAgIHRpbWVzdGFtcDogKyt0aW1lc3RhbXBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgYWN0aXZlUmVxdWVzdCA9IG1hbmFnZXIuZ2V0UmVxdWVzdCgpO1xuICAgICAgICBpZiAoIWFjdGl2ZVJlcXVlc3QpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdGFydEF0ID0gYWN0aXZlUmVxdWVzdC50aW1lc3RhbXA7XG4gICAgICAgIGNvbnN0IG5ld0RhdGEgPSBhd2FpdCBhY3RpdmVSZXF1ZXN0LmZldGNoZXI7XG4gICAgICAgIGlmIChzaG91bGRTdGFydFJlcXVlc3QpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGRlbGV0ZUFjdGl2ZVJlcXVlc3QsIGRlZHVwaW5nSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZVJlcXVlc3QgPSBtYW5hZ2VyLmdldFJlcXVlc3QoKTtcbiAgICAgICAgaWYgKCFhY3RpdmVSZXF1ZXN0IHx8IGFjdGl2ZVJlcXVlc3QudGltZXN0YW1wICE9PSBzdGFydEF0KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgYWN0aXZlTXV0YXRpb24gPSBtYW5hZ2VyLmdldE11dGF0aW9uKCk7XG4gICAgICAgIGlmIChhY3RpdmVNdXRhdGlvbiAmJiAoYWN0aXZlTXV0YXRpb24uc3RhcnRUaW1lID4gc3RhcnRBdCB8fCBhY3RpdmVNdXRhdGlvbi5lbmRUaW1lID4gc3RhcnRBdCB8fCBhY3RpdmVNdXRhdGlvbi5lbmRUaW1lID09PSAwKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtYW5hZ2VyLnNldENhY2hlKG5ld0RhdGEpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGRlbGV0ZUFjdGl2ZVJlcXVlc3QoKTtcbiAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIjtcbiAgICAgICAgY29uc3QgaXNPbmxpbmUgPSBpc09ubGluZVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoc2hvdWxkU3RhcnRSZXF1ZXN0ICYmIGlzVmlzaWJsZSAmJiBpc09ubGluZSlcbiAgICAgICAgICBoYW5kbGVFcnJvcigpO1xuICAgICAgICBtYW5hZ2VyLnNldEVycm9yKGVycik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSxcbiAgICBbbWFuYWdlciwgZmV0Y2hlciwgZGVkdXBpbmdJbnRlcnZhbCwgZXJyb3JSZXRyeUludGVydmFsLCBlcnJvclJldHJ5Q291bnRdXG4gICk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGhhbmRsZUlzT25saW5lKCkge1xuICAgICAgaXNPbmxpbmVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUlzT2ZmbGluZSgpIHtcbiAgICAgIGlzT25saW5lUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgaGFuZGxlSXNPbmxpbmUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBoYW5kbGVJc09mZmxpbmUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBoYW5kbGVJc09ubGluZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgaGFuZGxlSXNPZmZsaW5lKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IHJldmFsaWRhdGVDYWNoZSA9IHVzZUNhbGxiYWNrMihcbiAgICAoeyBzaG91bGREZWR1cGUgfSkgPT4ge1xuICAgICAgcmV0dXJuIF9yZXZhbGlkYXRlQ2FjaGUoeyBzaG91bGREZWR1cGUsIHJldHJ5Q291bnQ6IDAgfSk7XG4gICAgfSxcbiAgICBbX3JldmFsaWRhdGVDYWNoZV1cbiAgKTtcbiAgcmV0dXJuIHJldmFsaWRhdGVDYWNoZTtcbn1cbmZ1bmN0aW9uIHVzZU11dGF0ZShtYW5hZ2VyLCByZXZhbGlkYXRlQ2FjaGUpIHtcbiAgY29uc3QgbXV0YXRlID0gdXNlQ2FsbGJhY2syKFxuICAgIGFzeW5jIChkYXRhLCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBiZWZvcmVNdXRhdGlvblRpbWVzdGFtcCA9ICsrdGltZXN0YW1wO1xuICAgICAgbWFuYWdlci5zZXRNdXRhdGlvbih7XG4gICAgICAgIHN0YXJ0VGltZTogYmVmb3JlTXV0YXRpb25UaW1lc3RhbXAsXG4gICAgICAgIGVuZFRpbWU6IDBcbiAgICAgIH0pO1xuICAgICAgY29uc3QgY3VycmVudENhY2hlID0gbWFuYWdlci5nZXRDYWNoZSgpO1xuICAgICAgbWFuYWdlci5zZXRDYWNoZShvcHRpb25zLm9wdGltaXN0aWNEYXRhKTtcbiAgICAgIGxldCBlcnJvcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGRhdGE7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICB9XG4gICAgICBjb25zdCBhY3RpdmVNdXRhdGlvbiA9IG1hbmFnZXIuZ2V0TXV0YXRpb24oKTtcbiAgICAgIGlmIChhY3RpdmVNdXRhdGlvbiAmJiBiZWZvcmVNdXRhdGlvblRpbWVzdGFtcCAhPT0gYWN0aXZlTXV0YXRpb24uc3RhcnRUaW1lKSB7XG4gICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIG1hbmFnZXIuc2V0Q2FjaGUoY3VycmVudENhY2hlKTtcbiAgICAgIH1cbiAgICAgIG1hbmFnZXIuc2V0TXV0YXRpb24oe1xuICAgICAgICBzdGFydFRpbWU6IGJlZm9yZU11dGF0aW9uVGltZXN0YW1wLFxuICAgICAgICBlbmRUaW1lOiArK3RpbWVzdGFtcFxuICAgICAgfSk7XG4gICAgICBtYW5hZ2VyLnNldFJlcXVlc3Qodm9pZCAwKTtcbiAgICAgIHZvaWQgcmV2YWxpZGF0ZUNhY2hlKHsgc2hvdWxkRGVkdXBlOiBmYWxzZSB9KTtcbiAgICAgIGlmIChlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSxcbiAgICBbbWFuYWdlciwgcmV2YWxpZGF0ZUNhY2hlXVxuICApO1xuICByZXR1cm4gbXV0YXRlO1xufVxuXG4vLyBzcmMvY29tbWVudHMvQ29tbWVudHNSb29tLnRzeFxudmFyIFRIUkVBRF9JRF9QUkVGSVggPSBcInRoXCI7XG52YXIgQ09NTUVOVF9JRF9QUkVGSVggPSBcImNtXCI7XG52YXIgUE9MTElOR19JTlRFUlZBTF9SRUFMVElNRSA9IDNlNDtcbnZhciBQT0xMSU5HX0lOVEVSVkFMID0gNWUzO1xuZnVuY3Rpb24gY3JlYXRlQ29tbWVudHNSb29tKGVycm9yRXZlbnRTb3VyY2UpIHtcbiAgY29uc3Qgc3RvcmUgPSBjcmVhdGVDbGllbnRDYWNoZVN0b3JlKCk7XG4gIGNvbnN0IEZldGNoZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbiAgY29uc3QgUm9vbU1hbmFnZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbiAgZnVuY3Rpb24gZ2V0VGhyZWFkcyhtYW5hZ2VyKSB7XG4gICAgY29uc3QgdGhyZWFkcyA9IG1hbmFnZXIuZ2V0Q2FjaGUoKTtcbiAgICBpZiAoIXRocmVhZHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDYW5ub3QgdXBkYXRlIHRocmVhZHMgb3IgY29tbWVudHMgYmVmb3JlIHRoZXkgYXJlIGxvYWRlZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRocmVhZHM7XG4gIH1cbiAgZnVuY3Rpb24gQ29tbWVudHNSb29tUHJvdmlkZXIoe1xuICAgIHJvb20sXG4gICAgY2hpbGRyZW5cbiAgfSkge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGVSb29tUmV2YWxpZGF0aW9uTWFuYWdlcihyb29tLmlkLCB7XG4gICAgICAgIGdldENhY2hlOiBzdG9yZS5nZXRUaHJlYWRzLFxuICAgICAgICBzZXRDYWNoZTogc3RvcmUuc2V0VGhyZWFkc1xuICAgICAgfSk7XG4gICAgfSwgW3Jvb20uaWRdKTtcbiAgICBjb25zdCBmZXRjaGVyID0gUmVhY3QyLnVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBtYW5hZ2VyLmdldFJldmFsaWRhdGlvbk1hbmFnZXJzKCkuZmlsdGVyKChba2V5XSkgPT4gbWFuYWdlci5nZXRSZWZlcmVuY2VDb3VudChrZXkpID4gMCkubWFwKChbXywgbWFuYWdlcjJdKSA9PiBtYW5hZ2VyMi5nZXRPcHRpb25zKCkpO1xuICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIG9wdGlvbnMubWFwKGFzeW5jIChvcHRpb24pID0+IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgcm9vbS5nZXRUaHJlYWRzKG9wdGlvbik7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgY29uc3QgdGhyZWFkcyA9IEFycmF5LmZyb20oXG4gICAgICAgIG5ldyBNYXAocmVzcG9uc2VzLmZsYXQoKS5tYXAoKHRocmVhZCkgPT4gW3RocmVhZC5pZCwgdGhyZWFkXSkpLnZhbHVlcygpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRocmVhZHM7XG4gICAgfSwgW3Jvb20sIG1hbmFnZXJdKTtcbiAgICBjb25zdCByZXZhbGlkYXRlQ2FjaGUgPSB1c2VSZXZhbGlkYXRlQ2FjaGUobWFuYWdlciwgZmV0Y2hlcik7XG4gICAgY29uc3Qgc3RhdHVzID0gdXNlU3luY0V4dGVybmFsU3RvcmUzKFxuICAgICAgcm9vbS5ldmVudHMuc3RhdHVzLnN1YnNjcmliZSxcbiAgICAgIHJvb20uZ2V0U3RhdHVzLFxuICAgICAgcm9vbS5nZXRTdGF0dXNcbiAgICApO1xuICAgIGNvbnN0IGlzT25saW5lID0gdXNlSXNPbmxpbmUoKTtcbiAgICBjb25zdCBpc0RvY3VtZW50VmlzaWJsZSA9IHVzZUlzRG9jdW1lbnRWaXNpYmxlKCk7XG4gICAgY29uc3QgcmVmcmVzaEludGVydmFsID0gZ2V0UG9sbGluZ0ludGVydmFsKFxuICAgICAgaXNPbmxpbmUsXG4gICAgICBpc0RvY3VtZW50VmlzaWJsZSxcbiAgICAgIHN0YXR1cyA9PT0gXCJjb25uZWN0ZWRcIlxuICAgICk7XG4gICAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgICBsZXQgcmV2YWxpZGF0aW9uVGltZXJJZDtcbiAgICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmV2YWxpZGF0aW9uKCkge1xuICAgICAgICBpZiAocmVmcmVzaEludGVydmFsID09PSAwKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV2YWxpZGF0aW9uVGltZXJJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoaXNPbmxpbmUgJiYgaXNEb2N1bWVudFZpc2libGUgJiYgIW1hbmFnZXIuZ2V0RXJyb3IoKSAmJiBtYW5hZ2VyLmdldFRvdGFsUmVmZXJlbmNlQ291bnQoKSA+IDApIHtcbiAgICAgICAgICAgIHZvaWQgcmV2YWxpZGF0ZUNhY2hlKHsgc2hvdWxkRGVkdXBlOiB0cnVlIH0pLnRoZW4oXG4gICAgICAgICAgICAgIHNjaGVkdWxlUmV2YWxpZGF0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY2hlZHVsZVJldmFsaWRhdGlvbigpO1xuICAgICAgICB9LCByZWZyZXNoSW50ZXJ2YWwpO1xuICAgICAgfVxuICAgICAgc2NoZWR1bGVSZXZhbGlkYXRpb24oKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQocmV2YWxpZGF0aW9uVGltZXJJZCk7XG4gICAgICB9O1xuICAgIH0sIFtcbiAgICAgIHJldmFsaWRhdGVDYWNoZSxcbiAgICAgIHJlZnJlc2hJbnRlcnZhbCxcbiAgICAgIGlzT25saW5lLFxuICAgICAgaXNEb2N1bWVudFZpc2libGUsXG4gICAgICBtYW5hZ2VyXG4gICAgXSk7XG4gICAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgICBmdW5jdGlvbiBoYW5kbGVJc09ubGluZSgpIHtcbiAgICAgICAgaWYgKGlzRG9jdW1lbnRWaXNpYmxlKSB7XG4gICAgICAgICAgdm9pZCByZXZhbGlkYXRlQ2FjaGUoeyBzaG91bGREZWR1cGU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIGhhbmRsZUlzT25saW5lKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIGhhbmRsZUlzT25saW5lKTtcbiAgICAgIH07XG4gICAgfSwgW3JldmFsaWRhdGVDYWNoZSwgaXNEb2N1bWVudFZpc2libGVdKTtcbiAgICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJ2aXNpYmxlXCI7XG4gICAgICAgIGlmIChpc1Zpc2libGUgJiYgaXNPbmxpbmUpIHtcbiAgICAgICAgICB2b2lkIHJldmFsaWRhdGVDYWNoZSh7IHNob3VsZERlZHVwZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgIFwidmlzaWJpbGl0eWNoYW5nZVwiLFxuICAgICAgICAgIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2VcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfSwgW3JldmFsaWRhdGVDYWNoZSwgaXNPbmxpbmVdKTtcbiAgICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuY29tbWVudHMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdm9pZCByZXZhbGlkYXRlQ2FjaGUoeyBzaG91bGREZWR1cGU6IGZhbHNlIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgfTtcbiAgICB9LCBbcm9vbSwgcmV2YWxpZGF0ZUNhY2hlXSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChGZXRjaGVyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZmV0Y2hlciB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoUm9vbU1hbmFnZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBtYW5hZ2VyIH0sIGNoaWxkcmVuKSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlUm9vbU1hbmFnZXIoKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHVzZUNvbnRleHQoUm9vbU1hbmFnZXJDb250ZXh0KTtcbiAgICBpZiAobWFuYWdlciA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tbWVudHNSb29tUHJvdmlkZXIgaXMgbWlzc2luZyBmcm9tIHRoZSBSZWFjdCB0cmVlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hbmFnZXI7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIob3B0aW9ucywgcm9vbU1hbmFnZXIpIHtcbiAgICBjb25zdCBrZXkgPSBzdHJpbmdpZnkob3B0aW9ucyk7XG4gICAgY29uc3QgcmV2YWxpZGF0aW9uTWFuYWdlciA9IHJvb21NYW5hZ2VyLmdldFJldmFsaWRhdGlvbk1hbmFnZXIoa2V5KTtcbiAgICBpZiAoIXJldmFsaWRhdGlvbk1hbmFnZXIpIHtcbiAgICAgIGNvbnN0IHVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyID0gY3JlYXRlVXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIoXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHJvb21NYW5hZ2VyXG4gICAgICApO1xuICAgICAgcm9vbU1hbmFnZXIuc2V0UmV2YWxpZGF0aW9ubWFuYWdlcihrZXksIHVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyKTtcbiAgICAgIHJldHVybiB1c2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlcjtcbiAgICB9XG4gICAgcmV0dXJuIHJldmFsaWRhdGlvbk1hbmFnZXI7XG4gIH1cbiAgZnVuY3Rpb24gdXNlVGhyZWFkc0ZldGNoZXIoKSB7XG4gICAgY29uc3QgZmV0Y2hlciA9IHVzZUNvbnRleHQoRmV0Y2hlckNvbnRleHQpO1xuICAgIGlmIChmZXRjaGVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21tZW50c1Jvb21Qcm92aWRlciBpcyBtaXNzaW5nIGZyb20gdGhlIFJlYWN0IHRyZWUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2hlcjtcbiAgfVxuICBmdW5jdGlvbiB1c2VUaHJlYWRzKHJvb20sIG9wdGlvbnMgPSB7IHF1ZXJ5OiB7IG1ldGFkYXRhOiB7fSB9IH0pIHtcbiAgICBjb25zdCBrZXkgPSB1c2VNZW1vKCgpID0+IHN0cmluZ2lmeShvcHRpb25zKSwgW29wdGlvbnNdKTtcbiAgICBjb25zdCBtYW5hZ2VyID0gdXNlUm9vbU1hbmFnZXIoKTtcbiAgICBjb25zdCB1c2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlciA9IGdldFVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyKFxuICAgICAgb3B0aW9ucyxcbiAgICAgIG1hbmFnZXJcbiAgICApO1xuICAgIGNvbnN0IGZldGNoZXIgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHJldHVybiByb29tLmdldFRocmVhZHMob3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwcyAtLSBUaGUgbWlzc2luZyBkZXBlbmRlbmN5IGlzIGBvcHRpb25zYCBidXQgYGtleWAgYW5kIGBub3JtYWxpemVkYCBhcmUgYW5hbG9nb3VzLCBzbyB3ZSBvbmx5IGluY2x1ZGUgYGtleWAgYXMgZGVwZW5kZW5jeS4gVGhpcyBoZWxwcyBtaW5pbWl6ZSB0aGUgbnVtYmVyIG9mIHJlLXJlbmRlcnMgYXMgYG9wdGlvbnNgIGNhbiBjaGFuZ2Ugb24gZWFjaCByZW5kZXJcbiAgICAgIFtrZXksIHJvb21dXG4gICAgKTtcbiAgICBjb25zdCByZXZhbGlkYXRlQ2FjaGUgPSB1c2VSZXZhbGlkYXRlQ2FjaGUoXG4gICAgICB1c2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlcixcbiAgICAgIGZldGNoZXJcbiAgICApO1xuICAgIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgICAgdm9pZCByZXZhbGlkYXRlQ2FjaGUoeyBzaG91bGREZWR1cGU6IHRydWUgfSk7XG4gICAgfSwgW3JldmFsaWRhdGVDYWNoZV0pO1xuICAgIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgICAgbWFuYWdlci5pbmNyZW1lbnRSZWZlcmVuY2VDb3VudChrZXkpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgbWFuYWdlci5kZWNyZW1lbnRSZWZlcmVuY2VDb3VudChrZXkpO1xuICAgICAgfTtcbiAgICB9LCBbbWFuYWdlciwga2V5XSk7XG4gICAgY29uc3QgY2FjaGUgPSBfdXNlVGhyZWFkcyhyb29tLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cbiAgZnVuY3Rpb24gdXNlVGhyZWFkc1N1c3BlbnNlKHJvb20sIG9wdGlvbnMgPSB7IHF1ZXJ5OiB7IG1ldGFkYXRhOiB7fSB9IH0pIHtcbiAgICBjb25zdCBrZXkgPSB1c2VNZW1vKCgpID0+IHN0cmluZ2lmeShvcHRpb25zKSwgW29wdGlvbnNdKTtcbiAgICBjb25zdCBtYW5hZ2VyID0gdXNlUm9vbU1hbmFnZXIoKTtcbiAgICBjb25zdCB1c2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlciA9IGdldFVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyKFxuICAgICAgb3B0aW9ucyxcbiAgICAgIG1hbmFnZXJcbiAgICApO1xuICAgIGNvbnN0IGZldGNoZXIgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHJldHVybiByb29tLmdldFRocmVhZHMob3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwcyAtLSBUaGUgbWlzc2luZyBkZXBlbmRlbmN5IGlzIGBvcHRpb25zYCBidXQgYGtleWAgYW5kIGBub3JtYWxpemVkYCBhcmUgYW5hbG9nb3VzLCBzbyB3ZSBvbmx5IGluY2x1ZGUgYGtleWAgYXMgZGVwZW5kZW5jeS4gVGhpcyBoZWxwcyBtaW5pbWl6ZSB0aGUgbnVtYmVyIG9mIHJlLXJlbmRlcnMgYXMgYG9wdGlvbnNgIGNhbiBjaGFuZ2Ugb24gZWFjaCByZW5kZXJcbiAgICAgIFtrZXksIHJvb21dXG4gICAgKTtcbiAgICBjb25zdCByZXZhbGlkYXRlQ2FjaGUgPSB1c2VSZXZhbGlkYXRlQ2FjaGUoXG4gICAgICB1c2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlcixcbiAgICAgIGZldGNoZXJcbiAgICApO1xuICAgIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgICAgdm9pZCByZXZhbGlkYXRlQ2FjaGUoeyBzaG91bGREZWR1cGU6IHRydWUgfSk7XG4gICAgfSwgW3JldmFsaWRhdGVDYWNoZV0pO1xuICAgIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgICAgbWFuYWdlci5pbmNyZW1lbnRSZWZlcmVuY2VDb3VudChrZXkpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgbWFuYWdlci5kZWNyZW1lbnRSZWZlcmVuY2VDb3VudChrZXkpO1xuICAgICAgfTtcbiAgICB9LCBbbWFuYWdlciwga2V5XSk7XG4gICAgY29uc3QgY2FjaGUgPSBfdXNlVGhyZWFkcyhyb29tLCBvcHRpb25zKTtcbiAgICBpZiAoY2FjaGUuZXJyb3IpIHtcbiAgICAgIHRocm93IGNhY2hlLmVycm9yO1xuICAgIH1cbiAgICBpZiAoY2FjaGUuaXNMb2FkaW5nIHx8ICFjYWNoZS50aHJlYWRzKSB7XG4gICAgICB0aHJvdyByZXZhbGlkYXRlQ2FjaGUoe1xuICAgICAgICBzaG91bGREZWR1cGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIHRocmVhZHM6IGNhY2hlLnRocmVhZHMsXG4gICAgICBlcnJvcjogY2FjaGUuZXJyb3JcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIF91c2VUaHJlYWRzKHJvb20sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gdXNlUm9vbU1hbmFnZXIoKTtcbiAgICBjb25zdCB1c2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlciA9IGdldFVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyKFxuICAgICAgb3B0aW9ucyxcbiAgICAgIG1hbmFnZXJcbiAgICApO1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICAgIHN0b3JlLnN1YnNjcmliZSxcbiAgICAgICgpID0+IHN0b3JlLmdldFRocmVhZHMoKSxcbiAgICAgICgpID0+IHN0b3JlLmdldFRocmVhZHMoKSxcbiAgICAgIChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBpc0xvYWRpbmcgPSB1c2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlci5nZXRJc0xvYWRpbmcoKTtcbiAgICAgICAgaWYgKGlzTG9hZGluZykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0xvYWRpbmc6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMyID0gdXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIuZ2V0T3B0aW9ucygpO1xuICAgICAgICBjb25zdCBlcnJvciA9IHVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyLmdldEVycm9yKCk7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0gc3RhdGUuZmlsdGVyKCh0aHJlYWQpID0+IHtcbiAgICAgICAgICBpZiAodGhyZWFkLnJvb21JZCAhPT0gcm9vbS5pZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBjb25zdCBxdWVyeSA9IG9wdGlvbnMyLnF1ZXJ5ID8/IHt9O1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHF1ZXJ5Lm1ldGFkYXRhKSB7XG4gICAgICAgICAgICBpZiAodGhyZWFkLm1ldGFkYXRhW2tleV0gIT09IHF1ZXJ5Lm1ldGFkYXRhW2tleV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICB0aHJlYWRzOiBmaWx0ZXJlZCxcbiAgICAgICAgICBlcnJvclxuICAgICAgICB9O1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRWRpdFRocmVhZE1ldGFkYXRhKHJvb20pIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gdXNlUm9vbU1hbmFnZXIoKTtcbiAgICBjb25zdCBmZXRjaGVyID0gdXNlVGhyZWFkc0ZldGNoZXIoKTtcbiAgICBjb25zdCByZXZhbGlkYXRlID0gdXNlUmV2YWxpZGF0ZUNhY2hlKG1hbmFnZXIsIGZldGNoZXIpO1xuICAgIGNvbnN0IG11dGF0ZSA9IHVzZU11dGF0ZShtYW5hZ2VyLCByZXZhbGlkYXRlKTtcbiAgICBjb25zdCBlZGl0VGhyZWFkTWV0YWRhdGEgPSB1c2VDYWxsYmFjazMoXG4gICAgICAob3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCB0aHJlYWRJZCA9IG9wdGlvbnMudGhyZWFkSWQ7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gXCJtZXRhZGF0YVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLm1ldGFkYXRhIDoge307XG4gICAgICAgIGNvbnN0IHRocmVhZHMgPSBnZXRUaHJlYWRzKG1hbmFnZXIpO1xuICAgICAgICBjb25zdCBvcHRpbWlzdGljRGF0YSA9IHRocmVhZHMubWFwKFxuICAgICAgICAgICh0aHJlYWQpID0+IHRocmVhZC5pZCA9PT0gdGhyZWFkSWQgPyB7XG4gICAgICAgICAgICAuLi50aHJlYWQsXG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAuLi50aHJlYWQubWV0YWRhdGEsXG4gICAgICAgICAgICAgIC4uLm1ldGFkYXRhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSA6IHRocmVhZFxuICAgICAgICApO1xuICAgICAgICBtdXRhdGUocm9vbS5lZGl0VGhyZWFkTWV0YWRhdGEoeyBtZXRhZGF0YSwgdGhyZWFkSWQgfSksIHtcbiAgICAgICAgICBvcHRpbWlzdGljRGF0YVxuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgQ29tbWVudHNBcGlFcnJvcikpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBoYW5kbGVDb21tZW50c0FwaUVycm9yKGVycik7XG4gICAgICAgICAgZXJyb3JFdmVudFNvdXJjZS5ub3RpZnkoXG4gICAgICAgICAgICBuZXcgRWRpdFRocmVhZE1ldGFkYXRhRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgW3Jvb20sIG11dGF0ZSwgbWFuYWdlcl1cbiAgICApO1xuICAgIHJldHVybiBlZGl0VGhyZWFkTWV0YWRhdGE7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQ3JlYXRlVGhyZWFkKHJvb20pIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gdXNlUm9vbU1hbmFnZXIoKTtcbiAgICBjb25zdCBmZXRjaGVyID0gdXNlVGhyZWFkc0ZldGNoZXIoKTtcbiAgICBjb25zdCByZXZhbGlkYXRlID0gdXNlUmV2YWxpZGF0ZUNhY2hlKG1hbmFnZXIsIGZldGNoZXIpO1xuICAgIGNvbnN0IG11dGF0ZSA9IHVzZU11dGF0ZShtYW5hZ2VyLCByZXZhbGlkYXRlKTtcbiAgICBjb25zdCBjcmVhdGVUaHJlYWQgPSB1c2VDYWxsYmFjazMoXG4gICAgICAob3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5ib2R5O1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IFwibWV0YWRhdGFcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5tZXRhZGF0YSA6IHt9O1xuICAgICAgICBjb25zdCB0aHJlYWRzID0gZ2V0VGhyZWFkcyhtYW5hZ2VyKTtcbiAgICAgICAgY29uc3QgdGhyZWFkSWQgPSBjcmVhdGVUaHJlYWRJZCgpO1xuICAgICAgICBjb25zdCBjb21tZW50SWQgPSBjcmVhdGVDb21tZW50SWQoKTtcbiAgICAgICAgY29uc3Qgbm93ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IG5ld0NvbW1lbnQgPSB7XG4gICAgICAgICAgaWQ6IGNvbW1lbnRJZCxcbiAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgY3JlYXRlZEF0OiBub3csXG4gICAgICAgICAgdHlwZTogXCJjb21tZW50XCIsXG4gICAgICAgICAgdXNlcklkOiBnZXRDdXJyZW50VXNlcklkKHJvb20pLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgcmVhY3Rpb25zOiBbXVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBuZXdUaHJlYWQgPSB7XG4gICAgICAgICAgaWQ6IHRocmVhZElkLFxuICAgICAgICAgIHR5cGU6IFwidGhyZWFkXCIsXG4gICAgICAgICAgY3JlYXRlZEF0OiBub3csXG4gICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgIGNvbW1lbnRzOiBbbmV3Q29tbWVudF1cbiAgICAgICAgfTtcbiAgICAgICAgbXV0YXRlKHJvb20uY3JlYXRlVGhyZWFkKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgYm9keSwgbWV0YWRhdGEgfSksIHtcbiAgICAgICAgICBvcHRpbWlzdGljRGF0YTogWy4uLnRocmVhZHMsIG5ld1RocmVhZF1cbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIENvbW1lbnRzQXBpRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGVycm9yID0gaGFuZGxlQ29tbWVudHNBcGlFcnJvcihlcnIpO1xuICAgICAgICAgIGVycm9yRXZlbnRTb3VyY2Uubm90aWZ5KFxuICAgICAgICAgICAgbmV3IENyZWF0ZVRocmVhZEVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdUaHJlYWQ7XG4gICAgICB9LFxuICAgICAgW3Jvb20sIG11dGF0ZSwgbWFuYWdlcl1cbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVUaHJlYWQ7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQ3JlYXRlQ29tbWVudChyb29tKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHVzZVJvb21NYW5hZ2VyKCk7XG4gICAgY29uc3QgZmV0Y2hlciA9IHVzZVRocmVhZHNGZXRjaGVyKCk7XG4gICAgY29uc3QgcmV2YWxpZGF0ZSA9IHVzZVJldmFsaWRhdGVDYWNoZShtYW5hZ2VyLCBmZXRjaGVyKTtcbiAgICBjb25zdCBtdXRhdGUgPSB1c2VNdXRhdGUobWFuYWdlciwgcmV2YWxpZGF0ZSk7XG4gICAgY29uc3QgY3JlYXRlQ29tbWVudCA9IHVzZUNhbGxiYWNrMyhcbiAgICAgICh7IHRocmVhZElkLCBib2R5IH0pID0+IHtcbiAgICAgICAgY29uc3QgdGhyZWFkcyA9IGdldFRocmVhZHMobWFuYWdlcik7XG4gICAgICAgIGNvbnN0IGNvbW1lbnRJZCA9IGNyZWF0ZUNvbW1lbnRJZCgpO1xuICAgICAgICBjb25zdCBub3cgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgY29tbWVudCA9IHtcbiAgICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICB0eXBlOiBcImNvbW1lbnRcIixcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5vdyxcbiAgICAgICAgICB1c2VySWQ6IGdldEN1cnJlbnRVc2VySWQocm9vbSksXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICByZWFjdGlvbnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWNEYXRhID0gdGhyZWFkcy5tYXAoXG4gICAgICAgICAgKHRocmVhZCkgPT4gdGhyZWFkLmlkID09PSB0aHJlYWRJZCA/IHtcbiAgICAgICAgICAgIC4uLnRocmVhZCxcbiAgICAgICAgICAgIGNvbW1lbnRzOiBbLi4udGhyZWFkLmNvbW1lbnRzLCBjb21tZW50XVxuICAgICAgICAgIH0gOiB0aHJlYWRcbiAgICAgICAgKTtcbiAgICAgICAgbXV0YXRlKHJvb20uY3JlYXRlQ29tbWVudCh7IHRocmVhZElkLCBjb21tZW50SWQsIGJvZHkgfSksIHtcbiAgICAgICAgICBvcHRpbWlzdGljRGF0YVxuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgQ29tbWVudHNBcGlFcnJvcikpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBoYW5kbGVDb21tZW50c0FwaUVycm9yKGVycik7XG4gICAgICAgICAgZXJyb3JFdmVudFNvdXJjZS5ub3RpZnkoXG4gICAgICAgICAgICBuZXcgQ3JlYXRlQ29tbWVudEVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgICAgYm9keVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgICB9LFxuICAgICAgW3Jvb20sIG11dGF0ZSwgbWFuYWdlcl1cbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVDb21tZW50O1xuICB9XG4gIGZ1bmN0aW9uIHVzZUVkaXRDb21tZW50KHJvb20pIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gdXNlUm9vbU1hbmFnZXIoKTtcbiAgICBjb25zdCBmZXRjaGVyID0gdXNlVGhyZWFkc0ZldGNoZXIoKTtcbiAgICBjb25zdCByZXZhbGlkYXRlID0gdXNlUmV2YWxpZGF0ZUNhY2hlKG1hbmFnZXIsIGZldGNoZXIpO1xuICAgIGNvbnN0IG11dGF0ZSA9IHVzZU11dGF0ZShtYW5hZ2VyLCByZXZhbGlkYXRlKTtcbiAgICBjb25zdCBlZGl0Q29tbWVudCA9IHVzZUNhbGxiYWNrMyhcbiAgICAgICh7IHRocmVhZElkLCBjb21tZW50SWQsIGJvZHkgfSkgPT4ge1xuICAgICAgICBjb25zdCB0aHJlYWRzID0gZ2V0VGhyZWFkcyhtYW5hZ2VyKTtcbiAgICAgICAgY29uc3Qgbm93ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWNEYXRhID0gdGhyZWFkcy5tYXAoXG4gICAgICAgICAgKHRocmVhZCkgPT4gdGhyZWFkLmlkID09PSB0aHJlYWRJZCA/IHtcbiAgICAgICAgICAgIC4uLnRocmVhZCxcbiAgICAgICAgICAgIGNvbW1lbnRzOiB0aHJlYWQuY29tbWVudHMubWFwKFxuICAgICAgICAgICAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkID8ge1xuICAgICAgICAgICAgICAgIC4uLmNvbW1lbnQsXG4gICAgICAgICAgICAgICAgZWRpdGVkQXQ6IG5vdyxcbiAgICAgICAgICAgICAgICBib2R5XG4gICAgICAgICAgICAgIH0gOiBjb21tZW50XG4gICAgICAgICAgICApXG4gICAgICAgICAgfSA6IHRocmVhZFxuICAgICAgICApO1xuICAgICAgICBtdXRhdGUocm9vbS5lZGl0Q29tbWVudCh7IHRocmVhZElkLCBjb21tZW50SWQsIGJvZHkgfSksIHtcbiAgICAgICAgICBvcHRpbWlzdGljRGF0YVxuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgQ29tbWVudHNBcGlFcnJvcikpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBoYW5kbGVDb21tZW50c0FwaUVycm9yKGVycik7XG4gICAgICAgICAgZXJyb3JFdmVudFNvdXJjZS5ub3RpZnkoXG4gICAgICAgICAgICBuZXcgRWRpdENvbW1lbnRFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICAgIGJvZHlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgW3Jvb20sIG11dGF0ZSwgbWFuYWdlcl1cbiAgICApO1xuICAgIHJldHVybiBlZGl0Q29tbWVudDtcbiAgfVxuICBmdW5jdGlvbiB1c2VEZWxldGVDb21tZW50KHJvb20pIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gdXNlUm9vbU1hbmFnZXIoKTtcbiAgICBjb25zdCBmZXRjaGVyID0gdXNlVGhyZWFkc0ZldGNoZXIoKTtcbiAgICBjb25zdCByZXZhbGlkYXRlID0gdXNlUmV2YWxpZGF0ZUNhY2hlKG1hbmFnZXIsIGZldGNoZXIpO1xuICAgIGNvbnN0IG11dGF0ZSA9IHVzZU11dGF0ZShtYW5hZ2VyLCByZXZhbGlkYXRlKTtcbiAgICBjb25zdCBkZWxldGVDb21tZW50ID0gdXNlQ2FsbGJhY2szKFxuICAgICAgKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHRocmVhZHMgPSBnZXRUaHJlYWRzKG1hbmFnZXIpO1xuICAgICAgICBjb25zdCBub3cgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgbmV3VGhyZWFkcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRocmVhZCBvZiB0aHJlYWRzKSB7XG4gICAgICAgICAgaWYgKHRocmVhZC5pZCA9PT0gdGhyZWFkSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RocmVhZCA9IHtcbiAgICAgICAgICAgICAgLi4udGhyZWFkLFxuICAgICAgICAgICAgICBjb21tZW50czogdGhyZWFkLmNvbW1lbnRzLm1hcChcbiAgICAgICAgICAgICAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkID8ge1xuICAgICAgICAgICAgICAgICAgLi4uY29tbWVudCxcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRBdDogbm93LFxuICAgICAgICAgICAgICAgICAgYm9keTogdm9pZCAwXG4gICAgICAgICAgICAgICAgfSA6IGNvbW1lbnRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChuZXdUaHJlYWQuY29tbWVudHMuc29tZShcbiAgICAgICAgICAgICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuZGVsZXRlZEF0ID09PSB2b2lkIDBcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgbmV3VGhyZWFkcy5wdXNoKG5ld1RocmVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1RocmVhZHMucHVzaCh0aHJlYWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtdXRhdGUocm9vbS5kZWxldGVDb21tZW50KHsgdGhyZWFkSWQsIGNvbW1lbnRJZCB9KSwge1xuICAgICAgICAgIG9wdGltaXN0aWNEYXRhOiBuZXdUaHJlYWRzXG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBDb21tZW50c0FwaUVycm9yKSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBlcnJvciA9IGhhbmRsZUNvbW1lbnRzQXBpRXJyb3IoZXJyKTtcbiAgICAgICAgICBlcnJvckV2ZW50U291cmNlLm5vdGlmeShcbiAgICAgICAgICAgIG5ldyBEZWxldGVDb21tZW50RXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgICAgY29tbWVudElkXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFtyb29tLCBtdXRhdGUsIG1hbmFnZXJdXG4gICAgKTtcbiAgICByZXR1cm4gZGVsZXRlQ29tbWVudDtcbiAgfVxuICBmdW5jdGlvbiB1c2VBZGRSZWFjdGlvbihyb29tKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHVzZVJvb21NYW5hZ2VyKCk7XG4gICAgY29uc3QgZmV0Y2hlciA9IHVzZVRocmVhZHNGZXRjaGVyKCk7XG4gICAgY29uc3QgcmV2YWxpZGF0ZSA9IHVzZVJldmFsaWRhdGVDYWNoZShtYW5hZ2VyLCBmZXRjaGVyKTtcbiAgICBjb25zdCBtdXRhdGUgPSB1c2VNdXRhdGUobWFuYWdlciwgcmV2YWxpZGF0ZSk7XG4gICAgY29uc3QgY3JlYXRlQ29tbWVudCA9IHVzZUNhbGxiYWNrMyhcbiAgICAgICh7IHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pID0+IHtcbiAgICAgICAgY29uc3QgdGhyZWFkcyA9IGdldFRocmVhZHMobWFuYWdlcik7XG4gICAgICAgIGNvbnN0IG5vdyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCB1c2VySWQgPSBnZXRDdXJyZW50VXNlcklkKHJvb20pO1xuICAgICAgICBjb25zdCBvcHRpbWlzdGljRGF0YSA9IHRocmVhZHMubWFwKFxuICAgICAgICAgICh0aHJlYWQpID0+IHRocmVhZC5pZCA9PT0gdGhyZWFkSWQgPyB7XG4gICAgICAgICAgICAuLi50aHJlYWQsXG4gICAgICAgICAgICBjb21tZW50czogdGhyZWFkLmNvbW1lbnRzLm1hcCgoY29tbWVudCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoY29tbWVudC5pZCAhPT0gY29tbWVudElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IHJlYWN0aW9ucztcbiAgICAgICAgICAgICAgaWYgKGNvbW1lbnQucmVhY3Rpb25zLnNvbWUoXG4gICAgICAgICAgICAgICAgKHJlYWN0aW9uKSA9PiByZWFjdGlvbi5lbW9qaSA9PT0gZW1vamlcbiAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgIHJlYWN0aW9ucyA9IGNvbW1lbnQucmVhY3Rpb25zLm1hcChcbiAgICAgICAgICAgICAgICAgIChyZWFjdGlvbikgPT4gcmVhY3Rpb24uZW1vamkgPT09IGVtb2ppID8ge1xuICAgICAgICAgICAgICAgICAgICAuLi5yZWFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdXNlcnM6IFsuLi5yZWFjdGlvbi51c2VycywgeyBpZDogdXNlcklkIH1dXG4gICAgICAgICAgICAgICAgICB9IDogcmVhY3Rpb25cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlYWN0aW9ucyA9IFtcbiAgICAgICAgICAgICAgICAgIC4uLmNvbW1lbnQucmVhY3Rpb25zLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBlbW9qaSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEF0OiBub3csXG4gICAgICAgICAgICAgICAgICAgIHVzZXJzOiBbeyBpZDogdXNlcklkIH1dXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmNvbW1lbnQsXG4gICAgICAgICAgICAgICAgcmVhY3Rpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gOiB0aHJlYWRcbiAgICAgICAgKTtcbiAgICAgICAgbXV0YXRlKHJvb20uYWRkUmVhY3Rpb24oeyB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KSwge1xuICAgICAgICAgIG9wdGltaXN0aWNEYXRhXG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBDb21tZW50c0FwaUVycm9yKSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBlcnJvciA9IGhhbmRsZUNvbW1lbnRzQXBpRXJyb3IoZXJyKTtcbiAgICAgICAgICBlcnJvckV2ZW50U291cmNlLm5vdGlmeShcbiAgICAgICAgICAgIG5ldyBBZGRSZWFjdGlvbkVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgICAgZW1vamlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgW3Jvb20sIG11dGF0ZSwgbWFuYWdlcl1cbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVDb21tZW50O1xuICB9XG4gIGZ1bmN0aW9uIHVzZVJlbW92ZVJlYWN0aW9uKHJvb20pIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gdXNlUm9vbU1hbmFnZXIoKTtcbiAgICBjb25zdCBmZXRjaGVyID0gdXNlVGhyZWFkc0ZldGNoZXIoKTtcbiAgICBjb25zdCByZXZhbGlkYXRlID0gdXNlUmV2YWxpZGF0ZUNhY2hlKG1hbmFnZXIsIGZldGNoZXIpO1xuICAgIGNvbnN0IG11dGF0ZSA9IHVzZU11dGF0ZShtYW5hZ2VyLCByZXZhbGlkYXRlKTtcbiAgICBjb25zdCBjcmVhdGVDb21tZW50ID0gdXNlQ2FsbGJhY2szKFxuICAgICAgKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSkgPT4ge1xuICAgICAgICBjb25zdCB0aHJlYWRzID0gZ2V0VGhyZWFkcyhtYW5hZ2VyKTtcbiAgICAgICAgY29uc3QgdXNlcklkID0gZ2V0Q3VycmVudFVzZXJJZChyb29tKTtcbiAgICAgICAgY29uc3Qgb3B0aW1pc3RpY0RhdGEgPSB0aHJlYWRzLm1hcChcbiAgICAgICAgICAodGhyZWFkKSA9PiB0aHJlYWQuaWQgPT09IHRocmVhZElkID8ge1xuICAgICAgICAgICAgLi4udGhyZWFkLFxuICAgICAgICAgICAgY29tbWVudHM6IHRocmVhZC5jb21tZW50cy5tYXAoKGNvbW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGNvbW1lbnQuaWQgIT09IGNvbW1lbnRJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHJlYWN0aW9uSW5kZXggPSBjb21tZW50LnJlYWN0aW9ucy5maW5kSW5kZXgoXG4gICAgICAgICAgICAgICAgKHJlYWN0aW9uKSA9PiByZWFjdGlvbi5lbW9qaSA9PT0gZW1vamlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgbGV0IHJlYWN0aW9ucyA9IGNvbW1lbnQucmVhY3Rpb25zO1xuICAgICAgICAgICAgICBpZiAocmVhY3Rpb25JbmRleCA+PSAwICYmIGNvbW1lbnQucmVhY3Rpb25zW3JlYWN0aW9uSW5kZXhdLnVzZXJzLnNvbWUoXG4gICAgICAgICAgICAgICAgKHVzZXIpID0+IHVzZXIuaWQgPT09IHVzZXJJZFxuICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQucmVhY3Rpb25zW3JlYWN0aW9uSW5kZXhdLnVzZXJzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICByZWFjdGlvbnMgPSBbLi4uY29tbWVudC5yZWFjdGlvbnNdO1xuICAgICAgICAgICAgICAgICAgcmVhY3Rpb25zLnNwbGljZShyZWFjdGlvbkluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVhY3Rpb25zW3JlYWN0aW9uSW5kZXhdID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5yZWFjdGlvbnNbcmVhY3Rpb25JbmRleF0sXG4gICAgICAgICAgICAgICAgICAgIHVzZXJzOiByZWFjdGlvbnNbcmVhY3Rpb25JbmRleF0udXNlcnMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAgICh1c2VyKSA9PiB1c2VyLmlkICE9PSB1c2VySWRcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jb21tZW50LFxuICAgICAgICAgICAgICAgIHJlYWN0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IDogdGhyZWFkXG4gICAgICAgICk7XG4gICAgICAgIG11dGF0ZShyb29tLnJlbW92ZVJlYWN0aW9uKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSksIHtcbiAgICAgICAgICBvcHRpbWlzdGljRGF0YVxuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgQ29tbWVudHNBcGlFcnJvcikpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBoYW5kbGVDb21tZW50c0FwaUVycm9yKGVycik7XG4gICAgICAgICAgZXJyb3JFdmVudFNvdXJjZS5ub3RpZnkoXG4gICAgICAgICAgICBuZXcgUmVtb3ZlUmVhY3Rpb25FcnJvcihlcnJvciwge1xuICAgICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICAgIGVtb2ppXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFtyb29tLCBtdXRhdGUsIG1hbmFnZXJdXG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlQ29tbWVudDtcbiAgfVxuICByZXR1cm4ge1xuICAgIENvbW1lbnRzUm9vbVByb3ZpZGVyLFxuICAgIHVzZVRocmVhZHMsXG4gICAgdXNlVGhyZWFkc1N1c3BlbnNlLFxuICAgIHVzZUVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgICB1c2VDcmVhdGVUaHJlYWQsXG4gICAgdXNlQ3JlYXRlQ29tbWVudCxcbiAgICB1c2VFZGl0Q29tbWVudCxcbiAgICB1c2VEZWxldGVDb21tZW50LFxuICAgIHVzZUFkZFJlYWN0aW9uLFxuICAgIHVzZVJlbW92ZVJlYWN0aW9uXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVPcHRpbWlzdGljSWQocHJlZml4KSB7XG4gIHJldHVybiBgJHtwcmVmaXh9XyR7bmFub2lkKCl9YDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRocmVhZElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKFRIUkVBRF9JRF9QUkVGSVgpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKENPTU1FTlRfSURfUFJFRklYKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRVc2VySWQocm9vbSkge1xuICBjb25zdCBzZWxmID0gcm9vbS5nZXRTZWxmKCk7XG4gIGlmIChzZWxmID09PSBudWxsIHx8IHNlbGYuaWQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBcImFub255bW91c1wiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzZWxmLmlkO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVDb21tZW50c0FwaUVycm9yKGVycikge1xuICBjb25zdCBtZXNzYWdlID0gYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzICR7ZXJyLnN0YXR1c306ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgaWYgKGVyci5kZXRhaWxzPy5lcnJvciA9PT0gXCJGT1JCSURERU5cIikge1xuICAgIGNvbnN0IGRldGFpbGVkTWVzc2FnZSA9IFttZXNzYWdlLCBlcnIuZGV0YWlscy5zdWdnZXN0aW9uLCBlcnIuZGV0YWlscy5kb2NzXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIlxcblwiKTtcbiAgICBjb25zb2xlLmVycm9yKGRldGFpbGVkTWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb21SZXZhbGlkYXRpb25NYW5hZ2VyKHJvb21JZCwge1xuICBnZXRDYWNoZSxcbiAgc2V0Q2FjaGVcbn0pIHtcbiAgbGV0IHJlcXVlc3Q7XG4gIGxldCBlcnJvcjtcbiAgbGV0IG11dGF0aW9uO1xuICBjb25zdCByZXZhbGlkYXRpb25NYW5hZ2VyQnlPcHRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgcmVmZXJlbmNlQ291bnRCeU9wdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4ge1xuICAgIC8vIENhY2hlXG4gICAgZ2V0Q2FjaGUoKSB7XG4gICAgICBjb25zdCB0aHJlYWRzID0gZ2V0Q2FjaGUoKTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkID0gdGhyZWFkcy5maWx0ZXIoKHRocmVhZCkgPT4gdGhyZWFkLnJvb21JZCA9PT0gcm9vbUlkKTtcbiAgICAgIHJldHVybiBmaWx0ZXJlZDtcbiAgICB9LFxuICAgIHNldENhY2hlKHZhbHVlKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiByZXZhbGlkYXRpb25NYW5hZ2VyQnlPcHRpb25zLmtleXMoKSkge1xuICAgICAgICBpZiAocmVmZXJlbmNlQ291bnRCeU9wdGlvbnMuZ2V0KGtleSkgPT09IDApIHtcbiAgICAgICAgICByZXZhbGlkYXRpb25NYW5hZ2VyQnlPcHRpb25zLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHJlZmVyZW5jZUNvdW50QnlPcHRpb25zLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzb3J0ZWQgPSB2YWx1ZS5zb3J0KFxuICAgICAgICAoYSwgYikgPT4gbmV3IERhdGUoYS5jcmVhdGVkQXQpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGIuY3JlYXRlZEF0KS5nZXRUaW1lKClcbiAgICAgICk7XG4gICAgICBjb25zdCB0aHJlYWRzID0gZ2V0Q2FjaGUoKTtcbiAgICAgIGNvbnN0IG5ld1RocmVhZHMgPSB0aHJlYWRzLmZpbHRlcigodGhyZWFkKSA9PiB0aHJlYWQucm9vbUlkICE9PSByb29tSWQpLmNvbmNhdChzb3J0ZWQpO1xuICAgICAgc2V0Q2FjaGUobmV3VGhyZWFkcyk7XG4gICAgfSxcbiAgICAvLyBSZXF1ZXN0XG4gICAgZ2V0UmVxdWVzdCgpIHtcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH0sXG4gICAgc2V0UmVxdWVzdCh2YWx1ZSkge1xuICAgICAgcmVxdWVzdCA9IHZhbHVlO1xuICAgIH0sXG4gICAgLy8gRXJyb3JcbiAgICBnZXRFcnJvcigpIHtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9LFxuICAgIHNldEVycm9yKGVycikge1xuICAgICAgZXJyb3IgPSBlcnI7XG4gICAgfSxcbiAgICAvLyBNdXRhdGlvblxuICAgIGdldE11dGF0aW9uKCkge1xuICAgICAgcmV0dXJuIG11dGF0aW9uO1xuICAgIH0sXG4gICAgc2V0TXV0YXRpb24oaW5mbykge1xuICAgICAgbXV0YXRpb24gPSBpbmZvO1xuICAgIH0sXG4gICAgZ2V0UmV2YWxpZGF0aW9uTWFuYWdlcnMoKSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShyZXZhbGlkYXRpb25NYW5hZ2VyQnlPcHRpb25zLmVudHJpZXMoKSk7XG4gICAgfSxcbiAgICBnZXRSZXZhbGlkYXRpb25NYW5hZ2VyKGtleSkge1xuICAgICAgcmV0dXJuIHJldmFsaWRhdGlvbk1hbmFnZXJCeU9wdGlvbnMuZ2V0KGtleSk7XG4gICAgfSxcbiAgICBzZXRSZXZhbGlkYXRpb25tYW5hZ2VyKGtleSwgbWFuYWdlcikge1xuICAgICAgcmV2YWxpZGF0aW9uTWFuYWdlckJ5T3B0aW9ucy5zZXQoa2V5LCBtYW5hZ2VyKTtcbiAgICB9LFxuICAgIGdldFRvdGFsUmVmZXJlbmNlQ291bnQoKSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShyZWZlcmVuY2VDb3VudEJ5T3B0aW9ucy52YWx1ZXMoKSkucmVkdWNlKFxuICAgICAgICAoYWNjLCBjb3VudCkgPT4gYWNjICsgY291bnQsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgfSxcbiAgICBpbmNyZW1lbnRSZWZlcmVuY2VDb3VudChrZXkpIHtcbiAgICAgIGNvbnN0IGNvdW50ID0gcmVmZXJlbmNlQ291bnRCeU9wdGlvbnMuZ2V0KGtleSkgPz8gMDtcbiAgICAgIHJlZmVyZW5jZUNvdW50QnlPcHRpb25zLnNldChrZXksIGNvdW50ICsgMSk7XG4gICAgfSxcbiAgICBkZWNyZW1lbnRSZWZlcmVuY2VDb3VudChrZXkpIHtcbiAgICAgIGNvbnN0IGNvdW50ID0gcmVmZXJlbmNlQ291bnRCeU9wdGlvbnMuZ2V0KGtleSkgPz8gMDtcbiAgICAgIHJlZmVyZW5jZUNvdW50QnlPcHRpb25zLnNldChrZXksIGNvdW50IC0gMSk7XG4gICAgfSxcbiAgICBnZXRSZWZlcmVuY2VDb3VudChrZXkpIHtcbiAgICAgIHJldHVybiByZWZlcmVuY2VDb3VudEJ5T3B0aW9ucy5nZXQoa2V5KSA/PyAwO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudENhY2hlU3RvcmUoKSB7XG4gIGxldCB0aHJlYWRzID0gW107XG4gIGNvbnN0IHRocmVhZHNFdmVudFNvdXJjZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICByZXR1cm4ge1xuICAgIGdldFRocmVhZHMoKSB7XG4gICAgICByZXR1cm4gdGhyZWFkcztcbiAgICB9LFxuICAgIHNldFRocmVhZHModmFsdWUpIHtcbiAgICAgIHRocmVhZHMgPSB2YWx1ZTtcbiAgICAgIHRocmVhZHNFdmVudFNvdXJjZS5ub3RpZnkodGhyZWFkcyk7XG4gICAgfSxcbiAgICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aHJlYWRzRXZlbnRTb3VyY2Uuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVVc2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlcihvcHRpb25zLCBtYW5hZ2VyKSB7XG4gIGxldCBpc0xvYWRpbmcgPSB0cnVlO1xuICBsZXQgcmVxdWVzdDtcbiAgbGV0IGVycm9yO1xuICByZXR1cm4ge1xuICAgIC8vIENhY2hlXG4gICAgZ2V0Q2FjaGUoKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH0sXG4gICAgc2V0Q2FjaGUodmFsdWUpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gbmV3IE1hcChcbiAgICAgICAgKG1hbmFnZXIuZ2V0Q2FjaGUoKSA/PyBbXSkubWFwKCh0aHJlYWQpID0+IFt0aHJlYWQuaWQsIHRocmVhZF0pXG4gICAgICApO1xuICAgICAgZm9yIChjb25zdCB0aHJlYWQgb2YgdmFsdWUpIHtcbiAgICAgICAgY2FjaGUuc2V0KHRocmVhZC5pZCwgdGhyZWFkKTtcbiAgICAgIH1cbiAgICAgIG1hbmFnZXIuc2V0Q2FjaGUoQXJyYXkuZnJvbShjYWNoZS52YWx1ZXMoKSkpO1xuICAgICAgaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgfSxcbiAgICAvLyBSZXF1ZXN0XG4gICAgZ2V0UmVxdWVzdCgpIHtcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH0sXG4gICAgc2V0UmVxdWVzdCh2YWx1ZSkge1xuICAgICAgcmVxdWVzdCA9IHZhbHVlO1xuICAgIH0sXG4gICAgLy8gRXJyb3JcbiAgICBnZXRFcnJvcigpIHtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9LFxuICAgIHNldEVycm9yKGVycikge1xuICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICBpc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGNhY2hlID0gbWFuYWdlci5nZXRDYWNoZSgpO1xuICAgICAgbWFuYWdlci5zZXRDYWNoZShjYWNoZSk7XG4gICAgfSxcbiAgICAvLyBNdXRhdGlvblxuICAgIGdldE11dGF0aW9uKCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9LFxuICAgIHNldE11dGF0aW9uKF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGdldE9wdGlvbnMoKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9LFxuICAgIGdldElzTG9hZGluZygpIHtcbiAgICAgIHJldHVybiBpc0xvYWRpbmc7XG4gICAgfSxcbiAgICBzZXRJc0xvYWRpbmcodmFsdWUpIHtcbiAgICAgIGlzTG9hZGluZyA9IHZhbHVlO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBvbGxpbmdJbnRlcnZhbChpc0Jyb3dzZXJPbmxpbmUsIGlzRG9jdW1lbnRWaXNpYmxlLCBpc1Jvb21Db25uZWN0ZWQpIHtcbiAgaWYgKCFpc0Jyb3dzZXJPbmxpbmUgfHwgIWlzRG9jdW1lbnRWaXNpYmxlKVxuICAgIHJldHVybjtcbiAgaWYgKGlzUm9vbUNvbm5lY3RlZClcbiAgICByZXR1cm4gUE9MTElOR19JTlRFUlZBTF9SRUFMVElNRTtcbiAgcmV0dXJuIFBPTExJTkdfSU5URVJWQUw7XG59XG5cbi8vIHNyYy9jb21tZW50cy9saWIvdXNlLWRlYm91bmNlLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NCwgdXNlUmVmIGFzIHVzZVJlZjMsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMiB9IGZyb20gXCJyZWFjdFwiO1xudmFyIERFRkFVTFRfREVMQVkgPSA1MDA7XG5mdW5jdGlvbiB1c2VEZWJvdW5jZSh2YWx1ZSwgZGVsYXkgPSBERUZBVUxUX0RFTEFZKSB7XG4gIGNvbnN0IHRpbWVvdXQgPSB1c2VSZWYzKCk7XG4gIGNvbnN0IFtkZWJvdW5jZWRWYWx1ZSwgc2V0RGVib3VuY2VkVmFsdWVdID0gdXNlU3RhdGUyKHZhbHVlKTtcbiAgdXNlRWZmZWN0NCgoKSA9PiB7XG4gICAgaWYgKGRlbGF5ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGltZW91dC5jdXJyZW50ID09PSB2b2lkIDApIHtcbiAgICAgIHNldERlYm91bmNlZFZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgdGltZW91dC5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2V0RGVib3VuY2VkVmFsdWUodmFsdWUpO1xuICAgICAgdGltZW91dC5jdXJyZW50ID0gdm9pZCAwO1xuICAgIH0sIGRlbGF5KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0LmN1cnJlbnQpO1xuICAgIH07XG4gIH0sIFt2YWx1ZSwgZGVsYXldKTtcbiAgcmV0dXJuIGRlYm91bmNlZFZhbHVlO1xufVxuXG4vLyBzcmMvbGliL3VzZS1hc3luYy1jYWNoZS50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s0LCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NSwgdXNlTWVtbyBhcyB1c2VNZW1vMiwgdXNlUmVmIGFzIHVzZVJlZjQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlNCB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzXCI7XG5cbi8vIHNyYy9saWIvdXNlLWluaXRpYWwudHNcbmltcG9ydCB7IHVzZVN0YXRlIGFzIHVzZVN0YXRlMyB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlSW5pdGlhbCh2YWx1ZSkge1xuICByZXR1cm4gdXNlU3RhdGUzKHZhbHVlKVswXTtcbn1cblxuLy8gc3JjL2xpYi91c2UtYXN5bmMtY2FjaGUudHNcbnZhciBJTklUSUFMX0FTWU5DX1NUQVRFID0ge1xuICBpc0xvYWRpbmc6IGZhbHNlLFxuICBkYXRhOiB2b2lkIDAsXG4gIGVycm9yOiB2b2lkIDBcbn07XG52YXIgbm9vcCA9ICgpID0+IHtcbn07XG5mdW5jdGlvbiB1c2VBc3luY0NhY2hlKGNhY2hlLCBrZXksIG9wdGlvbnMpIHtcbiAgY29uc3QgZnJvemVuT3B0aW9ucyA9IHVzZUluaXRpYWwob3B0aW9ucyk7XG4gIGNvbnN0IGNhY2hlSXRlbSA9IHVzZU1lbW8yKCgpID0+IHtcbiAgICBpZiAoa2V5ID09PSBudWxsIHx8ICFjYWNoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlSXRlbTIgPSBjYWNoZS5jcmVhdGUoa2V5KTtcbiAgICB2b2lkIGNhY2hlSXRlbTIuZ2V0KCk7XG4gICAgcmV0dXJuIGNhY2hlSXRlbTI7XG4gIH0sIFtjYWNoZSwga2V5XSk7XG4gIGNvbnN0IHN1YnNjcmliZTIgPSB1c2VDYWxsYmFjazQoXG4gICAgKGNhbGxiYWNrKSA9PiBjYWNoZUl0ZW0/LnN1YnNjcmliZShjYWxsYmFjaykgPz8gbm9vcCxcbiAgICBbY2FjaGVJdGVtXVxuICApO1xuICBjb25zdCBnZXRTdGF0ZSA9IHVzZUNhbGxiYWNrNChcbiAgICAoKSA9PiBjYWNoZUl0ZW0/LmdldFN0YXRlKCkgPz8gSU5JVElBTF9BU1lOQ19TVEFURSxcbiAgICBbY2FjaGVJdGVtXVxuICApO1xuICBjb25zdCByZXZhbGlkYXRlID0gdXNlQ2FsbGJhY2s0KCgpID0+IGNhY2hlSXRlbT8ucmV2YWxpZGF0ZSgpLCBbY2FjaGVJdGVtXSk7XG4gIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmU0KHN1YnNjcmliZTIsIGdldFN0YXRlLCBnZXRTdGF0ZSk7XG4gIGNvbnN0IHByZXZpb3VzRGF0YSA9IHVzZVJlZjQoKTtcbiAgbGV0IGRhdGEgPSBzdGF0ZS5kYXRhO1xuICB1c2VFZmZlY3Q1KCgpID0+IHtcbiAgICBwcmV2aW91c0RhdGEuY3VycmVudCA9IHsga2V5LCBkYXRhOiBzdGF0ZS5kYXRhIH07XG4gIH0sIFtrZXksIHN0YXRlLmRhdGFdKTtcbiAgaWYgKCFjYWNoZUl0ZW0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIGRhdGE6IHZvaWQgMCxcbiAgICAgIGVycm9yOiB2b2lkIDAsXG4gICAgICBnZXRTdGF0ZSxcbiAgICAgIHJldmFsaWRhdGVcbiAgICB9O1xuICB9XG4gIGlmIChmcm96ZW5PcHRpb25zPy5zdXNwZW5zZSkge1xuICAgIGNvbnN0IGVycm9yID0gZ2V0U3RhdGUoKS5lcnJvcjtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZWxzZSBpZiAoZ2V0U3RhdGUoKS5pc0xvYWRpbmcpIHtcbiAgICAgIHRocm93IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNhY2hlSXRlbS5zdWJzY3JpYmVPbmNlKChzdGF0ZTIpID0+IHtcbiAgICAgICAgICBpZiAoIXN0YXRlMi5pc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0ZS5pc0xvYWRpbmcgJiYgZnJvemVuT3B0aW9ucz8ua2VlcFByZXZpb3VzRGF0YVdoaWxlTG9hZGluZyAmJiB0eXBlb2Ygc3RhdGUuZGF0YSA9PT0gXCJ1bmRlZmluZWRcIiAmJiBwcmV2aW91c0RhdGEuY3VycmVudD8ua2V5ICE9PSBrZXkgJiYgdHlwZW9mIHByZXZpb3VzRGF0YS5jdXJyZW50Py5kYXRhICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZGF0YSA9IHByZXZpb3VzRGF0YS5jdXJyZW50LmRhdGE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IHN0YXRlLmlzTG9hZGluZyxcbiAgICBkYXRhLFxuICAgIGVycm9yOiBzdGF0ZS5lcnJvcixcbiAgICBnZXRTdGF0ZSxcbiAgICByZXZhbGlkYXRlXG4gIH07XG59XG5cbi8vIHNyYy9saWIvdXNlLWxhdGVzdC50c1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDYsIHVzZVJlZiBhcyB1c2VSZWY1IH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VMYXRlc3QodmFsdWUpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmNSh2YWx1ZSk7XG4gIHVzZUVmZmVjdDYoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0sIFt2YWx1ZV0pO1xuICByZXR1cm4gcmVmO1xufVxuXG4vLyBzcmMvbGliL3VzZS1yZXJlbmRlci50c1xuaW1wb3J0IHsgdXNlUmVkdWNlciB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlUmVyZW5kZXIoKSB7XG4gIGNvbnN0IFssIHVwZGF0ZV0gPSB1c2VSZWR1Y2VyKFxuICAgIC8vIFRoaXMgaW1wbGVtZW50YXRpb24gd29ya3MgYnkgaW5jcmVtZW50aW5nIGEgaGlkZGVuIGNvdW50ZXIgdmFsdWUgdGhhdCBpc1xuICAgIC8vIG5ldmVyIGNvbnN1bWVkLiBTaW1wbHkgaW5jcmVtZW50aW5nIHRoZSBjb3VudGVyIGNoYW5nZXMgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gc3RhdGUgYW5kLCB0aHVzLCB0cmlnZ2VyIGEgcmUtcmVuZGVyLlxuICAgICh4KSA9PiB4ICsgMSxcbiAgICAwXG4gICk7XG4gIHJldHVybiB1cGRhdGU7XG59XG5cbi8vIHNyYy9mYWN0b3J5LnRzeFxudmFyIG5vb3AyID0gKCkgPT4ge1xufTtcbnZhciBpZGVudGl0eSA9ICh4KSA9PiB4O1xudmFyIG1pc3NpbmdfdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPSAocmVhY3RWZXJzaW9uLCByb29tSWQpID0+IGBXZSBub3RpY2VkIHlvdVxcdTIwMTlyZSB1c2luZyBSZWFjdCAke3JlYWN0VmVyc2lvbn0uIFBsZWFzZSBwYXNzIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIGF0IHRoZSBSb29tUHJvdmlkZXIgbGV2ZWwgdW50aWwgeW91XFx1MjAxOXJlIHJlYWR5IHRvIHVwZ3JhZGUgdG8gUmVhY3QgMTg6XG5cbiAgICBpbXBvcnQgeyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyB9IGZyb20gXCJyZWFjdC1kb21cIjsgIC8vIG9yIFwicmVhY3QtbmF0aXZlXCJcblxuICAgIDxSb29tUHJvdmlkZXIgaWQ9JHtKU09OLnN0cmluZ2lmeShcbiAgcm9vbUlkXG4pfSAuLi4gdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM9e3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzfT5cbiAgICAgIC4uLlxuICAgIDwvUm9vbVByb3ZpZGVyPlxuXG5XaHk/IFBsZWFzZSBzZWUgaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvcGxhdGZvcm0vdHJvdWJsZXNob290aW5nI3N0YWxlLXByb3BzLXpvbWJpZS1jaGlsZCBmb3IgbW9yZSBpbmZvcm1hdGlvbmA7XG52YXIgc3VwZXJmbHVvdXNfdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPSBcIllvdSBkb25cXHUyMDE5dCBuZWVkIHRvIHBhc3MgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgdG8gUm9vbVByb3ZpZGVyIGFueW1vcmUsIHNpbmNlIHlvdVxcdTIwMTlyZSBvbiBSZWFjdCAxOCsgYWxyZWFkeS5cIjtcbmZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhzLCBncywgZ3NzKSB7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIocywgZ3MsIGdzcywgaWRlbnRpdHkpO1xufVxudmFyIFNUQUJMRV9FTVBUWV9MSVNUID0gT2JqZWN0LmZyZWV6ZShbXSk7XG5mdW5jdGlvbiBhbHdheXNFbXB0eUxpc3QoKSB7XG4gIHJldHVybiBTVEFCTEVfRU1QVFlfTElTVDtcbn1cbmZ1bmN0aW9uIGFsd2F5c051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWFrZU11dGF0aW9uQ29udGV4dChyb29tKSB7XG4gIGNvbnN0IGVycm1zZyA9IFwiVGhpcyBtdXRhdGlvbiBjYW5ub3QgYmUgdXNlZCB1bnRpbCBjb25uZWN0ZWQgdG8gdGhlIExpdmVibG9ja3Mgcm9vbVwiO1xuICByZXR1cm4ge1xuICAgIGdldCBzdG9yYWdlKCkge1xuICAgICAgY29uc3QgbXV0YWJsZVJvb3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpO1xuICAgICAgaWYgKG11dGFibGVSb290ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJtc2cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG11dGFibGVSb290O1xuICAgIH0sXG4gICAgZ2V0IHNlbGYoKSB7XG4gICAgICBjb25zdCBzZWxmID0gcm9vbS5nZXRTZWxmKCk7XG4gICAgICBpZiAoc2VsZiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJybXNnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG4gICAgZ2V0IG90aGVycygpIHtcbiAgICAgIGNvbnN0IG90aGVycyA9IHJvb20uZ2V0T3RoZXJzKCk7XG4gICAgICBpZiAocm9vbS5nZXRTZWxmKCkgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm1zZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3RoZXJzO1xuICAgIH0sXG4gICAgc2V0TXlQcmVzZW5jZTogcm9vbS51cGRhdGVQcmVzZW5jZVxuICB9O1xufVxudmFyIGhhc1dhcm5lZElmTm9SZXNvbHZlVXNlcnMgPSBmYWxzZTtcbmZ1bmN0aW9uIHdhcm5JZk5vUmVzb2x2ZVVzZXJzKHVzZXJzQ2FjaGUpIHtcbiAgaWYgKCFoYXNXYXJuZWRJZk5vUmVzb2x2ZVVzZXJzICYmICF1c2Vyc0NhY2hlICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiU2V0IHRoZSByZXNvbHZlVXNlcnMgb3B0aW9uIGluIGNyZWF0ZVJvb21Db250ZXh0IHRvIHNwZWNpZnkgdXNlciBpbmZvLlwiXG4gICAgKTtcbiAgICBoYXNXYXJuZWRJZk5vUmVzb2x2ZVVzZXJzID0gdHJ1ZTtcbiAgfVxufVxudmFyIENvbnRleHRCdW5kbGUgPSBSZWFjdDMuY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIHVzZVJvb21Db250ZXh0QnVuZGxlKCkge1xuICBjb25zdCBidW5kbGUgPSBSZWFjdDMudXNlQ29udGV4dChDb250ZXh0QnVuZGxlKTtcbiAgaWYgKGJ1bmRsZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJvb21Qcm92aWRlciBpcyBtaXNzaW5nIGZyb20gdGhlIFJlYWN0IHRyZWUuXCIpO1xuICB9XG4gIHJldHVybiBidW5kbGU7XG59XG5mdW5jdGlvbiBjcmVhdGVSb29tQ29udGV4dChjbGllbnQsIG9wdGlvbnMpIHtcbiAgY29uc3QgUm9vbUNvbnRleHQgPSBSZWFjdDMuY3JlYXRlQ29udGV4dChudWxsKTtcbiAgY29uc3QgY29tbWVudHNFcnJvckV2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlMigpO1xuICBjb25zdCB7IENvbW1lbnRzUm9vbVByb3ZpZGVyLCAuLi5jb21tZW50c1Jvb20gfSA9IGNyZWF0ZUNvbW1lbnRzUm9vbShjb21tZW50c0Vycm9yRXZlbnRTb3VyY2UpO1xuICBmdW5jdGlvbiBSb29tUHJvdmlkZXJPdXRlcihwcm9wcykge1xuICAgIGNvbnN0IFtjYWNoZV0gPSBSZWFjdDMudXNlU3RhdGUoXG4gICAgICAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gICAgKTtcbiAgICBjb25zdCBzdGFibGVFbnRlclJvb20gPSBSZWFjdDMudXNlQ2FsbGJhY2soXG4gICAgICAocm9vbUlkLCBvcHRpb25zMikgPT4ge1xuICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQocm9vbUlkKTtcbiAgICAgICAgaWYgKGNhY2hlZClcbiAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICBjb25zdCBydiA9IGNsaWVudC5lbnRlclJvb20oXG4gICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgIG9wdGlvbnMyXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG9yaWdMZWF2ZSA9IHJ2LmxlYXZlO1xuICAgICAgICBydi5sZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICBvcmlnTGVhdmUoKTtcbiAgICAgICAgICBjYWNoZS5kZWxldGUocm9vbUlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FjaGUuc2V0KHJvb21JZCwgcnYpO1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9LFxuICAgICAgW2NhY2hlXVxuICAgICk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChSb29tUHJvdmlkZXJJbm5lciwgeyAuLi5wcm9wcywgc3RhYmxlRW50ZXJSb29tIH0pO1xuICB9XG4gIGZ1bmN0aW9uIFJvb21Qcm92aWRlcklubmVyKHByb3BzKSB7XG4gICAgY29uc3QgeyBpZDogcm9vbUlkLCBzdGFibGVFbnRlclJvb20gfSA9IHByb3BzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghcm9vbUlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlJvb21Qcm92aWRlciBpZCBwcm9wZXJ0eSBpcyByZXF1aXJlZC4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2Vycm9ycy9saXZlYmxvY2tzLXJlYWN0L1Jvb21Qcm92aWRlci1pZC1wcm9wZXJ0eS1pcy1yZXF1aXJlZFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHJvb21JZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb29tUHJvdmlkZXIgaWQgcHJvcGVydHkgc2hvdWxkIGJlIGEgc3RyaW5nLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1ham9yUmVhY3RWZXJzaW9uID0gcGFyc2VJbnQoUmVhY3QzLnZlcnNpb24pIHx8IDE7XG4gICAgICBjb25zdCBvbGRSZWFjdFZlcnNpb24gPSBtYWpvclJlYWN0VmVyc2lvbiA8IDE4O1xuICAgICAgZXJyb3JJZihcbiAgICAgICAgb2xkUmVhY3RWZXJzaW9uICYmIHByb3BzLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID09PSB2b2lkIDAsXG4gICAgICAgIG1pc3NpbmdfdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMobWFqb3JSZWFjdFZlcnNpb24sIHJvb21JZClcbiAgICAgICk7XG4gICAgICBkZXByZWNhdGVJZihcbiAgICAgICAgIW9sZFJlYWN0VmVyc2lvbiAmJiBwcm9wcy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyAhPT0gdm9pZCAwLFxuICAgICAgICBzdXBlcmZsdW91c191bnN0YWJsZV9iYXRjaGVkVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZnJvemVuUHJvcHMgPSB1c2VJbml0aWFsKHtcbiAgICAgIGluaXRpYWxQcmVzZW5jZTogcHJvcHMuaW5pdGlhbFByZXNlbmNlLFxuICAgICAgaW5pdGlhbFN0b3JhZ2U6IHByb3BzLmluaXRpYWxTdG9yYWdlLFxuICAgICAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IHByb3BzLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzLFxuICAgICAgYXV0b0Nvbm5lY3Q6IHByb3BzLmF1dG9Db25uZWN0ID8/IHByb3BzLnNob3VsZEluaXRpYWxseUNvbm5lY3QgPz8gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgIH0pO1xuICAgIGNvbnN0IFt7IHJvb20gfSwgc2V0Um9vbUxlYXZlUGFpcl0gPSBSZWFjdDMudXNlU3RhdGUoXG4gICAgICAoKSA9PiBzdGFibGVFbnRlclJvb20ocm9vbUlkLCB7XG4gICAgICAgIC4uLmZyb3plblByb3BzLFxuICAgICAgICBhdXRvQ29ubmVjdDogZmFsc2VcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IHVzaW5nIGZhbHNlIGhlcmUgb24gdGhlIGZpcnN0IHJlbmRlciwgc2VlIGJlbG93XG4gICAgICB9KVxuICAgICk7XG4gICAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBwYWlyID0gc3RhYmxlRW50ZXJSb29tKHJvb21JZCwgZnJvemVuUHJvcHMpO1xuICAgICAgc2V0Um9vbUxlYXZlUGFpcihwYWlyKTtcbiAgICAgIGNvbnN0IHsgcm9vbTogcm9vbTIsIGxlYXZlIH0gPSBwYWlyO1xuICAgICAgaWYgKGZyb3plblByb3BzLmF1dG9Db25uZWN0KSB7XG4gICAgICAgIHJvb20yLmNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGxlYXZlKCk7XG4gICAgICB9O1xuICAgIH0sIFtyb29tSWQsIGZyb3plblByb3BzLCBzdGFibGVFbnRlclJvb21dKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFJvb21Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiByb29tIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChDb21tZW50c1Jvb21Qcm92aWRlciwgeyByb29tIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChcbiAgICAgIENvbnRleHRCdW5kbGUuUHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiBpbnRlcm5hbEJ1bmRsZVxuICAgICAgfSxcbiAgICAgIHByb3BzLmNoaWxkcmVuXG4gICAgKSkpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbm5lY3Rpb25JZFNlbGVjdG9yKG90aGVycykge1xuICAgIHJldHVybiBvdGhlcnMubWFwKCh1c2VyKSA9PiB1c2VyLmNvbm5lY3Rpb25JZCk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlUm9vbSgpIHtcbiAgICBjb25zdCByb29tID0gUmVhY3QzLnVzZUNvbnRleHQoUm9vbUNvbnRleHQpO1xuICAgIGlmIChyb29tID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb29tUHJvdmlkZXIgaXMgbWlzc2luZyBmcm9tIHRoZSBSZWFjdCB0cmVlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb207XG4gIH1cbiAgZnVuY3Rpb24gdXNlU3RhdHVzKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc3Vic2NyaWJlMiA9IHJvb20uZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmU7XG4gICAgY29uc3QgZ2V0U25hcHNob3QyID0gcm9vbS5nZXRTdGF0dXM7XG4gICAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSByb29tLmdldFN0YXR1cztcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUzKHN1YnNjcmliZTIsIGdldFNuYXBzaG90MiwgZ2V0U2VydmVyU25hcHNob3QpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU15UHJlc2VuY2UoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBzdWJzY3JpYmUyID0gcm9vbS5ldmVudHMubXlQcmVzZW5jZS5zdWJzY3JpYmU7XG4gICAgY29uc3QgZ2V0U25hcHNob3QyID0gcm9vbS5nZXRQcmVzZW5jZTtcbiAgICBjb25zdCBwcmVzZW5jZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhzdWJzY3JpYmUyLCBnZXRTbmFwc2hvdDIsIGdldFNuYXBzaG90Mik7XG4gICAgY29uc3Qgc2V0UHJlc2VuY2UgPSByb29tLnVwZGF0ZVByZXNlbmNlO1xuICAgIHJldHVybiBbcHJlc2VuY2UsIHNldFByZXNlbmNlXTtcbiAgfVxuICBmdW5jdGlvbiB1c2VVcGRhdGVNeVByZXNlbmNlKCkge1xuICAgIHJldHVybiB1c2VSb29tKCkudXBkYXRlUHJlc2VuY2U7XG4gIH1cbiAgZnVuY3Rpb24gdXNlT3RoZXJzKHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBzdWJzY3JpYmUyID0gcm9vbS5ldmVudHMub3RoZXJzLnN1YnNjcmliZTtcbiAgICBjb25zdCBnZXRTbmFwc2hvdDIgPSByb29tLmdldE90aGVycztcbiAgICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGFsd2F5c0VtcHR5TGlzdDtcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgICAgc3Vic2NyaWJlMixcbiAgICAgIGdldFNuYXBzaG90MixcbiAgICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgICAgc2VsZWN0b3IgPz8gaWRlbnRpdHksXG4gICAgICBpc0VxdWFsXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzKCkge1xuICAgIHJldHVybiB1c2VPdGhlcnMoY29ubmVjdGlvbklkU2VsZWN0b3IsIHNoYWxsb3cpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU90aGVyc01hcHBlZChpdGVtU2VsZWN0b3IsIGl0ZW1Jc0VxdWFsKSB7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3QzLnVzZUNhbGxiYWNrKFxuICAgICAgKG90aGVycykgPT4gb3RoZXJzLm1hcChcbiAgICAgICAgKG90aGVyKSA9PiBbb3RoZXIuY29ubmVjdGlvbklkLCBpdGVtU2VsZWN0b3Iob3RoZXIpXVxuICAgICAgKSxcbiAgICAgIFtpdGVtU2VsZWN0b3JdXG4gICAgKTtcbiAgICBjb25zdCB3cmFwcGVkSXNFcXVhbCA9IFJlYWN0My51c2VDYWxsYmFjayhcbiAgICAgIChhLCBiKSA9PiB7XG4gICAgICAgIGNvbnN0IGVxID0gaXRlbUlzRXF1YWwgPz8gT2JqZWN0LmlzO1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoKGF0dXBsZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBidHVwbGUgPSBiW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gYXR1cGxlWzBdID09PSBidHVwbGVbMF0gJiYgZXEoYXR1cGxlWzFdLCBidHVwbGVbMV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBbaXRlbUlzRXF1YWxdXG4gICAgKTtcbiAgICByZXR1cm4gdXNlT3RoZXJzKHdyYXBwZWRTZWxlY3Rvciwgd3JhcHBlZElzRXF1YWwpO1xuICB9XG4gIGNvbnN0IE5PVF9GT1VORCA9IFN5bWJvbCgpO1xuICBmdW5jdGlvbiB1c2VPdGhlcihjb25uZWN0aW9uSWQsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3QzLnVzZUNhbGxiYWNrKFxuICAgICAgKG90aGVycykgPT4ge1xuICAgICAgICBjb25zdCBvdGhlcjIgPSBvdGhlcnMuZmluZChcbiAgICAgICAgICAob3RoZXIzKSA9PiBvdGhlcjMuY29ubmVjdGlvbklkID09PSBjb25uZWN0aW9uSWRcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG90aGVyMiAhPT0gdm9pZCAwID8gc2VsZWN0b3Iob3RoZXIyKSA6IE5PVF9GT1VORDtcbiAgICAgIH0sXG4gICAgICBbY29ubmVjdGlvbklkLCBzZWxlY3Rvcl1cbiAgICApO1xuICAgIGNvbnN0IHdyYXBwZWRJc0VxdWFsID0gUmVhY3QzLnVzZUNhbGxiYWNrKFxuICAgICAgKHByZXYsIGN1cnIpID0+IHtcbiAgICAgICAgaWYgKHByZXYgPT09IE5PVF9GT1VORCB8fCBjdXJyID09PSBOT1RfRk9VTkQpIHtcbiAgICAgICAgICByZXR1cm4gcHJldiA9PT0gY3VycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcSA9IGlzRXF1YWwgPz8gT2JqZWN0LmlzO1xuICAgICAgICByZXR1cm4gZXEocHJldiwgY3Vycik7XG4gICAgICB9LFxuICAgICAgW2lzRXF1YWxdXG4gICAgKTtcbiAgICBjb25zdCBvdGhlciA9IHVzZU90aGVycyh3cmFwcGVkU2VsZWN0b3IsIHdyYXBwZWRJc0VxdWFsKTtcbiAgICBpZiAob3RoZXIgPT09IE5PVF9GT1VORCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTm8gc3VjaCBvdGhlciB1c2VyIHdpdGggY29ubmVjdGlvbiBpZCAke2Nvbm5lY3Rpb25JZH0gZXhpc3RzYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG90aGVyO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUJyb2FkY2FzdEV2ZW50KCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIFJlYWN0My51c2VDYWxsYmFjayhcbiAgICAgIChldmVudCwgb3B0aW9uczIgPSB7IHNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5OiBmYWxzZSB9KSA9PiB7XG4gICAgICAgIHJvb20uYnJvYWRjYXN0RXZlbnQoZXZlbnQsIG9wdGlvbnMyKTtcbiAgICAgIH0sXG4gICAgICBbcm9vbV1cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU90aGVyc0xpc3RlbmVyKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlTGF0ZXN0KGNhbGxiYWNrKTtcbiAgICBSZWFjdDMudXNlRWZmZWN0KFxuICAgICAgKCkgPT4gcm9vbS5ldmVudHMub3RoZXJzLnN1YnNjcmliZSgoZXZlbnQpID0+IHNhdmVkQ2FsbGJhY2suY3VycmVudChldmVudCkpLFxuICAgICAgW3Jvb20sIHNhdmVkQ2FsbGJhY2tdXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VMb3N0Q29ubmVjdGlvbkxpc3RlbmVyKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlTGF0ZXN0KGNhbGxiYWNrKTtcbiAgICBSZWFjdDMudXNlRWZmZWN0KFxuICAgICAgKCkgPT4gcm9vbS5ldmVudHMubG9zdENvbm5lY3Rpb24uc3Vic2NyaWJlKFxuICAgICAgICAoZXZlbnQpID0+IHNhdmVkQ2FsbGJhY2suY3VycmVudChldmVudClcbiAgICAgICksXG4gICAgICBbcm9vbSwgc2F2ZWRDYWxsYmFja11cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUVycm9yTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICAgIFJlYWN0My51c2VFZmZlY3QoXG4gICAgICAoKSA9PiByb29tLmV2ZW50cy5lcnJvci5zdWJzY3JpYmUoKGUpID0+IHNhdmVkQ2FsbGJhY2suY3VycmVudChlKSksXG4gICAgICBbcm9vbSwgc2F2ZWRDYWxsYmFja11cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUV2ZW50TGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICAgIFJlYWN0My51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnREYXRhKSA9PiB7XG4gICAgICAgIHNhdmVkQ2FsbGJhY2suY3VycmVudChldmVudERhdGEpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiByb29tLmV2ZW50cy5jdXN0b21FdmVudC5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICAgIH0sIFtyb29tLCBzYXZlZENhbGxiYWNrXSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlU2VsZihtYXliZVNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBzdWJzY3JpYmUyID0gcm9vbS5ldmVudHMuc2VsZi5zdWJzY3JpYmU7XG4gICAgY29uc3QgZ2V0U25hcHNob3QyID0gcm9vbS5nZXRTZWxmO1xuICAgIGNvbnN0IHNlbGVjdG9yID0gbWF5YmVTZWxlY3RvciA/PyBpZGVudGl0eTtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdDMudXNlQ2FsbGJhY2soXG4gICAgICAobWUpID0+IG1lICE9PSBudWxsID8gc2VsZWN0b3IobWUpIDogbnVsbCxcbiAgICAgIFtzZWxlY3Rvcl1cbiAgICApO1xuICAgIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzTnVsbDtcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgICAgc3Vic2NyaWJlMixcbiAgICAgIGdldFNuYXBzaG90MixcbiAgICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgICAgd3JhcHBlZFNlbGVjdG9yLFxuICAgICAgaXNFcXVhbFxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlTXV0YWJsZVN0b3JhZ2VSb290KCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc3Vic2NyaWJlMiA9IHJvb20uZXZlbnRzLnN0b3JhZ2VEaWRMb2FkLnN1YnNjcmliZU9uY2U7XG4gICAgY29uc3QgZ2V0U25hcHNob3QyID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3Q7XG4gICAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSBhbHdheXNOdWxsO1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTMoc3Vic2NyaWJlMiwgZ2V0U25hcHNob3QyLCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlU3RvcmFnZVJvb3QoKSB7XG4gICAgcmV0dXJuIFt1c2VNdXRhYmxlU3RvcmFnZVJvb3QoKV07XG4gIH1cbiAgZnVuY3Rpb24gdXNlSGlzdG9yeSgpIHtcbiAgICByZXR1cm4gdXNlUm9vbSgpLmhpc3Rvcnk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlVW5kbygpIHtcbiAgICByZXR1cm4gdXNlSGlzdG9yeSgpLnVuZG87XG4gIH1cbiAgZnVuY3Rpb24gdXNlUmVkbygpIHtcbiAgICByZXR1cm4gdXNlSGlzdG9yeSgpLnJlZG87XG4gIH1cbiAgZnVuY3Rpb24gdXNlQ2FuVW5kbygpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHN1YnNjcmliZTIgPSByb29tLmV2ZW50cy5oaXN0b3J5LnN1YnNjcmliZTtcbiAgICBjb25zdCBjYW5VbmRvID0gcm9vbS5oaXN0b3J5LmNhblVuZG87XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhzdWJzY3JpYmUyLCBjYW5VbmRvLCBjYW5VbmRvKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VDYW5SZWRvKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc3Vic2NyaWJlMiA9IHJvb20uZXZlbnRzLmhpc3Rvcnkuc3Vic2NyaWJlO1xuICAgIGNvbnN0IGNhblJlZG8gPSByb29tLmhpc3RvcnkuY2FuUmVkbztcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUzKHN1YnNjcmliZTIsIGNhblJlZG8sIGNhblJlZG8pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUJhdGNoKCkge1xuICAgIHJldHVybiB1c2VSb29tKCkuYmF0Y2g7XG4gIH1cbiAgZnVuY3Rpb24gdXNlTGVnYWN5S2V5KGtleSkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgcm9vdE9yTnVsbCA9IHVzZU11dGFibGVTdG9yYWdlUm9vdCgpO1xuICAgIGNvbnN0IHJlcmVuZGVyID0gdXNlUmVyZW5kZXIoKTtcbiAgICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChyb290T3JOdWxsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJvb3QgPSByb290T3JOdWxsO1xuICAgICAgbGV0IHVuc3ViQ3VycjtcbiAgICAgIGxldCBjdXJyID0gcm9vdC5nZXQoa2V5KTtcbiAgICAgIGZ1bmN0aW9uIHN1YnNjcmliZVRvQ3VycigpIHtcbiAgICAgICAgdW5zdWJDdXJyID0gaXNMaXZlTm9kZShjdXJyKSA/IHJvb20uc3Vic2NyaWJlKGN1cnIsIHJlcmVuZGVyKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uUm9vdENoYW5nZSgpIHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSByb290LmdldChrZXkpO1xuICAgICAgICBpZiAobmV3VmFsdWUgIT09IGN1cnIpIHtcbiAgICAgICAgICB1bnN1YkN1cnI/LigpO1xuICAgICAgICAgIGN1cnIgPSBuZXdWYWx1ZTtcbiAgICAgICAgICBzdWJzY3JpYmVUb0N1cnIoKTtcbiAgICAgICAgICByZXJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdWJzY3JpYmVUb0N1cnIoKTtcbiAgICAgIHJlcmVuZGVyKCk7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZVJvb3QgPSByb29tLnN1YnNjcmliZShyb290LCBvblJvb3RDaGFuZ2UpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdW5zdWJzY3JpYmVSb290KCk7XG4gICAgICAgIHVuc3ViQ3Vycj8uKCk7XG4gICAgICB9O1xuICAgIH0sIFtyb290T3JOdWxsLCByb29tLCBrZXksIHJlcmVuZGVyXSk7XG4gICAgaWYgKHJvb3RPck51bGwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcm9vdE9yTnVsbC5nZXQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXNlU3RvcmFnZShzZWxlY3RvciwgaXNFcXVhbCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgcm9vdE9yTnVsbCA9IHVzZU11dGFibGVTdG9yYWdlUm9vdCgpO1xuICAgIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9IFJlYWN0My51c2VDYWxsYmFjayhcbiAgICAgIChyb290T3JOdWxsMikgPT4gcm9vdE9yTnVsbDIgIT09IG51bGwgPyBzZWxlY3Rvcihyb290T3JOdWxsMikgOiBudWxsLFxuICAgICAgW3NlbGVjdG9yXVxuICAgICk7XG4gICAgY29uc3Qgc3Vic2NyaWJlMiA9IFJlYWN0My51c2VDYWxsYmFjayhcbiAgICAgIChvblN0b3JlQ2hhbmdlKSA9PiByb290T3JOdWxsICE9PSBudWxsID8gcm9vbS5zdWJzY3JpYmUocm9vdE9yTnVsbCwgb25TdG9yZUNoYW5nZSwgeyBpc0RlZXA6IHRydWUgfSkgOiBub29wMixcbiAgICAgIFtyb29tLCByb290T3JOdWxsXVxuICAgICk7XG4gICAgY29uc3QgZ2V0U25hcHNob3QyID0gUmVhY3QzLnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIGlmIChyb290T3JOdWxsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHJvb3RPck51bGw7XG4gICAgICAgIGNvbnN0IGltbSA9IHJvb3QudG9JbW11dGFibGUoKTtcbiAgICAgICAgcmV0dXJuIGltbTtcbiAgICAgIH1cbiAgICB9LCBbcm9vdE9yTnVsbF0pO1xuICAgIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzTnVsbDtcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgICAgc3Vic2NyaWJlMixcbiAgICAgIGdldFNuYXBzaG90MixcbiAgICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgICAgd3JhcHBlZFNlbGVjdG9yLFxuICAgICAgaXNFcXVhbFxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gZW5zdXJlTm90U2VydmVyU2lkZSgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIllvdSBjYW5ub3QgdXNlIHRoZSBTdXNwZW5zZSB2ZXJzaW9uIG9mIHRoaXMgaG9vayBvbiB0aGUgc2VydmVyIHNpZGUuIE1ha2Ugc3VyZSB0byBvbmx5IGNhbGwgdGhlbSBvbiB0aGUgY2xpZW50IHNpZGUuXFxuRm9yIHRpcHMsIHNlZSBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtcmVhY3Qjc3VzcGVuc2UtYXZvaWQtc3NyXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVzZVN1c3BlbmRVbnRpbFN0b3JhZ2VMb2FkZWQoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBpZiAocm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCk7XG4gICAgdGhyb3cgbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgICAgcm9vbS5ldmVudHMuc3RvcmFnZURpZExvYWQuc3Vic2NyaWJlT25jZSgoKSA9PiByZXMoKSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlU3VzcGVuZFVudGlsUHJlc2VuY2VMb2FkZWQoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBpZiAocm9vbS5nZXRTZWxmKCkgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5zdXJlTm90U2VydmVyU2lkZSgpO1xuICAgIHRocm93IG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgIHJvb20uZXZlbnRzLnNlbGYuc3Vic2NyaWJlT25jZSgoKSA9PiByZXMoKSk7XG4gICAgICByb29tLmV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlT25jZSgoKSA9PiByZXMoKSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlTXV0YXRpb24oY2FsbGJhY2ssIGRlcHMpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBSZWFjdDMudXNlTWVtbyhcbiAgICAgICgpID0+IHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgICAgcm9vbS5iYXRjaChcbiAgICAgICAgICAgICgpID0+IChcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgICAgICAgIG1ha2VNdXRhdGlvbkNvbnRleHQocm9vbSksXG4gICAgICAgICAgICAgICAgLi4uYXJnc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgIFtyb29tLCAuLi5kZXBzXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlU3RvcmFnZVN1c3BlbnNlKHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gICAgdXNlU3VzcGVuZFVudGlsU3RvcmFnZUxvYWRlZCgpO1xuICAgIHJldHVybiB1c2VTdG9yYWdlKFxuICAgICAgc2VsZWN0b3IsXG4gICAgICBpc0VxdWFsXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VTZWxmU3VzcGVuc2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZUxvYWRlZCgpO1xuICAgIHJldHVybiB1c2VTZWxmKFxuICAgICAgc2VsZWN0b3IsXG4gICAgICBpc0VxdWFsXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VPdGhlcnNTdXNwZW5zZShzZWxlY3RvciwgaXNFcXVhbCkge1xuICAgIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlTG9hZGVkKCk7XG4gICAgcmV0dXJuIHVzZU90aGVycyhcbiAgICAgIHNlbGVjdG9yLFxuICAgICAgaXNFcXVhbFxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlT3RoZXJzQ29ubmVjdGlvbklkc1N1c3BlbnNlKCkge1xuICAgIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlTG9hZGVkKCk7XG4gICAgcmV0dXJuIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHMoKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VPdGhlcnNNYXBwZWRTdXNwZW5zZShpdGVtU2VsZWN0b3IsIGl0ZW1Jc0VxdWFsKSB7XG4gICAgdXNlU3VzcGVuZFVudGlsUHJlc2VuY2VMb2FkZWQoKTtcbiAgICByZXR1cm4gdXNlT3RoZXJzTWFwcGVkKGl0ZW1TZWxlY3RvciwgaXRlbUlzRXF1YWwpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU90aGVyU3VzcGVuc2UoY29ubmVjdGlvbklkLCBzZWxlY3RvciwgaXNFcXVhbCkge1xuICAgIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlTG9hZGVkKCk7XG4gICAgcmV0dXJuIHVzZU90aGVyKGNvbm5lY3Rpb25JZCwgc2VsZWN0b3IsIGlzRXF1YWwpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUxlZ2FjeUtleVN1c3BlbnNlKGtleSkge1xuICAgIHVzZVN1c3BlbmRVbnRpbFN0b3JhZ2VMb2FkZWQoKTtcbiAgICByZXR1cm4gdXNlTGVnYWN5S2V5KGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlVGhyZWFkcyhvcHRpb25zMikge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIGNvbW1lbnRzUm9vbS51c2VUaHJlYWRzKHJvb20sIG9wdGlvbnMyKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VUaHJlYWRzU3VzcGVuc2Uob3B0aW9uczIpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBjb21tZW50c1Jvb20udXNlVGhyZWFkc1N1c3BlbnNlKHJvb20sIG9wdGlvbnMyKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VDcmVhdGVUaHJlYWQoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gY29tbWVudHNSb29tLnVzZUNyZWF0ZVRocmVhZChyb29tKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VFZGl0VGhyZWFkTWV0YWRhdGEoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gY29tbWVudHNSb29tLnVzZUVkaXRUaHJlYWRNZXRhZGF0YShyb29tKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VBZGRSZWFjdGlvbigpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBjb21tZW50c1Jvb20udXNlQWRkUmVhY3Rpb24ocm9vbSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlUmVtb3ZlUmVhY3Rpb24oKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gY29tbWVudHNSb29tLnVzZVJlbW92ZVJlYWN0aW9uKHJvb20pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUNyZWF0ZUNvbW1lbnQoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gY29tbWVudHNSb29tLnVzZUNyZWF0ZUNvbW1lbnQocm9vbSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRWRpdENvbW1lbnQoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gY29tbWVudHNSb29tLnVzZUVkaXRDb21tZW50KHJvb20pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZURlbGV0ZUNvbW1lbnQoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gY29tbWVudHNSb29tLnVzZURlbGV0ZUNvbW1lbnQocm9vbSk7XG4gIH1cbiAgY29uc3QgeyByZXNvbHZlVXNlcnMsIHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMgfSA9IG9wdGlvbnMgPz8ge307XG4gIGNvbnN0IHVzZXJzQ2FjaGUgPSByZXNvbHZlVXNlcnMgPyBjcmVhdGVBc3luY0NhY2hlKGFzeW5jIChzdHJpbmdpZmllZE9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc29sdmVVc2VycyhcbiAgICAgIEpTT04ucGFyc2Uoc3RyaW5naWZpZWRPcHRpb25zKVxuICAgICk7XG4gICAgcmV0dXJuIHVzZXJzPy5bMF07XG4gIH0pIDogdm9pZCAwO1xuICBmdW5jdGlvbiB1c2VVc2VyKHVzZXJJZCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3QgcmVzb2x2ZXJLZXkgPSBSZWFjdDMudXNlTWVtbyhcbiAgICAgICgpID0+IHN0cmluZ2lmeTIoeyB1c2VySWRzOiBbdXNlcklkXSwgcm9vbUlkOiByb29tLmlkIH0pLFxuICAgICAgW3VzZXJJZCwgcm9vbS5pZF1cbiAgICApO1xuICAgIGNvbnN0IHN0YXRlID0gdXNlQXN5bmNDYWNoZSh1c2Vyc0NhY2hlLCByZXNvbHZlcktleSk7XG4gICAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB3YXJuSWZOb1Jlc29sdmVVc2Vycyh1c2Vyc0NhY2hlKSwgW10pO1xuICAgIGlmIChzdGF0ZS5pc0xvYWRpbmcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzTG9hZGluZzogdHJ1ZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXNlcjogc3RhdGUuZGF0YSxcbiAgICAgICAgZXJyb3I6IHN0YXRlLmVycm9yLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1c2VVc2VyU3VzcGVuc2UodXNlcklkKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCByZXNvbHZlcktleSA9IFJlYWN0My51c2VNZW1vKFxuICAgICAgKCkgPT4gc3RyaW5naWZ5Mih7IHVzZXJJZHM6IFt1c2VySWRdLCByb29tSWQ6IHJvb20uaWQgfSksXG4gICAgICBbdXNlcklkLCByb29tLmlkXVxuICAgICk7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VBc3luY0NhY2hlKHVzZXJzQ2FjaGUsIHJlc29sdmVyS2V5LCB7XG4gICAgICBzdXNwZW5zZTogdHJ1ZVxuICAgIH0pO1xuICAgIFJlYWN0My51c2VFZmZlY3QoKCkgPT4gd2FybklmTm9SZXNvbHZlVXNlcnModXNlcnNDYWNoZSksIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgdXNlcjogc3RhdGUuZGF0YSxcbiAgICAgIGlzTG9hZGluZzogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNvbnN0IG1lbnRpb25TdWdnZXN0aW9uc0NhY2hlID0gY3JlYXRlQXN5bmNDYWNoZShcbiAgICByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zID8gKHN0cmluZ2lmaWVkT3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMoXG4gICAgICAgIEpTT04ucGFyc2Uoc3RyaW5naWZpZWRPcHRpb25zKVxuICAgICAgKTtcbiAgICB9IDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKFtdKVxuICApO1xuICBmdW5jdGlvbiB1c2VNZW50aW9uU3VnZ2VzdGlvbnMoc2VhcmNoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBkZWJvdW5jZWRTZWFyY2ggPSB1c2VEZWJvdW5jZShzZWFyY2gsIDUwMCk7XG4gICAgY29uc3QgcmVzb2x2ZXJLZXkgPSBSZWFjdDMudXNlTWVtbyhcbiAgICAgICgpID0+IGRlYm91bmNlZFNlYXJjaCAhPT0gdm9pZCAwID8gc3RyaW5naWZ5Mih7IHRleHQ6IGRlYm91bmNlZFNlYXJjaCwgcm9vbUlkOiByb29tLmlkIH0pIDogbnVsbCxcbiAgICAgIFtkZWJvdW5jZWRTZWFyY2gsIHJvb20uaWRdXG4gICAgKTtcbiAgICBjb25zdCB7IGRhdGEgfSA9IHVzZUFzeW5jQ2FjaGUobWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUsIHJlc29sdmVyS2V5LCB7XG4gICAgICBrZWVwUHJldmlvdXNEYXRhV2hpbGVMb2FkaW5nOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgY29uc3QgYnVuZGxlID0ge1xuICAgIFJvb21Db250ZXh0LFxuICAgIFJvb21Qcm92aWRlcjogUm9vbVByb3ZpZGVyT3V0ZXIsXG4gICAgdXNlUm9vbSxcbiAgICB1c2VTdGF0dXMsXG4gICAgdXNlQmF0Y2gsXG4gICAgdXNlQnJvYWRjYXN0RXZlbnQsXG4gICAgdXNlT3RoZXJzTGlzdGVuZXIsXG4gICAgdXNlTG9zdENvbm5lY3Rpb25MaXN0ZW5lcixcbiAgICB1c2VFcnJvckxpc3RlbmVyLFxuICAgIHVzZUV2ZW50TGlzdGVuZXIsXG4gICAgdXNlSGlzdG9yeSxcbiAgICB1c2VVbmRvLFxuICAgIHVzZVJlZG8sXG4gICAgdXNlQ2FuUmVkbyxcbiAgICB1c2VDYW5VbmRvLFxuICAgIC8vIFRoZXNlIGFyZSBqdXN0IGFsaWFzZXMuIFRoZSBwYXNzZWQtaW4ga2V5IHdpbGwgZGVmaW5lIHRoZWlyIHJldHVybiB2YWx1ZXMuXG4gICAgdXNlTGlzdDogdXNlTGVnYWN5S2V5LFxuICAgIHVzZU1hcDogdXNlTGVnYWN5S2V5LFxuICAgIHVzZU9iamVjdDogdXNlTGVnYWN5S2V5LFxuICAgIHVzZVN0b3JhZ2VSb290LFxuICAgIHVzZVN0b3JhZ2UsXG4gICAgdXNlU2VsZixcbiAgICB1c2VNeVByZXNlbmNlLFxuICAgIHVzZVVwZGF0ZU15UHJlc2VuY2UsXG4gICAgdXNlT3RoZXJzLFxuICAgIHVzZU90aGVyc01hcHBlZCxcbiAgICB1c2VPdGhlcnNDb25uZWN0aW9uSWRzLFxuICAgIHVzZU90aGVyLFxuICAgIHVzZU11dGF0aW9uLFxuICAgIHVzZVRocmVhZHMsXG4gICAgdXNlVXNlcixcbiAgICB1c2VDcmVhdGVUaHJlYWQsXG4gICAgdXNlRWRpdFRocmVhZE1ldGFkYXRhLFxuICAgIHVzZUNyZWF0ZUNvbW1lbnQsXG4gICAgdXNlRWRpdENvbW1lbnQsXG4gICAgdXNlRGVsZXRlQ29tbWVudCxcbiAgICB1c2VBZGRSZWFjdGlvbixcbiAgICB1c2VSZW1vdmVSZWFjdGlvbixcbiAgICBzdXNwZW5zZToge1xuICAgICAgUm9vbUNvbnRleHQsXG4gICAgICBSb29tUHJvdmlkZXI6IFJvb21Qcm92aWRlck91dGVyLFxuICAgICAgdXNlUm9vbSxcbiAgICAgIHVzZVN0YXR1cyxcbiAgICAgIHVzZUJhdGNoLFxuICAgICAgdXNlQnJvYWRjYXN0RXZlbnQsXG4gICAgICB1c2VPdGhlcnNMaXN0ZW5lcixcbiAgICAgIHVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIsXG4gICAgICB1c2VFcnJvckxpc3RlbmVyLFxuICAgICAgdXNlRXZlbnRMaXN0ZW5lcixcbiAgICAgIHVzZUhpc3RvcnksXG4gICAgICB1c2VVbmRvLFxuICAgICAgdXNlUmVkbyxcbiAgICAgIHVzZUNhblJlZG8sXG4gICAgICB1c2VDYW5VbmRvLFxuICAgICAgLy8gTGVnYWN5IGhvb2tzXG4gICAgICB1c2VMaXN0OiB1c2VMZWdhY3lLZXlTdXNwZW5zZSxcbiAgICAgIHVzZU1hcDogdXNlTGVnYWN5S2V5U3VzcGVuc2UsXG4gICAgICB1c2VPYmplY3Q6IHVzZUxlZ2FjeUtleVN1c3BlbnNlLFxuICAgICAgdXNlU3RvcmFnZVJvb3QsXG4gICAgICB1c2VTdG9yYWdlOiB1c2VTdG9yYWdlU3VzcGVuc2UsXG4gICAgICB1c2VTZWxmOiB1c2VTZWxmU3VzcGVuc2UsXG4gICAgICB1c2VNeVByZXNlbmNlLFxuICAgICAgdXNlVXBkYXRlTXlQcmVzZW5jZSxcbiAgICAgIHVzZU90aGVyczogdXNlT3RoZXJzU3VzcGVuc2UsXG4gICAgICB1c2VPdGhlcnNNYXBwZWQ6IHVzZU90aGVyc01hcHBlZFN1c3BlbnNlLFxuICAgICAgdXNlT3RoZXJzQ29ubmVjdGlvbklkczogdXNlT3RoZXJzQ29ubmVjdGlvbklkc1N1c3BlbnNlLFxuICAgICAgdXNlT3RoZXI6IHVzZU90aGVyU3VzcGVuc2UsXG4gICAgICB1c2VNdXRhdGlvbixcbiAgICAgIHVzZVRocmVhZHM6IHVzZVRocmVhZHNTdXNwZW5zZSxcbiAgICAgIHVzZVVzZXI6IHVzZVVzZXJTdXNwZW5zZSxcbiAgICAgIHVzZUNyZWF0ZVRocmVhZCxcbiAgICAgIHVzZUVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgICAgIHVzZUNyZWF0ZUNvbW1lbnQsXG4gICAgICB1c2VFZGl0Q29tbWVudCxcbiAgICAgIHVzZURlbGV0ZUNvbW1lbnQsXG4gICAgICB1c2VBZGRSZWFjdGlvbixcbiAgICAgIHVzZVJlbW92ZVJlYWN0aW9uXG4gICAgfVxuICB9O1xuICBjb25zdCBpbnRlcm5hbEJ1bmRsZSA9IHtcbiAgICAuLi5idW5kbGUsXG4gICAgaGFzUmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9uczogcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyAhPT0gdm9pZCAwLFxuICAgIHVzZU1lbnRpb25TdWdnZXN0aW9uc1xuICB9O1xuICByZXR1cm4gYnVuZGxlO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IHNoYWxsb3cgYXMgc2hhbGxvdzIgfSBmcm9tIFwiQGxpdmVibG9ja3MvY2xpZW50XCI7XG5kZXRlY3REdXBlcyhQS0dfTkFNRSwgUEtHX1ZFUlNJT04sIFBLR19GT1JNQVQpO1xuZXhwb3J0IHtcbiAgQ2xpZW50U2lkZVN1c3BlbnNlLFxuICBjcmVhdGVSb29tQ29udGV4dCxcbiAgc2hhbGxvdzIgYXMgc2hhbGxvdyxcbiAgdXNlUm9vbUNvbnRleHRCdW5kbGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbImRldGVjdER1cGVzIiwiUEtHX05BTUUiLCJQS0dfVkVSU0lPTiIsIlBLR19GT1JNQVQiLCJSZWFjdCIsIkNsaWVudFNpZGVTdXNwZW5zZSIsInByb3BzIiwibW91bnRlZCIsInNldE1vdW50ZWQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImNyZWF0ZUVsZW1lbnQiLCJTdXNwZW5zZSIsImZhbGxiYWNrIiwiY2hpbGRyZW4iLCJzaGFsbG93IiwiY3JlYXRlQXN5bmNDYWNoZSIsImRlcHJlY2F0ZUlmIiwiZXJyb3JJZiIsImlzTGl2ZU5vZGUiLCJtYWtlRXZlbnRTb3VyY2UiLCJtYWtlRXZlbnRTb3VyY2UyIiwic3RyaW5naWZ5Iiwic3RyaW5naWZ5MiIsIlJlYWN0MyIsInVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIiwidXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyIiwiQ29tbWVudHNBcGlFcnJvciIsIm5hbm9pZCIsIlJlYWN0MiIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDYWxsYmFjayIsInVzZUNhbGxiYWNrMyIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3QzIiwidXNlTWVtbyIsIkNyZWF0ZVRocmVhZEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNhdXNlIiwiY29udGV4dCIsIm5hbWUiLCJFZGl0VGhyZWFkTWV0YWRhdGFFcnJvciIsIkNyZWF0ZUNvbW1lbnRFcnJvciIsIkVkaXRDb21tZW50RXJyb3IiLCJEZWxldGVDb21tZW50RXJyb3IiLCJBZGRSZWFjdGlvbkVycm9yIiwiUmVtb3ZlUmVhY3Rpb25FcnJvciIsInVzZUNhbGxiYWNrMiIsInVzZUVmZmVjdDIiLCJ1c2VSZWYiLCJ1c2VSZWYyIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJ1c2VJc0RvY3VtZW50VmlzaWJsZSIsImlzVmlzaWJsZSIsInN1YnNjcmliZSIsImdldFNuYXBzaG90Iiwib25TdG9yZUNoYW5nZSIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJpc0RvY3VtZW50RGVmaW5lZCIsInZpc2liaWxpdHlTdGF0ZSIsInVzZVN5bmNFeHRlcm5hbFN0b3JlMiIsInVzZUlzT25saW5lIiwiaXNPbmxpbmVSZWYiLCJzdWJzY3JpYmUyIiwiaGFuZGxlSXNPbmxpbmUiLCJjdXJyZW50IiwiaGFuZGxlSXNPZmZsaW5lIiwid2luZG93IiwiZ2V0U25hcHNob3QyIiwiaXNPbmxpbmUiLCJERUZBVUxUX0VSUk9SX1JFVFJZX0lOVEVSVkFMIiwiREVGQVVMVF9NQVhfRVJST1JfUkVUUllfQ09VTlQiLCJERUZBVUxUX0RFRFVQSU5HX0lOVEVSVkFMIiwidGltZXN0YW1wIiwidXNlUmV2YWxpZGF0ZUNhY2hlIiwibWFuYWdlciIsImZldGNoZXIiLCJvcHRpb25zIiwiZGVkdXBpbmdJbnRlcnZhbCIsImVycm9yUmV0cnlJbnRlcnZhbCIsImVycm9yUmV0cnlDb3VudCIsIl9yZXZhbGlkYXRlQ2FjaGUiLCJzaG91bGREZWR1cGUiLCJyZXRyeUNvdW50Iiwic3RhcnRBdCIsInNob3VsZFN0YXJ0UmVxdWVzdCIsImdldFJlcXVlc3QiLCJkZWxldGVBY3RpdmVSZXF1ZXN0IiwiYWN0aXZlUmVxdWVzdCIsInNldFJlcXVlc3QiLCJoYW5kbGVFcnJvciIsInRpbWVvdXQiLCJNYXRoIiwicmFuZG9tIiwic2V0VGltZW91dCIsIm5ld0RhdGEiLCJhY3RpdmVNdXRhdGlvbiIsImdldE11dGF0aW9uIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsInNldENhY2hlIiwiZXJyIiwic2V0RXJyb3IiLCJyZXZhbGlkYXRlQ2FjaGUiLCJ1c2VNdXRhdGUiLCJtdXRhdGUiLCJkYXRhIiwiYmVmb3JlTXV0YXRpb25UaW1lc3RhbXAiLCJzZXRNdXRhdGlvbiIsImN1cnJlbnRDYWNoZSIsImdldENhY2hlIiwib3B0aW1pc3RpY0RhdGEiLCJlcnJvciIsIlRIUkVBRF9JRF9QUkVGSVgiLCJDT01NRU5UX0lEX1BSRUZJWCIsIlBPTExJTkdfSU5URVJWQUxfUkVBTFRJTUUiLCJQT0xMSU5HX0lOVEVSVkFMIiwiY3JlYXRlQ29tbWVudHNSb29tIiwiZXJyb3JFdmVudFNvdXJjZSIsInN0b3JlIiwiY3JlYXRlQ2xpZW50Q2FjaGVTdG9yZSIsIkZldGNoZXJDb250ZXh0IiwiUm9vbU1hbmFnZXJDb250ZXh0IiwiZ2V0VGhyZWFkcyIsInRocmVhZHMiLCJDb21tZW50c1Jvb21Qcm92aWRlciIsInJvb20iLCJjcmVhdGVSb29tUmV2YWxpZGF0aW9uTWFuYWdlciIsImlkIiwic2V0VGhyZWFkcyIsImdldFJldmFsaWRhdGlvbk1hbmFnZXJzIiwiZmlsdGVyIiwia2V5IiwiZ2V0UmVmZXJlbmNlQ291bnQiLCJtYXAiLCJfIiwibWFuYWdlcjIiLCJnZXRPcHRpb25zIiwicmVzcG9uc2VzIiwiUHJvbWlzZSIsImFsbCIsIm9wdGlvbiIsIkFycmF5IiwiZnJvbSIsIk1hcCIsImZsYXQiLCJ0aHJlYWQiLCJ2YWx1ZXMiLCJzdGF0dXMiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZTMiLCJldmVudHMiLCJnZXRTdGF0dXMiLCJpc0RvY3VtZW50VmlzaWJsZSIsInJlZnJlc2hJbnRlcnZhbCIsImdldFBvbGxpbmdJbnRlcnZhbCIsInJldmFsaWRhdGlvblRpbWVySWQiLCJzY2hlZHVsZVJldmFsaWRhdGlvbiIsImdldEVycm9yIiwiZ2V0VG90YWxSZWZlcmVuY2VDb3VudCIsInRoZW4iLCJjbGVhclRpbWVvdXQiLCJoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlIiwidW5zdWJzY3JpYmUiLCJjb21tZW50cyIsIlByb3ZpZGVyIiwidmFsdWUiLCJ1c2VSb29tTWFuYWdlciIsImdldFVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyIiwicm9vbU1hbmFnZXIiLCJyZXZhbGlkYXRpb25NYW5hZ2VyIiwiZ2V0UmV2YWxpZGF0aW9uTWFuYWdlciIsInVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyIiwiY3JlYXRlVXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIiLCJzZXRSZXZhbGlkYXRpb25tYW5hZ2VyIiwidXNlVGhyZWFkc0ZldGNoZXIiLCJ1c2VUaHJlYWRzIiwicXVlcnkiLCJtZXRhZGF0YSIsImluY3JlbWVudFJlZmVyZW5jZUNvdW50IiwiZGVjcmVtZW50UmVmZXJlbmNlQ291bnQiLCJjYWNoZSIsIl91c2VUaHJlYWRzIiwidXNlVGhyZWFkc1N1c3BlbnNlIiwiaXNMb2FkaW5nIiwic3RhdGUiLCJnZXRJc0xvYWRpbmciLCJvcHRpb25zMiIsImZpbHRlcmVkIiwicm9vbUlkIiwidXNlRWRpdFRocmVhZE1ldGFkYXRhIiwicmV2YWxpZGF0ZSIsImVkaXRUaHJlYWRNZXRhZGF0YSIsInRocmVhZElkIiwiY2F0Y2giLCJoYW5kbGVDb21tZW50c0FwaUVycm9yIiwibm90aWZ5IiwidXNlQ3JlYXRlVGhyZWFkIiwiY3JlYXRlVGhyZWFkIiwiYm9keSIsImNyZWF0ZVRocmVhZElkIiwiY29tbWVudElkIiwiY3JlYXRlQ29tbWVudElkIiwibm93IiwiRGF0ZSIsIm5ld0NvbW1lbnQiLCJjcmVhdGVkQXQiLCJ0eXBlIiwidXNlcklkIiwiZ2V0Q3VycmVudFVzZXJJZCIsInJlYWN0aW9ucyIsIm5ld1RocmVhZCIsInVzZUNyZWF0ZUNvbW1lbnQiLCJjcmVhdGVDb21tZW50IiwiY29tbWVudCIsInVzZUVkaXRDb21tZW50IiwiZWRpdENvbW1lbnQiLCJlZGl0ZWRBdCIsInVzZURlbGV0ZUNvbW1lbnQiLCJkZWxldGVDb21tZW50IiwibmV3VGhyZWFkcyIsImRlbGV0ZWRBdCIsInNvbWUiLCJwdXNoIiwidXNlQWRkUmVhY3Rpb24iLCJlbW9qaSIsInJlYWN0aW9uIiwidXNlcnMiLCJhZGRSZWFjdGlvbiIsInVzZVJlbW92ZVJlYWN0aW9uIiwicmVhY3Rpb25JbmRleCIsImZpbmRJbmRleCIsInVzZXIiLCJsZW5ndGgiLCJzcGxpY2UiLCJyZW1vdmVSZWFjdGlvbiIsImNyZWF0ZU9wdGltaXN0aWNJZCIsInByZWZpeCIsInNlbGYiLCJnZXRTZWxmIiwibWVzc2FnZSIsImRldGFpbHMiLCJkZXRhaWxlZE1lc3NhZ2UiLCJzdWdnZXN0aW9uIiwiZG9jcyIsIkJvb2xlYW4iLCJqb2luIiwiY29uc29sZSIsInJlcXVlc3QiLCJtdXRhdGlvbiIsInJldmFsaWRhdGlvbk1hbmFnZXJCeU9wdGlvbnMiLCJyZWZlcmVuY2VDb3VudEJ5T3B0aW9ucyIsImtleXMiLCJnZXQiLCJkZWxldGUiLCJzb3J0ZWQiLCJzb3J0IiwiYSIsImIiLCJnZXRUaW1lIiwiY29uY2F0IiwiaW5mbyIsImVudHJpZXMiLCJzZXQiLCJyZWR1Y2UiLCJhY2MiLCJjb3VudCIsInRocmVhZHNFdmVudFNvdXJjZSIsImNhbGxiYWNrIiwic2V0SXNMb2FkaW5nIiwiaXNCcm93c2VyT25saW5lIiwiaXNSb29tQ29ubmVjdGVkIiwidXNlRWZmZWN0NCIsInVzZVJlZjMiLCJ1c2VTdGF0ZTIiLCJERUZBVUxUX0RFTEFZIiwidXNlRGVib3VuY2UiLCJkZWxheSIsImRlYm91bmNlZFZhbHVlIiwic2V0RGVib3VuY2VkVmFsdWUiLCJ1c2VDYWxsYmFjazQiLCJ1c2VFZmZlY3Q1IiwidXNlTWVtbzIiLCJ1c2VSZWY0IiwidXNlU3luY0V4dGVybmFsU3RvcmU0IiwidXNlU3RhdGUzIiwidXNlSW5pdGlhbCIsIklOSVRJQUxfQVNZTkNfU1RBVEUiLCJub29wIiwidXNlQXN5bmNDYWNoZSIsInByZXZpb3VzRGF0YSIsImZyb3plbk9wdGlvbnMiLCJjYWNoZUl0ZW0iLCJjYWNoZUl0ZW0yIiwiY3JlYXRlIiwiZ2V0U3RhdGUiLCJzdXNwZW5zZSIsInJlc29sdmUiLCJzdWJzY3JpYmVPbmNlIiwic3RhdGUyIiwia2VlcFByZXZpb3VzRGF0YVdoaWxlTG9hZGluZyIsInVzZUVmZmVjdDYiLCJ1c2VSZWY1IiwidXNlTGF0ZXN0IiwicmVmIiwidXNlUmVkdWNlciIsInVzZVJlcmVuZGVyIiwidXBkYXRlIiwieCIsIm5vb3AyIiwiaWRlbnRpdHkiLCJtaXNzaW5nX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwicmVhY3RWZXJzaW9uIiwiSlNPTiIsInN1cGVyZmx1b3VzX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwicyIsImdzIiwiZ3NzIiwiU1RBQkxFX0VNUFRZX0xJU1QiLCJPYmplY3QiLCJmcmVlemUiLCJhbHdheXNFbXB0eUxpc3QiLCJhbHdheXNOdWxsIiwibWFrZU11dGF0aW9uQ29udGV4dCIsImVycm1zZyIsInN0b3JhZ2UiLCJtdXRhYmxlUm9vdCIsImdldFN0b3JhZ2VTbmFwc2hvdCIsIm90aGVycyIsImdldE90aGVycyIsInNldE15UHJlc2VuY2UiLCJ1cGRhdGVQcmVzZW5jZSIsImhhc1dhcm5lZElmTm9SZXNvbHZlVXNlcnMiLCJ3YXJuSWZOb1Jlc29sdmVVc2VycyIsInVzZXJzQ2FjaGUiLCJwcm9jZXNzIiwid2FybiIsIkNvbnRleHRCdW5kbGUiLCJ1c2VSb29tQ29udGV4dEJ1bmRsZSIsImJ1bmRsZSIsImNyZWF0ZVJvb21Db250ZXh0IiwiY2xpZW50IiwiUm9vbUNvbnRleHQiLCJjb21tZW50c0Vycm9yRXZlbnRTb3VyY2UiLCJjb21tZW50c1Jvb20iLCJSb29tUHJvdmlkZXJPdXRlciIsInN0YWJsZUVudGVyUm9vbSIsImNhY2hlZCIsInJ2IiwiZW50ZXJSb29tIiwib3JpZ0xlYXZlIiwibGVhdmUiLCJSb29tUHJvdmlkZXJJbm5lciIsIm1ham9yUmVhY3RWZXJzaW9uIiwicGFyc2VJbnQiLCJ2ZXJzaW9uIiwib2xkUmVhY3RWZXJzaW9uIiwidW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJmcm96ZW5Qcm9wcyIsImluaXRpYWxQcmVzZW5jZSIsImluaXRpYWxTdG9yYWdlIiwiYXV0b0Nvbm5lY3QiLCJzaG91bGRJbml0aWFsbHlDb25uZWN0Iiwic2V0Um9vbUxlYXZlUGFpciIsInBhaXIiLCJyb29tMiIsImNvbm5lY3QiLCJpbnRlcm5hbEJ1bmRsZSIsImNvbm5lY3Rpb25JZFNlbGVjdG9yIiwiY29ubmVjdGlvbklkIiwidXNlUm9vbSIsInVzZVN0YXR1cyIsImdldFNlcnZlclNuYXBzaG90IiwidXNlTXlQcmVzZW5jZSIsIm15UHJlc2VuY2UiLCJnZXRQcmVzZW5jZSIsInByZXNlbmNlIiwic2V0UHJlc2VuY2UiLCJ1c2VVcGRhdGVNeVByZXNlbmNlIiwidXNlT3RoZXJzIiwic2VsZWN0b3IiLCJpc0VxdWFsIiwidXNlT3RoZXJzQ29ubmVjdGlvbklkcyIsInVzZU90aGVyc01hcHBlZCIsIml0ZW1TZWxlY3RvciIsIml0ZW1Jc0VxdWFsIiwid3JhcHBlZFNlbGVjdG9yIiwib3RoZXIiLCJ3cmFwcGVkSXNFcXVhbCIsImVxIiwiaXMiLCJldmVyeSIsImF0dXBsZSIsImluZGV4IiwiYnR1cGxlIiwiTk9UX0ZPVU5EIiwiU3ltYm9sIiwidXNlT3RoZXIiLCJvdGhlcjIiLCJmaW5kIiwib3RoZXIzIiwicHJldiIsImN1cnIiLCJ1c2VCcm9hZGNhc3RFdmVudCIsImV2ZW50Iiwic2hvdWxkUXVldWVFdmVudElmTm90UmVhZHkiLCJicm9hZGNhc3RFdmVudCIsInVzZU90aGVyc0xpc3RlbmVyIiwic2F2ZWRDYWxsYmFjayIsInVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIiLCJsb3N0Q29ubmVjdGlvbiIsInVzZUVycm9yTGlzdGVuZXIiLCJlIiwidXNlRXZlbnRMaXN0ZW5lciIsImxpc3RlbmVyIiwiZXZlbnREYXRhIiwiY3VzdG9tRXZlbnQiLCJ1c2VTZWxmIiwibWF5YmVTZWxlY3RvciIsIm1lIiwidXNlTXV0YWJsZVN0b3JhZ2VSb290Iiwic3RvcmFnZURpZExvYWQiLCJ1c2VTdG9yYWdlUm9vdCIsInVzZUhpc3RvcnkiLCJoaXN0b3J5IiwidXNlVW5kbyIsInVuZG8iLCJ1c2VSZWRvIiwicmVkbyIsInVzZUNhblVuZG8iLCJjYW5VbmRvIiwidXNlQ2FuUmVkbyIsImNhblJlZG8iLCJ1c2VCYXRjaCIsImJhdGNoIiwidXNlTGVnYWN5S2V5Iiwicm9vdE9yTnVsbCIsInJlcmVuZGVyIiwicm9vdCIsInVuc3ViQ3VyciIsInN1YnNjcmliZVRvQ3VyciIsIm9uUm9vdENoYW5nZSIsIm5ld1ZhbHVlIiwidW5zdWJzY3JpYmVSb290IiwidXNlU3RvcmFnZSIsInJvb3RPck51bGwyIiwiaXNEZWVwIiwiaW1tIiwidG9JbW11dGFibGUiLCJlbnN1cmVOb3RTZXJ2ZXJTaWRlIiwidXNlU3VzcGVuZFVudGlsU3RvcmFnZUxvYWRlZCIsInJlcyIsInVzZVN1c3BlbmRVbnRpbFByZXNlbmNlTG9hZGVkIiwidXNlTXV0YXRpb24iLCJkZXBzIiwiYXJncyIsInVzZVN0b3JhZ2VTdXNwZW5zZSIsInVzZVNlbGZTdXNwZW5zZSIsInVzZU90aGVyc1N1c3BlbnNlIiwidXNlT3RoZXJzQ29ubmVjdGlvbklkc1N1c3BlbnNlIiwidXNlT3RoZXJzTWFwcGVkU3VzcGVuc2UiLCJ1c2VPdGhlclN1c3BlbnNlIiwidXNlTGVnYWN5S2V5U3VzcGVuc2UiLCJyZXNvbHZlVXNlcnMiLCJyZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zIiwic3RyaW5naWZpZWRPcHRpb25zIiwicGFyc2UiLCJ1c2VVc2VyIiwicmVzb2x2ZXJLZXkiLCJ1c2VySWRzIiwidXNlVXNlclN1c3BlbnNlIiwibWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUiLCJ1c2VNZW50aW9uU3VnZ2VzdGlvbnMiLCJzZWFyY2giLCJkZWJvdW5jZWRTZWFyY2giLCJ0ZXh0IiwiUm9vbVByb3ZpZGVyIiwidXNlTGlzdCIsInVzZU1hcCIsInVzZU9iamVjdCIsImhhc1Jlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMiLCJzaGFsbG93MiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@liveblocks/react/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_tagged_template_literal.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_tagged_template_literal.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _tagged_template_literal; },\n/* harmony export */   _tagged_template_literal: function() { return /* binding */ _tagged_template_literal; }\n/* harmony export */ });\nfunction _tagged_template_literal(strings, raw) {\n    if (!raw) raw = strings.slice(0);\n    return Object.freeze(Object.defineProperties(strings, {\n        raw: {\n            value: Object.freeze(raw)\n        }\n    }));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL190YWdnZWRfdGVtcGxhdGVfbGl0ZXJhbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPLFNBQVNBLHlCQUF5QkMsT0FBTyxFQUFFQyxHQUFHO0lBQ2pELElBQUksQ0FBQ0EsS0FBS0EsTUFBTUQsUUFBUUUsS0FBSyxDQUFDO0lBRTlCLE9BQU9DLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0UsZ0JBQWdCLENBQUNMLFNBQVM7UUFBRUMsS0FBSztZQUFFSyxPQUFPSCxPQUFPQyxNQUFNLENBQUNIO1FBQUs7SUFBRTtBQUMvRjtBQUN5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2VzbS9fdGFnZ2VkX3RlbXBsYXRlX2xpdGVyYWwuanM/YmNlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gX3RhZ2dlZF90ZW1wbGF0ZV9saXRlcmFsKHN0cmluZ3MsIHJhdykge1xuICAgIGlmICghcmF3KSByYXcgPSBzdHJpbmdzLnNsaWNlKDApO1xuXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3RyaW5ncywgeyByYXc6IHsgdmFsdWU6IE9iamVjdC5mcmVlemUocmF3KSB9IH0pKTtcbn1cbmV4cG9ydCB7IF90YWdnZWRfdGVtcGxhdGVfbGl0ZXJhbCBhcyBfIH07XG4iXSwibmFtZXMiOlsiX3RhZ2dlZF90ZW1wbGF0ZV9saXRlcmFsIiwic3RyaW5ncyIsInJhdyIsInNsaWNlIiwiT2JqZWN0IiwiZnJlZXplIiwiZGVmaW5lUHJvcGVydGllcyIsInZhbHVlIiwiXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_tagged_template_literal.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/nanoid/index.browser.js":
/*!**********************************************!*\
  !*** ./node_modules/nanoid/index.browser.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customAlphabet: function() { return /* binding */ customAlphabet; },\n/* harmony export */   customRandom: function() { return /* binding */ customRandom; },\n/* harmony export */   nanoid: function() { return /* binding */ nanoid; },\n/* harmony export */   random: function() { return /* binding */ random; },\n/* harmony export */   urlAlphabet: function() { return /* reexport safe */ _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__.urlAlphabet; }\n/* harmony export */ });\n/* harmony import */ var _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url-alphabet/index.js */ \"(app-pages-browser)/./node_modules/nanoid/url-alphabet/index.js\");\n\nlet random = (bytes)=>crypto.getRandomValues(new Uint8Array(bytes));\nlet customRandom = (alphabet, defaultSize, getRandom)=>{\n    let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;\n    let step = -~(1.6 * mask * defaultSize / alphabet.length);\n    return function() {\n        let size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultSize;\n        let id = \"\";\n        while(true){\n            let bytes = getRandom(step);\n            let j = step;\n            while(j--){\n                id += alphabet[bytes[j] & mask] || \"\";\n                if (id.length === size) return id;\n            }\n        }\n    };\n};\nlet customAlphabet = function(alphabet) {\n    let size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 21;\n    return customRandom(alphabet, size, random);\n};\nlet nanoid = function() {\n    let size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 21;\n    return crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte)=>{\n        byte &= 63;\n        if (byte < 36) {\n            id += byte.toString(36);\n        } else if (byte < 62) {\n            id += (byte - 26).toString(36).toUpperCase();\n        } else if (byte > 62) {\n            id += \"-\";\n        } else {\n            id += \"_\";\n        }\n        return id;\n    }, \"\");\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uYW5vaWQvaW5kZXguYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBcUQ7QUFDckQsSUFBSUMsU0FBU0MsQ0FBQUEsUUFBU0MsT0FBT0MsZUFBZSxDQUFDLElBQUlDLFdBQVdIO0FBQzVELElBQUlJLGVBQWUsQ0FBQ0MsVUFBVUMsYUFBYUM7SUFDekMsSUFBSUMsT0FBTyxDQUFDLEtBQU1DLEtBQUtDLEdBQUcsQ0FBQ0wsU0FBU00sTUFBTSxHQUFHLEtBQUtGLEtBQUtHLEdBQUcsSUFBSztJQUMvRCxJQUFJQyxPQUFPLENBQUMsQ0FBRSxPQUFPTCxPQUFPRixjQUFlRCxTQUFTTSxNQUFNO0lBQzFELE9BQU87WUFBQ0csd0VBQU9SO1FBQ2IsSUFBSVMsS0FBSztRQUNULE1BQU8sS0FBTTtZQUNYLElBQUlmLFFBQVFPLFVBQVVNO1lBQ3RCLElBQUlHLElBQUlIO1lBQ1IsTUFBT0csSUFBSztnQkFDVkQsTUFBTVYsUUFBUSxDQUFDTCxLQUFLLENBQUNnQixFQUFFLEdBQUdSLEtBQUssSUFBSTtnQkFDbkMsSUFBSU8sR0FBR0osTUFBTSxLQUFLRyxNQUFNLE9BQU9DO1lBQ2pDO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsSUFBSUUsaUJBQWlCLFNBQUNaO1FBQVVTLHdFQUFPO1dBQ3JDVixhQUFhQyxVQUFVUyxNQUFNZjs7QUFDL0IsSUFBSW1CLFNBQVM7UUFBQ0osd0VBQU87V0FDbkJiLE9BQU9DLGVBQWUsQ0FBQyxJQUFJQyxXQUFXVyxPQUFPSyxNQUFNLENBQUMsQ0FBQ0osSUFBSUs7UUFDdkRBLFFBQVE7UUFDUixJQUFJQSxPQUFPLElBQUk7WUFDYkwsTUFBTUssS0FBS0MsUUFBUSxDQUFDO1FBQ3RCLE9BQU8sSUFBSUQsT0FBTyxJQUFJO1lBQ3BCTCxNQUFNLENBQUNLLE9BQU8sRUFBQyxFQUFHQyxRQUFRLENBQUMsSUFBSUMsV0FBVztRQUM1QyxPQUFPLElBQUlGLE9BQU8sSUFBSTtZQUNwQkwsTUFBTTtRQUNSLE9BQU87WUFDTEEsTUFBTTtRQUNSO1FBQ0EsT0FBT0E7SUFDVCxHQUFHOztBQUMrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmFub2lkL2luZGV4LmJyb3dzZXIuanM/NjE1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1cmxBbHBoYWJldCB9IGZyb20gJy4vdXJsLWFscGhhYmV0L2luZGV4LmpzJ1xubGV0IHJhbmRvbSA9IGJ5dGVzID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKVxubGV0IGN1c3RvbVJhbmRvbSA9IChhbHBoYWJldCwgZGVmYXVsdFNpemUsIGdldFJhbmRvbSkgPT4ge1xuICBsZXQgbWFzayA9ICgyIDw8IChNYXRoLmxvZyhhbHBoYWJldC5sZW5ndGggLSAxKSAvIE1hdGguTE4yKSkgLSAxXG4gIGxldCBzdGVwID0gLX4oKDEuNiAqIG1hc2sgKiBkZWZhdWx0U2l6ZSkgLyBhbHBoYWJldC5sZW5ndGgpXG4gIHJldHVybiAoc2l6ZSA9IGRlZmF1bHRTaXplKSA9PiB7XG4gICAgbGV0IGlkID0gJydcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbGV0IGJ5dGVzID0gZ2V0UmFuZG9tKHN0ZXApXG4gICAgICBsZXQgaiA9IHN0ZXBcbiAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgaWQgKz0gYWxwaGFiZXRbYnl0ZXNbal0gJiBtYXNrXSB8fCAnJ1xuICAgICAgICBpZiAoaWQubGVuZ3RoID09PSBzaXplKSByZXR1cm4gaWRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmxldCBjdXN0b21BbHBoYWJldCA9IChhbHBoYWJldCwgc2l6ZSA9IDIxKSA9PlxuICBjdXN0b21SYW5kb20oYWxwaGFiZXQsIHNpemUsIHJhbmRvbSlcbmxldCBuYW5vaWQgPSAoc2l6ZSA9IDIxKSA9PlxuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHNpemUpKS5yZWR1Y2UoKGlkLCBieXRlKSA9PiB7XG4gICAgYnl0ZSAmPSA2M1xuICAgIGlmIChieXRlIDwgMzYpIHtcbiAgICAgIGlkICs9IGJ5dGUudG9TdHJpbmcoMzYpXG4gICAgfSBlbHNlIGlmIChieXRlIDwgNjIpIHtcbiAgICAgIGlkICs9IChieXRlIC0gMjYpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpXG4gICAgfSBlbHNlIGlmIChieXRlID4gNjIpIHtcbiAgICAgIGlkICs9ICctJ1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCArPSAnXydcbiAgICB9XG4gICAgcmV0dXJuIGlkXG4gIH0sICcnKVxuZXhwb3J0IHsgbmFub2lkLCBjdXN0b21BbHBoYWJldCwgY3VzdG9tUmFuZG9tLCB1cmxBbHBoYWJldCwgcmFuZG9tIH1cbiJdLCJuYW1lcyI6WyJ1cmxBbHBoYWJldCIsInJhbmRvbSIsImJ5dGVzIiwiY3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwiVWludDhBcnJheSIsImN1c3RvbVJhbmRvbSIsImFscGhhYmV0IiwiZGVmYXVsdFNpemUiLCJnZXRSYW5kb20iLCJtYXNrIiwiTWF0aCIsImxvZyIsImxlbmd0aCIsIkxOMiIsInN0ZXAiLCJzaXplIiwiaWQiLCJqIiwiY3VzdG9tQWxwaGFiZXQiLCJuYW5vaWQiLCJyZWR1Y2UiLCJieXRlIiwidG9TdHJpbmciLCJ0b1VwcGVyQ2FzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/nanoid/index.browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/nanoid/url-alphabet/index.js":
/*!***************************************************!*\
  !*** ./node_modules/nanoid/url-alphabet/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   urlAlphabet: function() { return /* binding */ urlAlphabet; }\n/* harmony export */ });\nlet urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uYW5vaWQvdXJsLWFscGhhYmV0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxJQUFJQSxjQUNGO0FBQ29CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uYW5vaWQvdXJsLWFscGhhYmV0L2luZGV4LmpzPzE5MDQiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHVybEFscGhhYmV0ID1cbiAgJ3VzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3QnXG5leHBvcnQgeyB1cmxBbHBoYWJldCB9XG4iXSwibmFtZXMiOlsidXJsQWxwaGFiZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/nanoid/url-alphabet/index.js\n"));

/***/ })

});